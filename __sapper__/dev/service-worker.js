(function () {
	'use strict';

	// This file is generated by Sapper â€” do not edit it!
	const timestamp = 1608019299579;

	const files = [
		"/service-worker-index.html",
		"/android-chrome-192x192.png",
		"/android-chrome-512x512.png",
		"/apple-touch-icon.png",
		"/browserconfig.xml",
		"/favicon-16x16.png",
		"/favicon-32x32.png",
		"/favicon.ico",
		"/favicon.png",
		"/global.css",
		"/location.svg",
		"/logo-192.png",
		"/logo-512.png",
		"/manifest.webmanifest",
		"/mstile-144x144.png",
		"/mstile-150x150.png",
		"/mstile-310x150.png",
		"/mstile-310x310.png",
		"/mstile-70x70.png",
		"/safari-pinned-tab.svg"
	];

	const shell = [
		"/client/client.7e805b57.js",
		"/client/inject_styles.5607aec6.js",
		"/client/index.51342f95.js",
		"/client/Geocoder.7a0ff419.js",
		"/client/partners.6f7f5f5c.js",
		"/client/about.513b26a4.js",
		"/client/index.7fd1f125.js",
		"/client/[id].29ecd3df.js",
		"/client/_commonjsHelpers.91583ccb.js",
		"/client/sapper-dev-client.1e7a4a5e.js",
		"/client/autoComplete.min.86378da8.js"
	];

	// @ts-ignore
	try {
	    self['workbox:core:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const messages = {
	    'invalid-value': ({ paramName, validValueDescription, value }) => {
	        if (!paramName || !validValueDescription) {
	            throw new Error(`Unexpected input to 'invalid-value' error.`);
	        }
	        return `The '${paramName}' parameter was given a value with an ` +
	            `unexpected value. ${validValueDescription} Received a value of ` +
	            `${JSON.stringify(value)}.`;
	    },
	    'not-an-array': ({ moduleName, className, funcName, paramName }) => {
	        if (!moduleName || !className || !funcName || !paramName) {
	            throw new Error(`Unexpected input to 'not-an-array' error.`);
	        }
	        return `The parameter '${paramName}' passed into ` +
	            `'${moduleName}.${className}.${funcName}()' must be an array.`;
	    },
	    'incorrect-type': ({ expectedType, paramName, moduleName, className, funcName }) => {
	        if (!expectedType || !paramName || !moduleName || !funcName) {
	            throw new Error(`Unexpected input to 'incorrect-type' error.`);
	        }
	        return `The parameter '${paramName}' passed into ` +
	            `'${moduleName}.${className ? (className + '.') : ''}` +
	            `${funcName}()' must be of type ${expectedType}.`;
	    },
	    'incorrect-class': ({ expectedClass, paramName, moduleName, className, funcName, isReturnValueProblem }) => {
	        if (!expectedClass || !moduleName || !funcName) {
	            throw new Error(`Unexpected input to 'incorrect-class' error.`);
	        }
	        if (isReturnValueProblem) {
	            return `The return value from ` +
	                `'${moduleName}.${className ? (className + '.') : ''}${funcName}()' ` +
	                `must be an instance of class ${expectedClass.name}.`;
	        }
	        return `The parameter '${paramName}' passed into ` +
	            `'${moduleName}.${className ? (className + '.') : ''}${funcName}()' ` +
	            `must be an instance of class ${expectedClass.name}.`;
	    },
	    'missing-a-method': ({ expectedMethod, paramName, moduleName, className, funcName }) => {
	        if (!expectedMethod || !paramName || !moduleName || !className
	            || !funcName) {
	            throw new Error(`Unexpected input to 'missing-a-method' error.`);
	        }
	        return `${moduleName}.${className}.${funcName}() expected the ` +
	            `'${paramName}' parameter to expose a '${expectedMethod}' method.`;
	    },
	    'add-to-cache-list-unexpected-type': ({ entry }) => {
	        return `An unexpected entry was passed to ` +
	            `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` +
	            `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` +
	            `strings with one or more characters, objects with a url property or ` +
	            `Request objects.`;
	    },
	    'add-to-cache-list-conflicting-entries': ({ firstEntry, secondEntry }) => {
	        if (!firstEntry || !secondEntry) {
	            throw new Error(`Unexpected input to ` +
	                `'add-to-cache-list-duplicate-entries' error.`);
	        }
	        return `Two of the entries passed to ` +
	            `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` +
	            `${firstEntry._entryId} but different revision details. Workbox is ` +
	            `unable to cache and version the asset correctly. Please remove one ` +
	            `of the entries.`;
	    },
	    'plugin-error-request-will-fetch': ({ thrownError }) => {
	        if (!thrownError) {
	            throw new Error(`Unexpected input to ` +
	                `'plugin-error-request-will-fetch', error.`);
	        }
	        return `An error was thrown by a plugins 'requestWillFetch()' method. ` +
	            `The thrown error message was: '${thrownError.message}'.`;
	    },
	    'invalid-cache-name': ({ cacheNameId, value }) => {
	        if (!cacheNameId) {
	            throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);
	        }
	        return `You must provide a name containing at least one character for ` +
	            `setCacheDetails({${cacheNameId}: '...'}). Received a value of ` +
	            `'${JSON.stringify(value)}'`;
	    },
	    'unregister-route-but-not-found-with-method': ({ method }) => {
	        if (!method) {
	            throw new Error(`Unexpected input to ` +
	                `'unregister-route-but-not-found-with-method' error.`);
	        }
	        return `The route you're trying to unregister was not  previously ` +
	            `registered for the method type '${method}'.`;
	    },
	    'unregister-route-route-not-registered': () => {
	        return `The route you're trying to unregister was not previously ` +
	            `registered.`;
	    },
	    'queue-replay-failed': ({ name }) => {
	        return `Replaying the background sync queue '${name}' failed.`;
	    },
	    'duplicate-queue-name': ({ name }) => {
	        return `The Queue name '${name}' is already being used. ` +
	            `All instances of backgroundSync.Queue must be given unique names.`;
	    },
	    'expired-test-without-max-age': ({ methodName, paramName }) => {
	        return `The '${methodName}()' method can only be used when the ` +
	            `'${paramName}' is used in the constructor.`;
	    },
	    'unsupported-route-type': ({ moduleName, className, funcName, paramName }) => {
	        return `The supplied '${paramName}' parameter was an unsupported type. ` +
	            `Please check the docs for ${moduleName}.${className}.${funcName} for ` +
	            `valid input types.`;
	    },
	    'not-array-of-class': ({ value, expectedClass, moduleName, className, funcName, paramName }) => {
	        return `The supplied '${paramName}' parameter must be an array of ` +
	            `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` +
	            `Please check the call to ${moduleName}.${className}.${funcName}() ` +
	            `to fix the issue.`;
	    },
	    'max-entries-or-age-required': ({ moduleName, className, funcName }) => {
	        return `You must define either config.maxEntries or config.maxAgeSeconds` +
	            `in ${moduleName}.${className}.${funcName}`;
	    },
	    'statuses-or-headers-required': ({ moduleName, className, funcName }) => {
	        return `You must define either config.statuses or config.headers` +
	            `in ${moduleName}.${className}.${funcName}`;
	    },
	    'invalid-string': ({ moduleName, funcName, paramName }) => {
	        if (!paramName || !moduleName || !funcName) {
	            throw new Error(`Unexpected input to 'invalid-string' error.`);
	        }
	        return `When using strings, the '${paramName}' parameter must start with ` +
	            `'http' (for cross-origin matches) or '/' (for same-origin matches). ` +
	            `Please see the docs for ${moduleName}.${funcName}() for ` +
	            `more info.`;
	    },
	    'channel-name-required': () => {
	        return `You must provide a channelName to construct a ` +
	            `BroadcastCacheUpdate instance.`;
	    },
	    'invalid-responses-are-same-args': () => {
	        return `The arguments passed into responsesAreSame() appear to be ` +
	            `invalid. Please ensure valid Responses are used.`;
	    },
	    'expire-custom-caches-only': () => {
	        return `You must provide a 'cacheName' property when using the ` +
	            `expiration plugin with a runtime caching strategy.`;
	    },
	    'unit-must-be-bytes': ({ normalizedRangeHeader }) => {
	        if (!normalizedRangeHeader) {
	            throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);
	        }
	        return `The 'unit' portion of the Range header must be set to 'bytes'. ` +
	            `The Range header provided was "${normalizedRangeHeader}"`;
	    },
	    'single-range-only': ({ normalizedRangeHeader }) => {
	        if (!normalizedRangeHeader) {
	            throw new Error(`Unexpected input to 'single-range-only' error.`);
	        }
	        return `Multiple ranges are not supported. Please use a  single start ` +
	            `value, and optional end value. The Range header provided was ` +
	            `"${normalizedRangeHeader}"`;
	    },
	    'invalid-range-values': ({ normalizedRangeHeader }) => {
	        if (!normalizedRangeHeader) {
	            throw new Error(`Unexpected input to 'invalid-range-values' error.`);
	        }
	        return `The Range header is missing both start and end values. At least ` +
	            `one of those values is needed. The Range header provided was ` +
	            `"${normalizedRangeHeader}"`;
	    },
	    'no-range-header': () => {
	        return `No Range header was found in the Request provided.`;
	    },
	    'range-not-satisfiable': ({ size, start, end }) => {
	        return `The start (${start}) and end (${end}) values in the Range are ` +
	            `not satisfiable by the cached response, which is ${size} bytes.`;
	    },
	    'attempt-to-cache-non-get-request': ({ url, method }) => {
	        return `Unable to cache '${url}' because it is a '${method}' request and ` +
	            `only 'GET' requests can be cached.`;
	    },
	    'cache-put-with-no-response': ({ url }) => {
	        return `There was an attempt to cache '${url}' but the response was not ` +
	            `defined.`;
	    },
	    'no-response': ({ url, error }) => {
	        let message = `The strategy could not generate a response for '${url}'.`;
	        if (error) {
	            message += ` The underlying error is ${error}.`;
	        }
	        return message;
	    },
	    'bad-precaching-response': ({ url, status }) => {
	        return `The precaching request for '${url}' failed` +
	            (status ? ` with an HTTP status of ${status}.` : `.`);
	    },
	    'non-precached-url': ({ url }) => {
	        return `createHandlerBoundToURL('${url}') was called, but that URL is ` +
	            `not precached. Please pass in a URL that is precached instead.`;
	    },
	    'add-to-cache-list-conflicting-integrities': ({ url }) => {
	        return `Two of the entries passed to ` +
	            `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` +
	            `${url} with different integrity values. Please remove one of them.`;
	    },
	    'missing-precache-entry': ({ cacheName, url }) => {
	        return `Unable to find a precached response in ${cacheName} for ${url}.`;
	    },
	    'cross-origin-copy-response': ({ origin }) => {
	        return `workbox-core.copyResponse() can only be used with same-origin ` +
	            `responses. It was passed a response with origin ${origin}.`;
	    },
	};

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const generatorFunction = (code, details = {}) => {
	    const message = messages[code];
	    if (!message) {
	        throw new Error(`Unable to find message for code '${code}'.`);
	    }
	    return message(details);
	};
	const messageGenerator =  generatorFunction;

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Workbox errors should be thrown with this class.
	 * This allows use to ensure the type easily in tests,
	 * helps developers identify errors from workbox
	 * easily and allows use to optimise error
	 * messages correctly.
	 *
	 * @private
	 */
	class WorkboxError extends Error {
	    /**
	     *
	     * @param {string} errorCode The error code that
	     * identifies this particular error.
	     * @param {Object=} details Any relevant arguments
	     * that will help developers identify issues should
	     * be added as a key on the context object.
	     */
	    constructor(errorCode, details) {
	        const message = messageGenerator(errorCode, details);
	        super(message);
	        this.name = errorCode;
	        this.details = details;
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/*
	 * This method throws if the supplied value is not an array.
	 * The destructed values are required to produce a meaningful error for users.
	 * The destructed and restructured object is so it's clear what is
	 * needed.
	 */
	const isArray = (value, details) => {
	    if (!Array.isArray(value)) {
	        throw new WorkboxError('not-an-array', details);
	    }
	};
	const hasMethod = (object, expectedMethod, details) => {
	    const type = typeof object[expectedMethod];
	    if (type !== 'function') {
	        details['expectedMethod'] = expectedMethod;
	        throw new WorkboxError('missing-a-method', details);
	    }
	};
	const isType = (object, expectedType, details) => {
	    if (typeof object !== expectedType) {
	        details['expectedType'] = expectedType;
	        throw new WorkboxError('incorrect-type', details);
	    }
	};
	const isInstance = (object, expectedClass, details) => {
	    if (!(object instanceof expectedClass)) {
	        details['expectedClass'] = expectedClass;
	        throw new WorkboxError('incorrect-class', details);
	    }
	};
	const isOneOf = (value, validValues, details) => {
	    if (!validValues.includes(value)) {
	        details['validValueDescription'] =
	            `Valid values are ${JSON.stringify(validValues)}.`;
	        throw new WorkboxError('invalid-value', details);
	    }
	};
	const isArrayOfClass = (value, expectedClass, details) => {
	    const error = new WorkboxError('not-array-of-class', details);
	    if (!Array.isArray(value)) {
	        throw error;
	    }
	    for (const item of value) {
	        if (!(item instanceof expectedClass)) {
	            throw error;
	        }
	    }
	};
	const finalAssertExports =  {
	    hasMethod,
	    isArray,
	    isInstance,
	    isOneOf,
	    isType,
	    isArrayOfClass,
	};

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const _cacheNameDetails = {
	    googleAnalytics: 'googleAnalytics',
	    precache: 'precache-v2',
	    prefix: 'workbox',
	    runtime: 'runtime',
	    suffix: typeof registration !== 'undefined' ? registration.scope : '',
	};
	const _createCacheName = (cacheName) => {
	    return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix]
	        .filter((value) => value && value.length > 0)
	        .join('-');
	};
	const eachCacheNameDetail = (fn) => {
	    for (const key of Object.keys(_cacheNameDetails)) {
	        fn(key);
	    }
	};
	const cacheNames = {
	    updateDetails: (details) => {
	        eachCacheNameDetail((key) => {
	            if (typeof details[key] === 'string') {
	                _cacheNameDetails[key] = details[key];
	            }
	        });
	    },
	    getGoogleAnalyticsName: (userCacheName) => {
	        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);
	    },
	    getPrecacheName: (userCacheName) => {
	        return userCacheName || _createCacheName(_cacheNameDetails.precache);
	    },
	    getPrefix: () => {
	        return _cacheNameDetails.prefix;
	    },
	    getRuntimeName: (userCacheName) => {
	        return userCacheName || _createCacheName(_cacheNameDetails.runtime);
	    },
	    getSuffix: () => {
	        return _cacheNameDetails.suffix;
	    },
	};

	/*
	  Copyright 2019 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const logger = ( (() => {
	    // Don't overwrite this value if it's already set.
	    // See https://github.com/GoogleChrome/workbox/pull/2284#issuecomment-560470923
	    if (!('__WB_DISABLE_DEV_LOGS' in self)) {
	        self.__WB_DISABLE_DEV_LOGS = false;
	    }
	    let inGroup = false;
	    const methodToColorMap = {
	        debug: `#7f8c8d`,
	        log: `#2ecc71`,
	        warn: `#f39c12`,
	        error: `#c0392b`,
	        groupCollapsed: `#3498db`,
	        groupEnd: null,
	    };
	    const print = function (method, args) {
	        if (self.__WB_DISABLE_DEV_LOGS) {
	            return;
	        }
	        if (method === 'groupCollapsed') {
	            // Safari doesn't print all console.groupCollapsed() arguments:
	            // https://bugs.webkit.org/show_bug.cgi?id=182754
	            if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
	                console[method](...args);
	                return;
	            }
	        }
	        const styles = [
	            `background: ${methodToColorMap[method]}`,
	            `border-radius: 0.5em`,
	            `color: white`,
	            `font-weight: bold`,
	            `padding: 2px 0.5em`,
	        ];
	        // When in a group, the workbox prefix is not displayed.
	        const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];
	        console[method](...logPrefix, ...args);
	        if (method === 'groupCollapsed') {
	            inGroup = true;
	        }
	        if (method === 'groupEnd') {
	            inGroup = false;
	        }
	    };
	    const api = {};
	    const loggerMethods = Object.keys(methodToColorMap);
	    for (const key of loggerMethods) {
	        const method = key;
	        api[method] = (...args) => {
	            print(method, args);
	        };
	    }
	    return api;
	})());

	/*
	  Copyright 2020 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A utility method that makes it easier to use `event.waitUntil` with
	 * async functions and return the result.
	 *
	 * @param {ExtendableEvent} event
	 * @param {Function} asyncFn
	 * @return {Function}
	 * @private
	 */
	function waitUntil(event, asyncFn) {
	    const returnPromise = asyncFn();
	    event.waitUntil(returnPromise);
	    return returnPromise;
	}

	// @ts-ignore
	try {
	    self['workbox:precaching:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	// Name of the search parameter used to store revision info.
	const REVISION_SEARCH_PARAM = '__WB_REVISION__';
	/**
	 * Converts a manifest entry into a versioned URL suitable for precaching.
	 *
	 * @param {Object|string} entry
	 * @return {string} A URL with versioning info.
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function createCacheKey(entry) {
	    if (!entry) {
	        throw new WorkboxError('add-to-cache-list-unexpected-type', { entry });
	    }
	    // If a precache manifest entry is a string, it's assumed to be a versioned
	    // URL, like '/app.abcd1234.js'. Return as-is.
	    if (typeof entry === 'string') {
	        const urlObject = new URL(entry, location.href);
	        return {
	            cacheKey: urlObject.href,
	            url: urlObject.href,
	        };
	    }
	    const { revision, url } = entry;
	    if (!url) {
	        throw new WorkboxError('add-to-cache-list-unexpected-type', { entry });
	    }
	    // If there's just a URL and no revision, then it's also assumed to be a
	    // versioned URL.
	    if (!revision) {
	        const urlObject = new URL(url, location.href);
	        return {
	            cacheKey: urlObject.href,
	            url: urlObject.href,
	        };
	    }
	    // Otherwise, construct a properly versioned URL using the custom Workbox
	    // search parameter along with the revision info.
	    const cacheKeyURL = new URL(url, location.href);
	    const originalURL = new URL(url, location.href);
	    cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);
	    return {
	        cacheKey: cacheKeyURL.href,
	        url: originalURL.href,
	    };
	}

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A plugin, designed to be used with PrecacheController, to determine the
	 * of assets that were updated (or not updated) during the install event.
	 *
	 * @private
	 */
	class PrecacheInstallReportPlugin {
	    constructor() {
	        this.updatedURLs = [];
	        this.notUpdatedURLs = [];
	        this.handlerWillStart = async ({ request, state, }) => {
	            // TODO: `state` should never be undefined...
	            if (state) {
	                state.originalRequest = request;
	            }
	        };
	        this.cachedResponseWillBeUsed = async ({ event, state, cachedResponse, }) => {
	            if (event.type === 'install') {
	                // TODO: `state` should never be undefined...
	                const url = state.originalRequest.url;
	                if (cachedResponse) {
	                    this.notUpdatedURLs.push(url);
	                }
	                else {
	                    this.updatedURLs.push(url);
	                }
	            }
	            return cachedResponse;
	        };
	    }
	}

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A plugin, designed to be used with PrecacheController, to translate URLs into
	 * the corresponding cache key, based on the current revision info.
	 *
	 * @private
	 */
	class PrecacheCacheKeyPlugin {
	    constructor({ precacheController }) {
	        this.cacheKeyWillBeUsed = async ({ request, params, }) => {
	            const cacheKey = params && params.cacheKey ||
	                this._precacheController.getCacheKeyForURL(request.url);
	            return cacheKey ? new Request(cacheKey) : request;
	        };
	        this._precacheController = precacheController;
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * @param {string} groupTitle
	 * @param {Array<string>} deletedURLs
	 *
	 * @private
	 */
	const logGroup = (groupTitle, deletedURLs) => {
	    logger.groupCollapsed(groupTitle);
	    for (const url of deletedURLs) {
	        logger.log(url);
	    }
	    logger.groupEnd();
	};
	/**
	 * @param {Array<string>} deletedURLs
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function printCleanupDetails(deletedURLs) {
	    const deletionCount = deletedURLs.length;
	    if (deletionCount > 0) {
	        logger.groupCollapsed(`During precaching cleanup, ` +
	            `${deletionCount} cached ` +
	            `request${deletionCount === 1 ? ' was' : 's were'} deleted.`);
	        logGroup('Deleted Cache Requests', deletedURLs);
	        logger.groupEnd();
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * @param {string} groupTitle
	 * @param {Array<string>} urls
	 *
	 * @private
	 */
	function _nestedGroup(groupTitle, urls) {
	    if (urls.length === 0) {
	        return;
	    }
	    logger.groupCollapsed(groupTitle);
	    for (const url of urls) {
	        logger.log(url);
	    }
	    logger.groupEnd();
	}
	/**
	 * @param {Array<string>} urlsToPrecache
	 * @param {Array<string>} urlsAlreadyPrecached
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function printInstallDetails(urlsToPrecache, urlsAlreadyPrecached) {
	    const precachedCount = urlsToPrecache.length;
	    const alreadyPrecachedCount = urlsAlreadyPrecached.length;
	    if (precachedCount || alreadyPrecachedCount) {
	        let message = `Precaching ${precachedCount} file${precachedCount === 1 ? '' : 's'}.`;
	        if (alreadyPrecachedCount > 0) {
	            message += ` ${alreadyPrecachedCount} ` +
	                `file${alreadyPrecachedCount === 1 ? ' is' : 's are'} already cached.`;
	        }
	        logger.groupCollapsed(message);
	        _nestedGroup(`View newly precached URLs.`, urlsToPrecache);
	        _nestedGroup(`View previously precached URLs.`, urlsAlreadyPrecached);
	        logger.groupEnd();
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	let supportStatus;
	/**
	 * A utility function that determines whether the current browser supports
	 * constructing a new `Response` from a `response.body` stream.
	 *
	 * @return {boolean} `true`, if the current browser can successfully
	 *     construct a `Response` from a `response.body` stream, `false` otherwise.
	 *
	 * @private
	 */
	function canConstructResponseFromBodyStream() {
	    if (supportStatus === undefined) {
	        const testResponse = new Response('');
	        if ('body' in testResponse) {
	            try {
	                new Response(testResponse.body);
	                supportStatus = true;
	            }
	            catch (error) {
	                supportStatus = false;
	            }
	        }
	        supportStatus = false;
	    }
	    return supportStatus;
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Allows developers to copy a response and modify its `headers`, `status`,
	 * or `statusText` values (the values settable via a
	 * [`ResponseInit`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#Syntax}
	 * object in the constructor).
	 * To modify these values, pass a function as the second argument. That
	 * function will be invoked with a single object with the response properties
	 * `{headers, status, statusText}`. The return value of this function will
	 * be used as the `ResponseInit` for the new `Response`. To change the values
	 * either modify the passed parameter(s) and return it, or return a totally
	 * new object.
	 *
	 * This method is intentionally limited to same-origin responses, regardless of
	 * whether CORS was used or not.
	 *
	 * @param {Response} response
	 * @param {Function} modifier
	 * @memberof module:workbox-core
	 */
	async function copyResponse(response, modifier) {
	    let origin = null;
	    // If response.url isn't set, assume it's cross-origin and keep origin null.
	    if (response.url) {
	        const responseURL = new URL(response.url);
	        origin = responseURL.origin;
	    }
	    if (origin !== self.location.origin) {
	        throw new WorkboxError('cross-origin-copy-response', { origin });
	    }
	    const clonedResponse = response.clone();
	    // Create a fresh `ResponseInit` object by cloning the headers.
	    const responseInit = {
	        headers: new Headers(clonedResponse.headers),
	        status: clonedResponse.status,
	        statusText: clonedResponse.statusText,
	    };
	    // Apply any user modifications.
	    const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;
	    // Create the new response from the body stream and `ResponseInit`
	    // modifications. Note: not all browsers support the Response.body stream,
	    // so fall back to reading the entire body into memory as a blob.
	    const body = canConstructResponseFromBodyStream() ?
	        clonedResponse.body : await clonedResponse.blob();
	    return new Response(body, modifiedResponseInit);
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const getFriendlyURL = (url) => {
	    const urlObj = new URL(String(url), location.href);
	    // See https://github.com/GoogleChrome/workbox/issues/2323
	    // We want to include everything, except for the origin if it's same-origin.
	    return urlObj.href.replace(new RegExp(`^${location.origin}`), '');
	};

	/*
	  Copyright 2020 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	function stripParams(fullURL, ignoreParams) {
	    const strippedURL = new URL(fullURL);
	    for (const param of ignoreParams) {
	        strippedURL.searchParams.delete(param);
	    }
	    return strippedURL.href;
	}
	/**
	 * Matches an item in the cache, ignoring specific URL params. This is similar
	 * to the `ignoreSearch` option, but it allows you to ignore just specific
	 * params (while continuing to match on the others).
	 *
	 * @private
	 * @param {Cache} cache
	 * @param {Request} request
	 * @param {Object} matchOptions
	 * @param {Array<string>} ignoreParams
	 * @return {Promise<Response|undefined>}
	 */
	async function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {
	    const strippedRequestURL = stripParams(request.url, ignoreParams);
	    // If the request doesn't include any ignored params, match as normal.
	    if (request.url === strippedRequestURL) {
	        return cache.match(request, matchOptions);
	    }
	    // Otherwise, match by comparing keys
	    const keysOptions = { ...matchOptions, ignoreSearch: true };
	    const cacheKeys = await cache.keys(request, keysOptions);
	    for (const cacheKey of cacheKeys) {
	        const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);
	        if (strippedRequestURL === strippedCacheKeyURL) {
	            return cache.match(cacheKey, matchOptions);
	        }
	    }
	    return;
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * The Deferred class composes Promises in a way that allows for them to be
	 * resolved or rejected from outside the constructor. In most cases promises
	 * should be used directly, but Deferreds can be necessary when the logic to
	 * resolve a promise must be separate.
	 *
	 * @private
	 */
	class Deferred {
	    /**
	     * Creates a promise and exposes its resolve and reject functions as methods.
	     */
	    constructor() {
	        this.promise = new Promise((resolve, reject) => {
	            this.resolve = resolve;
	            this.reject = reject;
	        });
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	// Callbacks to be executed whenever there's a quota error.
	const quotaErrorCallbacks = new Set();

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Runs all of the callback functions, one at a time sequentially, in the order
	 * in which they were registered.
	 *
	 * @memberof module:workbox-core
	 * @private
	 */
	async function executeQuotaErrorCallbacks() {
	    {
	        logger.log(`About to run ${quotaErrorCallbacks.size} ` +
	            `callbacks to clean up caches.`);
	    }
	    for (const callback of quotaErrorCallbacks) {
	        await callback();
	        {
	            logger.log(callback, 'is complete.');
	        }
	    }
	    {
	        logger.log('Finished running callbacks.');
	    }
	}

	/*
	  Copyright 2019 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Returns a promise that resolves and the passed number of milliseconds.
	 * This utility is an async/await-friendly version of `setTimeout`.
	 *
	 * @param {number} ms
	 * @return {Promise}
	 * @private
	 */
	function timeout(ms) {
	    return new Promise((resolve) => setTimeout(resolve, ms));
	}

	// @ts-ignore
	try {
	    self['workbox:strategies:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	function toRequest(input) {
	    return (typeof input === 'string') ? new Request(input) : input;
	}
	/**
	 * A class created every time a Strategy instance instance calls
	 * [handle()]{@link module:workbox-strategies.Strategy~handle} or
	 * [handleAll()]{@link module:workbox-strategies.Strategy~handleAll} that wraps all fetch and
	 * cache actions around plugin callbacks and keeps track of when the strategy
	 * is "done" (i.e. all added `event.waitUntil()` promises have resolved).
	 *
	 * @memberof module:workbox-strategies
	 */
	class StrategyHandler {
	    /**
	     * Creates a new instance associated with the passed strategy and event
	     * that's handling the request.
	     *
	     * The constructor also initializes the state that will be passed to each of
	     * the plugins handling this request.
	     *
	     * @param {module:workbox-strategies.Strategy} strategy
	     * @param {Object} options
	     * @param {Request|string} options.request A request to run this strategy for.
	     * @param {ExtendableEvent} options.event The event associated with the
	     *     request.
	     * @param {URL} [options.url]
	     * @param {*} [options.params]
	     *     [match callback]{@link module:workbox-routing~matchCallback},
	     *     (if applicable).
	     */
	    constructor(strategy, options) {
	        this._cacheKeys = {};
	        /**
	         * The request the strategy is performing (passed to the strategy's
	         * `handle()` or `handleAll()` method).
	         * @name request
	         * @instance
	         * @type {Request}
	         * @memberof module:workbox-strategies.StrategyHandler
	         */
	        /**
	         * The event associated with this request.
	         * @name event
	         * @instance
	         * @type {ExtendableEvent}
	         * @memberof module:workbox-strategies.StrategyHandler
	         */
	        /**
	         * A `URL` instance of `request.url` (if passed to the strategy's
	         * `handle()` or `handleAll()` method).
	         * Note: the `url` param will be present if the strategy was invoked
	         * from a workbox `Route` object.
	         * @name url
	         * @instance
	         * @type {URL|undefined}
	         * @memberof module:workbox-strategies.StrategyHandler
	         */
	        /**
	         * A `param` value (if passed to the strategy's
	         * `handle()` or `handleAll()` method).
	         * Note: the `param` param will be present if the strategy was invoked
	         * from a workbox `Route` object and the
	         * [match callback]{@link module:workbox-routing~matchCallback} returned
	         * a truthy value (it will be that value).
	         * @name params
	         * @instance
	         * @type {*|undefined}
	         * @memberof module:workbox-strategies.StrategyHandler
	         */
	        {
	            finalAssertExports.isInstance(options.event, ExtendableEvent, {
	                moduleName: 'workbox-strategies',
	                className: 'StrategyHandler',
	                funcName: 'constructor',
	                paramName: 'options.event',
	            });
	        }
	        Object.assign(this, options);
	        this.event = options.event;
	        this._strategy = strategy;
	        this._handlerDeferred = new Deferred();
	        this._extendLifetimePromises = [];
	        // Copy the plugins list (since it's mutable on the strategy),
	        // so any mutations don't affect this handler instance.
	        this._plugins = [...strategy.plugins];
	        this._pluginStateMap = new Map();
	        for (const plugin of this._plugins) {
	            this._pluginStateMap.set(plugin, {});
	        }
	        this.event.waitUntil(this._handlerDeferred.promise);
	    }
	    /**
	     * Fetches a given request (and invokes any applicable plugin callback
	     * methods) using the `fetchOptions` and `plugins` defined on the strategy
	     * object.
	     *
	     * The following plugin lifecycle methods are invoked when using this method:
	     * - `requestWillFetch()`
	     * - `fetchDidSucceed()`
	     * - `fetchDidFail()`
	     *
	     * @param {Request|string} input The URL or request to fetch.
	     * @return {Promise<Response>}
	     */
	    fetch(input) {
	        return this.waitUntil((async () => {
	            const { event } = this;
	            let request = toRequest(input);
	            if (request.mode === 'navigate' &&
	                event instanceof FetchEvent &&
	                event.preloadResponse) {
	                const possiblePreloadResponse = await event.preloadResponse;
	                if (possiblePreloadResponse) {
	                    {
	                        logger.log(`Using a preloaded navigation response for ` +
	                            `'${getFriendlyURL(request.url)}'`);
	                    }
	                    return possiblePreloadResponse;
	                }
	            }
	            // If there is a fetchDidFail plugin, we need to save a clone of the
	            // original request before it's either modified by a requestWillFetch
	            // plugin or before the original request's body is consumed via fetch().
	            const originalRequest = this.hasCallback('fetchDidFail') ?
	                request.clone() : null;
	            try {
	                for (const cb of this.iterateCallbacks('requestWillFetch')) {
	                    request = await cb({ request: request.clone(), event });
	                }
	            }
	            catch (err) {
	                throw new WorkboxError('plugin-error-request-will-fetch', {
	                    thrownError: err,
	                });
	            }
	            // The request can be altered by plugins with `requestWillFetch` making
	            // the original request (most likely from a `fetch` event) different
	            // from the Request we make. Pass both to `fetchDidFail` to aid debugging.
	            const pluginFilteredRequest = request.clone();
	            try {
	                let fetchResponse;
	                // See https://github.com/GoogleChrome/workbox/issues/1796
	                fetchResponse = await fetch(request, request.mode === 'navigate' ?
	                    undefined : this._strategy.fetchOptions);
	                if ("development" !== 'production') {
	                    logger.debug(`Network request for ` +
	                        `'${getFriendlyURL(request.url)}' returned a response with ` +
	                        `status '${fetchResponse.status}'.`);
	                }
	                for (const callback of this.iterateCallbacks('fetchDidSucceed')) {
	                    fetchResponse = await callback({
	                        event,
	                        request: pluginFilteredRequest,
	                        response: fetchResponse,
	                    });
	                }
	                return fetchResponse;
	            }
	            catch (error) {
	                {
	                    logger.error(`Network request for ` +
	                        `'${getFriendlyURL(request.url)}' threw an error.`, error);
	                }
	                // `originalRequest` will only exist if a `fetchDidFail` callback
	                // is being used (see above).
	                if (originalRequest) {
	                    await this.runCallbacks('fetchDidFail', {
	                        error,
	                        event,
	                        originalRequest: originalRequest.clone(),
	                        request: pluginFilteredRequest.clone(),
	                    });
	                }
	                throw error;
	            }
	        })());
	    }
	    /**
	     * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on
	     * the response generated by `this.fetch()`.
	     *
	     * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,
	     * so you do not have to manually call `waitUntil()` on the event.
	     *
	     * @param {Request|string} input The request or URL to fetch and cache.
	     * @return {Promise<Response>}
	     */
	    async fetchAndCachePut(input) {
	        const response = await this.fetch(input);
	        const responseClone = response.clone();
	        this.waitUntil(this.cachePut(input, responseClone));
	        return response;
	    }
	    /**
	     * Matches a request from the cache (and invokes any applicable plugin
	     * callback methods) using the `cacheName`, `matchOptions`, and `plugins`
	     * defined on the strategy object.
	     *
	     * The following plugin lifecycle methods are invoked when using this method:
	     * - cacheKeyWillByUsed()
	     * - cachedResponseWillByUsed()
	     *
	     * @param {Request|string} key The Request or URL to use as the cache key.
	     * @return {Promise<Response|undefined>} A matching response, if found.
	     */
	    cacheMatch(key) {
	        return this.waitUntil((async () => {
	            const request = toRequest(key);
	            let cachedResponse;
	            const { cacheName, matchOptions } = this._strategy;
	            const effectiveRequest = await this.getCacheKey(request, 'read');
	            const multiMatchOptions = { ...matchOptions, ...{ cacheName } };
	            cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);
	            {
	                if (cachedResponse) {
	                    logger.debug(`Found a cached response in '${cacheName}'.`);
	                }
	                else {
	                    logger.debug(`No cached response found in '${cacheName}'.`);
	                }
	            }
	            for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {
	                cachedResponse = (await callback({
	                    cacheName,
	                    matchOptions,
	                    cachedResponse,
	                    request: effectiveRequest,
	                    event: this.event,
	                })) || undefined;
	            }
	            return cachedResponse;
	        })());
	    }
	    /**
	     * Puts a request/response pair in the cache (and invokes any applicable
	     * plugin callback methods) using the `cacheName` and `plugins` defined on
	     * the strategy object.
	     *
	     * The following plugin lifecycle methods are invoked when using this method:
	     * - cacheKeyWillByUsed()
	     * - cacheWillUpdate()
	     * - cacheDidUpdate()
	     *
	     * @param {Request|string} key The request or URL to use as the cache key.
	     * @param {Promise<void>} response The response to cache.
	     */
	    async cachePut(key, response) {
	        const request = toRequest(key);
	        // Run in the next task to avoid blocking other cache reads.
	        // https://github.com/w3c/ServiceWorker/issues/1397
	        await timeout(0);
	        const effectiveRequest = await this.getCacheKey(request, 'write');
	        {
	            if (effectiveRequest.method && effectiveRequest.method !== 'GET') {
	                throw new WorkboxError('attempt-to-cache-non-get-request', {
	                    url: getFriendlyURL(effectiveRequest.url),
	                    method: effectiveRequest.method,
	                });
	            }
	        }
	        if (!response) {
	            {
	                logger.error(`Cannot cache non-existent response for ` +
	                    `'${getFriendlyURL(effectiveRequest.url)}'.`);
	            }
	            throw new WorkboxError('cache-put-with-no-response', {
	                url: getFriendlyURL(effectiveRequest.url),
	            });
	        }
	        const responseToCache = await this._ensureResponseSafeToCache(response);
	        if (!responseToCache) {
	            {
	                logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` +
	                    `will not be cached.`, responseToCache);
	            }
	            return;
	        }
	        const { cacheName, matchOptions } = this._strategy;
	        const cache = await self.caches.open(cacheName);
	        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');
	        const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams(
	        // TODO(philipwalton): the `__WB_REVISION__` param is a precaching
	        // feature. Consider into ways to only add this behavior if using
	        // precaching.
	        cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions) :
	            null;
	        {
	            logger.debug(`Updating the '${cacheName}' cache with a new Response ` +
	                `for ${getFriendlyURL(effectiveRequest.url)}.`);
	        }
	        try {
	            await cache.put(effectiveRequest, hasCacheUpdateCallback ?
	                responseToCache.clone() : responseToCache);
	        }
	        catch (error) {
	            // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError
	            if (error.name === 'QuotaExceededError') {
	                await executeQuotaErrorCallbacks();
	            }
	            throw error;
	        }
	        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {
	            await callback({
	                cacheName,
	                oldResponse,
	                newResponse: responseToCache.clone(),
	                request: effectiveRequest,
	                event: this.event,
	            });
	        }
	    }
	    /**
	     * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and
	     * executes any of those callbacks found in sequence. The final `Request`
	     * object returned by the last plugin is treated as the cache key for cache
	     * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have
	     * been registered, the passed request is returned unmodified
	     *
	     * @param {Request} request
	     * @param {string} mode
	     * @return {Promise<Request>}
	     */
	    async getCacheKey(request, mode) {
	        if (!this._cacheKeys[mode]) {
	            let effectiveRequest = request;
	            for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {
	                effectiveRequest = toRequest(await callback({
	                    mode,
	                    request: effectiveRequest,
	                    event: this.event,
	                    params: this.params,
	                }));
	            }
	            this._cacheKeys[mode] = effectiveRequest;
	        }
	        return this._cacheKeys[mode];
	    }
	    /**
	     * Returns true if the strategy has at least one plugin with the given
	     * callback.
	     *
	     * @param {string} name The name of the callback to check for.
	     * @return {boolean}
	     */
	    hasCallback(name) {
	        for (const plugin of this._strategy.plugins) {
	            if (name in plugin) {
	                return true;
	            }
	        }
	        return false;
	    }
	    /**
	     * Runs all plugin callbacks matching the given name, in order, passing the
	     * given param object (merged ith the current plugin state) as the only
	     * argument.
	     *
	     * Note: since this method runs all plugins, it's not suitable for cases
	     * where the return value of a callback needs to be applied prior to calling
	     * the next callback. See
	     * [`iterateCallbacks()`]{@link module:workbox-strategies.StrategyHandler#iterateCallbacks}
	     * below for how to handle that case.
	     *
	     * @param {string} name The name of the callback to run within each plugin.
	     * @param {Object} param The object to pass as the first (and only) param
	     *     when executing each callback. This object will be merged with the
	     *     current plugin state prior to callback execution.
	     */
	    async runCallbacks(name, param) {
	        for (const callback of this.iterateCallbacks(name)) {
	            // TODO(philipwalton): not sure why `any` is needed. It seems like
	            // this should work with `as WorkboxPluginCallbackParam[C]`.
	            await callback(param);
	        }
	    }
	    /**
	     * Accepts a callback and returns an iterable of matching plugin callbacks,
	     * where each callback is wrapped with the current handler state (i.e. when
	     * you call each callback, whatever object parameter you pass it will
	     * be merged with the plugin's current state).
	     *
	     * @param {string} name The name fo the callback to run
	     * @return {Array<Function>}
	     */
	    *iterateCallbacks(name) {
	        for (const plugin of this._strategy.plugins) {
	            if (typeof plugin[name] === 'function') {
	                const state = this._pluginStateMap.get(plugin);
	                const statefulCallback = (param) => {
	                    const statefulParam = { ...param, state };
	                    // TODO(philipwalton): not sure why `any` is needed. It seems like
	                    // this should work with `as WorkboxPluginCallbackParam[C]`.
	                    return plugin[name](statefulParam);
	                };
	                yield statefulCallback;
	            }
	        }
	    }
	    /**
	     * Adds a promise to the
	     * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}
	     * of the event event associated with the request being handled (usually a
	     * `FetchEvent`).
	     *
	     * Note: you can await
	     * [`doneWaiting()`]{@link module:workbox-strategies.StrategyHandler~doneWaiting}
	     * to know when all added promises have settled.
	     *
	     * @param {Promise} promise A promise to add to the extend lifetime promises
	     *     of the event that triggered the request.
	     */
	    waitUntil(promise) {
	        this._extendLifetimePromises.push(promise);
	        return promise;
	    }
	    /**
	     * Returns a promise that resolves once all promises passed to
	     * [`waitUntil()`]{@link module:workbox-strategies.StrategyHandler~waitUntil}
	     * have settled.
	     *
	     * Note: any work done after `doneWaiting()` settles should be manually
	     * passed to an event's `waitUntil()` method (not this handler's
	     * `waitUntil()` method), otherwise the service worker thread my be killed
	     * prior to your work completing.
	     */
	    async doneWaiting() {
	        let promise;
	        while (promise = this._extendLifetimePromises.shift()) {
	            await promise;
	        }
	    }
	    /**
	     * Stops running the strategy and immediately resolves any pending
	     * `waitUntil()` promises.
	     */
	    destroy() {
	        this._handlerDeferred.resolve();
	    }
	    /**
	     * This method will call cacheWillUpdate on the available plugins (or use
	     * status === 200) to determine if the Response is safe and valid to cache.
	     *
	     * @param {Request} options.request
	     * @param {Response} options.response
	     * @return {Promise<Response|undefined>}
	     *
	     * @private
	     */
	    async _ensureResponseSafeToCache(response) {
	        let responseToCache = response;
	        let pluginsUsed = false;
	        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {
	            responseToCache = (await callback({
	                request: this.request,
	                response: responseToCache,
	                event: this.event,
	            })) || undefined;
	            pluginsUsed = true;
	            if (!responseToCache) {
	                break;
	            }
	        }
	        if (!pluginsUsed) {
	            if (responseToCache && responseToCache.status !== 200) {
	                responseToCache = undefined;
	            }
	            {
	                if (responseToCache) {
	                    if (responseToCache.status !== 200) {
	                        if (responseToCache.status === 0) {
	                            logger.warn(`The response for '${this.request.url}' ` +
	                                `is an opaque response. The caching strategy that you're ` +
	                                `using will not cache opaque responses by default.`);
	                        }
	                        else {
	                            logger.debug(`The response for '${this.request.url}' ` +
	                                `returned a status code of '${response.status}' and won't ` +
	                                `be cached as a result.`);
	                        }
	                    }
	                }
	            }
	        }
	        return responseToCache;
	    }
	}

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * An abstract base class that all other strategy classes must extend from:
	 *
	 * @memberof module:workbox-strategies
	 */
	class Strategy {
	    /**
	     * Creates a new instance of the strategy and sets all documented option
	     * properties as public instance properties.
	     *
	     * Note: if a custom strategy class extends the base Strategy class and does
	     * not need more than these properties, it does not need to define its own
	     * constructor.
	     *
	     * @param {Object} [options]
	     * @param {string} [options.cacheName] Cache name to store and retrieve
	     * requests. Defaults to the cache names provided by
	     * [workbox-core]{@link module:workbox-core.cacheNames}.
	     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
	     * to use in conjunction with this caching strategy.
	     * @param {Object} [options.fetchOptions] Values passed along to the
	     * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}
	     * of all fetch() requests made by this strategy.
	     * @param {Object} [options.matchOptions] The
	     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
	     * for any `cache.match()` or `cache.put()` calls made by this strategy.
	     */
	    constructor(options = {}) {
	        /**
	         * Cache name to store and retrieve
	         * requests. Defaults to the cache names provided by
	         * [workbox-core]{@link module:workbox-core.cacheNames}.
	         *
	         * @type {string}
	         */
	        this.cacheName = cacheNames.getRuntimeName(options.cacheName);
	        /**
	         * The list
	         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
	         * used by this strategy.
	         *
	         * @type {Array<Object>}
	         */
	        this.plugins = options.plugins || [];
	        /**
	         * Values passed along to the
	         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}
	         * of all fetch() requests made by this strategy.
	         *
	         * @type {Object}
	         */
	        this.fetchOptions = options.fetchOptions;
	        /**
	         * The
	         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
	         * for any `cache.match()` or `cache.put()` calls made by this strategy.
	         *
	         * @type {Object}
	         */
	        this.matchOptions = options.matchOptions;
	    }
	    /**
	     * Perform a request strategy and returns a `Promise` that will resolve with
	     * a `Response`, invoking all relevant plugin callbacks.
	     *
	     * When a strategy instance is registered with a Workbox
	     * [route]{@link module:workbox-routing.Route}, this method is automatically
	     * called when the route matches.
	     *
	     * Alternatively, this method can be used in a standalone `FetchEvent`
	     * listener by passing it to `event.respondWith()`.
	     *
	     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
	     *     properties listed below.
	     * @param {Request|string} options.request A request to run this strategy for.
	     * @param {ExtendableEvent} options.event The event associated with the
	     *     request.
	     * @param {URL} [options.url]
	     * @param {*} [options.params]
	     */
	    handle(options) {
	        const [responseDone] = this.handleAll(options);
	        return responseDone;
	    }
	    /**
	     * Similar to [`handle()`]{@link module:workbox-strategies.Strategy~handle}, but
	     * instead of just returning a `Promise` that resolves to a `Response` it
	     * it will return an tuple of [response, done] promises, where the former
	     * (`response`) is equivalent to what `handle()` returns, and the latter is a
	     * Promise that will resolve once any promises that were added to
	     * `event.waitUntil()` as part of performing the strategy have completed.
	     *
	     * You can await the `done` promise to ensure any extra work performed by
	     * the strategy (usually caching responses) completes successfully.
	     *
	     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
	     *     properties listed below.
	     * @param {Request|string} options.request A request to run this strategy for.
	     * @param {ExtendableEvent} options.event The event associated with the
	     *     request.
	     * @param {URL} [options.url]
	     * @param {*} [options.params]
	     * @return {Array<Promise>} A tuple of [response, done]
	     *     promises that can be used to determine when the response resolves as
	     *     well as when the handler has completed all its work.
	     */
	    handleAll(options) {
	        // Allow for flexible options to be passed.
	        if (options instanceof FetchEvent) {
	            options = {
	                event: options,
	                request: options.request,
	            };
	        }
	        const event = options.event;
	        const request = typeof options.request === 'string' ?
	            new Request(options.request) :
	            options.request;
	        const params = 'params' in options ? options.params : undefined;
	        const handler = new StrategyHandler(this, { event, request, params });
	        const responseDone = this._getResponse(handler, request, event);
	        const handlerDone = this._awaitComplete(responseDone, handler, request, event);
	        // Return an array of promises, suitable for use with Promise.all().
	        return [responseDone, handlerDone];
	    }
	    async _getResponse(handler, request, event) {
	        await handler.runCallbacks('handlerWillStart', { event, request });
	        let response = undefined;
	        try {
	            response = await this._handle(request, handler);
	            // The "official" Strategy subclasses all throw this error automatically,
	            // but in case a third-party Strategy doesn't, ensure that we have a
	            // consistent failure when there's no response or an error response.
	            if (!response || response.type === 'error') {
	                throw new WorkboxError('no-response', { url: request.url });
	            }
	        }
	        catch (error) {
	            for (const callback of handler.iterateCallbacks('handlerDidError')) {
	                response = await callback({ error, event, request });
	                if (response) {
	                    break;
	                }
	            }
	            if (!response) {
	                throw error;
	            }
	            else {
	                logger.log(`While responding to '${getFriendlyURL(request.url)}', ` +
	                    `an ${error} error occurred. Using a fallback response provided by ` +
	                    `a handlerDidError plugin.`);
	            }
	        }
	        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {
	            response = await callback({ event, request, response });
	        }
	        return response;
	    }
	    async _awaitComplete(responseDone, handler, request, event) {
	        let response;
	        let error;
	        try {
	            response = await responseDone;
	        }
	        catch (error) {
	            // Ignore errors, as response errors should be caught via the `response`
	            // promise above. The `done` promise will only throw for errors in
	            // promises passed to `handler.waitUntil()`.
	        }
	        try {
	            await handler.runCallbacks('handlerDidRespond', {
	                event,
	                request,
	                response,
	            });
	            await handler.doneWaiting();
	        }
	        catch (waitUntilError) {
	            error = waitUntilError;
	        }
	        await handler.runCallbacks('handlerDidComplete', {
	            event,
	            request,
	            response,
	            error,
	        });
	        handler.destroy();
	        if (error) {
	            throw error;
	        }
	    }
	}
	/**
	 * Classes extending the `Strategy` based class should implement this method,
	 * and leverage the [`handler`]{@link module:workbox-strategies.StrategyHandler}
	 * arg to perform all fetching and cache logic, which will ensure all relevant
	 * cache, cache options, fetch options and plugins are used (per the current
	 * strategy instance).
	 *
	 * @name _handle
	 * @instance
	 * @abstract
	 * @function
	 * @param {Request} request
	 * @param {module:workbox-strategies.StrategyHandler} handler
	 * @return {Promise<Response>}
	 *
	 * @memberof module:workbox-strategies.Strategy
	 */

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const copyRedirectedCacheableResponsesPlugin = {
	    async cacheWillUpdate({ response }) {
	        return response.redirected ? await copyResponse(response) : response;
	    }
	};
	/**
	 * A [Strategy]{@link module:workbox-strategies.Strategy} implementation
	 * specifically designed to work with
	 * [PrecacheController]{@link module:workbox-precaching.PrecacheController}
	 * to both cache and fetch precached assets.
	 *
	 * Note: an instance of this class is created automatically when creating a
	 * `PrecacheController`; it's generally not necessary to create this yourself.
	 *
	 * @extends module:workbox-strategies.Strategy
	 * @memberof module:workbox-precaching
	 */
	class PrecacheStrategy extends Strategy {
	    /**
	     *
	     * @param {Object} [options]
	     * @param {string} [options.cacheName] Cache name to store and retrieve
	     * requests. Defaults to the cache names provided by
	     * [workbox-core]{@link module:workbox-core.cacheNames}.
	     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
	     * to use in conjunction with this caching strategy.
	     * @param {Object} [options.fetchOptions] Values passed along to the
	     * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}
	     * of all fetch() requests made by this strategy.
	     * @param {Object} [options.matchOptions] The
	     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
	     * for any `cache.match()` or `cache.put()` calls made by this strategy.
	     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
	     * get the response from the network if there's a precache miss.
	     */
	    constructor(options = {}) {
	        options.cacheName = cacheNames.getPrecacheName(options.cacheName);
	        super(options);
	        this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true;
	        // Redirected responses cannot be used to satisfy a navigation request, so
	        // any redirected response must be "copied" rather than cloned, so the new
	        // response doesn't contain the `redirected` flag. See:
	        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1
	        this.plugins.push(copyRedirectedCacheableResponsesPlugin);
	    }
	    /**
	     * @private
	     * @param {Request|string} request A request to run this strategy for.
	     * @param {module:workbox-strategies.StrategyHandler} handler The event that
	     *     triggered the request.
	     * @return {Promise<Response>}
	     */
	    async _handle(request, handler) {
	        const response = await handler.cacheMatch(request);
	        if (!response) {
	            // If this is an `install` event then populate the cache. If this is a
	            // `fetch` event (or any other event) then respond with the cached
	            // response.
	            if (handler.event && handler.event.type === 'install') {
	                return await this._handleInstall(request, handler);
	            }
	            return await this._handleFetch(request, handler);
	        }
	        return response;
	    }
	    async _handleFetch(request, handler) {
	        let response;
	        // Fall back to the network if we don't have a cached response
	        // (perhaps due to manual cache cleanup).
	        if (this._fallbackToNetwork) {
	            {
	                logger.warn(`The precached response for ` +
	                    `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` +
	                    `found. Falling back to the network instead.`);
	            }
	            response = await handler.fetch(request);
	        }
	        else {
	            // This shouldn't normally happen, but there are edge cases:
	            // https://github.com/GoogleChrome/workbox/issues/1441
	            throw new WorkboxError('missing-precache-entry', {
	                cacheName: this.cacheName,
	                url: request.url,
	            });
	        }
	        {
	            const cacheKey = handler.params && handler.params.cacheKey ||
	                await handler.getCacheKey(request, 'read');
	            // Workbox is going to handle the route.
	            // print the routing details to the console.
	            logger.groupCollapsed(`Precaching is responding to: ` +
	                getFriendlyURL(request.url));
	            logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey.url)}`);
	            logger.groupCollapsed(`View request details here.`);
	            logger.log(request);
	            logger.groupEnd();
	            logger.groupCollapsed(`View response details here.`);
	            logger.log(response);
	            logger.groupEnd();
	            logger.groupEnd();
	        }
	        return response;
	    }
	    async _handleInstall(request, handler) {
	        const response = await handler.fetchAndCachePut(request);
	        // Any time there's no response, consider it a precaching error.
	        let responseSafeToPrecache = Boolean(response);
	        // Also consider it an error if the user didn't pass their own
	        // cacheWillUpdate plugin, and the response is a 400+ (note: this means
	        // that by default opaque responses can be precached).
	        if (response && response.status >= 400 &&
	            !this._usesCustomCacheableResponseLogic()) {
	            responseSafeToPrecache = false;
	        }
	        if (!responseSafeToPrecache) {
	            // Throwing here will lead to the `install` handler failing, which
	            // we want to do if *any* of the responses aren't safe to cache.
	            throw new WorkboxError('bad-precaching-response', {
	                url: request.url,
	                status: response.status,
	            });
	        }
	        return response;
	    }
	    /**
	     * Returns true if any users plugins were added containing their own
	     * `cacheWillUpdate` callback.
	     *
	     * This method indicates whether the default cacheable response logic (i.e.
	     * <400, including opaque responses) should be used. If a custom plugin
	     * with a `cacheWillUpdate` callback is passed, then the strategy should
	     * defer to that plugin's logic.
	     *
	     * @private
	     */
	    _usesCustomCacheableResponseLogic() {
	        return this.plugins.some((plugin) => plugin.cacheWillUpdate &&
	            plugin !== copyRedirectedCacheableResponsesPlugin);
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Performs efficient precaching of assets.
	 *
	 * @memberof module:workbox-precaching
	 */
	class PrecacheController {
	    /**
	     * Create a new PrecacheController.
	     *
	     * @param {Object} [options]
	     * @param {string} [options.cacheName] The cache to use for precaching.
	     * @param {string} [options.plugins] Plugins to use when precaching as well
	     * as responding to fetch events for precached assets.
	     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
	     * get the response from the network if there's a precache miss.
	     */
	    constructor({ cacheName, plugins = [], fallbackToNetwork = true } = {}) {
	        this._urlsToCacheKeys = new Map();
	        this._urlsToCacheModes = new Map();
	        this._cacheKeysToIntegrities = new Map();
	        this._strategy = new PrecacheStrategy({
	            cacheName: cacheNames.getPrecacheName(cacheName),
	            plugins: [
	                ...plugins,
	                new PrecacheCacheKeyPlugin({ precacheController: this }),
	            ],
	            fallbackToNetwork,
	        });
	        // Bind the install and activate methods to the instance.
	        this.install = this.install.bind(this);
	        this.activate = this.activate.bind(this);
	    }
	    /**
	     * @type {module:workbox-precaching.PrecacheStrategy} The strategy created by this controller and
	     * used to cache assets and respond to fetch events.
	     */
	    get strategy() {
	        return this._strategy;
	    }
	    /**
	     * Adds items to the precache list, removing any duplicates and
	     * stores the files in the
	     * ["precache cache"]{@link module:workbox-core.cacheNames} when the service
	     * worker installs.
	     *
	     * This method can be called multiple times.
	     *
	     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.
	     */
	    precache(entries) {
	        this.addToCacheList(entries);
	        if (!this._installAndActiveListenersAdded) {
	            self.addEventListener('install', this.install);
	            self.addEventListener('activate', this.activate);
	            this._installAndActiveListenersAdded = true;
	        }
	    }
	    /**
	     * This method will add items to the precache list, removing duplicates
	     * and ensuring the information is valid.
	     *
	     * @param {Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>} entries
	     *     Array of entries to precache.
	     */
	    addToCacheList(entries) {
	        {
	            finalAssertExports.isArray(entries, {
	                moduleName: 'workbox-precaching',
	                className: 'PrecacheController',
	                funcName: 'addToCacheList',
	                paramName: 'entries',
	            });
	        }
	        const urlsToWarnAbout = [];
	        for (const entry of entries) {
	            // See https://github.com/GoogleChrome/workbox/issues/2259
	            if (typeof entry === 'string') {
	                urlsToWarnAbout.push(entry);
	            }
	            else if (entry && entry.revision === undefined) {
	                urlsToWarnAbout.push(entry.url);
	            }
	            const { cacheKey, url } = createCacheKey(entry);
	            const cacheMode = (typeof entry !== 'string' && entry.revision) ?
	                'reload' : 'default';
	            if (this._urlsToCacheKeys.has(url) &&
	                this._urlsToCacheKeys.get(url) !== cacheKey) {
	                throw new WorkboxError('add-to-cache-list-conflicting-entries', {
	                    firstEntry: this._urlsToCacheKeys.get(url),
	                    secondEntry: cacheKey,
	                });
	            }
	            if (typeof entry !== 'string' && entry.integrity) {
	                if (this._cacheKeysToIntegrities.has(cacheKey) &&
	                    this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {
	                    throw new WorkboxError('add-to-cache-list-conflicting-integrities', {
	                        url,
	                    });
	                }
	                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);
	            }
	            this._urlsToCacheKeys.set(url, cacheKey);
	            this._urlsToCacheModes.set(url, cacheMode);
	            if (urlsToWarnAbout.length > 0) {
	                const warningMessage = `Workbox is precaching URLs without revision ` +
	                    `info: ${urlsToWarnAbout.join(', ')}\nThis is generally NOT safe. ` +
	                    `Learn more at https://bit.ly/wb-precache`;
	                {
	                    logger.warn(warningMessage);
	                }
	            }
	        }
	    }
	    /**
	     * Precaches new and updated assets. Call this method from the service worker
	     * install event.
	     *
	     * Note: this method calls `event.waitUntil()` for you, so you do not need
	     * to call it yourself in your event handlers.
	     *
	     * @param {Object} options
	     * @param {Event} options.event The install event.
	     * @return {Promise<module:workbox-precaching.InstallResult>}
	     */
	    install(event) {
	        return waitUntil(event, async () => {
	            const installReportPlugin = new PrecacheInstallReportPlugin();
	            this.strategy.plugins.push(installReportPlugin);
	            // Cache entries one at a time.
	            // See https://github.com/GoogleChrome/workbox/issues/2528
	            for (const [url, cacheKey] of this._urlsToCacheKeys) {
	                const integrity = this._cacheKeysToIntegrities.get(cacheKey);
	                const cacheMode = this._urlsToCacheModes.get(url);
	                const request = new Request(url, {
	                    integrity,
	                    cache: cacheMode,
	                    credentials: 'same-origin',
	                });
	                await Promise.all(this.strategy.handleAll({
	                    params: { cacheKey },
	                    request,
	                    event,
	                }));
	            }
	            const { updatedURLs, notUpdatedURLs } = installReportPlugin;
	            {
	                printInstallDetails(updatedURLs, notUpdatedURLs);
	            }
	            return { updatedURLs, notUpdatedURLs };
	        });
	    }
	    /**
	     * Deletes assets that are no longer present in the current precache manifest.
	     * Call this method from the service worker activate event.
	     *
	     * Note: this method calls `event.waitUntil()` for you, so you do not need
	     * to call it yourself in your event handlers.
	     *
	     * @param {ExtendableEvent}
	     * @return {Promise<module:workbox-precaching.CleanupResult>}
	     */
	    activate(event) {
	        return waitUntil(event, async () => {
	            const cache = await self.caches.open(this.strategy.cacheName);
	            const currentlyCachedRequests = await cache.keys();
	            const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());
	            const deletedURLs = [];
	            for (const request of currentlyCachedRequests) {
	                if (!expectedCacheKeys.has(request.url)) {
	                    await cache.delete(request);
	                    deletedURLs.push(request.url);
	                }
	            }
	            {
	                printCleanupDetails(deletedURLs);
	            }
	            return { deletedURLs };
	        });
	    }
	    /**
	     * Returns a mapping of a precached URL to the corresponding cache key, taking
	     * into account the revision information for the URL.
	     *
	     * @return {Map<string, string>} A URL to cache key mapping.
	     */
	    getURLsToCacheKeys() {
	        return this._urlsToCacheKeys;
	    }
	    /**
	     * Returns a list of all the URLs that have been precached by the current
	     * service worker.
	     *
	     * @return {Array<string>} The precached URLs.
	     */
	    getCachedURLs() {
	        return [...this._urlsToCacheKeys.keys()];
	    }
	    /**
	     * Returns the cache key used for storing a given URL. If that URL is
	     * unversioned, like `/index.html', then the cache key will be the original
	     * URL with a search parameter appended to it.
	     *
	     * @param {string} url A URL whose cache key you want to look up.
	     * @return {string} The versioned URL that corresponds to a cache key
	     * for the original URL, or undefined if that URL isn't precached.
	     */
	    getCacheKeyForURL(url) {
	        const urlObject = new URL(url, location.href);
	        return this._urlsToCacheKeys.get(urlObject.href);
	    }
	    /**
	     * This acts as a drop-in replacement for
	     * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)
	     * with the following differences:
	     *
	     * - It knows what the name of the precache is, and only checks in that cache.
	     * - It allows you to pass in an "original" URL without versioning parameters,
	     * and it will automatically look up the correct cache key for the currently
	     * active revision of that URL.
	     *
	     * E.g., `matchPrecache('index.html')` will find the correct precached
	     * response for the currently active service worker, even if the actual cache
	     * key is `'/index.html?__WB_REVISION__=1234abcd'`.
	     *
	     * @param {string|Request} request The key (without revisioning parameters)
	     * to look up in the precache.
	     * @return {Promise<Response|undefined>}
	     */
	    async matchPrecache(request) {
	        const url = request instanceof Request ? request.url : request;
	        const cacheKey = this.getCacheKeyForURL(url);
	        if (cacheKey) {
	            const cache = await self.caches.open(this.strategy.cacheName);
	            return cache.match(cacheKey);
	        }
	        return undefined;
	    }
	    /**
	     * Returns a function that looks up `url` in the precache (taking into
	     * account revision information), and returns the corresponding `Response`.
	     *
	     * @param {string} url The precached URL which will be used to lookup the
	     * `Response`.
	     * @return {module:workbox-routing~handlerCallback}
	     */
	    createHandlerBoundToURL(url) {
	        const cacheKey = this.getCacheKeyForURL(url);
	        if (!cacheKey) {
	            throw new WorkboxError('non-precached-url', { url });
	        }
	        return (options) => {
	            options.request = new Request(url);
	            options.params = { cacheKey, ...options.params };
	            return this.strategy.handle(options);
	        };
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	let precacheController;
	/**
	 * @return {PrecacheController}
	 * @private
	 */
	const getOrCreatePrecacheController = () => {
	    if (!precacheController) {
	        precacheController = new PrecacheController();
	    }
	    return precacheController;
	};

	// @ts-ignore
	try {
	    self['workbox:routing:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * The default HTTP method, 'GET', used when there's no specific method
	 * configured for a route.
	 *
	 * @type {string}
	 *
	 * @private
	 */
	const defaultMethod = 'GET';
	/**
	 * The list of valid HTTP methods associated with requests that could be routed.
	 *
	 * @type {Array<string>}
	 *
	 * @private
	 */
	const validMethods = [
	    'DELETE',
	    'GET',
	    'HEAD',
	    'PATCH',
	    'POST',
	    'PUT',
	];

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * @param {function()|Object} handler Either a function, or an object with a
	 * 'handle' method.
	 * @return {Object} An object with a handle method.
	 *
	 * @private
	 */
	const normalizeHandler = (handler) => {
	    if (handler && typeof handler === 'object') {
	        {
	            finalAssertExports.hasMethod(handler, 'handle', {
	                moduleName: 'workbox-routing',
	                className: 'Route',
	                funcName: 'constructor',
	                paramName: 'handler',
	            });
	        }
	        return handler;
	    }
	    else {
	        {
	            finalAssertExports.isType(handler, 'function', {
	                moduleName: 'workbox-routing',
	                className: 'Route',
	                funcName: 'constructor',
	                paramName: 'handler',
	            });
	        }
	        return { handle: handler };
	    }
	};

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A `Route` consists of a pair of callback functions, "match" and "handler".
	 * The "match" callback determine if a route should be used to "handle" a
	 * request by returning a non-falsy value if it can. The "handler" callback
	 * is called when there is a match and should return a Promise that resolves
	 * to a `Response`.
	 *
	 * @memberof module:workbox-routing
	 */
	class Route {
	    /**
	     * Constructor for Route class.
	     *
	     * @param {module:workbox-routing~matchCallback} match
	     * A callback function that determines whether the route matches a given
	     * `fetch` event by returning a non-falsy value.
	     * @param {module:workbox-routing~handlerCallback} handler A callback
	     * function that returns a Promise resolving to a Response.
	     * @param {string} [method='GET'] The HTTP method to match the Route
	     * against.
	     */
	    constructor(match, handler, method = defaultMethod) {
	        {
	            finalAssertExports.isType(match, 'function', {
	                moduleName: 'workbox-routing',
	                className: 'Route',
	                funcName: 'constructor',
	                paramName: 'match',
	            });
	            if (method) {
	                finalAssertExports.isOneOf(method, validMethods, { paramName: 'method' });
	            }
	        }
	        // These values are referenced directly by Router so cannot be
	        // altered by minificaton.
	        this.handler = normalizeHandler(handler);
	        this.match = match;
	        this.method = method;
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * RegExpRoute makes it easy to create a regular expression based
	 * [Route]{@link module:workbox-routing.Route}.
	 *
	 * For same-origin requests the RegExp only needs to match part of the URL. For
	 * requests against third-party servers, you must define a RegExp that matches
	 * the start of the URL.
	 *
	 * [See the module docs for info.]{@link https://developers.google.com/web/tools/workbox/modules/workbox-routing}
	 *
	 * @memberof module:workbox-routing
	 * @extends module:workbox-routing.Route
	 */
	class RegExpRoute extends Route {
	    /**
	     * If the regular expression contains
	     * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},
	     * the captured values will be passed to the
	     * [handler's]{@link module:workbox-routing~handlerCallback} `params`
	     * argument.
	     *
	     * @param {RegExp} regExp The regular expression to match against URLs.
	     * @param {module:workbox-routing~handlerCallback} handler A callback
	     * function that returns a Promise resulting in a Response.
	     * @param {string} [method='GET'] The HTTP method to match the Route
	     * against.
	     */
	    constructor(regExp, handler, method) {
	        {
	            finalAssertExports.isInstance(regExp, RegExp, {
	                moduleName: 'workbox-routing',
	                className: 'RegExpRoute',
	                funcName: 'constructor',
	                paramName: 'pattern',
	            });
	        }
	        const match = ({ url }) => {
	            const result = regExp.exec(url.href);
	            // Return immediately if there's no match.
	            if (!result) {
	                return;
	            }
	            // Require that the match start at the first character in the URL string
	            // if it's a cross-origin request.
	            // See https://github.com/GoogleChrome/workbox/issues/281 for the context
	            // behind this behavior.
	            if ((url.origin !== location.origin) && (result.index !== 0)) {
	                {
	                    logger.debug(`The regular expression '${regExp}' only partially matched ` +
	                        `against the cross-origin URL '${url}'. RegExpRoute's will only ` +
	                        `handle cross-origin requests if they match the entire URL.`);
	                }
	                return;
	            }
	            // If the route matches, but there aren't any capture groups defined, then
	            // this will return [], which is truthy and therefore sufficient to
	            // indicate a match.
	            // If there are capture groups, then it will return their values.
	            return result.slice(1);
	        };
	        super(match, handler, method);
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * The Router can be used to process a FetchEvent through one or more
	 * [Routes]{@link module:workbox-routing.Route} responding  with a Request if
	 * a matching route exists.
	 *
	 * If no route matches a given a request, the Router will use a "default"
	 * handler if one is defined.
	 *
	 * Should the matching Route throw an error, the Router will use a "catch"
	 * handler if one is defined to gracefully deal with issues and respond with a
	 * Request.
	 *
	 * If a request matches multiple routes, the **earliest** registered route will
	 * be used to respond to the request.
	 *
	 * @memberof module:workbox-routing
	 */
	class Router {
	    /**
	     * Initializes a new Router.
	     */
	    constructor() {
	        this._routes = new Map();
	        this._defaultHandlerMap = new Map();
	    }
	    /**
	     * @return {Map<string, Array<module:workbox-routing.Route>>} routes A `Map` of HTTP
	     * method name ('GET', etc.) to an array of all the corresponding `Route`
	     * instances that are registered.
	     */
	    get routes() {
	        return this._routes;
	    }
	    /**
	     * Adds a fetch event listener to respond to events when a route matches
	     * the event's request.
	     */
	    addFetchListener() {
	        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
	        self.addEventListener('fetch', ((event) => {
	            const { request } = event;
	            const responsePromise = this.handleRequest({ request, event });
	            if (responsePromise) {
	                event.respondWith(responsePromise);
	            }
	        }));
	    }
	    /**
	     * Adds a message event listener for URLs to cache from the window.
	     * This is useful to cache resources loaded on the page prior to when the
	     * service worker started controlling it.
	     *
	     * The format of the message data sent from the window should be as follows.
	     * Where the `urlsToCache` array may consist of URL strings or an array of
	     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).
	     *
	     * ```
	     * {
	     *   type: 'CACHE_URLS',
	     *   payload: {
	     *     urlsToCache: [
	     *       './script1.js',
	     *       './script2.js',
	     *       ['./script3.js', {mode: 'no-cors'}],
	     *     ],
	     *   },
	     * }
	     * ```
	     */
	    addCacheListener() {
	        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
	        self.addEventListener('message', ((event) => {
	            if (event.data && event.data.type === 'CACHE_URLS') {
	                const { payload } = event.data;
	                {
	                    logger.debug(`Caching URLs from the window`, payload.urlsToCache);
	                }
	                const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {
	                    if (typeof entry === 'string') {
	                        entry = [entry];
	                    }
	                    const request = new Request(...entry);
	                    return this.handleRequest({ request, event });
	                    // TODO(philipwalton): TypeScript errors without this typecast for
	                    // some reason (probably a bug). The real type here should work but
	                    // doesn't: `Array<Promise<Response> | undefined>`.
	                })); // TypeScript
	                event.waitUntil(requestPromises);
	                // If a MessageChannel was used, reply to the message on success.
	                if (event.ports && event.ports[0]) {
	                    requestPromises.then(() => event.ports[0].postMessage(true));
	                }
	            }
	        }));
	    }
	    /**
	     * Apply the routing rules to a FetchEvent object to get a Response from an
	     * appropriate Route's handler.
	     *
	     * @param {Object} options
	     * @param {Request} options.request The request to handle.
	     * @param {ExtendableEvent} options.event The event that triggered the
	     *     request.
	     * @return {Promise<Response>|undefined} A promise is returned if a
	     *     registered route can handle the request. If there is no matching
	     *     route and there's no `defaultHandler`, `undefined` is returned.
	     */
	    handleRequest({ request, event }) {
	        {
	            finalAssertExports.isInstance(request, Request, {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'handleRequest',
	                paramName: 'options.request',
	            });
	        }
	        const url = new URL(request.url, location.href);
	        if (!url.protocol.startsWith('http')) {
	            {
	                logger.debug(`Workbox Router only supports URLs that start with 'http'.`);
	            }
	            return;
	        }
	        const sameOrigin = url.origin === location.origin;
	        const { params, route } = this.findMatchingRoute({
	            event,
	            request,
	            sameOrigin,
	            url,
	        });
	        let handler = route && route.handler;
	        const debugMessages = [];
	        {
	            if (handler) {
	                debugMessages.push([
	                    `Found a route to handle this request:`, route,
	                ]);
	                if (params) {
	                    debugMessages.push([
	                        `Passing the following params to the route's handler:`, params,
	                    ]);
	                }
	            }
	        }
	        // If we don't have a handler because there was no matching route, then
	        // fall back to defaultHandler if that's defined.
	        const method = request.method;
	        if (!handler && this._defaultHandlerMap.has(method)) {
	            {
	                debugMessages.push(`Failed to find a matching route. Falling ` +
	                    `back to the default handler for ${method}.`);
	            }
	            handler = this._defaultHandlerMap.get(method);
	        }
	        if (!handler) {
	            {
	                // No handler so Workbox will do nothing. If logs is set of debug
	                // i.e. verbose, we should print out this information.
	                logger.debug(`No route found for: ${getFriendlyURL(url)}`);
	            }
	            return;
	        }
	        {
	            // We have a handler, meaning Workbox is going to handle the route.
	            // print the routing details to the console.
	            logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);
	            debugMessages.forEach((msg) => {
	                if (Array.isArray(msg)) {
	                    logger.log(...msg);
	                }
	                else {
	                    logger.log(msg);
	                }
	            });
	            logger.groupEnd();
	        }
	        // Wrap in try and catch in case the handle method throws a synchronous
	        // error. It should still callback to the catch handler.
	        let responsePromise;
	        try {
	            responsePromise = handler.handle({ url, request, event, params });
	        }
	        catch (err) {
	            responsePromise = Promise.reject(err);
	        }
	        if (responsePromise instanceof Promise && this._catchHandler) {
	            responsePromise = responsePromise.catch((err) => {
	                {
	                    // Still include URL here as it will be async from the console group
	                    // and may not make sense without the URL
	                    logger.groupCollapsed(`Error thrown when responding to: ` +
	                        ` ${getFriendlyURL(url)}. Falling back to Catch Handler.`);
	                    logger.error(`Error thrown by:`, route);
	                    logger.error(err);
	                    logger.groupEnd();
	                }
	                return this._catchHandler.handle({ url, request, event });
	            });
	        }
	        return responsePromise;
	    }
	    /**
	     * Checks a request and URL (and optionally an event) against the list of
	     * registered routes, and if there's a match, returns the corresponding
	     * route along with any params generated by the match.
	     *
	     * @param {Object} options
	     * @param {URL} options.url
	     * @param {Request} options.request The request to match.
	     * @param {Event} options.event The corresponding event.
	     * @return {Object} An object with `route` and `params` properties.
	     *     They are populated if a matching route was found or `undefined`
	     *     otherwise.
	     */
	    findMatchingRoute({ url, sameOrigin, request, event }) {
	        const routes = this._routes.get(request.method) || [];
	        for (const route of routes) {
	            let params;
	            const matchResult = route.match({ url, sameOrigin, request, event });
	            if (matchResult) {
	                {
	                    // Warn developers that using an async matchCallback is almost always
	                    // not the right thing to do. 
	                    if (matchResult instanceof Promise) {
	                        logger.warn(`While routing ${getFriendlyURL(url)}, an async ` +
	                            `matchCallback function was used. Please convert the ` +
	                            `following route to use a synchronous matchCallback function:`, route);
	                    }
	                }
	                // See https://github.com/GoogleChrome/workbox/issues/2079
	                params = matchResult;
	                if (Array.isArray(matchResult) && matchResult.length === 0) {
	                    // Instead of passing an empty array in as params, use undefined.
	                    params = undefined;
	                }
	                else if ((matchResult.constructor === Object &&
	                    Object.keys(matchResult).length === 0)) {
	                    // Instead of passing an empty object in as params, use undefined.
	                    params = undefined;
	                }
	                else if (typeof matchResult === 'boolean') {
	                    // For the boolean value true (rather than just something truth-y),
	                    // don't set params.
	                    // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353
	                    params = undefined;
	                }
	                // Return early if have a match.
	                return { route, params };
	            }
	        }
	        // If no match was found above, return and empty object.
	        return {};
	    }
	    /**
	     * Define a default `handler` that's called when no routes explicitly
	     * match the incoming request.
	     *
	     * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.
	     *
	     * Without a default handler, unmatched requests will go against the
	     * network as if there were no service worker present.
	     *
	     * @param {module:workbox-routing~handlerCallback} handler A callback
	     * function that returns a Promise resulting in a Response.
	     * @param {string} [method='GET'] The HTTP method to associate with this
	     * default handler. Each method has its own default.
	     */
	    setDefaultHandler(handler, method = defaultMethod) {
	        this._defaultHandlerMap.set(method, normalizeHandler(handler));
	    }
	    /**
	     * If a Route throws an error while handling a request, this `handler`
	     * will be called and given a chance to provide a response.
	     *
	     * @param {module:workbox-routing~handlerCallback} handler A callback
	     * function that returns a Promise resulting in a Response.
	     */
	    setCatchHandler(handler) {
	        this._catchHandler = normalizeHandler(handler);
	    }
	    /**
	     * Registers a route with the router.
	     *
	     * @param {module:workbox-routing.Route} route The route to register.
	     */
	    registerRoute(route) {
	        {
	            finalAssertExports.isType(route, 'object', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route',
	            });
	            finalAssertExports.hasMethod(route, 'match', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route',
	            });
	            finalAssertExports.isType(route.handler, 'object', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route',
	            });
	            finalAssertExports.hasMethod(route.handler, 'handle', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route.handler',
	            });
	            finalAssertExports.isType(route.method, 'string', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route.method',
	            });
	        }
	        if (!this._routes.has(route.method)) {
	            this._routes.set(route.method, []);
	        }
	        // Give precedence to all of the earlier routes by adding this additional
	        // route to the end of the array.
	        this._routes.get(route.method).push(route);
	    }
	    /**
	     * Unregisters a route with the router.
	     *
	     * @param {module:workbox-routing.Route} route The route to unregister.
	     */
	    unregisterRoute(route) {
	        if (!this._routes.has(route.method)) {
	            throw new WorkboxError('unregister-route-but-not-found-with-method', {
	                method: route.method,
	            });
	        }
	        const routeIndex = this._routes.get(route.method).indexOf(route);
	        if (routeIndex > -1) {
	            this._routes.get(route.method).splice(routeIndex, 1);
	        }
	        else {
	            throw new WorkboxError('unregister-route-route-not-registered');
	        }
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	let defaultRouter;
	/**
	 * Creates a new, singleton Router instance if one does not exist. If one
	 * does already exist, that instance is returned.
	 *
	 * @private
	 * @return {Router}
	 */
	const getOrCreateDefaultRouter = () => {
	    if (!defaultRouter) {
	        defaultRouter = new Router();
	        // The helpers that use the default Router assume these listeners exist.
	        defaultRouter.addFetchListener();
	        defaultRouter.addCacheListener();
	    }
	    return defaultRouter;
	};

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Easily register a RegExp, string, or function with a caching
	 * strategy to a singleton Router instance.
	 *
	 * This method will generate a Route for you if needed and
	 * call [registerRoute()]{@link module:workbox-routing.Router#registerRoute}.
	 *
	 * @param {RegExp|string|module:workbox-routing.Route~matchCallback|module:workbox-routing.Route} capture
	 * If the capture param is a `Route`, all other arguments will be ignored.
	 * @param {module:workbox-routing~handlerCallback} [handler] A callback
	 * function that returns a Promise resulting in a Response. This parameter
	 * is required if `capture` is not a `Route` object.
	 * @param {string} [method='GET'] The HTTP method to match the Route
	 * against.
	 * @return {module:workbox-routing.Route} The generated `Route`(Useful for
	 * unregistering).
	 *
	 * @memberof module:workbox-routing
	 */
	function registerRoute(capture, handler, method) {
	    let route;
	    if (typeof capture === 'string') {
	        const captureUrl = new URL(capture, location.href);
	        {
	            if (!(capture.startsWith('/') || capture.startsWith('http'))) {
	                throw new WorkboxError('invalid-string', {
	                    moduleName: 'workbox-routing',
	                    funcName: 'registerRoute',
	                    paramName: 'capture',
	                });
	            }
	            // We want to check if Express-style wildcards are in the pathname only.
	            // TODO: Remove this log message in v4.
	            const valueToCheck = capture.startsWith('http') ?
	                captureUrl.pathname : capture;
	            // See https://github.com/pillarjs/path-to-regexp#parameters
	            const wildcards = '[*:?+]';
	            if ((new RegExp(`${wildcards}`)).exec(valueToCheck)) {
	                logger.debug(`The '$capture' parameter contains an Express-style wildcard ` +
	                    `character (${wildcards}). Strings are now always interpreted as ` +
	                    `exact matches; use a RegExp for partial or wildcard matches.`);
	            }
	        }
	        const matchCallback = ({ url }) => {
	            {
	                if ((url.pathname === captureUrl.pathname) &&
	                    (url.origin !== captureUrl.origin)) {
	                    logger.debug(`${capture} only partially matches the cross-origin URL ` +
	                        `${url}. This route will only handle cross-origin requests ` +
	                        `if they match the entire URL.`);
	                }
	            }
	            return url.href === captureUrl.href;
	        };
	        // If `capture` is a string then `handler` and `method` must be present.
	        route = new Route(matchCallback, handler, method);
	    }
	    else if (capture instanceof RegExp) {
	        // If `capture` is a `RegExp` then `handler` and `method` must be present.
	        route = new RegExpRoute(capture, handler, method);
	    }
	    else if (typeof capture === 'function') {
	        // If `capture` is a function then `handler` and `method` must be present.
	        route = new Route(capture, handler, method);
	    }
	    else if (capture instanceof Route) {
	        route = capture;
	    }
	    else {
	        throw new WorkboxError('unsupported-route-type', {
	            moduleName: 'workbox-routing',
	            funcName: 'registerRoute',
	            paramName: 'capture',
	        });
	    }
	    const defaultRouter = getOrCreateDefaultRouter();
	    defaultRouter.registerRoute(route);
	    return route;
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Removes any URL search parameters that should be ignored.
	 *
	 * @param {URL} urlObject The original URL.
	 * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against
	 * each search parameter name. Matches mean that the search parameter should be
	 * ignored.
	 * @return {URL} The URL with any ignored search parameters removed.
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching = []) {
	    // Convert the iterable into an array at the start of the loop to make sure
	    // deletion doesn't mess up iteration.
	    for (const paramName of [...urlObject.searchParams.keys()]) {
	        if (ignoreURLParametersMatching.some((regExp) => regExp.test(paramName))) {
	            urlObject.searchParams.delete(paramName);
	        }
	    }
	    return urlObject;
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Generator function that yields possible variations on the original URL to
	 * check, one at a time.
	 *
	 * @param {string} url
	 * @param {Object} options
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function* generateURLVariations(url, { ignoreURLParametersMatching = [/^utm_/, /^fbclid$/], directoryIndex = 'index.html', cleanURLs = true, urlManipulation, } = {}) {
	    const urlObject = new URL(url, location.href);
	    urlObject.hash = '';
	    yield urlObject.href;
	    const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);
	    yield urlWithoutIgnoredParams.href;
	    if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {
	        const directoryURL = new URL(urlWithoutIgnoredParams.href);
	        directoryURL.pathname += directoryIndex;
	        yield directoryURL.href;
	    }
	    if (cleanURLs) {
	        const cleanURL = new URL(urlWithoutIgnoredParams.href);
	        cleanURL.pathname += '.html';
	        yield cleanURL.href;
	    }
	    if (urlManipulation) {
	        const additionalURLs = urlManipulation({ url: urlObject });
	        for (const urlToAttempt of additionalURLs) {
	            yield urlToAttempt.href;
	        }
	    }
	}

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A subclass of [Route]{@link module:workbox-routing.Route} that takes a
	 * [PrecacheController]{@link module:workbox-precaching.PrecacheController}
	 * instance and uses it to match incoming requests and handle fetching
	 * responses from the precache.
	 *
	 * @memberof module:workbox-precaching
	 * @extends module:workbox-routing.Route
	 */
	class PrecacheRoute extends Route {
	    /**
	     * @param {PrecacheController} precacheController A `PrecacheController`
	     * instance used to both match requests and respond to fetch events.
	     * @param {Object} [options] Options to control how requests are matched
	     * against the list of precached URLs.
	     * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will
	     * check cache entries for a URLs ending with '/' to see if there is a hit when
	     * appending the `directoryIndex` value.
	     * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An
	     * array of regex's to remove search params when looking for a cache match.
	     * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will
	     * check the cache for the URL with a `.html` added to the end of the end.
	     * @param {module:workbox-precaching~urlManipulation} [options.urlManipulation]
	     * This is a function that should take a URL and return an array of
	     * alternative URLs that should be checked for precache matches.
	     */
	    constructor(precacheController, options) {
	        const match = ({ request }) => {
	            const urlsToCacheKeys = precacheController.getURLsToCacheKeys();
	            for (const possibleURL of generateURLVariations(request.url, options)) {
	                const cacheKey = urlsToCacheKeys.get(possibleURL);
	                if (cacheKey) {
	                    return { cacheKey };
	                }
	            }
	            {
	                logger.debug(`Precaching did not find a match for ` +
	                    getFriendlyURL(request.url));
	            }
	            return;
	        };
	        super(match, precacheController.strategy);
	    }
	}

	/*
	  Copyright 2019 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Add a `fetch` listener to the service worker that will
	 * respond to
	 * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}
	 * with precached assets.
	 *
	 * Requests for assets that aren't precached, the `FetchEvent` will not be
	 * responded to, allowing the event to fall through to other `fetch` event
	 * listeners.
	 *
	 * @param {Object} [options] See
	 * [PrecacheRoute options]{@link module:workbox-precaching.PrecacheRoute}.
	 *
	 * @memberof module:workbox-precaching
	 */
	function addRoute(options) {
	    const precacheController = getOrCreatePrecacheController();
	    const precacheRoute = new PrecacheRoute(precacheController, options);
	    registerRoute(precacheRoute);
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Adds items to the precache list, removing any duplicates and
	 * stores the files in the
	 * ["precache cache"]{@link module:workbox-core.cacheNames} when the service
	 * worker installs.
	 *
	 * This method can be called multiple times.
	 *
	 * Please note: This method **will not** serve any of the cached files for you.
	 * It only precaches files. To respond to a network request you call
	 * [addRoute()]{@link module:workbox-precaching.addRoute}.
	 *
	 * If you have a single array of files to precache, you can just call
	 * [precacheAndRoute()]{@link module:workbox-precaching.precacheAndRoute}.
	 *
	 * @param {Array<Object|string>} [entries=[]] Array of entries to precache.
	 *
	 * @memberof module:workbox-precaching
	 */
	function precache(entries) {
	    const precacheController = getOrCreatePrecacheController();
	    precacheController.precache(entries);
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * This method will add entries to the precache list and add a route to
	 * respond to fetch events.
	 *
	 * This is a convenience method that will call
	 * [precache()]{@link module:workbox-precaching.precache} and
	 * [addRoute()]{@link module:workbox-precaching.addRoute} in a single call.
	 *
	 * @param {Array<Object|string>} entries Array of entries to precache.
	 * @param {Object} [options] See
	 * [PrecacheRoute options]{@link module:workbox-precaching.PrecacheRoute}.
	 *
	 * @memberof module:workbox-precaching
	 */
	function precacheAndRoute(entries, options) {
	    precache(entries);
	    addRoute(options);
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const messages$1 = {
	    strategyStart: (strategyName, request) => `Using ${strategyName} to respond to '${getFriendlyURL(request.url)}'`,
	    printFinalResponse: (response) => {
	        if (response) {
	            logger.groupCollapsed(`View the final response here.`);
	            logger.log(response || '[No response returned]');
	            logger.groupEnd();
	        }
	    },
	};

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}
	 * request strategy.
	 *
	 * A cache first strategy is useful for assets that have been revisioned,
	 * such as URLs like `/styles/example.a8f5f1.css`, since they
	 * can be cached for long periods of time.
	 *
	 * If the network request fails, and there is no cache match, this will throw
	 * a `WorkboxError` exception.
	 *
	 * @extends module:workbox-strategies.Strategy
	 * @memberof module:workbox-strategies
	 */
	class CacheFirst extends Strategy {
	    /**
	     * @private
	     * @param {Request|string} request A request to run this strategy for.
	     * @param {module:workbox-strategies.StrategyHandler} handler The event that
	     *     triggered the request.
	     * @return {Promise<Response>}
	     */
	    async _handle(request, handler) {
	        const logs = [];
	        {
	            finalAssertExports.isInstance(request, Request, {
	                moduleName: 'workbox-strategies',
	                className: this.constructor.name,
	                funcName: 'makeRequest',
	                paramName: 'request',
	            });
	        }
	        let response = await handler.cacheMatch(request);
	        let error;
	        if (!response) {
	            {
	                logs.push(`No response found in the '${this.cacheName}' cache. ` +
	                    `Will respond with a network request.`);
	            }
	            try {
	                response = await handler.fetchAndCachePut(request);
	            }
	            catch (err) {
	                error = err;
	            }
	            {
	                if (response) {
	                    logs.push(`Got response from network.`);
	                }
	                else {
	                    logs.push(`Unable to get a response from the network.`);
	                }
	            }
	        }
	        else {
	            {
	                logs.push(`Found a cached response in the '${this.cacheName}' cache.`);
	            }
	        }
	        {
	            logger.groupCollapsed(messages$1.strategyStart(this.constructor.name, request));
	            for (const log of logs) {
	                logger.log(log);
	            }
	            messages$1.printFinalResponse(response);
	            logger.groupEnd();
	        }
	        if (!response) {
	            throw new WorkboxError('no-response', { url: request.url, error });
	        }
	        return response;
	    }
	}

	/*
	  Copyright 2019 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A helper function that prevents a promise from being flagged as unused.
	 *
	 * @private
	 **/
	function dontWaitFor(promise) {
	    // Effective no-op.
	    promise.then(() => { });
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A class that wraps common IndexedDB functionality in a promise-based API.
	 * It exposes all the underlying power and functionality of IndexedDB, but
	 * wraps the most commonly used features in a way that's much simpler to use.
	 *
	 * @private
	 */
	class DBWrapper {
	    /**
	     * @param {string} name
	     * @param {number} version
	     * @param {Object=} [callback]
	     * @param {!Function} [callbacks.onupgradeneeded]
	     * @param {!Function} [callbacks.onversionchange] Defaults to
	     *     DBWrapper.prototype._onversionchange when not specified.
	     * @private
	     */
	    constructor(name, version, { onupgradeneeded, onversionchange, } = {}) {
	        this._db = null;
	        this._name = name;
	        this._version = version;
	        this._onupgradeneeded = onupgradeneeded;
	        this._onversionchange = onversionchange || (() => this.close());
	    }
	    /**
	     * Returns the IDBDatabase instance (not normally needed).
	     * @return {IDBDatabase|undefined}
	     *
	     * @private
	     */
	    get db() {
	        return this._db;
	    }
	    /**
	     * Opens a connected to an IDBDatabase, invokes any onupgradedneeded
	     * callback, and added an onversionchange callback to the database.
	     *
	     * @return {IDBDatabase}
	     * @private
	     */
	    async open() {
	        if (this._db)
	            return;
	        this._db = await new Promise((resolve, reject) => {
	            // This flag is flipped to true if the timeout callback runs prior
	            // to the request failing or succeeding. Note: we use a timeout instead
	            // of an onblocked handler since there are cases where onblocked will
	            // never never run. A timeout better handles all possible scenarios:
	            // https://github.com/w3c/IndexedDB/issues/223
	            let openRequestTimedOut = false;
	            setTimeout(() => {
	                openRequestTimedOut = true;
	                reject(new Error('The open request was blocked and timed out'));
	            }, this.OPEN_TIMEOUT);
	            const openRequest = indexedDB.open(this._name, this._version);
	            openRequest.onerror = () => reject(openRequest.error);
	            openRequest.onupgradeneeded = (evt) => {
	                if (openRequestTimedOut) {
	                    openRequest.transaction.abort();
	                    openRequest.result.close();
	                }
	                else if (typeof this._onupgradeneeded === 'function') {
	                    this._onupgradeneeded(evt);
	                }
	            };
	            openRequest.onsuccess = () => {
	                const db = openRequest.result;
	                if (openRequestTimedOut) {
	                    db.close();
	                }
	                else {
	                    db.onversionchange = this._onversionchange.bind(this);
	                    resolve(db);
	                }
	            };
	        });
	        return this;
	    }
	    /**
	     * Polyfills the native `getKey()` method. Note, this is overridden at
	     * runtime if the browser supports the native method.
	     *
	     * @param {string} storeName
	     * @param {*} query
	     * @return {Array}
	     * @private
	     */
	    async getKey(storeName, query) {
	        return (await this.getAllKeys(storeName, query, 1))[0];
	    }
	    /**
	     * Polyfills the native `getAll()` method. Note, this is overridden at
	     * runtime if the browser supports the native method.
	     *
	     * @param {string} storeName
	     * @param {*} query
	     * @param {number} count
	     * @return {Array}
	     * @private
	     */
	    async getAll(storeName, query, count) {
	        return await this.getAllMatching(storeName, { query, count });
	    }
	    /**
	     * Polyfills the native `getAllKeys()` method. Note, this is overridden at
	     * runtime if the browser supports the native method.
	     *
	     * @param {string} storeName
	     * @param {*} query
	     * @param {number} count
	     * @return {Array}
	     * @private
	     */
	    async getAllKeys(storeName, query, count) {
	        const entries = await this.getAllMatching(storeName, { query, count, includeKeys: true });
	        return entries.map((entry) => entry.key);
	    }
	    /**
	     * Supports flexible lookup in an object store by specifying an index,
	     * query, direction, and count. This method returns an array of objects
	     * with the signature .
	     *
	     * @param {string} storeName
	     * @param {Object} [opts]
	     * @param {string} [opts.index] The index to use (if specified).
	     * @param {*} [opts.query]
	     * @param {IDBCursorDirection} [opts.direction]
	     * @param {number} [opts.count] The max number of results to return.
	     * @param {boolean} [opts.includeKeys] When true, the structure of the
	     *     returned objects is changed from an array of values to an array of
	     *     objects in the form {key, primaryKey, value}.
	     * @return {Array}
	     * @private
	     */
	    async getAllMatching(storeName, { index, query = null, // IE/Edge errors if query === `undefined`.
	    direction = 'next', count, includeKeys = false, } = {}) {
	        return await this.transaction([storeName], 'readonly', (txn, done) => {
	            const store = txn.objectStore(storeName);
	            const target = index ? store.index(index) : store;
	            const results = [];
	            const request = target.openCursor(query, direction);
	            request.onsuccess = () => {
	                const cursor = request.result;
	                if (cursor) {
	                    results.push(includeKeys ? cursor : cursor.value);
	                    if (count && results.length >= count) {
	                        done(results);
	                    }
	                    else {
	                        cursor.continue();
	                    }
	                }
	                else {
	                    done(results);
	                }
	            };
	        });
	    }
	    /**
	     * Accepts a list of stores, a transaction type, and a callback and
	     * performs a transaction. A promise is returned that resolves to whatever
	     * value the callback chooses. The callback holds all the transaction logic
	     * and is invoked with two arguments:
	     *   1. The IDBTransaction object
	     *   2. A `done` function, that's used to resolve the promise when
	     *      when the transaction is done, if passed a value, the promise is
	     *      resolved to that value.
	     *
	     * @param {Array<string>} storeNames An array of object store names
	     *     involved in the transaction.
	     * @param {string} type Can be `readonly` or `readwrite`.
	     * @param {!Function} callback
	     * @return {*} The result of the transaction ran by the callback.
	     * @private
	     */
	    async transaction(storeNames, type, callback) {
	        await this.open();
	        return await new Promise((resolve, reject) => {
	            const txn = this._db.transaction(storeNames, type);
	            txn.onabort = () => reject(txn.error);
	            txn.oncomplete = () => resolve();
	            callback(txn, (value) => resolve(value));
	        });
	    }
	    /**
	     * Delegates async to a native IDBObjectStore method.
	     *
	     * @param {string} method The method name.
	     * @param {string} storeName The object store name.
	     * @param {string} type Can be `readonly` or `readwrite`.
	     * @param {...*} args The list of args to pass to the native method.
	     * @return {*} The result of the transaction.
	     * @private
	     */
	    async _call(method, storeName, type, ...args) {
	        const callback = (txn, done) => {
	            const objStore = txn.objectStore(storeName);
	            // TODO(philipwalton): Fix this underlying TS2684 error.
	            // @ts-ignore
	            const request = objStore[method].apply(objStore, args);
	            request.onsuccess = () => done(request.result);
	        };
	        return await this.transaction([storeName], type, callback);
	    }
	    /**
	     * Closes the connection opened by `DBWrapper.open()`. Generally this method
	     * doesn't need to be called since:
	     *   1. It's usually better to keep a connection open since opening
	     *      a new connection is somewhat slow.
	     *   2. Connections are automatically closed when the reference is
	     *      garbage collected.
	     * The primary use case for needing to close a connection is when another
	     * reference (typically in another tab) needs to upgrade it and would be
	     * blocked by the current, open connection.
	     *
	     * @private
	     */
	    close() {
	        if (this._db) {
	            this._db.close();
	            this._db = null;
	        }
	    }
	}
	// Exposed on the prototype to let users modify the default timeout on a
	// per-instance or global basis.
	DBWrapper.prototype.OPEN_TIMEOUT = 2000;
	// Wrap native IDBObjectStore methods according to their mode.
	const methodsToWrap = {
	    readonly: ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],
	    readwrite: ['add', 'put', 'clear', 'delete'],
	};
	for (const [mode, methods] of Object.entries(methodsToWrap)) {
	    for (const method of methods) {
	        if (method in IDBObjectStore.prototype) {
	            // Don't use arrow functions here since we're outside of the class.
	            DBWrapper.prototype[method] =
	                async function (storeName, ...args) {
	                    return await this._call(method, storeName, mode, ...args);
	                };
	        }
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Deletes the database.
	 * Note: this is exported separately from the DBWrapper module because most
	 * usages of IndexedDB in workbox dont need deleting, and this way it can be
	 * reused in tests to delete databases without creating DBWrapper instances.
	 *
	 * @param {string} name The database name.
	 * @private
	 */
	const deleteDatabase = async (name) => {
	    await new Promise((resolve, reject) => {
	        const request = indexedDB.deleteDatabase(name);
	        request.onerror = () => {
	            reject(request.error);
	        };
	        request.onblocked = () => {
	            reject(new Error('Delete blocked'));
	        };
	        request.onsuccess = () => {
	            resolve();
	        };
	    });
	};

	// @ts-ignore
	try {
	    self['workbox:expiration:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const DB_NAME = 'workbox-expiration';
	const OBJECT_STORE_NAME = 'cache-entries';
	const normalizeURL = (unNormalizedUrl) => {
	    const url = new URL(unNormalizedUrl, location.href);
	    url.hash = '';
	    return url.href;
	};
	/**
	 * Returns the timestamp model.
	 *
	 * @private
	 */
	class CacheTimestampsModel {
	    /**
	     *
	     * @param {string} cacheName
	     *
	     * @private
	     */
	    constructor(cacheName) {
	        this._cacheName = cacheName;
	        this._db = new DBWrapper(DB_NAME, 1, {
	            onupgradeneeded: (event) => this._handleUpgrade(event),
	        });
	    }
	    /**
	     * Should perform an upgrade of indexedDB.
	     *
	     * @param {Event} event
	     *
	     * @private
	     */
	    _handleUpgrade(event) {
	        const db = event.target.result;
	        // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we
	        // have to use the `id` keyPath here and create our own values (a
	        // concatenation of `url + cacheName`) instead of simply using
	        // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.
	        const objStore = db.createObjectStore(OBJECT_STORE_NAME, { keyPath: 'id' });
	        // TODO(philipwalton): once we don't have to support EdgeHTML, we can
	        // create a single index with the keyPath `['cacheName', 'timestamp']`
	        // instead of doing both these indexes.
	        objStore.createIndex('cacheName', 'cacheName', { unique: false });
	        objStore.createIndex('timestamp', 'timestamp', { unique: false });
	        // Previous versions of `workbox-expiration` used `this._cacheName`
	        // as the IDBDatabase name.
	        deleteDatabase(this._cacheName);
	    }
	    /**
	     * @param {string} url
	     * @param {number} timestamp
	     *
	     * @private
	     */
	    async setTimestamp(url, timestamp) {
	        url = normalizeURL(url);
	        const entry = {
	            url,
	            timestamp,
	            cacheName: this._cacheName,
	            // Creating an ID from the URL and cache name won't be necessary once
	            // Edge switches to Chromium and all browsers we support work with
	            // array keyPaths.
	            id: this._getId(url),
	        };
	        await this._db.put(OBJECT_STORE_NAME, entry);
	    }
	    /**
	     * Returns the timestamp stored for a given URL.
	     *
	     * @param {string} url
	     * @return {number}
	     *
	     * @private
	     */
	    async getTimestamp(url) {
	        const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));
	        return entry.timestamp;
	    }
	    /**
	     * Iterates through all the entries in the object store (from newest to
	     * oldest) and removes entries once either `maxCount` is reached or the
	     * entry's timestamp is less than `minTimestamp`.
	     *
	     * @param {number} minTimestamp
	     * @param {number} maxCount
	     * @return {Array<string>}
	     *
	     * @private
	     */
	    async expireEntries(minTimestamp, maxCount) {
	        const entriesToDelete = await this._db.transaction(OBJECT_STORE_NAME, 'readwrite', (txn, done) => {
	            const store = txn.objectStore(OBJECT_STORE_NAME);
	            const request = store.index('timestamp').openCursor(null, 'prev');
	            const entriesToDelete = [];
	            let entriesNotDeletedCount = 0;
	            request.onsuccess = () => {
	                const cursor = request.result;
	                if (cursor) {
	                    const result = cursor.value;
	                    // TODO(philipwalton): once we can use a multi-key index, we
	                    // won't have to check `cacheName` here.
	                    if (result.cacheName === this._cacheName) {
	                        // Delete an entry if it's older than the max age or
	                        // if we already have the max number allowed.
	                        if ((minTimestamp && result.timestamp < minTimestamp) ||
	                            (maxCount && entriesNotDeletedCount >= maxCount)) {
	                            // TODO(philipwalton): we should be able to delete the
	                            // entry right here, but doing so causes an iteration
	                            // bug in Safari stable (fixed in TP). Instead we can
	                            // store the keys of the entries to delete, and then
	                            // delete the separate transactions.
	                            // https://github.com/GoogleChrome/workbox/issues/1978
	                            // cursor.delete();
	                            // We only need to return the URL, not the whole entry.
	                            entriesToDelete.push(cursor.value);
	                        }
	                        else {
	                            entriesNotDeletedCount++;
	                        }
	                    }
	                    cursor.continue();
	                }
	                else {
	                    done(entriesToDelete);
	                }
	            };
	        });
	        // TODO(philipwalton): once the Safari bug in the following issue is fixed,
	        // we should be able to remove this loop and do the entry deletion in the
	        // cursor loop above:
	        // https://github.com/GoogleChrome/workbox/issues/1978
	        const urlsDeleted = [];
	        for (const entry of entriesToDelete) {
	            await this._db.delete(OBJECT_STORE_NAME, entry.id);
	            urlsDeleted.push(entry.url);
	        }
	        return urlsDeleted;
	    }
	    /**
	     * Takes a URL and returns an ID that will be unique in the object store.
	     *
	     * @param {string} url
	     * @return {string}
	     *
	     * @private
	     */
	    _getId(url) {
	        // Creating an ID from the URL and cache name won't be necessary once
	        // Edge switches to Chromium and all browsers we support work with
	        // array keyPaths.
	        return this._cacheName + '|' + normalizeURL(url);
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * The `CacheExpiration` class allows you define an expiration and / or
	 * limit on the number of responses stored in a
	 * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).
	 *
	 * @memberof module:workbox-expiration
	 */
	class CacheExpiration {
	    /**
	     * To construct a new CacheExpiration instance you must provide at least
	     * one of the `config` properties.
	     *
	     * @param {string} cacheName Name of the cache to apply restrictions to.
	     * @param {Object} config
	     * @param {number} [config.maxEntries] The maximum number of entries to cache.
	     * Entries used the least will be removed as the maximum is reached.
	     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before
	     * it's treated as stale and removed.
	     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)
	     * that will be used when calling `delete()` on the cache.
	     */
	    constructor(cacheName, config = {}) {
	        this._isRunning = false;
	        this._rerunRequested = false;
	        {
	            finalAssertExports.isType(cacheName, 'string', {
	                moduleName: 'workbox-expiration',
	                className: 'CacheExpiration',
	                funcName: 'constructor',
	                paramName: 'cacheName',
	            });
	            if (!(config.maxEntries || config.maxAgeSeconds)) {
	                throw new WorkboxError('max-entries-or-age-required', {
	                    moduleName: 'workbox-expiration',
	                    className: 'CacheExpiration',
	                    funcName: 'constructor',
	                });
	            }
	            if (config.maxEntries) {
	                finalAssertExports.isType(config.maxEntries, 'number', {
	                    moduleName: 'workbox-expiration',
	                    className: 'CacheExpiration',
	                    funcName: 'constructor',
	                    paramName: 'config.maxEntries',
	                });
	            }
	            if (config.maxAgeSeconds) {
	                finalAssertExports.isType(config.maxAgeSeconds, 'number', {
	                    moduleName: 'workbox-expiration',
	                    className: 'CacheExpiration',
	                    funcName: 'constructor',
	                    paramName: 'config.maxAgeSeconds',
	                });
	            }
	        }
	        this._maxEntries = config.maxEntries;
	        this._maxAgeSeconds = config.maxAgeSeconds;
	        this._matchOptions = config.matchOptions;
	        this._cacheName = cacheName;
	        this._timestampModel = new CacheTimestampsModel(cacheName);
	    }
	    /**
	     * Expires entries for the given cache and given criteria.
	     */
	    async expireEntries() {
	        if (this._isRunning) {
	            this._rerunRequested = true;
	            return;
	        }
	        this._isRunning = true;
	        const minTimestamp = this._maxAgeSeconds ?
	            Date.now() - (this._maxAgeSeconds * 1000) : 0;
	        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);
	        // Delete URLs from the cache
	        const cache = await self.caches.open(this._cacheName);
	        for (const url of urlsExpired) {
	            await cache.delete(url, this._matchOptions);
	        }
	        {
	            if (urlsExpired.length > 0) {
	                logger.groupCollapsed(`Expired ${urlsExpired.length} ` +
	                    `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +
	                    `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +
	                    `'${this._cacheName}' cache.`);
	                logger.log(`Expired the following ${urlsExpired.length === 1 ?
                    'URL' : 'URLs'}:`);
	                urlsExpired.forEach((url) => logger.log(`    ${url}`));
	                logger.groupEnd();
	            }
	            else {
	                logger.debug(`Cache expiration ran and found no entries to remove.`);
	            }
	        }
	        this._isRunning = false;
	        if (this._rerunRequested) {
	            this._rerunRequested = false;
	            dontWaitFor(this.expireEntries());
	        }
	    }
	    /**
	     * Update the timestamp for the given URL. This ensures the when
	     * removing entries based on maximum entries, most recently used
	     * is accurate or when expiring, the timestamp is up-to-date.
	     *
	     * @param {string} url
	     */
	    async updateTimestamp(url) {
	        {
	            finalAssertExports.isType(url, 'string', {
	                moduleName: 'workbox-expiration',
	                className: 'CacheExpiration',
	                funcName: 'updateTimestamp',
	                paramName: 'url',
	            });
	        }
	        await this._timestampModel.setTimestamp(url, Date.now());
	    }
	    /**
	     * Can be used to check if a URL has expired or not before it's used.
	     *
	     * This requires a look up from IndexedDB, so can be slow.
	     *
	     * Note: This method will not remove the cached entry, call
	     * `expireEntries()` to remove indexedDB and Cache entries.
	     *
	     * @param {string} url
	     * @return {boolean}
	     */
	    async isURLExpired(url) {
	        if (!this._maxAgeSeconds) {
	            {
	                throw new WorkboxError(`expired-test-without-max-age`, {
	                    methodName: 'isURLExpired',
	                    paramName: 'maxAgeSeconds',
	                });
	            }
	        }
	        else {
	            const timestamp = await this._timestampModel.getTimestamp(url);
	            const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);
	            return (timestamp < expireOlderThan);
	        }
	    }
	    /**
	     * Removes the IndexedDB object store used to keep track of cache expiration
	     * metadata.
	     */
	    async delete() {
	        // Make sure we don't attempt another rerun if we're called in the middle of
	        // a cache expiration.
	        this._rerunRequested = false;
	        await this._timestampModel.expireEntries(Infinity); // Expires all.
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Adds a function to the set of quotaErrorCallbacks that will be executed if
	 * there's a quota error.
	 *
	 * @param {Function} callback
	 * @memberof module:workbox-core
	 */
	function registerQuotaErrorCallback(callback) {
	    {
	        finalAssertExports.isType(callback, 'function', {
	            moduleName: 'workbox-core',
	            funcName: 'register',
	            paramName: 'callback',
	        });
	    }
	    quotaErrorCallbacks.add(callback);
	    {
	        logger.log('Registered a callback to respond to quota errors.', callback);
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * This plugin can be used in a `workbox-strategy` to regularly enforce a
	 * limit on the age and / or the number of cached requests.
	 *
	 * It can only be used with `workbox-strategy` instances that have a
	 * [custom `cacheName` property set](/web/tools/workbox/guides/configure-workbox#custom_cache_names_in_strategies).
	 * In other words, it can't be used to expire entries in strategy that uses the
	 * default runtime cache name.
	 *
	 * Whenever a cached request is used or updated, this plugin will look
	 * at the associated cache and remove any old or extra requests.
	 *
	 * When using `maxAgeSeconds`, requests may be used *once* after expiring
	 * because the expiration clean up will not have occurred until *after* the
	 * cached request has been used. If the request has a "Date" header, then
	 * a light weight expiration check is performed and the request will not be
	 * used immediately.
	 *
	 * When using `maxEntries`, the entry least-recently requested will be removed
	 * from the cache first.
	 *
	 * @memberof module:workbox-expiration
	 */
	class ExpirationPlugin {
	    /**
	     * @param {Object} config
	     * @param {number} [config.maxEntries] The maximum number of entries to cache.
	     * Entries used the least will be removed as the maximum is reached.
	     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before
	     * it's treated as stale and removed.
	     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)
	     * that will be used when calling `delete()` on the cache.
	     * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to
	     * automatic deletion if the available storage quota has been exceeded.
	     */
	    constructor(config = {}) {
	        /**
	         * A "lifecycle" callback that will be triggered automatically by the
	         * `workbox-strategies` handlers when a `Response` is about to be returned
	         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to
	         * the handler. It allows the `Response` to be inspected for freshness and
	         * prevents it from being used if the `Response`'s `Date` header value is
	         * older than the configured `maxAgeSeconds`.
	         *
	         * @param {Object} options
	         * @param {string} options.cacheName Name of the cache the response is in.
	         * @param {Response} options.cachedResponse The `Response` object that's been
	         *     read from a cache and whose freshness should be checked.
	         * @return {Response} Either the `cachedResponse`, if it's
	         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.
	         *
	         * @private
	         */
	        this.cachedResponseWillBeUsed = async ({ event, request, cacheName, cachedResponse }) => {
	            if (!cachedResponse) {
	                return null;
	            }
	            const isFresh = this._isResponseDateFresh(cachedResponse);
	            // Expire entries to ensure that even if the expiration date has
	            // expired, it'll only be used once.
	            const cacheExpiration = this._getCacheExpiration(cacheName);
	            dontWaitFor(cacheExpiration.expireEntries());
	            // Update the metadata for the request URL to the current timestamp,
	            // but don't `await` it as we don't want to block the response.
	            const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);
	            if (event) {
	                try {
	                    event.waitUntil(updateTimestampDone);
	                }
	                catch (error) {
	                    {
	                        // The event may not be a fetch event; only log the URL if it is.
	                        if ('request' in event) {
	                            logger.warn(`Unable to ensure service worker stays alive when ` +
	                                `updating cache entry for ` +
	                                `'${getFriendlyURL(event.request.url)}'.`);
	                        }
	                    }
	                }
	            }
	            return isFresh ? cachedResponse : null;
	        };
	        /**
	         * A "lifecycle" callback that will be triggered automatically by the
	         * `workbox-strategies` handlers when an entry is added to a cache.
	         *
	         * @param {Object} options
	         * @param {string} options.cacheName Name of the cache that was updated.
	         * @param {string} options.request The Request for the cached entry.
	         *
	         * @private
	         */
	        this.cacheDidUpdate = async ({ cacheName, request }) => {
	            {
	                finalAssertExports.isType(cacheName, 'string', {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'cacheDidUpdate',
	                    paramName: 'cacheName',
	                });
	                finalAssertExports.isInstance(request, Request, {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'cacheDidUpdate',
	                    paramName: 'request',
	                });
	            }
	            const cacheExpiration = this._getCacheExpiration(cacheName);
	            await cacheExpiration.updateTimestamp(request.url);
	            await cacheExpiration.expireEntries();
	        };
	        {
	            if (!(config.maxEntries || config.maxAgeSeconds)) {
	                throw new WorkboxError('max-entries-or-age-required', {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'constructor',
	                });
	            }
	            if (config.maxEntries) {
	                finalAssertExports.isType(config.maxEntries, 'number', {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'constructor',
	                    paramName: 'config.maxEntries',
	                });
	            }
	            if (config.maxAgeSeconds) {
	                finalAssertExports.isType(config.maxAgeSeconds, 'number', {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'constructor',
	                    paramName: 'config.maxAgeSeconds',
	                });
	            }
	        }
	        this._config = config;
	        this._maxAgeSeconds = config.maxAgeSeconds;
	        this._cacheExpirations = new Map();
	        if (config.purgeOnQuotaError) {
	            registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());
	        }
	    }
	    /**
	     * A simple helper method to return a CacheExpiration instance for a given
	     * cache name.
	     *
	     * @param {string} cacheName
	     * @return {CacheExpiration}
	     *
	     * @private
	     */
	    _getCacheExpiration(cacheName) {
	        if (cacheName === cacheNames.getRuntimeName()) {
	            throw new WorkboxError('expire-custom-caches-only');
	        }
	        let cacheExpiration = this._cacheExpirations.get(cacheName);
	        if (!cacheExpiration) {
	            cacheExpiration = new CacheExpiration(cacheName, this._config);
	            this._cacheExpirations.set(cacheName, cacheExpiration);
	        }
	        return cacheExpiration;
	    }
	    /**
	     * @param {Response} cachedResponse
	     * @return {boolean}
	     *
	     * @private
	     */
	    _isResponseDateFresh(cachedResponse) {
	        if (!this._maxAgeSeconds) {
	            // We aren't expiring by age, so return true, it's fresh
	            return true;
	        }
	        // Check if the 'date' header will suffice a quick expiration check.
	        // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for
	        // discussion.
	        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);
	        if (dateHeaderTimestamp === null) {
	            // Unable to parse date, so assume it's fresh.
	            return true;
	        }
	        // If we have a valid headerTime, then our response is fresh iff the
	        // headerTime plus maxAgeSeconds is greater than the current time.
	        const now = Date.now();
	        return dateHeaderTimestamp >= now - (this._maxAgeSeconds * 1000);
	    }
	    /**
	     * This method will extract the data header and parse it into a useful
	     * value.
	     *
	     * @param {Response} cachedResponse
	     * @return {number|null}
	     *
	     * @private
	     */
	    _getDateHeaderTimestamp(cachedResponse) {
	        if (!cachedResponse.headers.has('date')) {
	            return null;
	        }
	        const dateHeader = cachedResponse.headers.get('date');
	        const parsedDate = new Date(dateHeader);
	        const headerTime = parsedDate.getTime();
	        // If the Date header was invalid for some reason, parsedDate.getTime()
	        // will return NaN.
	        if (isNaN(headerTime)) {
	            return null;
	        }
	        return headerTime;
	    }
	    /**
	     * This is a helper method that performs two operations:
	     *
	     * - Deletes *all* the underlying Cache instances associated with this plugin
	     * instance, by calling caches.delete() on your behalf.
	     * - Deletes the metadata from IndexedDB used to keep track of expiration
	     * details for each Cache instance.
	     *
	     * When using cache expiration, calling this method is preferable to calling
	     * `caches.delete()` directly, since this will ensure that the IndexedDB
	     * metadata is also cleanly removed and open IndexedDB instances are deleted.
	     *
	     * Note that if you're *not* using cache expiration for a given cache, calling
	     * `caches.delete()` and passing in the cache's name should be sufficient.
	     * There is no Workbox-specific method needed for cleanup in that case.
	     */
	    async deleteCacheAndMetadata() {
	        // Do this one at a time instead of all at once via `Promise.all()` to
	        // reduce the chance of inconsistency if a promise rejects.
	        for (const [cacheName, cacheExpiration] of this._cacheExpirations) {
	            await self.caches.delete(cacheName);
	            await cacheExpiration.delete();
	        }
	        // Reset this._cacheExpirations to its initial state.
	        this._cacheExpirations = new Map();
	    }
	}

	self.__WB_DISABLE_DEV_LOGS = true;

	precacheAndRoute(shell);
	precacheAndRoute(files);

	registerRoute(
	/* eslint-disable-next-line */
	  new RegExp('https:\/\/producteursagri\.opendatasoft\.com'),
	  new CacheFirst({
	    cacheName: `ods-requests-${timestamp}`,
	    plugins: [
	      new ExpirationPlugin({
	        maxEntries: 50,
	        maxAgeSeconds: 3600 * 24,
	      }),
	    ],
	  }),
	);

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VydmljZS13b3JrZXIuanMiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ub2RlX21vZHVsZXMvQHNhcHBlci9zZXJ2aWNlLXdvcmtlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvX3ZlcnNpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL21vZGVscy9tZXNzYWdlcy9tZXNzYWdlcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvbW9kZWxzL21lc3NhZ2VzL21lc3NhZ2VHZW5lcmF0b3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtY29yZS9fcHJpdmF0ZS9jYWNoZU5hbWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL3dhaXRVbnRpbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXByZWNhY2hpbmcvX3ZlcnNpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL2NyZWF0ZUNhY2hlS2V5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy91dGlscy9QcmVjYWNoZUluc3RhbGxSZXBvcnRQbHVnaW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL1ByZWNhY2hlQ2FjaGVLZXlQbHVnaW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL3ByaW50Q2xlYW51cERldGFpbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL3ByaW50SW5zdGFsbERldGFpbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL2NhbkNvbnN0cnVjdFJlc3BvbnNlRnJvbUJvZHlTdHJlYW0uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL2NvcHlSZXNwb25zZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL2NhY2hlTWF0Y2hJZ25vcmVQYXJhbXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL0RlZmVycmVkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtY29yZS9tb2RlbHMvcXVvdGFFcnJvckNhbGxiYWNrcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvX3ByaXZhdGUvZXhlY3V0ZVF1b3RhRXJyb3JDYWxsYmFja3MuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL3RpbWVvdXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1zdHJhdGVnaWVzL192ZXJzaW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtc3RyYXRlZ2llcy9TdHJhdGVneUhhbmRsZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1zdHJhdGVnaWVzL1N0cmF0ZWd5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy9QcmVjYWNoZVN0cmF0ZWd5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy9QcmVjYWNoZUNvbnRyb2xsZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL2dldE9yQ3JlYXRlUHJlY2FjaGVDb250cm9sbGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcm91dGluZy9fdmVyc2lvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXJvdXRpbmcvdXRpbHMvY29uc3RhbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcm91dGluZy91dGlscy9ub3JtYWxpemVIYW5kbGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcm91dGluZy9Sb3V0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXJvdXRpbmcvUmVnRXhwUm91dGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1yb3V0aW5nL1JvdXRlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXJvdXRpbmcvdXRpbHMvZ2V0T3JDcmVhdGVEZWZhdWx0Um91dGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcm91dGluZy9yZWdpc3RlclJvdXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy91dGlscy9yZW1vdmVJZ25vcmVkU2VhcmNoUGFyYW1zLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy91dGlscy9nZW5lcmF0ZVVSTFZhcmlhdGlvbnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL1ByZWNhY2hlUm91dGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL2FkZFJvdXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy9wcmVjYWNoZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXByZWNhY2hpbmcvcHJlY2FjaGVBbmRSb3V0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXN0cmF0ZWdpZXMvdXRpbHMvbWVzc2FnZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1zdHJhdGVnaWVzL0NhY2hlRmlyc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL2RvbnRXYWl0Rm9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtY29yZS9fcHJpdmF0ZS9EQldyYXBwZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL2RlbGV0ZURhdGFiYXNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtZXhwaXJhdGlvbi9fdmVyc2lvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWV4cGlyYXRpb24vbW9kZWxzL0NhY2hlVGltZXN0YW1wc01vZGVsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtZXhwaXJhdGlvbi9DYWNoZUV4cGlyYXRpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL3JlZ2lzdGVyUXVvdGFFcnJvckNhbGxiYWNrLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtZXhwaXJhdGlvbi9FeHBpcmF0aW9uUGx1Z2luLmpzIiwiLi4vLi4vc3JjL3NlcnZpY2Utd29ya2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgU2FwcGVyIOKAlCBkbyBub3QgZWRpdCBpdCFcbmV4cG9ydCBjb25zdCB0aW1lc3RhbXAgPSAxNjA4MDE5Mjk5NTc5O1xuXG5leHBvcnQgY29uc3QgZmlsZXMgPSBbXG5cdFwiL3NlcnZpY2Utd29ya2VyLWluZGV4Lmh0bWxcIixcblx0XCIvYW5kcm9pZC1jaHJvbWUtMTkyeDE5Mi5wbmdcIixcblx0XCIvYW5kcm9pZC1jaHJvbWUtNTEyeDUxMi5wbmdcIixcblx0XCIvYXBwbGUtdG91Y2gtaWNvbi5wbmdcIixcblx0XCIvYnJvd3NlcmNvbmZpZy54bWxcIixcblx0XCIvZmF2aWNvbi0xNngxNi5wbmdcIixcblx0XCIvZmF2aWNvbi0zMngzMi5wbmdcIixcblx0XCIvZmF2aWNvbi5pY29cIixcblx0XCIvZmF2aWNvbi5wbmdcIixcblx0XCIvZ2xvYmFsLmNzc1wiLFxuXHRcIi9sb2NhdGlvbi5zdmdcIixcblx0XCIvbG9nby0xOTIucG5nXCIsXG5cdFwiL2xvZ28tNTEyLnBuZ1wiLFxuXHRcIi9tYW5pZmVzdC53ZWJtYW5pZmVzdFwiLFxuXHRcIi9tc3RpbGUtMTQ0eDE0NC5wbmdcIixcblx0XCIvbXN0aWxlLTE1MHgxNTAucG5nXCIsXG5cdFwiL21zdGlsZS0zMTB4MTUwLnBuZ1wiLFxuXHRcIi9tc3RpbGUtMzEweDMxMC5wbmdcIixcblx0XCIvbXN0aWxlLTcweDcwLnBuZ1wiLFxuXHRcIi9zYWZhcmktcGlubmVkLXRhYi5zdmdcIlxuXTtcbmV4cG9ydCB7IGZpbGVzIGFzIGFzc2V0cyB9OyAvLyBsZWdhY3lcblxuZXhwb3J0IGNvbnN0IHNoZWxsID0gW1xuXHRcIi9jbGllbnQvY2xpZW50LjdlODA1YjU3LmpzXCIsXG5cdFwiL2NsaWVudC9pbmplY3Rfc3R5bGVzLjU2MDdhZWM2LmpzXCIsXG5cdFwiL2NsaWVudC9pbmRleC41MTM0MmY5NS5qc1wiLFxuXHRcIi9jbGllbnQvR2VvY29kZXIuN2EwZmY0MTkuanNcIixcblx0XCIvY2xpZW50L3BhcnRuZXJzLjZmN2Y1ZjVjLmpzXCIsXG5cdFwiL2NsaWVudC9hYm91dC41MTNiMjZhNC5qc1wiLFxuXHRcIi9jbGllbnQvaW5kZXguN2ZkMWYxMjUuanNcIixcblx0XCIvY2xpZW50L1tpZF0uMjllY2QzZGYuanNcIixcblx0XCIvY2xpZW50L19jb21tb25qc0hlbHBlcnMuOTE1ODNjY2IuanNcIixcblx0XCIvY2xpZW50L3NhcHBlci1kZXYtY2xpZW50LjFlN2E0YTVlLmpzXCIsXG5cdFwiL2NsaWVudC9hdXRvQ29tcGxldGUubWluLjg2Mzc4ZGE4LmpzXCJcbl07XG5cbmV4cG9ydCBjb25zdCByb3V0ZXMgPSBbXG5cdHsgcGF0dGVybjogL15cXC8kLyB9LFxuXHR7IHBhdHRlcm46IC9eXFwvcGFydG5lcnNcXC8/JC8gfSxcblx0eyBwYXR0ZXJuOiAvXlxcL2Fib3V0XFwvPyQvIH0sXG5cdHsgcGF0dGVybjogL15cXC9mYXJtc1xcLz8kLyB9LFxuXHR7IHBhdHRlcm46IC9eXFwvZmFybXNcXC8oW14vXSs/KVxcLz8kLyB9XG5dOyIsIlwidXNlIHN0cmljdFwiO1xuLy8gQHRzLWlnbm9yZVxudHJ5IHtcbiAgICBzZWxmWyd3b3JrYm94OmNvcmU6Ni4wLjInXSAmJiBfKCk7XG59XG5jYXRjaCAoZSkgeyB9XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgJy4uLy4uL192ZXJzaW9uLmpzJztcbmV4cG9ydCBjb25zdCBtZXNzYWdlcyA9IHtcbiAgICAnaW52YWxpZC12YWx1ZSc6ICh7IHBhcmFtTmFtZSwgdmFsaWRWYWx1ZURlc2NyaXB0aW9uLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIGlmICghcGFyYW1OYW1lIHx8ICF2YWxpZFZhbHVlRGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAnaW52YWxpZC12YWx1ZScgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBUaGUgJyR7cGFyYW1OYW1lfScgcGFyYW1ldGVyIHdhcyBnaXZlbiBhIHZhbHVlIHdpdGggYW4gYCArXG4gICAgICAgICAgICBgdW5leHBlY3RlZCB2YWx1ZS4gJHt2YWxpZFZhbHVlRGVzY3JpcHRpb259IFJlY2VpdmVkIGEgdmFsdWUgb2YgYCArXG4gICAgICAgICAgICBgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9LmA7XG4gICAgfSxcbiAgICAnbm90LWFuLWFycmF5JzogKHsgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSwgcGFyYW1OYW1lIH0pID0+IHtcbiAgICAgICAgaWYgKCFtb2R1bGVOYW1lIHx8ICFjbGFzc05hbWUgfHwgIWZ1bmNOYW1lIHx8ICFwYXJhbU5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAnbm90LWFuLWFycmF5JyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFRoZSBwYXJhbWV0ZXIgJyR7cGFyYW1OYW1lfScgcGFzc2VkIGludG8gYCArXG4gICAgICAgICAgICBgJyR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWV9LiR7ZnVuY05hbWV9KCknIG11c3QgYmUgYW4gYXJyYXkuYDtcbiAgICB9LFxuICAgICdpbmNvcnJlY3QtdHlwZSc6ICh7IGV4cGVjdGVkVHlwZSwgcGFyYW1OYW1lLCBtb2R1bGVOYW1lLCBjbGFzc05hbWUsIGZ1bmNOYW1lIH0pID0+IHtcbiAgICAgICAgaWYgKCFleHBlY3RlZFR5cGUgfHwgIXBhcmFtTmFtZSB8fCAhbW9kdWxlTmFtZSB8fCAhZnVuY05hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAnaW5jb3JyZWN0LXR5cGUnIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgVGhlIHBhcmFtZXRlciAnJHtwYXJhbU5hbWV9JyBwYXNzZWQgaW50byBgICtcbiAgICAgICAgICAgIGAnJHttb2R1bGVOYW1lfS4ke2NsYXNzTmFtZSA/IChjbGFzc05hbWUgKyAnLicpIDogJyd9YCArXG4gICAgICAgICAgICBgJHtmdW5jTmFtZX0oKScgbXVzdCBiZSBvZiB0eXBlICR7ZXhwZWN0ZWRUeXBlfS5gO1xuICAgIH0sXG4gICAgJ2luY29ycmVjdC1jbGFzcyc6ICh7IGV4cGVjdGVkQ2xhc3MsIHBhcmFtTmFtZSwgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSwgaXNSZXR1cm5WYWx1ZVByb2JsZW0gfSkgPT4ge1xuICAgICAgICBpZiAoIWV4cGVjdGVkQ2xhc3MgfHwgIW1vZHVsZU5hbWUgfHwgIWZ1bmNOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ2luY29ycmVjdC1jbGFzcycgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUmV0dXJuVmFsdWVQcm9ibGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gYFRoZSByZXR1cm4gdmFsdWUgZnJvbSBgICtcbiAgICAgICAgICAgICAgICBgJyR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWUgPyAoY2xhc3NOYW1lICsgJy4nKSA6ICcnfSR7ZnVuY05hbWV9KCknIGAgK1xuICAgICAgICAgICAgICAgIGBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIGNsYXNzICR7ZXhwZWN0ZWRDbGFzcy5uYW1lfS5gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgVGhlIHBhcmFtZXRlciAnJHtwYXJhbU5hbWV9JyBwYXNzZWQgaW50byBgICtcbiAgICAgICAgICAgIGAnJHttb2R1bGVOYW1lfS4ke2NsYXNzTmFtZSA/IChjbGFzc05hbWUgKyAnLicpIDogJyd9JHtmdW5jTmFtZX0oKScgYCArXG4gICAgICAgICAgICBgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBjbGFzcyAke2V4cGVjdGVkQ2xhc3MubmFtZX0uYDtcbiAgICB9LFxuICAgICdtaXNzaW5nLWEtbWV0aG9kJzogKHsgZXhwZWN0ZWRNZXRob2QsIHBhcmFtTmFtZSwgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSB9KSA9PiB7XG4gICAgICAgIGlmICghZXhwZWN0ZWRNZXRob2QgfHwgIXBhcmFtTmFtZSB8fCAhbW9kdWxlTmFtZSB8fCAhY2xhc3NOYW1lXG4gICAgICAgICAgICB8fCAhZnVuY05hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAnbWlzc2luZy1hLW1ldGhvZCcgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lfS4ke2Z1bmNOYW1lfSgpIGV4cGVjdGVkIHRoZSBgICtcbiAgICAgICAgICAgIGAnJHtwYXJhbU5hbWV9JyBwYXJhbWV0ZXIgdG8gZXhwb3NlIGEgJyR7ZXhwZWN0ZWRNZXRob2R9JyBtZXRob2QuYDtcbiAgICB9LFxuICAgICdhZGQtdG8tY2FjaGUtbGlzdC11bmV4cGVjdGVkLXR5cGUnOiAoeyBlbnRyeSB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgQW4gdW5leHBlY3RlZCBlbnRyeSB3YXMgcGFzc2VkIHRvIGAgK1xuICAgICAgICAgICAgYCd3b3JrYm94LXByZWNhY2hpbmcuUHJlY2FjaGVDb250cm9sbGVyLmFkZFRvQ2FjaGVMaXN0KCknIFRoZSBlbnRyeSBgICtcbiAgICAgICAgICAgIGAnJHtKU09OLnN0cmluZ2lmeShlbnRyeSl9JyBpc24ndCBzdXBwb3J0ZWQuIFlvdSBtdXN0IHN1cHBseSBhbiBhcnJheSBvZiBgICtcbiAgICAgICAgICAgIGBzdHJpbmdzIHdpdGggb25lIG9yIG1vcmUgY2hhcmFjdGVycywgb2JqZWN0cyB3aXRoIGEgdXJsIHByb3BlcnR5IG9yIGAgK1xuICAgICAgICAgICAgYFJlcXVlc3Qgb2JqZWN0cy5gO1xuICAgIH0sXG4gICAgJ2FkZC10by1jYWNoZS1saXN0LWNvbmZsaWN0aW5nLWVudHJpZXMnOiAoeyBmaXJzdEVudHJ5LCBzZWNvbmRFbnRyeSB9KSA9PiB7XG4gICAgICAgIGlmICghZmlyc3RFbnRyeSB8fCAhc2Vjb25kRW50cnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byBgICtcbiAgICAgICAgICAgICAgICBgJ2FkZC10by1jYWNoZS1saXN0LWR1cGxpY2F0ZS1lbnRyaWVzJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFR3byBvZiB0aGUgZW50cmllcyBwYXNzZWQgdG8gYCArXG4gICAgICAgICAgICBgJ3dvcmtib3gtcHJlY2FjaGluZy5QcmVjYWNoZUNvbnRyb2xsZXIuYWRkVG9DYWNoZUxpc3QoKScgaGFkIHRoZSBVUkwgYCArXG4gICAgICAgICAgICBgJHtmaXJzdEVudHJ5Ll9lbnRyeUlkfSBidXQgZGlmZmVyZW50IHJldmlzaW9uIGRldGFpbHMuIFdvcmtib3ggaXMgYCArXG4gICAgICAgICAgICBgdW5hYmxlIHRvIGNhY2hlIGFuZCB2ZXJzaW9uIHRoZSBhc3NldCBjb3JyZWN0bHkuIFBsZWFzZSByZW1vdmUgb25lIGAgK1xuICAgICAgICAgICAgYG9mIHRoZSBlbnRyaWVzLmA7XG4gICAgfSxcbiAgICAncGx1Z2luLWVycm9yLXJlcXVlc3Qtd2lsbC1mZXRjaCc6ICh7IHRocm93bkVycm9yIH0pID0+IHtcbiAgICAgICAgaWYgKCF0aHJvd25FcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0IHRvIGAgK1xuICAgICAgICAgICAgICAgIGAncGx1Z2luLWVycm9yLXJlcXVlc3Qtd2lsbC1mZXRjaCcsIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgQW4gZXJyb3Igd2FzIHRocm93biBieSBhIHBsdWdpbnMgJ3JlcXVlc3RXaWxsRmV0Y2goKScgbWV0aG9kLiBgICtcbiAgICAgICAgICAgIGBUaGUgdGhyb3duIGVycm9yIG1lc3NhZ2Ugd2FzOiAnJHt0aHJvd25FcnJvci5tZXNzYWdlfScuYDtcbiAgICB9LFxuICAgICdpbnZhbGlkLWNhY2hlLW5hbWUnOiAoeyBjYWNoZU5hbWVJZCwgdmFsdWUgfSkgPT4ge1xuICAgICAgICBpZiAoIWNhY2hlTmFtZUlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgJ2NhY2hlTmFtZUlkJyBmb3IgZXJyb3IgJ2ludmFsaWQtY2FjaGUtbmFtZSdgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFlvdSBtdXN0IHByb3ZpZGUgYSBuYW1lIGNvbnRhaW5pbmcgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciBmb3IgYCArXG4gICAgICAgICAgICBgc2V0Q2FjaGVEZXRhaWxzKHske2NhY2hlTmFtZUlkfTogJy4uLid9KS4gUmVjZWl2ZWQgYSB2YWx1ZSBvZiBgICtcbiAgICAgICAgICAgIGAnJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9J2A7XG4gICAgfSxcbiAgICAndW5yZWdpc3Rlci1yb3V0ZS1idXQtbm90LWZvdW5kLXdpdGgtbWV0aG9kJzogKHsgbWV0aG9kIH0pID0+IHtcbiAgICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byBgICtcbiAgICAgICAgICAgICAgICBgJ3VucmVnaXN0ZXItcm91dGUtYnV0LW5vdC1mb3VuZC13aXRoLW1ldGhvZCcgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBUaGUgcm91dGUgeW91J3JlIHRyeWluZyB0byB1bnJlZ2lzdGVyIHdhcyBub3QgIHByZXZpb3VzbHkgYCArXG4gICAgICAgICAgICBgcmVnaXN0ZXJlZCBmb3IgdGhlIG1ldGhvZCB0eXBlICcke21ldGhvZH0nLmA7XG4gICAgfSxcbiAgICAndW5yZWdpc3Rlci1yb3V0ZS1yb3V0ZS1ub3QtcmVnaXN0ZXJlZCc6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGBUaGUgcm91dGUgeW91J3JlIHRyeWluZyB0byB1bnJlZ2lzdGVyIHdhcyBub3QgcHJldmlvdXNseSBgICtcbiAgICAgICAgICAgIGByZWdpc3RlcmVkLmA7XG4gICAgfSxcbiAgICAncXVldWUtcmVwbGF5LWZhaWxlZCc6ICh7IG5hbWUgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFJlcGxheWluZyB0aGUgYmFja2dyb3VuZCBzeW5jIHF1ZXVlICcke25hbWV9JyBmYWlsZWQuYDtcbiAgICB9LFxuICAgICdkdXBsaWNhdGUtcXVldWUtbmFtZSc6ICh7IG5hbWUgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFRoZSBRdWV1ZSBuYW1lICcke25hbWV9JyBpcyBhbHJlYWR5IGJlaW5nIHVzZWQuIGAgK1xuICAgICAgICAgICAgYEFsbCBpbnN0YW5jZXMgb2YgYmFja2dyb3VuZFN5bmMuUXVldWUgbXVzdCBiZSBnaXZlbiB1bmlxdWUgbmFtZXMuYDtcbiAgICB9LFxuICAgICdleHBpcmVkLXRlc3Qtd2l0aG91dC1tYXgtYWdlJzogKHsgbWV0aG9kTmFtZSwgcGFyYW1OYW1lIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGBUaGUgJyR7bWV0aG9kTmFtZX0oKScgbWV0aG9kIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiB0aGUgYCArXG4gICAgICAgICAgICBgJyR7cGFyYW1OYW1lfScgaXMgdXNlZCBpbiB0aGUgY29uc3RydWN0b3IuYDtcbiAgICB9LFxuICAgICd1bnN1cHBvcnRlZC1yb3V0ZS10eXBlJzogKHsgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSwgcGFyYW1OYW1lIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGBUaGUgc3VwcGxpZWQgJyR7cGFyYW1OYW1lfScgcGFyYW1ldGVyIHdhcyBhbiB1bnN1cHBvcnRlZCB0eXBlLiBgICtcbiAgICAgICAgICAgIGBQbGVhc2UgY2hlY2sgdGhlIGRvY3MgZm9yICR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWV9LiR7ZnVuY05hbWV9IGZvciBgICtcbiAgICAgICAgICAgIGB2YWxpZCBpbnB1dCB0eXBlcy5gO1xuICAgIH0sXG4gICAgJ25vdC1hcnJheS1vZi1jbGFzcyc6ICh7IHZhbHVlLCBleHBlY3RlZENsYXNzLCBtb2R1bGVOYW1lLCBjbGFzc05hbWUsIGZ1bmNOYW1lLCBwYXJhbU5hbWUgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFRoZSBzdXBwbGllZCAnJHtwYXJhbU5hbWV9JyBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBhcnJheSBvZiBgICtcbiAgICAgICAgICAgIGAnJHtleHBlY3RlZENsYXNzfScgb2JqZWN0cy4gUmVjZWl2ZWQgJyR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSwnLiBgICtcbiAgICAgICAgICAgIGBQbGVhc2UgY2hlY2sgdGhlIGNhbGwgdG8gJHttb2R1bGVOYW1lfS4ke2NsYXNzTmFtZX0uJHtmdW5jTmFtZX0oKSBgICtcbiAgICAgICAgICAgIGB0byBmaXggdGhlIGlzc3VlLmA7XG4gICAgfSxcbiAgICAnbWF4LWVudHJpZXMtb3ItYWdlLXJlcXVpcmVkJzogKHsgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgWW91IG11c3QgZGVmaW5lIGVpdGhlciBjb25maWcubWF4RW50cmllcyBvciBjb25maWcubWF4QWdlU2Vjb25kc2AgK1xuICAgICAgICAgICAgYGluICR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWV9LiR7ZnVuY05hbWV9YDtcbiAgICB9LFxuICAgICdzdGF0dXNlcy1vci1oZWFkZXJzLXJlcXVpcmVkJzogKHsgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgWW91IG11c3QgZGVmaW5lIGVpdGhlciBjb25maWcuc3RhdHVzZXMgb3IgY29uZmlnLmhlYWRlcnNgICtcbiAgICAgICAgICAgIGBpbiAke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lfS4ke2Z1bmNOYW1lfWA7XG4gICAgfSxcbiAgICAnaW52YWxpZC1zdHJpbmcnOiAoeyBtb2R1bGVOYW1lLCBmdW5jTmFtZSwgcGFyYW1OYW1lIH0pID0+IHtcbiAgICAgICAgaWYgKCFwYXJhbU5hbWUgfHwgIW1vZHVsZU5hbWUgfHwgIWZ1bmNOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ2ludmFsaWQtc3RyaW5nJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFdoZW4gdXNpbmcgc3RyaW5ncywgdGhlICcke3BhcmFtTmFtZX0nIHBhcmFtZXRlciBtdXN0IHN0YXJ0IHdpdGggYCArXG4gICAgICAgICAgICBgJ2h0dHAnIChmb3IgY3Jvc3Mtb3JpZ2luIG1hdGNoZXMpIG9yICcvJyAoZm9yIHNhbWUtb3JpZ2luIG1hdGNoZXMpLiBgICtcbiAgICAgICAgICAgIGBQbGVhc2Ugc2VlIHRoZSBkb2NzIGZvciAke21vZHVsZU5hbWV9LiR7ZnVuY05hbWV9KCkgZm9yIGAgK1xuICAgICAgICAgICAgYG1vcmUgaW5mby5gO1xuICAgIH0sXG4gICAgJ2NoYW5uZWwtbmFtZS1yZXF1aXJlZCc6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGBZb3UgbXVzdCBwcm92aWRlIGEgY2hhbm5lbE5hbWUgdG8gY29uc3RydWN0IGEgYCArXG4gICAgICAgICAgICBgQnJvYWRjYXN0Q2FjaGVVcGRhdGUgaW5zdGFuY2UuYDtcbiAgICB9LFxuICAgICdpbnZhbGlkLXJlc3BvbnNlcy1hcmUtc2FtZS1hcmdzJzogKCkgPT4ge1xuICAgICAgICByZXR1cm4gYFRoZSBhcmd1bWVudHMgcGFzc2VkIGludG8gcmVzcG9uc2VzQXJlU2FtZSgpIGFwcGVhciB0byBiZSBgICtcbiAgICAgICAgICAgIGBpbnZhbGlkLiBQbGVhc2UgZW5zdXJlIHZhbGlkIFJlc3BvbnNlcyBhcmUgdXNlZC5gO1xuICAgIH0sXG4gICAgJ2V4cGlyZS1jdXN0b20tY2FjaGVzLW9ubHknOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBgWW91IG11c3QgcHJvdmlkZSBhICdjYWNoZU5hbWUnIHByb3BlcnR5IHdoZW4gdXNpbmcgdGhlIGAgK1xuICAgICAgICAgICAgYGV4cGlyYXRpb24gcGx1Z2luIHdpdGggYSBydW50aW1lIGNhY2hpbmcgc3RyYXRlZ3kuYDtcbiAgICB9LFxuICAgICd1bml0LW11c3QtYmUtYnl0ZXMnOiAoeyBub3JtYWxpemVkUmFuZ2VIZWFkZXIgfSkgPT4ge1xuICAgICAgICBpZiAoIW5vcm1hbGl6ZWRSYW5nZUhlYWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0IHRvICd1bml0LW11c3QtYmUtYnl0ZXMnIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgVGhlICd1bml0JyBwb3J0aW9uIG9mIHRoZSBSYW5nZSBoZWFkZXIgbXVzdCBiZSBzZXQgdG8gJ2J5dGVzJy4gYCArXG4gICAgICAgICAgICBgVGhlIFJhbmdlIGhlYWRlciBwcm92aWRlZCB3YXMgXCIke25vcm1hbGl6ZWRSYW5nZUhlYWRlcn1cImA7XG4gICAgfSxcbiAgICAnc2luZ2xlLXJhbmdlLW9ubHknOiAoeyBub3JtYWxpemVkUmFuZ2VIZWFkZXIgfSkgPT4ge1xuICAgICAgICBpZiAoIW5vcm1hbGl6ZWRSYW5nZUhlYWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0IHRvICdzaW5nbGUtcmFuZ2Utb25seScgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBNdWx0aXBsZSByYW5nZXMgYXJlIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgYSAgc2luZ2xlIHN0YXJ0IGAgK1xuICAgICAgICAgICAgYHZhbHVlLCBhbmQgb3B0aW9uYWwgZW5kIHZhbHVlLiBUaGUgUmFuZ2UgaGVhZGVyIHByb3ZpZGVkIHdhcyBgICtcbiAgICAgICAgICAgIGBcIiR7bm9ybWFsaXplZFJhbmdlSGVhZGVyfVwiYDtcbiAgICB9LFxuICAgICdpbnZhbGlkLXJhbmdlLXZhbHVlcyc6ICh7IG5vcm1hbGl6ZWRSYW5nZUhlYWRlciB9KSA9PiB7XG4gICAgICAgIGlmICghbm9ybWFsaXplZFJhbmdlSGVhZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ2ludmFsaWQtcmFuZ2UtdmFsdWVzJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFRoZSBSYW5nZSBoZWFkZXIgaXMgbWlzc2luZyBib3RoIHN0YXJ0IGFuZCBlbmQgdmFsdWVzLiBBdCBsZWFzdCBgICtcbiAgICAgICAgICAgIGBvbmUgb2YgdGhvc2UgdmFsdWVzIGlzIG5lZWRlZC4gVGhlIFJhbmdlIGhlYWRlciBwcm92aWRlZCB3YXMgYCArXG4gICAgICAgICAgICBgXCIke25vcm1hbGl6ZWRSYW5nZUhlYWRlcn1cImA7XG4gICAgfSxcbiAgICAnbm8tcmFuZ2UtaGVhZGVyJzogKCkgPT4ge1xuICAgICAgICByZXR1cm4gYE5vIFJhbmdlIGhlYWRlciB3YXMgZm91bmQgaW4gdGhlIFJlcXVlc3QgcHJvdmlkZWQuYDtcbiAgICB9LFxuICAgICdyYW5nZS1ub3Qtc2F0aXNmaWFibGUnOiAoeyBzaXplLCBzdGFydCwgZW5kIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGBUaGUgc3RhcnQgKCR7c3RhcnR9KSBhbmQgZW5kICgke2VuZH0pIHZhbHVlcyBpbiB0aGUgUmFuZ2UgYXJlIGAgK1xuICAgICAgICAgICAgYG5vdCBzYXRpc2ZpYWJsZSBieSB0aGUgY2FjaGVkIHJlc3BvbnNlLCB3aGljaCBpcyAke3NpemV9IGJ5dGVzLmA7XG4gICAgfSxcbiAgICAnYXR0ZW1wdC10by1jYWNoZS1ub24tZ2V0LXJlcXVlc3QnOiAoeyB1cmwsIG1ldGhvZCB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgVW5hYmxlIHRvIGNhY2hlICcke3VybH0nIGJlY2F1c2UgaXQgaXMgYSAnJHttZXRob2R9JyByZXF1ZXN0IGFuZCBgICtcbiAgICAgICAgICAgIGBvbmx5ICdHRVQnIHJlcXVlc3RzIGNhbiBiZSBjYWNoZWQuYDtcbiAgICB9LFxuICAgICdjYWNoZS1wdXQtd2l0aC1uby1yZXNwb25zZSc6ICh7IHVybCB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgVGhlcmUgd2FzIGFuIGF0dGVtcHQgdG8gY2FjaGUgJyR7dXJsfScgYnV0IHRoZSByZXNwb25zZSB3YXMgbm90IGAgK1xuICAgICAgICAgICAgYGRlZmluZWQuYDtcbiAgICB9LFxuICAgICduby1yZXNwb25zZSc6ICh7IHVybCwgZXJyb3IgfSkgPT4ge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IGBUaGUgc3RyYXRlZ3kgY291bGQgbm90IGdlbmVyYXRlIGEgcmVzcG9uc2UgZm9yICcke3VybH0nLmA7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBgIFRoZSB1bmRlcmx5aW5nIGVycm9yIGlzICR7ZXJyb3J9LmA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICAnYmFkLXByZWNhY2hpbmctcmVzcG9uc2UnOiAoeyB1cmwsIHN0YXR1cyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgVGhlIHByZWNhY2hpbmcgcmVxdWVzdCBmb3IgJyR7dXJsfScgZmFpbGVkYCArXG4gICAgICAgICAgICAoc3RhdHVzID8gYCB3aXRoIGFuIEhUVFAgc3RhdHVzIG9mICR7c3RhdHVzfS5gIDogYC5gKTtcbiAgICB9LFxuICAgICdub24tcHJlY2FjaGVkLXVybCc6ICh7IHVybCB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgY3JlYXRlSGFuZGxlckJvdW5kVG9VUkwoJyR7dXJsfScpIHdhcyBjYWxsZWQsIGJ1dCB0aGF0IFVSTCBpcyBgICtcbiAgICAgICAgICAgIGBub3QgcHJlY2FjaGVkLiBQbGVhc2UgcGFzcyBpbiBhIFVSTCB0aGF0IGlzIHByZWNhY2hlZCBpbnN0ZWFkLmA7XG4gICAgfSxcbiAgICAnYWRkLXRvLWNhY2hlLWxpc3QtY29uZmxpY3RpbmctaW50ZWdyaXRpZXMnOiAoeyB1cmwgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFR3byBvZiB0aGUgZW50cmllcyBwYXNzZWQgdG8gYCArXG4gICAgICAgICAgICBgJ3dvcmtib3gtcHJlY2FjaGluZy5QcmVjYWNoZUNvbnRyb2xsZXIuYWRkVG9DYWNoZUxpc3QoKScgaGFkIHRoZSBVUkwgYCArXG4gICAgICAgICAgICBgJHt1cmx9IHdpdGggZGlmZmVyZW50IGludGVncml0eSB2YWx1ZXMuIFBsZWFzZSByZW1vdmUgb25lIG9mIHRoZW0uYDtcbiAgICB9LFxuICAgICdtaXNzaW5nLXByZWNhY2hlLWVudHJ5JzogKHsgY2FjaGVOYW1lLCB1cmwgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFVuYWJsZSB0byBmaW5kIGEgcHJlY2FjaGVkIHJlc3BvbnNlIGluICR7Y2FjaGVOYW1lfSBmb3IgJHt1cmx9LmA7XG4gICAgfSxcbiAgICAnY3Jvc3Mtb3JpZ2luLWNvcHktcmVzcG9uc2UnOiAoeyBvcmlnaW4gfSkgPT4ge1xuICAgICAgICByZXR1cm4gYHdvcmtib3gtY29yZS5jb3B5UmVzcG9uc2UoKSBjYW4gb25seSBiZSB1c2VkIHdpdGggc2FtZS1vcmlnaW4gYCArXG4gICAgICAgICAgICBgcmVzcG9uc2VzLiBJdCB3YXMgcGFzc2VkIGEgcmVzcG9uc2Ugd2l0aCBvcmlnaW4gJHtvcmlnaW59LmA7XG4gICAgfSxcbn07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBtZXNzYWdlcyB9IGZyb20gJy4vbWVzc2FnZXMuanMnO1xuaW1wb3J0ICcuLi8uLi9fdmVyc2lvbi5qcyc7XG5jb25zdCBmYWxsYmFjayA9IChjb2RlLCAuLi5hcmdzKSA9PiB7XG4gICAgbGV0IG1zZyA9IGNvZGU7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBtc2cgKz0gYCA6OiAke0pTT04uc3RyaW5naWZ5KGFyZ3MpfWA7XG4gICAgfVxuICAgIHJldHVybiBtc2c7XG59O1xuY29uc3QgZ2VuZXJhdG9yRnVuY3Rpb24gPSAoY29kZSwgZGV0YWlscyA9IHt9KSA9PiB7XG4gICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VzW2NvZGVdO1xuICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIG1lc3NhZ2UgZm9yIGNvZGUgJyR7Y29kZX0nLmApO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZShkZXRhaWxzKTtcbn07XG5leHBvcnQgY29uc3QgbWVzc2FnZUdlbmVyYXRvciA9IChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSA/XG4gICAgZmFsbGJhY2sgOiBnZW5lcmF0b3JGdW5jdGlvbjtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IG1lc3NhZ2VHZW5lcmF0b3IgfSBmcm9tICcuLi9tb2RlbHMvbWVzc2FnZXMvbWVzc2FnZUdlbmVyYXRvci5qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogV29ya2JveCBlcnJvcnMgc2hvdWxkIGJlIHRocm93biB3aXRoIHRoaXMgY2xhc3MuXG4gKiBUaGlzIGFsbG93cyB1c2UgdG8gZW5zdXJlIHRoZSB0eXBlIGVhc2lseSBpbiB0ZXN0cyxcbiAqIGhlbHBzIGRldmVsb3BlcnMgaWRlbnRpZnkgZXJyb3JzIGZyb20gd29ya2JveFxuICogZWFzaWx5IGFuZCBhbGxvd3MgdXNlIHRvIG9wdGltaXNlIGVycm9yXG4gKiBtZXNzYWdlcyBjb3JyZWN0bHkuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgV29ya2JveEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVycm9yQ29kZSBUaGUgZXJyb3IgY29kZSB0aGF0XG4gICAgICogaWRlbnRpZmllcyB0aGlzIHBhcnRpY3VsYXIgZXJyb3IuXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBkZXRhaWxzIEFueSByZWxldmFudCBhcmd1bWVudHNcbiAgICAgKiB0aGF0IHdpbGwgaGVscCBkZXZlbG9wZXJzIGlkZW50aWZ5IGlzc3VlcyBzaG91bGRcbiAgICAgKiBiZSBhZGRlZCBhcyBhIGtleSBvbiB0aGUgY29udGV4dCBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZXJyb3JDb2RlLCBkZXRhaWxzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlR2VuZXJhdG9yKGVycm9yQ29kZSwgZGV0YWlscyk7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnJvckNvZGU7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgfVxufVxuZXhwb3J0IHsgV29ya2JveEVycm9yIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBXb3JrYm94RXJyb3IgfSBmcm9tICcuLi9fcHJpdmF0ZS9Xb3JrYm94RXJyb3IuanMnO1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKlxuICogVGhpcyBtZXRob2QgdGhyb3dzIGlmIHRoZSBzdXBwbGllZCB2YWx1ZSBpcyBub3QgYW4gYXJyYXkuXG4gKiBUaGUgZGVzdHJ1Y3RlZCB2YWx1ZXMgYXJlIHJlcXVpcmVkIHRvIHByb2R1Y2UgYSBtZWFuaW5nZnVsIGVycm9yIGZvciB1c2Vycy5cbiAqIFRoZSBkZXN0cnVjdGVkIGFuZCByZXN0cnVjdHVyZWQgb2JqZWN0IGlzIHNvIGl0J3MgY2xlYXIgd2hhdCBpc1xuICogbmVlZGVkLlxuICovXG5jb25zdCBpc0FycmF5ID0gKHZhbHVlLCBkZXRhaWxzKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdub3QtYW4tYXJyYXknLCBkZXRhaWxzKTtcbiAgICB9XG59O1xuY29uc3QgaGFzTWV0aG9kID0gKG9iamVjdCwgZXhwZWN0ZWRNZXRob2QsIGRldGFpbHMpID0+IHtcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIG9iamVjdFtleHBlY3RlZE1ldGhvZF07XG4gICAgaWYgKHR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGV0YWlsc1snZXhwZWN0ZWRNZXRob2QnXSA9IGV4cGVjdGVkTWV0aG9kO1xuICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdtaXNzaW5nLWEtbWV0aG9kJywgZGV0YWlscyk7XG4gICAgfVxufTtcbmNvbnN0IGlzVHlwZSA9IChvYmplY3QsIGV4cGVjdGVkVHlwZSwgZGV0YWlscykgPT4ge1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgZGV0YWlsc1snZXhwZWN0ZWRUeXBlJ10gPSBleHBlY3RlZFR5cGU7XG4gICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2luY29ycmVjdC10eXBlJywgZGV0YWlscyk7XG4gICAgfVxufTtcbmNvbnN0IGlzSW5zdGFuY2UgPSAob2JqZWN0LCBleHBlY3RlZENsYXNzLCBkZXRhaWxzKSA9PiB7XG4gICAgaWYgKCEob2JqZWN0IGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgZGV0YWlsc1snZXhwZWN0ZWRDbGFzcyddID0gZXhwZWN0ZWRDbGFzcztcbiAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignaW5jb3JyZWN0LWNsYXNzJywgZGV0YWlscyk7XG4gICAgfVxufTtcbmNvbnN0IGlzT25lT2YgPSAodmFsdWUsIHZhbGlkVmFsdWVzLCBkZXRhaWxzKSA9PiB7XG4gICAgaWYgKCF2YWxpZFZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgZGV0YWlsc1sndmFsaWRWYWx1ZURlc2NyaXB0aW9uJ10gPVxuICAgICAgICAgICAgYFZhbGlkIHZhbHVlcyBhcmUgJHtKU09OLnN0cmluZ2lmeSh2YWxpZFZhbHVlcyl9LmA7XG4gICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2ludmFsaWQtdmFsdWUnLCBkZXRhaWxzKTtcbiAgICB9XG59O1xuY29uc3QgaXNBcnJheU9mQ2xhc3MgPSAodmFsdWUsIGV4cGVjdGVkQ2xhc3MsIGRldGFpbHMpID0+IHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBXb3JrYm94RXJyb3IoJ25vdC1hcnJheS1vZi1jbGFzcycsIGRldGFpbHMpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGZpbmFsQXNzZXJ0RXhwb3J0cyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyBudWxsIDoge1xuICAgIGhhc01ldGhvZCxcbiAgICBpc0FycmF5LFxuICAgIGlzSW5zdGFuY2UsXG4gICAgaXNPbmVPZixcbiAgICBpc1R5cGUsXG4gICAgaXNBcnJheU9mQ2xhc3MsXG59O1xuZXhwb3J0IHsgZmluYWxBc3NlcnRFeHBvcnRzIGFzIGFzc2VydCB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG5jb25zdCBfY2FjaGVOYW1lRGV0YWlscyA9IHtcbiAgICBnb29nbGVBbmFseXRpY3M6ICdnb29nbGVBbmFseXRpY3MnLFxuICAgIHByZWNhY2hlOiAncHJlY2FjaGUtdjInLFxuICAgIHByZWZpeDogJ3dvcmtib3gnLFxuICAgIHJ1bnRpbWU6ICdydW50aW1lJyxcbiAgICBzdWZmaXg6IHR5cGVvZiByZWdpc3RyYXRpb24gIT09ICd1bmRlZmluZWQnID8gcmVnaXN0cmF0aW9uLnNjb3BlIDogJycsXG59O1xuY29uc3QgX2NyZWF0ZUNhY2hlTmFtZSA9IChjYWNoZU5hbWUpID0+IHtcbiAgICByZXR1cm4gW19jYWNoZU5hbWVEZXRhaWxzLnByZWZpeCwgY2FjaGVOYW1lLCBfY2FjaGVOYW1lRGV0YWlscy5zdWZmaXhdXG4gICAgICAgIC5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwKVxuICAgICAgICAuam9pbignLScpO1xufTtcbmNvbnN0IGVhY2hDYWNoZU5hbWVEZXRhaWwgPSAoZm4pID0+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhfY2FjaGVOYW1lRGV0YWlscykpIHtcbiAgICAgICAgZm4oa2V5KTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGNhY2hlTmFtZXMgPSB7XG4gICAgdXBkYXRlRGV0YWlsczogKGRldGFpbHMpID0+IHtcbiAgICAgICAgZWFjaENhY2hlTmFtZURldGFpbCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRldGFpbHNba2V5XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBfY2FjaGVOYW1lRGV0YWlsc1trZXldID0gZGV0YWlsc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGdldEdvb2dsZUFuYWx5dGljc05hbWU6ICh1c2VyQ2FjaGVOYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiB1c2VyQ2FjaGVOYW1lIHx8IF9jcmVhdGVDYWNoZU5hbWUoX2NhY2hlTmFtZURldGFpbHMuZ29vZ2xlQW5hbHl0aWNzKTtcbiAgICB9LFxuICAgIGdldFByZWNhY2hlTmFtZTogKHVzZXJDYWNoZU5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHVzZXJDYWNoZU5hbWUgfHwgX2NyZWF0ZUNhY2hlTmFtZShfY2FjaGVOYW1lRGV0YWlscy5wcmVjYWNoZSk7XG4gICAgfSxcbiAgICBnZXRQcmVmaXg6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIF9jYWNoZU5hbWVEZXRhaWxzLnByZWZpeDtcbiAgICB9LFxuICAgIGdldFJ1bnRpbWVOYW1lOiAodXNlckNhY2hlTmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gdXNlckNhY2hlTmFtZSB8fCBfY3JlYXRlQ2FjaGVOYW1lKF9jYWNoZU5hbWVEZXRhaWxzLnJ1bnRpbWUpO1xuICAgIH0sXG4gICAgZ2V0U3VmZml4OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBfY2FjaGVOYW1lRGV0YWlscy5zdWZmaXg7XG4gICAgfSxcbn07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG5jb25zdCBsb2dnZXIgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyA/IG51bGwgOiAoKCkgPT4ge1xuICAgIC8vIERvbid0IG92ZXJ3cml0ZSB0aGlzIHZhbHVlIGlmIGl0J3MgYWxyZWFkeSBzZXQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvd29ya2JveC9wdWxsLzIyODQjaXNzdWVjb21tZW50LTU2MDQ3MDkyM1xuICAgIGlmICghKCdfX1dCX0RJU0FCTEVfREVWX0xPR1MnIGluIHNlbGYpKSB7XG4gICAgICAgIHNlbGYuX19XQl9ESVNBQkxFX0RFVl9MT0dTID0gZmFsc2U7XG4gICAgfVxuICAgIGxldCBpbkdyb3VwID0gZmFsc2U7XG4gICAgY29uc3QgbWV0aG9kVG9Db2xvck1hcCA9IHtcbiAgICAgICAgZGVidWc6IGAjN2Y4YzhkYCxcbiAgICAgICAgbG9nOiBgIzJlY2M3MWAsXG4gICAgICAgIHdhcm46IGAjZjM5YzEyYCxcbiAgICAgICAgZXJyb3I6IGAjYzAzOTJiYCxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGAjMzQ5OGRiYCxcbiAgICAgICAgZ3JvdXBFbmQ6IG51bGwsXG4gICAgfTtcbiAgICBjb25zdCBwcmludCA9IGZ1bmN0aW9uIChtZXRob2QsIGFyZ3MpIHtcbiAgICAgICAgaWYgKHNlbGYuX19XQl9ESVNBQkxFX0RFVl9MT0dTKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ2dyb3VwQ29sbGFwc2VkJykge1xuICAgICAgICAgICAgLy8gU2FmYXJpIGRvZXNuJ3QgcHJpbnQgYWxsIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoKSBhcmd1bWVudHM6XG4gICAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTgyNzU0XG4gICAgICAgICAgICBpZiAoL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGVbbWV0aG9kXSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3R5bGVzID0gW1xuICAgICAgICAgICAgYGJhY2tncm91bmQ6ICR7bWV0aG9kVG9Db2xvck1hcFttZXRob2RdfWAsXG4gICAgICAgICAgICBgYm9yZGVyLXJhZGl1czogMC41ZW1gLFxuICAgICAgICAgICAgYGNvbG9yOiB3aGl0ZWAsXG4gICAgICAgICAgICBgZm9udC13ZWlnaHQ6IGJvbGRgLFxuICAgICAgICAgICAgYHBhZGRpbmc6IDJweCAwLjVlbWAsXG4gICAgICAgIF07XG4gICAgICAgIC8vIFdoZW4gaW4gYSBncm91cCwgdGhlIHdvcmtib3ggcHJlZml4IGlzIG5vdCBkaXNwbGF5ZWQuXG4gICAgICAgIGNvbnN0IGxvZ1ByZWZpeCA9IGluR3JvdXAgPyBbXSA6IFsnJWN3b3JrYm94Jywgc3R5bGVzLmpvaW4oJzsnKV07XG4gICAgICAgIGNvbnNvbGVbbWV0aG9kXSguLi5sb2dQcmVmaXgsIC4uLmFyZ3MpO1xuICAgICAgICBpZiAobWV0aG9kID09PSAnZ3JvdXBDb2xsYXBzZWQnKSB7XG4gICAgICAgICAgICBpbkdyb3VwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kID09PSAnZ3JvdXBFbmQnKSB7XG4gICAgICAgICAgICBpbkdyb3VwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGFwaSA9IHt9O1xuICAgIGNvbnN0IGxvZ2dlck1ldGhvZHMgPSBPYmplY3Qua2V5cyhtZXRob2RUb0NvbG9yTWFwKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBsb2dnZXJNZXRob2RzKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGtleTtcbiAgICAgICAgYXBpW21ldGhvZF0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgcHJpbnQobWV0aG9kLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGFwaTtcbn0pKCkpO1xuZXhwb3J0IHsgbG9nZ2VyIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEEgdXRpbGl0eSBtZXRob2QgdGhhdCBtYWtlcyBpdCBlYXNpZXIgdG8gdXNlIGBldmVudC53YWl0VW50aWxgIHdpdGhcbiAqIGFzeW5jIGZ1bmN0aW9ucyBhbmQgcmV0dXJuIHRoZSByZXN1bHQuXG4gKlxuICogQHBhcmFtIHtFeHRlbmRhYmxlRXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3luY0ZuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHdhaXRVbnRpbChldmVudCwgYXN5bmNGbikge1xuICAgIGNvbnN0IHJldHVyblByb21pc2UgPSBhc3luY0ZuKCk7XG4gICAgZXZlbnQud2FpdFVudGlsKHJldHVyblByb21pc2UpO1xuICAgIHJldHVybiByZXR1cm5Qcm9taXNlO1xufVxuZXhwb3J0IHsgd2FpdFVudGlsIH07XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIEB0cy1pZ25vcmVcbnRyeSB7XG4gICAgc2VsZlsnd29ya2JveDpwcmVjYWNoaW5nOjYuMC4yJ10gJiYgXygpO1xufVxuY2F0Y2ggKGUpIHsgfVxuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgV29ya2JveEVycm9yIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8vIE5hbWUgb2YgdGhlIHNlYXJjaCBwYXJhbWV0ZXIgdXNlZCB0byBzdG9yZSByZXZpc2lvbiBpbmZvLlxuY29uc3QgUkVWSVNJT05fU0VBUkNIX1BBUkFNID0gJ19fV0JfUkVWSVNJT05fXyc7XG4vKipcbiAqIENvbnZlcnRzIGEgbWFuaWZlc3QgZW50cnkgaW50byBhIHZlcnNpb25lZCBVUkwgc3VpdGFibGUgZm9yIHByZWNhY2hpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBlbnRyeVxuICogQHJldHVybiB7c3RyaW5nfSBBIFVSTCB3aXRoIHZlcnNpb25pbmcgaW5mby5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhY2hlS2V5KGVudHJ5KSB7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdhZGQtdG8tY2FjaGUtbGlzdC11bmV4cGVjdGVkLXR5cGUnLCB7IGVudHJ5IH0pO1xuICAgIH1cbiAgICAvLyBJZiBhIHByZWNhY2hlIG1hbmlmZXN0IGVudHJ5IGlzIGEgc3RyaW5nLCBpdCdzIGFzc3VtZWQgdG8gYmUgYSB2ZXJzaW9uZWRcbiAgICAvLyBVUkwsIGxpa2UgJy9hcHAuYWJjZDEyMzQuanMnLiBSZXR1cm4gYXMtaXMuXG4gICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTChlbnRyeSwgbG9jYXRpb24uaHJlZik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYWNoZUtleTogdXJsT2JqZWN0LmhyZWYsXG4gICAgICAgICAgICB1cmw6IHVybE9iamVjdC5ocmVmLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7IHJldmlzaW9uLCB1cmwgfSA9IGVudHJ5O1xuICAgIGlmICghdXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2FkZC10by1jYWNoZS1saXN0LXVuZXhwZWN0ZWQtdHlwZScsIHsgZW50cnkgfSk7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlJ3MganVzdCBhIFVSTCBhbmQgbm8gcmV2aXNpb24sIHRoZW4gaXQncyBhbHNvIGFzc3VtZWQgdG8gYmUgYVxuICAgIC8vIHZlcnNpb25lZCBVUkwuXG4gICAgaWYgKCFyZXZpc2lvbikge1xuICAgICAgICBjb25zdCB1cmxPYmplY3QgPSBuZXcgVVJMKHVybCwgbG9jYXRpb24uaHJlZik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYWNoZUtleTogdXJsT2JqZWN0LmhyZWYsXG4gICAgICAgICAgICB1cmw6IHVybE9iamVjdC5ocmVmLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGNvbnN0cnVjdCBhIHByb3Blcmx5IHZlcnNpb25lZCBVUkwgdXNpbmcgdGhlIGN1c3RvbSBXb3JrYm94XG4gICAgLy8gc2VhcmNoIHBhcmFtZXRlciBhbG9uZyB3aXRoIHRoZSByZXZpc2lvbiBpbmZvLlxuICAgIGNvbnN0IGNhY2hlS2V5VVJMID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLmhyZWYpO1xuICAgIGNvbnN0IG9yaWdpbmFsVVJMID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLmhyZWYpO1xuICAgIGNhY2hlS2V5VVJMLnNlYXJjaFBhcmFtcy5zZXQoUkVWSVNJT05fU0VBUkNIX1BBUkFNLCByZXZpc2lvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2FjaGVLZXk6IGNhY2hlS2V5VVJMLmhyZWYsXG4gICAgICAgIHVybDogb3JpZ2luYWxVUkwuaHJlZixcbiAgICB9O1xufVxuIiwiLypcbiAgQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEEgcGx1Z2luLCBkZXNpZ25lZCB0byBiZSB1c2VkIHdpdGggUHJlY2FjaGVDb250cm9sbGVyLCB0byBkZXRlcm1pbmUgdGhlXG4gKiBvZiBhc3NldHMgdGhhdCB3ZXJlIHVwZGF0ZWQgKG9yIG5vdCB1cGRhdGVkKSBkdXJpbmcgdGhlIGluc3RhbGwgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUHJlY2FjaGVJbnN0YWxsUmVwb3J0UGx1Z2luIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy51cGRhdGVkVVJMcyA9IFtdO1xuICAgICAgICB0aGlzLm5vdFVwZGF0ZWRVUkxzID0gW107XG4gICAgICAgIHRoaXMuaGFuZGxlcldpbGxTdGFydCA9IGFzeW5jICh7IHJlcXVlc3QsIHN0YXRlLCB9KSA9PiB7XG4gICAgICAgICAgICAvLyBUT0RPOiBgc3RhdGVgIHNob3VsZCBuZXZlciBiZSB1bmRlZmluZWQuLi5cbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLm9yaWdpbmFsUmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2FjaGVkUmVzcG9uc2VXaWxsQmVVc2VkID0gYXN5bmMgKHsgZXZlbnQsIHN0YXRlLCBjYWNoZWRSZXNwb25zZSwgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdpbnN0YWxsJykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGBzdGF0ZWAgc2hvdWxkIG5ldmVyIGJlIHVuZGVmaW5lZC4uLlxuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IHN0YXRlLm9yaWdpbmFsUmVxdWVzdC51cmw7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90VXBkYXRlZFVSTHMucHVzaCh1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVkVVJMcy5wdXNoKHVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3BvbnNlO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCB7IFByZWNhY2hlSW5zdGFsbFJlcG9ydFBsdWdpbiB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEEgcGx1Z2luLCBkZXNpZ25lZCB0byBiZSB1c2VkIHdpdGggUHJlY2FjaGVDb250cm9sbGVyLCB0byB0cmFuc2xhdGUgVVJMcyBpbnRvXG4gKiB0aGUgY29ycmVzcG9uZGluZyBjYWNoZSBrZXksIGJhc2VkIG9uIHRoZSBjdXJyZW50IHJldmlzaW9uIGluZm8uXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUHJlY2FjaGVDYWNoZUtleVBsdWdpbiB7XG4gICAgY29uc3RydWN0b3IoeyBwcmVjYWNoZUNvbnRyb2xsZXIgfSkge1xuICAgICAgICB0aGlzLmNhY2hlS2V5V2lsbEJlVXNlZCA9IGFzeW5jICh7IHJlcXVlc3QsIHBhcmFtcywgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBwYXJhbXMgJiYgcGFyYW1zLmNhY2hlS2V5IHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJlY2FjaGVDb250cm9sbGVyLmdldENhY2hlS2V5Rm9yVVJMKHJlcXVlc3QudXJsKTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZUtleSA/IG5ldyBSZXF1ZXN0KGNhY2hlS2V5KSA6IHJlcXVlc3Q7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByZWNhY2hlQ29udHJvbGxlciA9IHByZWNhY2hlQ29udHJvbGxlcjtcbiAgICB9XG59XG5leHBvcnQgeyBQcmVjYWNoZUNhY2hlS2V5UGx1Z2luIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBUaXRsZVxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBkZWxldGVkVVJMc1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGxvZ0dyb3VwID0gKGdyb3VwVGl0bGUsIGRlbGV0ZWRVUkxzKSA9PiB7XG4gICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGdyb3VwVGl0bGUpO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIGRlbGV0ZWRVUkxzKSB7XG4gICAgICAgIGxvZ2dlci5sb2codXJsKTtcbiAgICB9XG4gICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGRlbGV0ZWRVUkxzXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmludENsZWFudXBEZXRhaWxzKGRlbGV0ZWRVUkxzKSB7XG4gICAgY29uc3QgZGVsZXRpb25Db3VudCA9IGRlbGV0ZWRVUkxzLmxlbmd0aDtcbiAgICBpZiAoZGVsZXRpb25Db3VudCA+IDApIHtcbiAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBEdXJpbmcgcHJlY2FjaGluZyBjbGVhbnVwLCBgICtcbiAgICAgICAgICAgIGAke2RlbGV0aW9uQ291bnR9IGNhY2hlZCBgICtcbiAgICAgICAgICAgIGByZXF1ZXN0JHtkZWxldGlvbkNvdW50ID09PSAxID8gJyB3YXMnIDogJ3Mgd2VyZSd9IGRlbGV0ZWQuYCk7XG4gICAgICAgIGxvZ0dyb3VwKCdEZWxldGVkIENhY2hlIFJlcXVlc3RzJywgZGVsZXRlZFVSTHMpO1xuICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICB9XG59XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBUaXRsZVxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB1cmxzXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX25lc3RlZEdyb3VwKGdyb3VwVGl0bGUsIHVybHMpIHtcbiAgICBpZiAodXJscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoZ3JvdXBUaXRsZSk7XG4gICAgZm9yIChjb25zdCB1cmwgb2YgdXJscykge1xuICAgICAgICBsb2dnZXIubG9nKHVybCk7XG4gICAgfVxuICAgIGxvZ2dlci5ncm91cEVuZCgpO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHVybHNUb1ByZWNhY2hlXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHVybHNBbHJlYWR5UHJlY2FjaGVkXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmludEluc3RhbGxEZXRhaWxzKHVybHNUb1ByZWNhY2hlLCB1cmxzQWxyZWFkeVByZWNhY2hlZCkge1xuICAgIGNvbnN0IHByZWNhY2hlZENvdW50ID0gdXJsc1RvUHJlY2FjaGUubGVuZ3RoO1xuICAgIGNvbnN0IGFscmVhZHlQcmVjYWNoZWRDb3VudCA9IHVybHNBbHJlYWR5UHJlY2FjaGVkLmxlbmd0aDtcbiAgICBpZiAocHJlY2FjaGVkQ291bnQgfHwgYWxyZWFkeVByZWNhY2hlZENvdW50KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gYFByZWNhY2hpbmcgJHtwcmVjYWNoZWRDb3VudH0gZmlsZSR7cHJlY2FjaGVkQ291bnQgPT09IDEgPyAnJyA6ICdzJ30uYDtcbiAgICAgICAgaWYgKGFscmVhZHlQcmVjYWNoZWRDb3VudCA+IDApIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYCAke2FscmVhZHlQcmVjYWNoZWRDb3VudH0gYCArXG4gICAgICAgICAgICAgICAgYGZpbGUke2FscmVhZHlQcmVjYWNoZWRDb3VudCA9PT0gMSA/ICcgaXMnIDogJ3MgYXJlJ30gYWxyZWFkeSBjYWNoZWQuYDtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQobWVzc2FnZSk7XG4gICAgICAgIF9uZXN0ZWRHcm91cChgVmlldyBuZXdseSBwcmVjYWNoZWQgVVJMcy5gLCB1cmxzVG9QcmVjYWNoZSk7XG4gICAgICAgIF9uZXN0ZWRHcm91cChgVmlldyBwcmV2aW91c2x5IHByZWNhY2hlZCBVUkxzLmAsIHVybHNBbHJlYWR5UHJlY2FjaGVkKTtcbiAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgfVxufVxuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG5sZXQgc3VwcG9ydFN0YXR1cztcbi8qKlxuICogQSB1dGlsaXR5IGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHNcbiAqIGNvbnN0cnVjdGluZyBhIG5ldyBgUmVzcG9uc2VgIGZyb20gYSBgcmVzcG9uc2UuYm9keWAgc3RyZWFtLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCwgaWYgdGhlIGN1cnJlbnQgYnJvd3NlciBjYW4gc3VjY2Vzc2Z1bGx5XG4gKiAgICAgY29uc3RydWN0IGEgYFJlc3BvbnNlYCBmcm9tIGEgYHJlc3BvbnNlLmJvZHlgIHN0cmVhbSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2FuQ29uc3RydWN0UmVzcG9uc2VGcm9tQm9keVN0cmVhbSgpIHtcbiAgICBpZiAoc3VwcG9ydFN0YXR1cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRlc3RSZXNwb25zZSA9IG5ldyBSZXNwb25zZSgnJyk7XG4gICAgICAgIGlmICgnYm9keScgaW4gdGVzdFJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ldyBSZXNwb25zZSh0ZXN0UmVzcG9uc2UuYm9keSk7XG4gICAgICAgICAgICAgICAgc3VwcG9ydFN0YXR1cyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzdXBwb3J0U3RhdHVzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwcG9ydFN0YXR1cyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwcG9ydFN0YXR1cztcbn1cbmV4cG9ydCB7IGNhbkNvbnN0cnVjdFJlc3BvbnNlRnJvbUJvZHlTdHJlYW0gfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGNhbkNvbnN0cnVjdFJlc3BvbnNlRnJvbUJvZHlTdHJlYW0gfSBmcm9tICcuL19wcml2YXRlL2NhbkNvbnN0cnVjdFJlc3BvbnNlRnJvbUJvZHlTdHJlYW0uanMnO1xuaW1wb3J0IHsgV29ya2JveEVycm9yIH0gZnJvbSAnLi9fcHJpdmF0ZS9Xb3JrYm94RXJyb3IuanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogQWxsb3dzIGRldmVsb3BlcnMgdG8gY29weSBhIHJlc3BvbnNlIGFuZCBtb2RpZnkgaXRzIGBoZWFkZXJzYCwgYHN0YXR1c2AsXG4gKiBvciBgc3RhdHVzVGV4dGAgdmFsdWVzICh0aGUgdmFsdWVzIHNldHRhYmxlIHZpYSBhXG4gKiBbYFJlc3BvbnNlSW5pdGBde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SZXNwb25zZS9SZXNwb25zZSNTeW50YXh9XG4gKiBvYmplY3QgaW4gdGhlIGNvbnN0cnVjdG9yKS5cbiAqIFRvIG1vZGlmeSB0aGVzZSB2YWx1ZXMsIHBhc3MgYSBmdW5jdGlvbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LiBUaGF0XG4gKiBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgd2l0aCBhIHNpbmdsZSBvYmplY3Qgd2l0aCB0aGUgcmVzcG9uc2UgcHJvcGVydGllc1xuICogYHtoZWFkZXJzLCBzdGF0dXMsIHN0YXR1c1RleHR9YC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIHdpbGxcbiAqIGJlIHVzZWQgYXMgdGhlIGBSZXNwb25zZUluaXRgIGZvciB0aGUgbmV3IGBSZXNwb25zZWAuIFRvIGNoYW5nZSB0aGUgdmFsdWVzXG4gKiBlaXRoZXIgbW9kaWZ5IHRoZSBwYXNzZWQgcGFyYW1ldGVyKHMpIGFuZCByZXR1cm4gaXQsIG9yIHJldHVybiBhIHRvdGFsbHlcbiAqIG5ldyBvYmplY3QuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgaW50ZW50aW9uYWxseSBsaW1pdGVkIHRvIHNhbWUtb3JpZ2luIHJlc3BvbnNlcywgcmVnYXJkbGVzcyBvZlxuICogd2hldGhlciBDT1JTIHdhcyB1c2VkIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNwb25zZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXJcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1jb3JlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvcHlSZXNwb25zZShyZXNwb25zZSwgbW9kaWZpZXIpIHtcbiAgICBsZXQgb3JpZ2luID0gbnVsbDtcbiAgICAvLyBJZiByZXNwb25zZS51cmwgaXNuJ3Qgc2V0LCBhc3N1bWUgaXQncyBjcm9zcy1vcmlnaW4gYW5kIGtlZXAgb3JpZ2luIG51bGwuXG4gICAgaWYgKHJlc3BvbnNlLnVybCkge1xuICAgICAgICBjb25zdCByZXNwb25zZVVSTCA9IG5ldyBVUkwocmVzcG9uc2UudXJsKTtcbiAgICAgICAgb3JpZ2luID0gcmVzcG9uc2VVUkwub3JpZ2luO1xuICAgIH1cbiAgICBpZiAob3JpZ2luICE9PSBzZWxmLmxvY2F0aW9uLm9yaWdpbikge1xuICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdjcm9zcy1vcmlnaW4tY29weS1yZXNwb25zZScsIHsgb3JpZ2luIH0pO1xuICAgIH1cbiAgICBjb25zdCBjbG9uZWRSZXNwb25zZSA9IHJlc3BvbnNlLmNsb25lKCk7XG4gICAgLy8gQ3JlYXRlIGEgZnJlc2ggYFJlc3BvbnNlSW5pdGAgb2JqZWN0IGJ5IGNsb25pbmcgdGhlIGhlYWRlcnMuXG4gICAgY29uc3QgcmVzcG9uc2VJbml0ID0ge1xuICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhjbG9uZWRSZXNwb25zZS5oZWFkZXJzKSxcbiAgICAgICAgc3RhdHVzOiBjbG9uZWRSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IGNsb25lZFJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgfTtcbiAgICAvLyBBcHBseSBhbnkgdXNlciBtb2RpZmljYXRpb25zLlxuICAgIGNvbnN0IG1vZGlmaWVkUmVzcG9uc2VJbml0ID0gbW9kaWZpZXIgPyBtb2RpZmllcihyZXNwb25zZUluaXQpIDogcmVzcG9uc2VJbml0O1xuICAgIC8vIENyZWF0ZSB0aGUgbmV3IHJlc3BvbnNlIGZyb20gdGhlIGJvZHkgc3RyZWFtIGFuZCBgUmVzcG9uc2VJbml0YFxuICAgIC8vIG1vZGlmaWNhdGlvbnMuIE5vdGU6IG5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB0aGUgUmVzcG9uc2UuYm9keSBzdHJlYW0sXG4gICAgLy8gc28gZmFsbCBiYWNrIHRvIHJlYWRpbmcgdGhlIGVudGlyZSBib2R5IGludG8gbWVtb3J5IGFzIGEgYmxvYi5cbiAgICBjb25zdCBib2R5ID0gY2FuQ29uc3RydWN0UmVzcG9uc2VGcm9tQm9keVN0cmVhbSgpID9cbiAgICAgICAgY2xvbmVkUmVzcG9uc2UuYm9keSA6IGF3YWl0IGNsb25lZFJlc3BvbnNlLmJsb2IoKTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHksIG1vZGlmaWVkUmVzcG9uc2VJbml0KTtcbn1cbmV4cG9ydCB7IGNvcHlSZXNwb25zZSB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG5jb25zdCBnZXRGcmllbmRseVVSTCA9ICh1cmwpID0+IHtcbiAgICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKFN0cmluZyh1cmwpLCBsb2NhdGlvbi5ocmVmKTtcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8yMzIzXG4gICAgLy8gV2Ugd2FudCB0byBpbmNsdWRlIGV2ZXJ5dGhpbmcsIGV4Y2VwdCBmb3IgdGhlIG9yaWdpbiBpZiBpdCdzIHNhbWUtb3JpZ2luLlxuICAgIHJldHVybiB1cmxPYmouaHJlZi5yZXBsYWNlKG5ldyBSZWdFeHAoYF4ke2xvY2F0aW9uLm9yaWdpbn1gKSwgJycpO1xufTtcbmV4cG9ydCB7IGdldEZyaWVuZGx5VVJMIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG5mdW5jdGlvbiBzdHJpcFBhcmFtcyhmdWxsVVJMLCBpZ25vcmVQYXJhbXMpIHtcbiAgICBjb25zdCBzdHJpcHBlZFVSTCA9IG5ldyBVUkwoZnVsbFVSTCk7XG4gICAgZm9yIChjb25zdCBwYXJhbSBvZiBpZ25vcmVQYXJhbXMpIHtcbiAgICAgICAgc3RyaXBwZWRVUkwuc2VhcmNoUGFyYW1zLmRlbGV0ZShwYXJhbSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpcHBlZFVSTC5ocmVmO1xufVxuLyoqXG4gKiBNYXRjaGVzIGFuIGl0ZW0gaW4gdGhlIGNhY2hlLCBpZ25vcmluZyBzcGVjaWZpYyBVUkwgcGFyYW1zLiBUaGlzIGlzIHNpbWlsYXJcbiAqIHRvIHRoZSBgaWdub3JlU2VhcmNoYCBvcHRpb24sIGJ1dCBpdCBhbGxvd3MgeW91IHRvIGlnbm9yZSBqdXN0IHNwZWNpZmljXG4gKiBwYXJhbXMgKHdoaWxlIGNvbnRpbnVpbmcgdG8gbWF0Y2ggb24gdGhlIG90aGVycykuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Q2FjaGV9IGNhY2hlXG4gKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRjaE9wdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gaWdub3JlUGFyYW1zXG4gKiBAcmV0dXJuIHtQcm9taXNlPFJlc3BvbnNlfHVuZGVmaW5lZD59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNhY2hlTWF0Y2hJZ25vcmVQYXJhbXMoY2FjaGUsIHJlcXVlc3QsIGlnbm9yZVBhcmFtcywgbWF0Y2hPcHRpb25zKSB7XG4gICAgY29uc3Qgc3RyaXBwZWRSZXF1ZXN0VVJMID0gc3RyaXBQYXJhbXMocmVxdWVzdC51cmwsIGlnbm9yZVBhcmFtcyk7XG4gICAgLy8gSWYgdGhlIHJlcXVlc3QgZG9lc24ndCBpbmNsdWRlIGFueSBpZ25vcmVkIHBhcmFtcywgbWF0Y2ggYXMgbm9ybWFsLlxuICAgIGlmIChyZXF1ZXN0LnVybCA9PT0gc3RyaXBwZWRSZXF1ZXN0VVJMKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5tYXRjaChyZXF1ZXN0LCBtYXRjaE9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIG1hdGNoIGJ5IGNvbXBhcmluZyBrZXlzXG4gICAgY29uc3Qga2V5c09wdGlvbnMgPSB7IC4uLm1hdGNoT3B0aW9ucywgaWdub3JlU2VhcmNoOiB0cnVlIH07XG4gICAgY29uc3QgY2FjaGVLZXlzID0gYXdhaXQgY2FjaGUua2V5cyhyZXF1ZXN0LCBrZXlzT3B0aW9ucyk7XG4gICAgZm9yIChjb25zdCBjYWNoZUtleSBvZiBjYWNoZUtleXMpIHtcbiAgICAgICAgY29uc3Qgc3RyaXBwZWRDYWNoZUtleVVSTCA9IHN0cmlwUGFyYW1zKGNhY2hlS2V5LnVybCwgaWdub3JlUGFyYW1zKTtcbiAgICAgICAgaWYgKHN0cmlwcGVkUmVxdWVzdFVSTCA9PT0gc3RyaXBwZWRDYWNoZUtleVVSTCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlLm1hdGNoKGNhY2hlS2V5LCBtYXRjaE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbn1cbmV4cG9ydCB7IGNhY2hlTWF0Y2hJZ25vcmVQYXJhbXMgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBUaGUgRGVmZXJyZWQgY2xhc3MgY29tcG9zZXMgUHJvbWlzZXMgaW4gYSB3YXkgdGhhdCBhbGxvd3MgZm9yIHRoZW0gdG8gYmVcbiAqIHJlc29sdmVkIG9yIHJlamVjdGVkIGZyb20gb3V0c2lkZSB0aGUgY29uc3RydWN0b3IuIEluIG1vc3QgY2FzZXMgcHJvbWlzZXNcbiAqIHNob3VsZCBiZSB1c2VkIGRpcmVjdGx5LCBidXQgRGVmZXJyZWRzIGNhbiBiZSBuZWNlc3Nhcnkgd2hlbiB0aGUgbG9naWMgdG9cbiAqIHJlc29sdmUgYSBwcm9taXNlIG11c3QgYmUgc2VwYXJhdGUuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgRGVmZXJyZWQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwcm9taXNlIGFuZCBleHBvc2VzIGl0cyByZXNvbHZlIGFuZCByZWplY3QgZnVuY3Rpb25zIGFzIG1ldGhvZHMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IHsgRGVmZXJyZWQgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLy8gQ2FsbGJhY2tzIHRvIGJlIGV4ZWN1dGVkIHdoZW5ldmVyIHRoZXJlJ3MgYSBxdW90YSBlcnJvci5cbmNvbnN0IHF1b3RhRXJyb3JDYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5leHBvcnQgeyBxdW90YUVycm9yQ2FsbGJhY2tzIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi9fcHJpdmF0ZS9sb2dnZXIuanMnO1xuaW1wb3J0IHsgcXVvdGFFcnJvckNhbGxiYWNrcyB9IGZyb20gJy4uL21vZGVscy9xdW90YUVycm9yQ2FsbGJhY2tzLmpzJztcbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBSdW5zIGFsbCBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zLCBvbmUgYXQgYSB0aW1lIHNlcXVlbnRpYWxseSwgaW4gdGhlIG9yZGVyXG4gKiBpbiB3aGljaCB0aGV5IHdlcmUgcmVnaXN0ZXJlZC5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtY29yZVxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZVF1b3RhRXJyb3JDYWxsYmFja3MoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgQWJvdXQgdG8gcnVuICR7cXVvdGFFcnJvckNhbGxiYWNrcy5zaXplfSBgICtcbiAgICAgICAgICAgIGBjYWxsYmFja3MgdG8gY2xlYW4gdXAgY2FjaGVzLmApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHF1b3RhRXJyb3JDYWxsYmFja3MpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2soKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coY2FsbGJhY2ssICdpcyBjb21wbGV0ZS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBsb2dnZXIubG9nKCdGaW5pc2hlZCBydW5uaW5nIGNhbGxiYWNrcy4nKTtcbiAgICB9XG59XG5leHBvcnQgeyBleGVjdXRlUXVvdGFFcnJvckNhbGxiYWNrcyB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFuZCB0aGUgcGFzc2VkIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gKiBUaGlzIHV0aWxpdHkgaXMgYW4gYXN5bmMvYXdhaXQtZnJpZW5kbHkgdmVyc2lvbiBvZiBgc2V0VGltZW91dGAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVvdXQobXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gQHRzLWlnbm9yZVxudHJ5IHtcbiAgICBzZWxmWyd3b3JrYm94OnN0cmF0ZWdpZXM6Ni4wLjInXSAmJiBfKCk7XG59XG5jYXRjaCAoZSkgeyB9XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzJztcbmltcG9ydCB7IGNhY2hlTWF0Y2hJZ25vcmVQYXJhbXMgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvY2FjaGVNYXRjaElnbm9yZVBhcmFtcy5qcyc7XG5pbXBvcnQgeyBEZWZlcnJlZCB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9EZWZlcnJlZC5qcyc7XG5pbXBvcnQgeyBleGVjdXRlUXVvdGFFcnJvckNhbGxiYWNrcyB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9leGVjdXRlUXVvdGFFcnJvckNhbGxiYWNrcy5qcyc7XG5pbXBvcnQgeyBnZXRGcmllbmRseVVSTCB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9nZXRGcmllbmRseVVSTC5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IHRpbWVvdXQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvdGltZW91dC5qcyc7XG5pbXBvcnQgeyBXb3JrYm94RXJyb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG5mdW5jdGlvbiB0b1JlcXVlc3QoaW5wdXQpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpID8gbmV3IFJlcXVlc3QoaW5wdXQpIDogaW5wdXQ7XG59XG4vKipcbiAqIEEgY2xhc3MgY3JlYXRlZCBldmVyeSB0aW1lIGEgU3RyYXRlZ3kgaW5zdGFuY2UgaW5zdGFuY2UgY2FsbHNcbiAqIFtoYW5kbGUoKV17QGxpbmsgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneX5oYW5kbGV9IG9yXG4gKiBbaGFuZGxlQWxsKClde0BsaW5rIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3l+aGFuZGxlQWxsfSB0aGF0IHdyYXBzIGFsbCBmZXRjaCBhbmRcbiAqIGNhY2hlIGFjdGlvbnMgYXJvdW5kIHBsdWdpbiBjYWxsYmFja3MgYW5kIGtlZXBzIHRyYWNrIG9mIHdoZW4gdGhlIHN0cmF0ZWd5XG4gKiBpcyBcImRvbmVcIiAoaS5lLiBhbGwgYWRkZWQgYGV2ZW50LndhaXRVbnRpbCgpYCBwcm9taXNlcyBoYXZlIHJlc29sdmVkKS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llc1xuICovXG5jbGFzcyBTdHJhdGVneUhhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBwYXNzZWQgc3RyYXRlZ3kgYW5kIGV2ZW50XG4gICAgICogdGhhdCdzIGhhbmRsaW5nIHRoZSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIGFsc28gaW5pdGlhbGl6ZXMgdGhlIHN0YXRlIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gZWFjaCBvZlxuICAgICAqIHRoZSBwbHVnaW5zIGhhbmRsaW5nIHRoaXMgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneX0gc3RyYXRlZ3lcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7UmVxdWVzdHxzdHJpbmd9IG9wdGlvbnMucmVxdWVzdCBBIHJlcXVlc3QgdG8gcnVuIHRoaXMgc3RyYXRlZ3kgZm9yLlxuICAgICAqIEBwYXJhbSB7RXh0ZW5kYWJsZUV2ZW50fSBvcHRpb25zLmV2ZW50IFRoZSBldmVudCBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgICogICAgIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHtVUkx9IFtvcHRpb25zLnVybF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLnBhcmFtc11cbiAgICAgKiAgICAgW21hdGNoIGNhbGxiYWNrXXtAbGluayBtb2R1bGU6d29ya2JveC1yb3V0aW5nfm1hdGNoQ2FsbGJhY2t9LFxuICAgICAqICAgICAoaWYgYXBwbGljYWJsZSkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RyYXRlZ3ksIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVLZXlzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVxdWVzdCB0aGUgc3RyYXRlZ3kgaXMgcGVyZm9ybWluZyAocGFzc2VkIHRvIHRoZSBzdHJhdGVneSdzXG4gICAgICAgICAqIGBoYW5kbGUoKWAgb3IgYGhhbmRsZUFsbCgpYCBtZXRob2QpLlxuICAgICAgICAgKiBAbmFtZSByZXF1ZXN0XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7UmVxdWVzdH1cbiAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3lIYW5kbGVyXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGV2ZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJlcXVlc3QuXG4gICAgICAgICAqIEBuYW1lIGV2ZW50XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7RXh0ZW5kYWJsZUV2ZW50fVxuICAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneUhhbmRsZXJcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGBVUkxgIGluc3RhbmNlIG9mIGByZXF1ZXN0LnVybGAgKGlmIHBhc3NlZCB0byB0aGUgc3RyYXRlZ3knc1xuICAgICAgICAgKiBgaGFuZGxlKClgIG9yIGBoYW5kbGVBbGwoKWAgbWV0aG9kKS5cbiAgICAgICAgICogTm90ZTogdGhlIGB1cmxgIHBhcmFtIHdpbGwgYmUgcHJlc2VudCBpZiB0aGUgc3RyYXRlZ3kgd2FzIGludm9rZWRcbiAgICAgICAgICogZnJvbSBhIHdvcmtib3ggYFJvdXRlYCBvYmplY3QuXG4gICAgICAgICAqIEBuYW1lIHVybFxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUge1VSTHx1bmRlZmluZWR9XG4gICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5SGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYHBhcmFtYCB2YWx1ZSAoaWYgcGFzc2VkIHRvIHRoZSBzdHJhdGVneSdzXG4gICAgICAgICAqIGBoYW5kbGUoKWAgb3IgYGhhbmRsZUFsbCgpYCBtZXRob2QpLlxuICAgICAgICAgKiBOb3RlOiB0aGUgYHBhcmFtYCBwYXJhbSB3aWxsIGJlIHByZXNlbnQgaWYgdGhlIHN0cmF0ZWd5IHdhcyBpbnZva2VkXG4gICAgICAgICAqIGZyb20gYSB3b3JrYm94IGBSb3V0ZWAgb2JqZWN0IGFuZCB0aGVcbiAgICAgICAgICogW21hdGNoIGNhbGxiYWNrXXtAbGluayBtb2R1bGU6d29ya2JveC1yb3V0aW5nfm1hdGNoQ2FsbGJhY2t9IHJldHVybmVkXG4gICAgICAgICAqIGEgdHJ1dGh5IHZhbHVlIChpdCB3aWxsIGJlIHRoYXQgdmFsdWUpLlxuICAgICAgICAgKiBAbmFtZSBwYXJhbXNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHsqfHVuZGVmaW5lZH1cbiAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3lIYW5kbGVyXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgYXNzZXJ0LmlzSW5zdGFuY2Uob3B0aW9ucy5ldmVudCwgRXh0ZW5kYWJsZUV2ZW50LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtc3RyYXRlZ2llcycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnU3RyYXRlZ3lIYW5kbGVyJyxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdvcHRpb25zLmV2ZW50JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZXZlbnQgPSBvcHRpb25zLmV2ZW50O1xuICAgICAgICB0aGlzLl9zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICB0aGlzLl9oYW5kbGVyRGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5fZXh0ZW5kTGlmZXRpbWVQcm9taXNlcyA9IFtdO1xuICAgICAgICAvLyBDb3B5IHRoZSBwbHVnaW5zIGxpc3QgKHNpbmNlIGl0J3MgbXV0YWJsZSBvbiB0aGUgc3RyYXRlZ3kpLFxuICAgICAgICAvLyBzbyBhbnkgbXV0YXRpb25zIGRvbid0IGFmZmVjdCB0aGlzIGhhbmRsZXIgaW5zdGFuY2UuXG4gICAgICAgIHRoaXMuX3BsdWdpbnMgPSBbLi4uc3RyYXRlZ3kucGx1Z2luc107XG4gICAgICAgIHRoaXMuX3BsdWdpblN0YXRlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLl9wbHVnaW5zKSB7XG4gICAgICAgICAgICB0aGlzLl9wbHVnaW5TdGF0ZU1hcC5zZXQocGx1Z2luLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudC53YWl0VW50aWwodGhpcy5faGFuZGxlckRlZmVycmVkLnByb21pc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgZ2l2ZW4gcmVxdWVzdCAoYW5kIGludm9rZXMgYW55IGFwcGxpY2FibGUgcGx1Z2luIGNhbGxiYWNrXG4gICAgICogbWV0aG9kcykgdXNpbmcgdGhlIGBmZXRjaE9wdGlvbnNgIGFuZCBgcGx1Z2luc2AgZGVmaW5lZCBvbiB0aGUgc3RyYXRlZ3lcbiAgICAgKiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIHBsdWdpbiBsaWZlY3ljbGUgbWV0aG9kcyBhcmUgaW52b2tlZCB3aGVuIHVzaW5nIHRoaXMgbWV0aG9kOlxuICAgICAqIC0gYHJlcXVlc3RXaWxsRmV0Y2goKWBcbiAgICAgKiAtIGBmZXRjaERpZFN1Y2NlZWQoKWBcbiAgICAgKiAtIGBmZXRjaERpZEZhaWwoKWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVxdWVzdHxzdHJpbmd9IGlucHV0IFRoZSBVUkwgb3IgcmVxdWVzdCB0byBmZXRjaC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJlc3BvbnNlPn1cbiAgICAgKi9cbiAgICBmZXRjaChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy53YWl0VW50aWwoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZXZlbnQgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdCA9IHRvUmVxdWVzdChpbnB1dCk7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5tb2RlID09PSAnbmF2aWdhdGUnICYmXG4gICAgICAgICAgICAgICAgZXZlbnQgaW5zdGFuY2VvZiBGZXRjaEV2ZW50ICYmXG4gICAgICAgICAgICAgICAgZXZlbnQucHJlbG9hZFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zc2libGVQcmVsb2FkUmVzcG9uc2UgPSBhd2FpdCBldmVudC5wcmVsb2FkUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlUHJlbG9hZFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBVc2luZyBhIHByZWxvYWRlZCBuYXZpZ2F0aW9uIHJlc3BvbnNlIGZvciBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJyR7Z2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpfSdgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zc2libGVQcmVsb2FkUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBmZXRjaERpZEZhaWwgcGx1Z2luLCB3ZSBuZWVkIHRvIHNhdmUgYSBjbG9uZSBvZiB0aGVcbiAgICAgICAgICAgIC8vIG9yaWdpbmFsIHJlcXVlc3QgYmVmb3JlIGl0J3MgZWl0aGVyIG1vZGlmaWVkIGJ5IGEgcmVxdWVzdFdpbGxGZXRjaFxuICAgICAgICAgICAgLy8gcGx1Z2luIG9yIGJlZm9yZSB0aGUgb3JpZ2luYWwgcmVxdWVzdCdzIGJvZHkgaXMgY29uc3VtZWQgdmlhIGZldGNoKCkuXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFJlcXVlc3QgPSB0aGlzLmhhc0NhbGxiYWNrKCdmZXRjaERpZEZhaWwnKSA/XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jbG9uZSgpIDogbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYiBvZiB0aGlzLml0ZXJhdGVDYWxsYmFja3MoJ3JlcXVlc3RXaWxsRmV0Y2gnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ID0gYXdhaXQgY2IoeyByZXF1ZXN0OiByZXF1ZXN0LmNsb25lKCksIGV2ZW50IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdwbHVnaW4tZXJyb3ItcmVxdWVzdC13aWxsLWZldGNoJywge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd25FcnJvcjogZXJyLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3QgY2FuIGJlIGFsdGVyZWQgYnkgcGx1Z2lucyB3aXRoIGByZXF1ZXN0V2lsbEZldGNoYCBtYWtpbmdcbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCByZXF1ZXN0IChtb3N0IGxpa2VseSBmcm9tIGEgYGZldGNoYCBldmVudCkgZGlmZmVyZW50XG4gICAgICAgICAgICAvLyBmcm9tIHRoZSBSZXF1ZXN0IHdlIG1ha2UuIFBhc3MgYm90aCB0byBgZmV0Y2hEaWRGYWlsYCB0byBhaWQgZGVidWdnaW5nLlxuICAgICAgICAgICAgY29uc3QgcGx1Z2luRmlsdGVyZWRSZXF1ZXN0ID0gcmVxdWVzdC5jbG9uZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgZmV0Y2hSZXNwb25zZTtcbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8xNzk2XG4gICAgICAgICAgICAgICAgZmV0Y2hSZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QsIHJlcXVlc3QubW9kZSA9PT0gJ25hdmlnYXRlJyA/XG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6IHRoaXMuX3N0cmF0ZWd5LmZldGNoT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBOZXR3b3JrIHJlcXVlc3QgZm9yIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCcke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0nIHJldHVybmVkIGEgcmVzcG9uc2Ugd2l0aCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBzdGF0dXMgJyR7ZmV0Y2hSZXNwb25zZS5zdGF0dXN9Jy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiB0aGlzLml0ZXJhdGVDYWxsYmFja3MoJ2ZldGNoRGlkU3VjY2VlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHBsdWdpbkZpbHRlcmVkUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBmZXRjaFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoUmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5ldHdvcmsgcmVxdWVzdCBmb3IgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgJyR7Z2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpfScgdGhyZXcgYW4gZXJyb3IuYCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBgb3JpZ2luYWxSZXF1ZXN0YCB3aWxsIG9ubHkgZXhpc3QgaWYgYSBgZmV0Y2hEaWRGYWlsYCBjYWxsYmFja1xuICAgICAgICAgICAgICAgIC8vIGlzIGJlaW5nIHVzZWQgKHNlZSBhYm92ZSkuXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJ1bkNhbGxiYWNrcygnZmV0Y2hEaWRGYWlsJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsUmVxdWVzdDogb3JpZ2luYWxSZXF1ZXN0LmNsb25lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBwbHVnaW5GaWx0ZXJlZFJlcXVlc3QuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgYHRoaXMuZmV0Y2goKWAgYW5kIChpbiB0aGUgYmFja2dyb3VuZCkgcnVucyBgdGhpcy5jYWNoZVB1dCgpYCBvblxuICAgICAqIHRoZSByZXNwb25zZSBnZW5lcmF0ZWQgYnkgYHRoaXMuZmV0Y2goKWAuXG4gICAgICpcbiAgICAgKiBUaGUgY2FsbCB0byBgdGhpcy5jYWNoZVB1dCgpYCBhdXRvbWF0aWNhbGx5IGludm9rZXMgYHRoaXMud2FpdFVudGlsKClgLFxuICAgICAqIHNvIHlvdSBkbyBub3QgaGF2ZSB0byBtYW51YWxseSBjYWxsIGB3YWl0VW50aWwoKWAgb24gdGhlIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fHN0cmluZ30gaW5wdXQgVGhlIHJlcXVlc3Qgb3IgVVJMIHRvIGZldGNoIGFuZCBjYWNoZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJlc3BvbnNlPn1cbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaEFuZENhY2hlUHV0KGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaChpbnB1dCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlQ2xvbmUgPSByZXNwb25zZS5jbG9uZSgpO1xuICAgICAgICB0aGlzLndhaXRVbnRpbCh0aGlzLmNhY2hlUHV0KGlucHV0LCByZXNwb25zZUNsb25lKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyBhIHJlcXVlc3QgZnJvbSB0aGUgY2FjaGUgKGFuZCBpbnZva2VzIGFueSBhcHBsaWNhYmxlIHBsdWdpblxuICAgICAqIGNhbGxiYWNrIG1ldGhvZHMpIHVzaW5nIHRoZSBgY2FjaGVOYW1lYCwgYG1hdGNoT3B0aW9uc2AsIGFuZCBgcGx1Z2luc2BcbiAgICAgKiBkZWZpbmVkIG9uIHRoZSBzdHJhdGVneSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIHBsdWdpbiBsaWZlY3ljbGUgbWV0aG9kcyBhcmUgaW52b2tlZCB3aGVuIHVzaW5nIHRoaXMgbWV0aG9kOlxuICAgICAqIC0gY2FjaGVLZXlXaWxsQnlVc2VkKClcbiAgICAgKiAtIGNhY2hlZFJlc3BvbnNlV2lsbEJ5VXNlZCgpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R8c3RyaW5nfSBrZXkgVGhlIFJlcXVlc3Qgb3IgVVJMIHRvIHVzZSBhcyB0aGUgY2FjaGUga2V5LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8UmVzcG9uc2V8dW5kZWZpbmVkPn0gQSBtYXRjaGluZyByZXNwb25zZSwgaWYgZm91bmQuXG4gICAgICovXG4gICAgY2FjaGVNYXRjaChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2FpdFVudGlsKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdG9SZXF1ZXN0KGtleSk7XG4gICAgICAgICAgICBsZXQgY2FjaGVkUmVzcG9uc2U7XG4gICAgICAgICAgICBjb25zdCB7IGNhY2hlTmFtZSwgbWF0Y2hPcHRpb25zIH0gPSB0aGlzLl9zdHJhdGVneTtcbiAgICAgICAgICAgIGNvbnN0IGVmZmVjdGl2ZVJlcXVlc3QgPSBhd2FpdCB0aGlzLmdldENhY2hlS2V5KHJlcXVlc3QsICdyZWFkJyk7XG4gICAgICAgICAgICBjb25zdCBtdWx0aU1hdGNoT3B0aW9ucyA9IHsgLi4ubWF0Y2hPcHRpb25zLCAuLi57IGNhY2hlTmFtZSB9IH07XG4gICAgICAgICAgICBjYWNoZWRSZXNwb25zZSA9IGF3YWl0IGNhY2hlcy5tYXRjaChlZmZlY3RpdmVSZXF1ZXN0LCBtdWx0aU1hdGNoT3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYEZvdW5kIGEgY2FjaGVkIHJlc3BvbnNlIGluICcke2NhY2hlTmFtZX0nLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBObyBjYWNoZWQgcmVzcG9uc2UgZm91bmQgaW4gJyR7Y2FjaGVOYW1lfScuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiB0aGlzLml0ZXJhdGVDYWxsYmFja3MoJ2NhY2hlZFJlc3BvbnNlV2lsbEJlVXNlZCcpKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkUmVzcG9uc2UgPSAoYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICBjYWNoZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGVmZmVjdGl2ZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgICAgICAgICAgIH0pKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzcG9uc2U7XG4gICAgICAgIH0pKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXRzIGEgcmVxdWVzdC9yZXNwb25zZSBwYWlyIGluIHRoZSBjYWNoZSAoYW5kIGludm9rZXMgYW55IGFwcGxpY2FibGVcbiAgICAgKiBwbHVnaW4gY2FsbGJhY2sgbWV0aG9kcykgdXNpbmcgdGhlIGBjYWNoZU5hbWVgIGFuZCBgcGx1Z2luc2AgZGVmaW5lZCBvblxuICAgICAqIHRoZSBzdHJhdGVneSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIHBsdWdpbiBsaWZlY3ljbGUgbWV0aG9kcyBhcmUgaW52b2tlZCB3aGVuIHVzaW5nIHRoaXMgbWV0aG9kOlxuICAgICAqIC0gY2FjaGVLZXlXaWxsQnlVc2VkKClcbiAgICAgKiAtIGNhY2hlV2lsbFVwZGF0ZSgpXG4gICAgICogLSBjYWNoZURpZFVwZGF0ZSgpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R8c3RyaW5nfSBrZXkgVGhlIHJlcXVlc3Qgb3IgVVJMIHRvIHVzZSBhcyB0aGUgY2FjaGUga2V5LlxuICAgICAqIEBwYXJhbSB7UHJvbWlzZTx2b2lkPn0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGFzeW5jIGNhY2hlUHV0KGtleSwgcmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRvUmVxdWVzdChrZXkpO1xuICAgICAgICAvLyBSdW4gaW4gdGhlIG5leHQgdGFzayB0byBhdm9pZCBibG9ja2luZyBvdGhlciBjYWNoZSByZWFkcy5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3czYy9TZXJ2aWNlV29ya2VyL2lzc3Vlcy8xMzk3XG4gICAgICAgIGF3YWl0IHRpbWVvdXQoMCk7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZVJlcXVlc3QgPSBhd2FpdCB0aGlzLmdldENhY2hlS2V5KHJlcXVlc3QsICd3cml0ZScpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdGl2ZVJlcXVlc3QubWV0aG9kICYmIGVmZmVjdGl2ZVJlcXVlc3QubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2F0dGVtcHQtdG8tY2FjaGUtbm9uLWdldC1yZXF1ZXN0Jywge1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGdldEZyaWVuZGx5VVJMKGVmZmVjdGl2ZVJlcXVlc3QudXJsKSxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBlZmZlY3RpdmVSZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgQ2Fubm90IGNhY2hlIG5vbi1leGlzdGVudCByZXNwb25zZSBmb3IgYCArXG4gICAgICAgICAgICAgICAgICAgIGAnJHtnZXRGcmllbmRseVVSTChlZmZlY3RpdmVSZXF1ZXN0LnVybCl9Jy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2NhY2hlLXB1dC13aXRoLW5vLXJlc3BvbnNlJywge1xuICAgICAgICAgICAgICAgIHVybDogZ2V0RnJpZW5kbHlVUkwoZWZmZWN0aXZlUmVxdWVzdC51cmwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2VUb0NhY2hlID0gYXdhaXQgdGhpcy5fZW5zdXJlUmVzcG9uc2VTYWZlVG9DYWNoZShyZXNwb25zZSk7XG4gICAgICAgIGlmICghcmVzcG9uc2VUb0NhY2hlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgUmVzcG9uc2UgJyR7Z2V0RnJpZW5kbHlVUkwoZWZmZWN0aXZlUmVxdWVzdC51cmwpfScgYCArXG4gICAgICAgICAgICAgICAgICAgIGB3aWxsIG5vdCBiZSBjYWNoZWQuYCwgcmVzcG9uc2VUb0NhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNhY2hlTmFtZSwgbWF0Y2hPcHRpb25zIH0gPSB0aGlzLl9zdHJhdGVneTtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBzZWxmLmNhY2hlcy5vcGVuKGNhY2hlTmFtZSk7XG4gICAgICAgIGNvbnN0IGhhc0NhY2hlVXBkYXRlQ2FsbGJhY2sgPSB0aGlzLmhhc0NhbGxiYWNrKCdjYWNoZURpZFVwZGF0ZScpO1xuICAgICAgICBjb25zdCBvbGRSZXNwb25zZSA9IGhhc0NhY2hlVXBkYXRlQ2FsbGJhY2sgPyBhd2FpdCBjYWNoZU1hdGNoSWdub3JlUGFyYW1zKFxuICAgICAgICAvLyBUT0RPKHBoaWxpcHdhbHRvbik6IHRoZSBgX19XQl9SRVZJU0lPTl9fYCBwYXJhbSBpcyBhIHByZWNhY2hpbmdcbiAgICAgICAgLy8gZmVhdHVyZS4gQ29uc2lkZXIgaW50byB3YXlzIHRvIG9ubHkgYWRkIHRoaXMgYmVoYXZpb3IgaWYgdXNpbmdcbiAgICAgICAgLy8gcHJlY2FjaGluZy5cbiAgICAgICAgY2FjaGUsIGVmZmVjdGl2ZVJlcXVlc3QuY2xvbmUoKSwgWydfX1dCX1JFVklTSU9OX18nXSwgbWF0Y2hPcHRpb25zKSA6XG4gICAgICAgICAgICBudWxsO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBVcGRhdGluZyB0aGUgJyR7Y2FjaGVOYW1lfScgY2FjaGUgd2l0aCBhIG5ldyBSZXNwb25zZSBgICtcbiAgICAgICAgICAgICAgICBgZm9yICR7Z2V0RnJpZW5kbHlVUkwoZWZmZWN0aXZlUmVxdWVzdC51cmwpfS5gKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgY2FjaGUucHV0KGVmZmVjdGl2ZVJlcXVlc3QsIGhhc0NhY2hlVXBkYXRlQ2FsbGJhY2sgP1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlVG9DYWNoZS5jbG9uZSgpIDogcmVzcG9uc2VUb0NhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRE9NRXhjZXB0aW9uI2V4Y2VwdGlvbi1RdW90YUV4Y2VlZGVkRXJyb3JcbiAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnUXVvdGFFeGNlZWRlZEVycm9yJykge1xuICAgICAgICAgICAgICAgIGF3YWl0IGV4ZWN1dGVRdW90YUVycm9yQ2FsbGJhY2tzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuaXRlcmF0ZUNhbGxiYWNrcygnY2FjaGVEaWRVcGRhdGUnKSkge1xuICAgICAgICAgICAgYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIGNhY2hlTmFtZSxcbiAgICAgICAgICAgICAgICBvbGRSZXNwb25zZSxcbiAgICAgICAgICAgICAgICBuZXdSZXNwb25zZTogcmVzcG9uc2VUb0NhY2hlLmNsb25lKCksXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogZWZmZWN0aXZlUmVxdWVzdCxcbiAgICAgICAgICAgICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgbGlzdCBvZiBwbHVnaW5zIGZvciB0aGUgYGNhY2hlS2V5V2lsbEJlVXNlZGAgY2FsbGJhY2ssIGFuZFxuICAgICAqIGV4ZWN1dGVzIGFueSBvZiB0aG9zZSBjYWxsYmFja3MgZm91bmQgaW4gc2VxdWVuY2UuIFRoZSBmaW5hbCBgUmVxdWVzdGBcbiAgICAgKiBvYmplY3QgcmV0dXJuZWQgYnkgdGhlIGxhc3QgcGx1Z2luIGlzIHRyZWF0ZWQgYXMgdGhlIGNhY2hlIGtleSBmb3IgY2FjaGVcbiAgICAgKiByZWFkcyBhbmQvb3Igd3JpdGVzLiBJZiBubyBgY2FjaGVLZXlXaWxsQmVVc2VkYCBwbHVnaW4gY2FsbGJhY2tzIGhhdmVcbiAgICAgKiBiZWVuIHJlZ2lzdGVyZWQsIHRoZSBwYXNzZWQgcmVxdWVzdCBpcyByZXR1cm5lZCB1bm1vZGlmaWVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8UmVxdWVzdD59XG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q2FjaGVLZXkocmVxdWVzdCwgbW9kZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlS2V5c1ttb2RlXSkge1xuICAgICAgICAgICAgbGV0IGVmZmVjdGl2ZVJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiB0aGlzLml0ZXJhdGVDYWxsYmFja3MoJ2NhY2hlS2V5V2lsbEJlVXNlZCcpKSB7XG4gICAgICAgICAgICAgICAgZWZmZWN0aXZlUmVxdWVzdCA9IHRvUmVxdWVzdChhd2FpdCBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGVmZmVjdGl2ZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHRoaXMucGFyYW1zLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NhY2hlS2V5c1ttb2RlXSA9IGVmZmVjdGl2ZVJlcXVlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlS2V5c1ttb2RlXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzdHJhdGVneSBoYXMgYXQgbGVhc3Qgb25lIHBsdWdpbiB3aXRoIHRoZSBnaXZlblxuICAgICAqIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNhbGxiYWNrIHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0NhbGxiYWNrKG5hbWUpIHtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5fc3RyYXRlZ3kucGx1Z2lucykge1xuICAgICAgICAgICAgaWYgKG5hbWUgaW4gcGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW5zIGFsbCBwbHVnaW4gY2FsbGJhY2tzIG1hdGNoaW5nIHRoZSBnaXZlbiBuYW1lLCBpbiBvcmRlciwgcGFzc2luZyB0aGVcbiAgICAgKiBnaXZlbiBwYXJhbSBvYmplY3QgKG1lcmdlZCBpdGggdGhlIGN1cnJlbnQgcGx1Z2luIHN0YXRlKSBhcyB0aGUgb25seVxuICAgICAqIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogTm90ZTogc2luY2UgdGhpcyBtZXRob2QgcnVucyBhbGwgcGx1Z2lucywgaXQncyBub3Qgc3VpdGFibGUgZm9yIGNhc2VzXG4gICAgICogd2hlcmUgdGhlIHJldHVybiB2YWx1ZSBvZiBhIGNhbGxiYWNrIG5lZWRzIHRvIGJlIGFwcGxpZWQgcHJpb3IgdG8gY2FsbGluZ1xuICAgICAqIHRoZSBuZXh0IGNhbGxiYWNrLiBTZWVcbiAgICAgKiBbYGl0ZXJhdGVDYWxsYmFja3MoKWBde0BsaW5rIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3lIYW5kbGVyI2l0ZXJhdGVDYWxsYmFja3N9XG4gICAgICogYmVsb3cgZm9yIGhvdyB0byBoYW5kbGUgdGhhdCBjYXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNhbGxiYWNrIHRvIHJ1biB3aXRoaW4gZWFjaCBwbHVnaW4uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtIFRoZSBvYmplY3QgdG8gcGFzcyBhcyB0aGUgZmlyc3QgKGFuZCBvbmx5KSBwYXJhbVxuICAgICAqICAgICB3aGVuIGV4ZWN1dGluZyBlYWNoIGNhbGxiYWNrLiBUaGlzIG9iamVjdCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZVxuICAgICAqICAgICBjdXJyZW50IHBsdWdpbiBzdGF0ZSBwcmlvciB0byBjYWxsYmFjayBleGVjdXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgcnVuQ2FsbGJhY2tzKG5hbWUsIHBhcmFtKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5pdGVyYXRlQ2FsbGJhY2tzKG5hbWUpKSB7XG4gICAgICAgICAgICAvLyBUT0RPKHBoaWxpcHdhbHRvbik6IG5vdCBzdXJlIHdoeSBgYW55YCBpcyBuZWVkZWQuIEl0IHNlZW1zIGxpa2VcbiAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIHdvcmsgd2l0aCBgYXMgV29ya2JveFBsdWdpbkNhbGxiYWNrUGFyYW1bQ11gLlxuICAgICAgICAgICAgYXdhaXQgY2FsbGJhY2socGFyYW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2VwdHMgYSBjYWxsYmFjayBhbmQgcmV0dXJucyBhbiBpdGVyYWJsZSBvZiBtYXRjaGluZyBwbHVnaW4gY2FsbGJhY2tzLFxuICAgICAqIHdoZXJlIGVhY2ggY2FsbGJhY2sgaXMgd3JhcHBlZCB3aXRoIHRoZSBjdXJyZW50IGhhbmRsZXIgc3RhdGUgKGkuZS4gd2hlblxuICAgICAqIHlvdSBjYWxsIGVhY2ggY2FsbGJhY2ssIHdoYXRldmVyIG9iamVjdCBwYXJhbWV0ZXIgeW91IHBhc3MgaXQgd2lsbFxuICAgICAqIGJlIG1lcmdlZCB3aXRoIHRoZSBwbHVnaW4ncyBjdXJyZW50IHN0YXRlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIGZvIHRoZSBjYWxsYmFjayB0byBydW5cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxGdW5jdGlvbj59XG4gICAgICovXG4gICAgKml0ZXJhdGVDYWxsYmFja3MobmFtZSkge1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLl9zdHJhdGVneS5wbHVnaW5zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBsdWdpbltuYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fcGx1Z2luU3RhdGVNYXAuZ2V0KHBsdWdpbik7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGVmdWxDYWxsYmFjayA9IChwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZWZ1bFBhcmFtID0geyAuLi5wYXJhbSwgc3RhdGUgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhwaGlsaXB3YWx0b24pOiBub3Qgc3VyZSB3aHkgYGFueWAgaXMgbmVlZGVkLiBJdCBzZWVtcyBsaWtlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIHdvcmsgd2l0aCBgYXMgV29ya2JveFBsdWdpbkNhbGxiYWNrUGFyYW1bQ11gLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luW25hbWVdKHN0YXRlZnVsUGFyYW0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgeWllbGQgc3RhdGVmdWxDYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcHJvbWlzZSB0byB0aGVcbiAgICAgKiBbZXh0ZW5kIGxpZmV0aW1lIHByb21pc2VzXXtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZXh0ZW5kYWJsZWV2ZW50LWV4dGVuZC1saWZldGltZS1wcm9taXNlc31cbiAgICAgKiBvZiB0aGUgZXZlbnQgZXZlbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSByZXF1ZXN0IGJlaW5nIGhhbmRsZWQgKHVzdWFsbHkgYVxuICAgICAqIGBGZXRjaEV2ZW50YCkuXG4gICAgICpcbiAgICAgKiBOb3RlOiB5b3UgY2FuIGF3YWl0XG4gICAgICogW2Bkb25lV2FpdGluZygpYF17QGxpbmsgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneUhhbmRsZXJ+ZG9uZVdhaXRpbmd9XG4gICAgICogdG8ga25vdyB3aGVuIGFsbCBhZGRlZCBwcm9taXNlcyBoYXZlIHNldHRsZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1Byb21pc2V9IHByb21pc2UgQSBwcm9taXNlIHRvIGFkZCB0byB0aGUgZXh0ZW5kIGxpZmV0aW1lIHByb21pc2VzXG4gICAgICogICAgIG9mIHRoZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICB3YWl0VW50aWwocHJvbWlzZSkge1xuICAgICAgICB0aGlzLl9leHRlbmRMaWZldGltZVByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgYWxsIHByb21pc2VzIHBhc3NlZCB0b1xuICAgICAqIFtgd2FpdFVudGlsKClgXXtAbGluayBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5SGFuZGxlcn53YWl0VW50aWx9XG4gICAgICogaGF2ZSBzZXR0bGVkLlxuICAgICAqXG4gICAgICogTm90ZTogYW55IHdvcmsgZG9uZSBhZnRlciBgZG9uZVdhaXRpbmcoKWAgc2V0dGxlcyBzaG91bGQgYmUgbWFudWFsbHlcbiAgICAgKiBwYXNzZWQgdG8gYW4gZXZlbnQncyBgd2FpdFVudGlsKClgIG1ldGhvZCAobm90IHRoaXMgaGFuZGxlcidzXG4gICAgICogYHdhaXRVbnRpbCgpYCBtZXRob2QpLCBvdGhlcndpc2UgdGhlIHNlcnZpY2Ugd29ya2VyIHRocmVhZCBteSBiZSBraWxsZWRcbiAgICAgKiBwcmlvciB0byB5b3VyIHdvcmsgY29tcGxldGluZy5cbiAgICAgKi9cbiAgICBhc3luYyBkb25lV2FpdGluZygpIHtcbiAgICAgICAgbGV0IHByb21pc2U7XG4gICAgICAgIHdoaWxlIChwcm9taXNlID0gdGhpcy5fZXh0ZW5kTGlmZXRpbWVQcm9taXNlcy5zaGlmdCgpKSB7XG4gICAgICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHJ1bm5pbmcgdGhlIHN0cmF0ZWd5IGFuZCBpbW1lZGlhdGVseSByZXNvbHZlcyBhbnkgcGVuZGluZ1xuICAgICAqIGB3YWl0VW50aWwoKWAgcHJvbWlzZXMuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlckRlZmVycmVkLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYWxsIGNhY2hlV2lsbFVwZGF0ZSBvbiB0aGUgYXZhaWxhYmxlIHBsdWdpbnMgKG9yIHVzZVxuICAgICAqIHN0YXR1cyA9PT0gMjAwKSB0byBkZXRlcm1pbmUgaWYgdGhlIFJlc3BvbnNlIGlzIHNhZmUgYW5kIHZhbGlkIHRvIGNhY2hlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fSBvcHRpb25zLnJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge1Jlc3BvbnNlfSBvcHRpb25zLnJlc3BvbnNlXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxSZXNwb25zZXx1bmRlZmluZWQ+fVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBfZW5zdXJlUmVzcG9uc2VTYWZlVG9DYWNoZShyZXNwb25zZSkge1xuICAgICAgICBsZXQgcmVzcG9uc2VUb0NhY2hlID0gcmVzcG9uc2U7XG4gICAgICAgIGxldCBwbHVnaW5zVXNlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuaXRlcmF0ZUNhbGxiYWNrcygnY2FjaGVXaWxsVXBkYXRlJykpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlVG9DYWNoZSA9IChhd2FpdCBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdDogdGhpcy5yZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZVRvQ2FjaGUsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICAgICAgICB9KSkgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgcGx1Z2luc1VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZVRvQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBsdWdpbnNVc2VkKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VUb0NhY2hlICYmIHJlc3BvbnNlVG9DYWNoZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlVG9DYWNoZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlVG9DYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VUb0NhY2hlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VUb0NhY2hlLnN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBUaGUgcmVzcG9uc2UgZm9yICcke3RoaXMucmVxdWVzdC51cmx9JyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGlzIGFuIG9wYXF1ZSByZXNwb25zZS4gVGhlIGNhY2hpbmcgc3RyYXRlZ3kgdGhhdCB5b3UncmUgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB1c2luZyB3aWxsIG5vdCBjYWNoZSBvcGFxdWUgcmVzcG9uc2VzIGJ5IGRlZmF1bHQuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFRoZSByZXNwb25zZSBmb3IgJyR7dGhpcy5yZXF1ZXN0LnVybH0nIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgcmV0dXJuZWQgYSBzdGF0dXMgY29kZSBvZiAnJHtyZXNwb25zZS5zdGF0dXN9JyBhbmQgd29uJ3QgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBiZSBjYWNoZWQgYXMgYSByZXN1bHQuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlVG9DYWNoZTtcbiAgICB9XG59XG5leHBvcnQgeyBTdHJhdGVneUhhbmRsZXIgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGNhY2hlTmFtZXMgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvY2FjaGVOYW1lcy5qcyc7XG5pbXBvcnQgeyBXb3JrYm94RXJyb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMnO1xuaW1wb3J0IHsgZ2V0RnJpZW5kbHlVUkwgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwuanMnO1xuaW1wb3J0IHsgU3RyYXRlZ3lIYW5kbGVyIH0gZnJvbSAnLi9TdHJhdGVneUhhbmRsZXIuanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogQW4gYWJzdHJhY3QgYmFzZSBjbGFzcyB0aGF0IGFsbCBvdGhlciBzdHJhdGVneSBjbGFzc2VzIG11c3QgZXh0ZW5kIGZyb206XG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXNcbiAqL1xuY2xhc3MgU3RyYXRlZ3kge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIHN0cmF0ZWd5IGFuZCBzZXRzIGFsbCBkb2N1bWVudGVkIG9wdGlvblxuICAgICAqIHByb3BlcnRpZXMgYXMgcHVibGljIGluc3RhbmNlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBpZiBhIGN1c3RvbSBzdHJhdGVneSBjbGFzcyBleHRlbmRzIHRoZSBiYXNlIFN0cmF0ZWd5IGNsYXNzIGFuZCBkb2VzXG4gICAgICogbm90IG5lZWQgbW9yZSB0aGFuIHRoZXNlIHByb3BlcnRpZXMsIGl0IGRvZXMgbm90IG5lZWQgdG8gZGVmaW5lIGl0cyBvd25cbiAgICAgKiBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2FjaGVOYW1lXSBDYWNoZSBuYW1lIHRvIHN0b3JlIGFuZCByZXRyaWV2ZVxuICAgICAqIHJlcXVlc3RzLiBEZWZhdWx0cyB0byB0aGUgY2FjaGUgbmFtZXMgcHJvdmlkZWQgYnlcbiAgICAgKiBbd29ya2JveC1jb3JlXXtAbGluayBtb2R1bGU6d29ya2JveC1jb3JlLmNhY2hlTmFtZXN9LlxuICAgICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gW29wdGlvbnMucGx1Z2luc10gW1BsdWdpbnNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi90b29scy93b3JrYm94L2d1aWRlcy91c2luZy1wbHVnaW5zfVxuICAgICAqIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoaXMgY2FjaGluZyBzdHJhdGVneS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZmV0Y2hPcHRpb25zXSBWYWx1ZXMgcGFzc2VkIGFsb25nIHRvIHRoZVxuICAgICAqIFtgaW5pdGBde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dPcldvcmtlckdsb2JhbFNjb3BlL2ZldGNoI1BhcmFtZXRlcnN9XG4gICAgICogb2YgYWxsIGZldGNoKCkgcmVxdWVzdHMgbWFkZSBieSB0aGlzIHN0cmF0ZWd5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5tYXRjaE9wdGlvbnNdIFRoZVxuICAgICAqIFtgQ2FjaGVRdWVyeU9wdGlvbnNgXXtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZGljdGRlZi1jYWNoZXF1ZXJ5b3B0aW9uc31cbiAgICAgKiBmb3IgYW55IGBjYWNoZS5tYXRjaCgpYCBvciBgY2FjaGUucHV0KClgIGNhbGxzIG1hZGUgYnkgdGhpcyBzdHJhdGVneS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhY2hlIG5hbWUgdG8gc3RvcmUgYW5kIHJldHJpZXZlXG4gICAgICAgICAqIHJlcXVlc3RzLiBEZWZhdWx0cyB0byB0aGUgY2FjaGUgbmFtZXMgcHJvdmlkZWQgYnlcbiAgICAgICAgICogW3dvcmtib3gtY29yZV17QGxpbmsgbW9kdWxlOndvcmtib3gtY29yZS5jYWNoZU5hbWVzfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FjaGVOYW1lID0gY2FjaGVOYW1lcy5nZXRSdW50aW1lTmFtZShvcHRpb25zLmNhY2hlTmFtZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGlzdFxuICAgICAgICAgKiBbUGx1Z2luc117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3Rvb2xzL3dvcmtib3gvZ3VpZGVzL3VzaW5nLXBsdWdpbnN9XG4gICAgICAgICAqIHVzZWQgYnkgdGhpcyBzdHJhdGVneS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0FycmF5PE9iamVjdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnMgfHwgW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZXMgcGFzc2VkIGFsb25nIHRvIHRoZVxuICAgICAgICAgKiBbYGluaXRgXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93T3JXb3JrZXJHbG9iYWxTY29wZS9mZXRjaCNQYXJhbWV0ZXJzfVxuICAgICAgICAgKiBvZiBhbGwgZmV0Y2goKSByZXF1ZXN0cyBtYWRlIGJ5IHRoaXMgc3RyYXRlZ3kuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZldGNoT3B0aW9ucyA9IG9wdGlvbnMuZmV0Y2hPcHRpb25zO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlXG4gICAgICAgICAqIFtgQ2FjaGVRdWVyeU9wdGlvbnNgXXtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZGljdGRlZi1jYWNoZXF1ZXJ5b3B0aW9uc31cbiAgICAgICAgICogZm9yIGFueSBgY2FjaGUubWF0Y2goKWAgb3IgYGNhY2hlLnB1dCgpYCBjYWxscyBtYWRlIGJ5IHRoaXMgc3RyYXRlZ3kuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hdGNoT3B0aW9ucyA9IG9wdGlvbnMubWF0Y2hPcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgcmVxdWVzdCBzdHJhdGVneSBhbmQgcmV0dXJucyBhIGBQcm9taXNlYCB0aGF0IHdpbGwgcmVzb2x2ZSB3aXRoXG4gICAgICogYSBgUmVzcG9uc2VgLCBpbnZva2luZyBhbGwgcmVsZXZhbnQgcGx1Z2luIGNhbGxiYWNrcy5cbiAgICAgKlxuICAgICAqIFdoZW4gYSBzdHJhdGVneSBpbnN0YW5jZSBpcyByZWdpc3RlcmVkIHdpdGggYSBXb3JrYm94XG4gICAgICogW3JvdXRlXXtAbGluayBtb2R1bGU6d29ya2JveC1yb3V0aW5nLlJvdXRlfSwgdGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseVxuICAgICAqIGNhbGxlZCB3aGVuIHRoZSByb3V0ZSBtYXRjaGVzLlxuICAgICAqXG4gICAgICogQWx0ZXJuYXRpdmVseSwgdGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgaW4gYSBzdGFuZGFsb25lIGBGZXRjaEV2ZW50YFxuICAgICAqIGxpc3RlbmVyIGJ5IHBhc3NpbmcgaXQgdG8gYGV2ZW50LnJlc3BvbmRXaXRoKClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGZXRjaEV2ZW50fE9iamVjdH0gb3B0aW9ucyBBIGBGZXRjaEV2ZW50YCBvciBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICAgKiAgICAgcHJvcGVydGllcyBsaXN0ZWQgYmVsb3cuXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fHN0cmluZ30gb3B0aW9ucy5yZXF1ZXN0IEEgcmVxdWVzdCB0byBydW4gdGhpcyBzdHJhdGVneSBmb3IuXG4gICAgICogQHBhcmFtIHtFeHRlbmRhYmxlRXZlbnR9IG9wdGlvbnMuZXZlbnQgVGhlIGV2ZW50IGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICAgKiAgICAgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0ge1VSTH0gW29wdGlvbnMudXJsXVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMucGFyYW1zXVxuICAgICAqL1xuICAgIGhhbmRsZShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IFtyZXNwb25zZURvbmVdID0gdGhpcy5oYW5kbGVBbGwob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZURvbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbWlsYXIgdG8gW2BoYW5kbGUoKWBde0BsaW5rIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3l+aGFuZGxlfSwgYnV0XG4gICAgICogaW5zdGVhZCBvZiBqdXN0IHJldHVybmluZyBhIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHRvIGEgYFJlc3BvbnNlYCBpdFxuICAgICAqIGl0IHdpbGwgcmV0dXJuIGFuIHR1cGxlIG9mIFtyZXNwb25zZSwgZG9uZV0gcHJvbWlzZXMsIHdoZXJlIHRoZSBmb3JtZXJcbiAgICAgKiAoYHJlc3BvbnNlYCkgaXMgZXF1aXZhbGVudCB0byB3aGF0IGBoYW5kbGUoKWAgcmV0dXJucywgYW5kIHRoZSBsYXR0ZXIgaXMgYVxuICAgICAqIFByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgb25jZSBhbnkgcHJvbWlzZXMgdGhhdCB3ZXJlIGFkZGVkIHRvXG4gICAgICogYGV2ZW50LndhaXRVbnRpbCgpYCBhcyBwYXJ0IG9mIHBlcmZvcm1pbmcgdGhlIHN0cmF0ZWd5IGhhdmUgY29tcGxldGVkLlxuICAgICAqXG4gICAgICogWW91IGNhbiBhd2FpdCB0aGUgYGRvbmVgIHByb21pc2UgdG8gZW5zdXJlIGFueSBleHRyYSB3b3JrIHBlcmZvcm1lZCBieVxuICAgICAqIHRoZSBzdHJhdGVneSAodXN1YWxseSBjYWNoaW5nIHJlc3BvbnNlcykgY29tcGxldGVzIHN1Y2Nlc3NmdWxseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmV0Y2hFdmVudHxPYmplY3R9IG9wdGlvbnMgQSBgRmV0Y2hFdmVudGAgb3IgYW4gb2JqZWN0IHdpdGggdGhlXG4gICAgICogICAgIHByb3BlcnRpZXMgbGlzdGVkIGJlbG93LlxuICAgICAqIEBwYXJhbSB7UmVxdWVzdHxzdHJpbmd9IG9wdGlvbnMucmVxdWVzdCBBIHJlcXVlc3QgdG8gcnVuIHRoaXMgc3RyYXRlZ3kgZm9yLlxuICAgICAqIEBwYXJhbSB7RXh0ZW5kYWJsZUV2ZW50fSBvcHRpb25zLmV2ZW50IFRoZSBldmVudCBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgICogICAgIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHtVUkx9IFtvcHRpb25zLnVybF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLnBhcmFtc11cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxQcm9taXNlPn0gQSB0dXBsZSBvZiBbcmVzcG9uc2UsIGRvbmVdXG4gICAgICogICAgIHByb21pc2VzIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIHJlc3BvbnNlIHJlc29sdmVzIGFzXG4gICAgICogICAgIHdlbGwgYXMgd2hlbiB0aGUgaGFuZGxlciBoYXMgY29tcGxldGVkIGFsbCBpdHMgd29yay5cbiAgICAgKi9cbiAgICBoYW5kbGVBbGwob3B0aW9ucykge1xuICAgICAgICAvLyBBbGxvdyBmb3IgZmxleGlibGUgb3B0aW9ucyB0byBiZSBwYXNzZWQuXG4gICAgICAgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgRmV0Y2hFdmVudCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBldmVudDogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBvcHRpb25zLnJlcXVlc3QsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gb3B0aW9ucy5ldmVudDtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHR5cGVvZiBvcHRpb25zLnJlcXVlc3QgPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgIG5ldyBSZXF1ZXN0KG9wdGlvbnMucmVxdWVzdCkgOlxuICAgICAgICAgICAgb3B0aW9ucy5yZXF1ZXN0O1xuICAgICAgICBjb25zdCBwYXJhbXMgPSAncGFyYW1zJyBpbiBvcHRpb25zID8gb3B0aW9ucy5wYXJhbXMgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgU3RyYXRlZ3lIYW5kbGVyKHRoaXMsIHsgZXZlbnQsIHJlcXVlc3QsIHBhcmFtcyB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VEb25lID0gdGhpcy5fZ2V0UmVzcG9uc2UoaGFuZGxlciwgcmVxdWVzdCwgZXZlbnQpO1xuICAgICAgICBjb25zdCBoYW5kbGVyRG9uZSA9IHRoaXMuX2F3YWl0Q29tcGxldGUocmVzcG9uc2VEb25lLCBoYW5kbGVyLCByZXF1ZXN0LCBldmVudCk7XG4gICAgICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiBwcm9taXNlcywgc3VpdGFibGUgZm9yIHVzZSB3aXRoIFByb21pc2UuYWxsKCkuXG4gICAgICAgIHJldHVybiBbcmVzcG9uc2VEb25lLCBoYW5kbGVyRG9uZV07XG4gICAgfVxuICAgIGFzeW5jIF9nZXRSZXNwb25zZShoYW5kbGVyLCByZXF1ZXN0LCBldmVudCkge1xuICAgICAgICBhd2FpdCBoYW5kbGVyLnJ1bkNhbGxiYWNrcygnaGFuZGxlcldpbGxTdGFydCcsIHsgZXZlbnQsIHJlcXVlc3QgfSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5faGFuZGxlKHJlcXVlc3QsIGhhbmRsZXIpO1xuICAgICAgICAgICAgLy8gVGhlIFwib2ZmaWNpYWxcIiBTdHJhdGVneSBzdWJjbGFzc2VzIGFsbCB0aHJvdyB0aGlzIGVycm9yIGF1dG9tYXRpY2FsbHksXG4gICAgICAgICAgICAvLyBidXQgaW4gY2FzZSBhIHRoaXJkLXBhcnR5IFN0cmF0ZWd5IGRvZXNuJ3QsIGVuc3VyZSB0aGF0IHdlIGhhdmUgYVxuICAgICAgICAgICAgLy8gY29uc2lzdGVudCBmYWlsdXJlIHdoZW4gdGhlcmUncyBubyByZXNwb25zZSBvciBhbiBlcnJvciByZXNwb25zZS5cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UgfHwgcmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ25vLXJlc3BvbnNlJywgeyB1cmw6IHJlcXVlc3QudXJsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBoYW5kbGVyLml0ZXJhdGVDYWxsYmFja3MoJ2hhbmRsZXJEaWRFcnJvcicpKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFjayh7IGVycm9yLCBldmVudCwgcmVxdWVzdCB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFdoaWxlIHJlc3BvbmRpbmcgdG8gJyR7Z2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpfScsIGAgK1xuICAgICAgICAgICAgICAgICAgICBgYW4gJHtlcnJvcn0gZXJyb3Igb2NjdXJyZWQuIFVzaW5nIGEgZmFsbGJhY2sgcmVzcG9uc2UgcHJvdmlkZWQgYnkgYCArXG4gICAgICAgICAgICAgICAgICAgIGBhIGhhbmRsZXJEaWRFcnJvciBwbHVnaW4uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBoYW5kbGVyLml0ZXJhdGVDYWxsYmFja3MoJ2hhbmRsZXJXaWxsUmVzcG9uZCcpKSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrKHsgZXZlbnQsIHJlcXVlc3QsIHJlc3BvbnNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgX2F3YWl0Q29tcGxldGUocmVzcG9uc2VEb25lLCBoYW5kbGVyLCByZXF1ZXN0LCBldmVudCkge1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2VEb25lO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWdub3JlIGVycm9ycywgYXMgcmVzcG9uc2UgZXJyb3JzIHNob3VsZCBiZSBjYXVnaHQgdmlhIHRoZSBgcmVzcG9uc2VgXG4gICAgICAgICAgICAvLyBwcm9taXNlIGFib3ZlLiBUaGUgYGRvbmVgIHByb21pc2Ugd2lsbCBvbmx5IHRocm93IGZvciBlcnJvcnMgaW5cbiAgICAgICAgICAgIC8vIHByb21pc2VzIHBhc3NlZCB0byBgaGFuZGxlci53YWl0VW50aWwoKWAuXG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIucnVuQ2FsbGJhY2tzKCdoYW5kbGVyRGlkUmVzcG9uZCcsIHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmRvbmVXYWl0aW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKHdhaXRVbnRpbEVycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IHdhaXRVbnRpbEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGhhbmRsZXIucnVuQ2FsbGJhY2tzKCdoYW5kbGVyRGlkQ29tcGxldGUnLCB7XG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICB9KTtcbiAgICAgICAgaGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgeyBTdHJhdGVneSB9O1xuLyoqXG4gKiBDbGFzc2VzIGV4dGVuZGluZyB0aGUgYFN0cmF0ZWd5YCBiYXNlZCBjbGFzcyBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kLFxuICogYW5kIGxldmVyYWdlIHRoZSBbYGhhbmRsZXJgXXtAbGluayBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5SGFuZGxlcn1cbiAqIGFyZyB0byBwZXJmb3JtIGFsbCBmZXRjaGluZyBhbmQgY2FjaGUgbG9naWMsIHdoaWNoIHdpbGwgZW5zdXJlIGFsbCByZWxldmFudFxuICogY2FjaGUsIGNhY2hlIG9wdGlvbnMsIGZldGNoIG9wdGlvbnMgYW5kIHBsdWdpbnMgYXJlIHVzZWQgKHBlciB0aGUgY3VycmVudFxuICogc3RyYXRlZ3kgaW5zdGFuY2UpLlxuICpcbiAqIEBuYW1lIF9oYW5kbGVcbiAqIEBpbnN0YW5jZVxuICogQGFic3RyYWN0XG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdFxuICogQHBhcmFtIHttb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5SGFuZGxlcn0gaGFuZGxlclxuICogQHJldHVybiB7UHJvbWlzZTxSZXNwb25zZT59XG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3lcbiAqL1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgY29weVJlc3BvbnNlIH0gZnJvbSAnd29ya2JveC1jb3JlL2NvcHlSZXNwb25zZS5qcyc7XG5pbXBvcnQgeyBjYWNoZU5hbWVzIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2NhY2hlTmFtZXMuanMnO1xuaW1wb3J0IHsgZ2V0RnJpZW5kbHlVUkwgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwuanMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5qcyc7XG5pbXBvcnQgeyBXb3JrYm94RXJyb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCB7IFN0cmF0ZWd5IH0gZnJvbSAnd29ya2JveC1zdHJhdGVnaWVzL1N0cmF0ZWd5LmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG5jb25zdCBjb3B5UmVkaXJlY3RlZENhY2hlYWJsZVJlc3BvbnNlc1BsdWdpbiA9IHtcbiAgICBhc3luYyBjYWNoZVdpbGxVcGRhdGUoeyByZXNwb25zZSB9KSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5yZWRpcmVjdGVkID8gYXdhaXQgY29weVJlc3BvbnNlKHJlc3BvbnNlKSA6IHJlc3BvbnNlO1xuICAgIH1cbn07XG4vKipcbiAqIEEgW1N0cmF0ZWd5XXtAbGluayBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5fSBpbXBsZW1lbnRhdGlvblxuICogc3BlY2lmaWNhbGx5IGRlc2lnbmVkIHRvIHdvcmsgd2l0aFxuICogW1ByZWNhY2hlQ29udHJvbGxlcl17QGxpbmsgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5QcmVjYWNoZUNvbnRyb2xsZXJ9XG4gKiB0byBib3RoIGNhY2hlIGFuZCBmZXRjaCBwcmVjYWNoZWQgYXNzZXRzLlxuICpcbiAqIE5vdGU6IGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgaXMgY3JlYXRlZCBhdXRvbWF0aWNhbGx5IHdoZW4gY3JlYXRpbmcgYVxuICogYFByZWNhY2hlQ29udHJvbGxlcmA7IGl0J3MgZ2VuZXJhbGx5IG5vdCBuZWNlc3NhcnkgdG8gY3JlYXRlIHRoaXMgeW91cnNlbGYuXG4gKlxuICogQGV4dGVuZHMgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneVxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmdcbiAqL1xuY2xhc3MgUHJlY2FjaGVTdHJhdGVneSBleHRlbmRzIFN0cmF0ZWd5IHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2FjaGVOYW1lXSBDYWNoZSBuYW1lIHRvIHN0b3JlIGFuZCByZXRyaWV2ZVxuICAgICAqIHJlcXVlc3RzLiBEZWZhdWx0cyB0byB0aGUgY2FjaGUgbmFtZXMgcHJvdmlkZWQgYnlcbiAgICAgKiBbd29ya2JveC1jb3JlXXtAbGluayBtb2R1bGU6d29ya2JveC1jb3JlLmNhY2hlTmFtZXN9LlxuICAgICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gW29wdGlvbnMucGx1Z2luc10gW1BsdWdpbnNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi90b29scy93b3JrYm94L2d1aWRlcy91c2luZy1wbHVnaW5zfVxuICAgICAqIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoaXMgY2FjaGluZyBzdHJhdGVneS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZmV0Y2hPcHRpb25zXSBWYWx1ZXMgcGFzc2VkIGFsb25nIHRvIHRoZVxuICAgICAqIFtgaW5pdGBde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dPcldvcmtlckdsb2JhbFNjb3BlL2ZldGNoI1BhcmFtZXRlcnN9XG4gICAgICogb2YgYWxsIGZldGNoKCkgcmVxdWVzdHMgbWFkZSBieSB0aGlzIHN0cmF0ZWd5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5tYXRjaE9wdGlvbnNdIFRoZVxuICAgICAqIFtgQ2FjaGVRdWVyeU9wdGlvbnNgXXtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZGljdGRlZi1jYWNoZXF1ZXJ5b3B0aW9uc31cbiAgICAgKiBmb3IgYW55IGBjYWNoZS5tYXRjaCgpYCBvciBgY2FjaGUucHV0KClgIGNhbGxzIG1hZGUgYnkgdGhpcyBzdHJhdGVneS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZhbGxiYWNrVG9OZXR3b3JrPXRydWVdIFdoZXRoZXIgdG8gYXR0ZW1wdCB0b1xuICAgICAqIGdldCB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgbmV0d29yayBpZiB0aGVyZSdzIGEgcHJlY2FjaGUgbWlzcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgb3B0aW9ucy5jYWNoZU5hbWUgPSBjYWNoZU5hbWVzLmdldFByZWNhY2hlTmFtZShvcHRpb25zLmNhY2hlTmFtZSk7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9mYWxsYmFja1RvTmV0d29yayA9IG9wdGlvbnMuZmFsbGJhY2tUb05ldHdvcmsgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xuICAgICAgICAvLyBSZWRpcmVjdGVkIHJlc3BvbnNlcyBjYW5ub3QgYmUgdXNlZCB0byBzYXRpc2Z5IGEgbmF2aWdhdGlvbiByZXF1ZXN0LCBzb1xuICAgICAgICAvLyBhbnkgcmVkaXJlY3RlZCByZXNwb25zZSBtdXN0IGJlIFwiY29waWVkXCIgcmF0aGVyIHRoYW4gY2xvbmVkLCBzbyB0aGUgbmV3XG4gICAgICAgIC8vIHJlc3BvbnNlIGRvZXNuJ3QgY29udGFpbiB0aGUgYHJlZGlyZWN0ZWRgIGZsYWcuIFNlZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjY5MzYzJmRlc2M9MiNjMVxuICAgICAgICB0aGlzLnBsdWdpbnMucHVzaChjb3B5UmVkaXJlY3RlZENhY2hlYWJsZVJlc3BvbnNlc1BsdWdpbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fHN0cmluZ30gcmVxdWVzdCBBIHJlcXVlc3QgdG8gcnVuIHRoaXMgc3RyYXRlZ3kgZm9yLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneUhhbmRsZXJ9IGhhbmRsZXIgVGhlIGV2ZW50IHRoYXRcbiAgICAgKiAgICAgdHJpZ2dlcmVkIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8UmVzcG9uc2U+fVxuICAgICAqL1xuICAgIGFzeW5jIF9oYW5kbGUocmVxdWVzdCwgaGFuZGxlcikge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGhhbmRsZXIuY2FjaGVNYXRjaChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhbiBgaW5zdGFsbGAgZXZlbnQgdGhlbiBwb3B1bGF0ZSB0aGUgY2FjaGUuIElmIHRoaXMgaXMgYVxuICAgICAgICAgICAgLy8gYGZldGNoYCBldmVudCAob3IgYW55IG90aGVyIGV2ZW50KSB0aGVuIHJlc3BvbmQgd2l0aCB0aGUgY2FjaGVkXG4gICAgICAgICAgICAvLyByZXNwb25zZS5cbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmV2ZW50ICYmIGhhbmRsZXIuZXZlbnQudHlwZSA9PT0gJ2luc3RhbGwnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2hhbmRsZUluc3RhbGwocmVxdWVzdCwgaGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5faGFuZGxlRmV0Y2gocmVxdWVzdCwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyBfaGFuZGxlRmV0Y2gocmVxdWVzdCwgaGFuZGxlcikge1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIC8vIEZhbGwgYmFjayB0byB0aGUgbmV0d29yayBpZiB3ZSBkb24ndCBoYXZlIGEgY2FjaGVkIHJlc3BvbnNlXG4gICAgICAgIC8vIChwZXJoYXBzIGR1ZSB0byBtYW51YWwgY2FjaGUgY2xlYW51cCkuXG4gICAgICAgIGlmICh0aGlzLl9mYWxsYmFja1RvTmV0d29yaykge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgVGhlIHByZWNhY2hlZCByZXNwb25zZSBmb3IgYCArXG4gICAgICAgICAgICAgICAgICAgIGAke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0gaW4gJHt0aGlzLmNhY2hlTmFtZX0gd2FzIG5vdCBgICtcbiAgICAgICAgICAgICAgICAgICAgYGZvdW5kLiBGYWxsaW5nIGJhY2sgdG8gdGhlIG5ldHdvcmsgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlci5mZXRjaChyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IG5vcm1hbGx5IGhhcHBlbiwgYnV0IHRoZXJlIGFyZSBlZGdlIGNhc2VzOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8xNDQxXG4gICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdtaXNzaW5nLXByZWNhY2hlLWVudHJ5Jywge1xuICAgICAgICAgICAgICAgIGNhY2hlTmFtZTogdGhpcy5jYWNoZU5hbWUsXG4gICAgICAgICAgICAgICAgdXJsOiByZXF1ZXN0LnVybCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IGhhbmRsZXIucGFyYW1zICYmIGhhbmRsZXIucGFyYW1zLmNhY2hlS2V5IHx8XG4gICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5nZXRDYWNoZUtleShyZXF1ZXN0LCAncmVhZCcpO1xuICAgICAgICAgICAgLy8gV29ya2JveCBpcyBnb2luZyB0byBoYW5kbGUgdGhlIHJvdXRlLlxuICAgICAgICAgICAgLy8gcHJpbnQgdGhlIHJvdXRpbmcgZGV0YWlscyB0byB0aGUgY29uc29sZS5cbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgUHJlY2FjaGluZyBpcyByZXNwb25kaW5nIHRvOiBgICtcbiAgICAgICAgICAgICAgICBnZXRGcmllbmRseVVSTChyZXF1ZXN0LnVybCkpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgU2VydmluZyB0aGUgcHJlY2FjaGVkIHVybDogJHtnZXRGcmllbmRseVVSTChjYWNoZUtleS51cmwpfWApO1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBWaWV3IHJlcXVlc3QgZGV0YWlscyBoZXJlLmApO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhyZXF1ZXN0KTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBWaWV3IHJlc3BvbnNlIGRldGFpbHMgaGVyZS5gKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIF9oYW5kbGVJbnN0YWxsKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmZldGNoQW5kQ2FjaGVQdXQocmVxdWVzdCk7XG4gICAgICAgIC8vIEFueSB0aW1lIHRoZXJlJ3Mgbm8gcmVzcG9uc2UsIGNvbnNpZGVyIGl0IGEgcHJlY2FjaGluZyBlcnJvci5cbiAgICAgICAgbGV0IHJlc3BvbnNlU2FmZVRvUHJlY2FjaGUgPSBCb29sZWFuKHJlc3BvbnNlKTtcbiAgICAgICAgLy8gQWxzbyBjb25zaWRlciBpdCBhbiBlcnJvciBpZiB0aGUgdXNlciBkaWRuJ3QgcGFzcyB0aGVpciBvd25cbiAgICAgICAgLy8gY2FjaGVXaWxsVXBkYXRlIHBsdWdpbiwgYW5kIHRoZSByZXNwb25zZSBpcyBhIDQwMCsgKG5vdGU6IHRoaXMgbWVhbnNcbiAgICAgICAgLy8gdGhhdCBieSBkZWZhdWx0IG9wYXF1ZSByZXNwb25zZXMgY2FuIGJlIHByZWNhY2hlZCkuXG4gICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5zdGF0dXMgPj0gNDAwICYmXG4gICAgICAgICAgICAhdGhpcy5fdXNlc0N1c3RvbUNhY2hlYWJsZVJlc3BvbnNlTG9naWMoKSkge1xuICAgICAgICAgICAgcmVzcG9uc2VTYWZlVG9QcmVjYWNoZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzcG9uc2VTYWZlVG9QcmVjYWNoZSkge1xuICAgICAgICAgICAgLy8gVGhyb3dpbmcgaGVyZSB3aWxsIGxlYWQgdG8gdGhlIGBpbnN0YWxsYCBoYW5kbGVyIGZhaWxpbmcsIHdoaWNoXG4gICAgICAgICAgICAvLyB3ZSB3YW50IHRvIGRvIGlmICphbnkqIG9mIHRoZSByZXNwb25zZXMgYXJlbid0IHNhZmUgdG8gY2FjaGUuXG4gICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdiYWQtcHJlY2FjaGluZy1yZXNwb25zZScsIHtcbiAgICAgICAgICAgICAgICB1cmw6IHJlcXVlc3QudXJsLFxuICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYW55IHVzZXJzIHBsdWdpbnMgd2VyZSBhZGRlZCBjb250YWluaW5nIHRoZWlyIG93blxuICAgICAqIGBjYWNoZVdpbGxVcGRhdGVgIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRlZmF1bHQgY2FjaGVhYmxlIHJlc3BvbnNlIGxvZ2ljIChpLmUuXG4gICAgICogPDQwMCwgaW5jbHVkaW5nIG9wYXF1ZSByZXNwb25zZXMpIHNob3VsZCBiZSB1c2VkLiBJZiBhIGN1c3RvbSBwbHVnaW5cbiAgICAgKiB3aXRoIGEgYGNhY2hlV2lsbFVwZGF0ZWAgY2FsbGJhY2sgaXMgcGFzc2VkLCB0aGVuIHRoZSBzdHJhdGVneSBzaG91bGRcbiAgICAgKiBkZWZlciB0byB0aGF0IHBsdWdpbidzIGxvZ2ljLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXNlc0N1c3RvbUNhY2hlYWJsZVJlc3BvbnNlTG9naWMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBsdWdpbnMuc29tZSgocGx1Z2luKSA9PiBwbHVnaW4uY2FjaGVXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICBwbHVnaW4gIT09IGNvcHlSZWRpcmVjdGVkQ2FjaGVhYmxlUmVzcG9uc2VzUGx1Z2luKTtcbiAgICB9XG59XG5leHBvcnQgeyBQcmVjYWNoZVN0cmF0ZWd5IH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzJztcbmltcG9ydCB7IGNhY2hlTmFtZXMgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvY2FjaGVOYW1lcy5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IFdvcmtib3hFcnJvciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9Xb3JrYm94RXJyb3IuanMnO1xuaW1wb3J0IHsgd2FpdFVudGlsIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL3dhaXRVbnRpbC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDYWNoZUtleSB9IGZyb20gJy4vdXRpbHMvY3JlYXRlQ2FjaGVLZXkuanMnO1xuaW1wb3J0IHsgUHJlY2FjaGVJbnN0YWxsUmVwb3J0UGx1Z2luIH0gZnJvbSAnLi91dGlscy9QcmVjYWNoZUluc3RhbGxSZXBvcnRQbHVnaW4uanMnO1xuaW1wb3J0IHsgUHJlY2FjaGVDYWNoZUtleVBsdWdpbiB9IGZyb20gJy4vdXRpbHMvUHJlY2FjaGVDYWNoZUtleVBsdWdpbi5qcyc7XG5pbXBvcnQgeyBwcmludENsZWFudXBEZXRhaWxzIH0gZnJvbSAnLi91dGlscy9wcmludENsZWFudXBEZXRhaWxzLmpzJztcbmltcG9ydCB7IHByaW50SW5zdGFsbERldGFpbHMgfSBmcm9tICcuL3V0aWxzL3ByaW50SW5zdGFsbERldGFpbHMuanMnO1xuaW1wb3J0IHsgUHJlY2FjaGVTdHJhdGVneSB9IGZyb20gJy4vUHJlY2FjaGVTdHJhdGVneS5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBQZXJmb3JtcyBlZmZpY2llbnQgcHJlY2FjaGluZyBvZiBhc3NldHMuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmdcbiAqL1xuY2xhc3MgUHJlY2FjaGVDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgUHJlY2FjaGVDb250cm9sbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jYWNoZU5hbWVdIFRoZSBjYWNoZSB0byB1c2UgZm9yIHByZWNhY2hpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBsdWdpbnNdIFBsdWdpbnMgdG8gdXNlIHdoZW4gcHJlY2FjaGluZyBhcyB3ZWxsXG4gICAgICogYXMgcmVzcG9uZGluZyB0byBmZXRjaCBldmVudHMgZm9yIHByZWNhY2hlZCBhc3NldHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mYWxsYmFja1RvTmV0d29yaz10cnVlXSBXaGV0aGVyIHRvIGF0dGVtcHQgdG9cbiAgICAgKiBnZXQgdGhlIHJlc3BvbnNlIGZyb20gdGhlIG5ldHdvcmsgaWYgdGhlcmUncyBhIHByZWNhY2hlIG1pc3MuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBjYWNoZU5hbWUsIHBsdWdpbnMgPSBbXSwgZmFsbGJhY2tUb05ldHdvcmsgPSB0cnVlIH0gPSB7fSkge1xuICAgICAgICB0aGlzLl91cmxzVG9DYWNoZUtleXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3VybHNUb0NhY2hlTW9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NhY2hlS2V5c1RvSW50ZWdyaXRpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3N0cmF0ZWd5ID0gbmV3IFByZWNhY2hlU3RyYXRlZ3koe1xuICAgICAgICAgICAgY2FjaGVOYW1lOiBjYWNoZU5hbWVzLmdldFByZWNhY2hlTmFtZShjYWNoZU5hbWUpLFxuICAgICAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgICAgIC4uLnBsdWdpbnMsXG4gICAgICAgICAgICAgICAgbmV3IFByZWNhY2hlQ2FjaGVLZXlQbHVnaW4oeyBwcmVjYWNoZUNvbnRyb2xsZXI6IHRoaXMgfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZmFsbGJhY2tUb05ldHdvcmssXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBCaW5kIHRoZSBpbnN0YWxsIGFuZCBhY3RpdmF0ZSBtZXRob2RzIHRvIHRoZSBpbnN0YW5jZS5cbiAgICAgICAgdGhpcy5pbnN0YWxsID0gdGhpcy5pbnN0YWxsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSB0aGlzLmFjdGl2YXRlLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nLlByZWNhY2hlU3RyYXRlZ3l9IFRoZSBzdHJhdGVneSBjcmVhdGVkIGJ5IHRoaXMgY29udHJvbGxlciBhbmRcbiAgICAgKiB1c2VkIHRvIGNhY2hlIGFzc2V0cyBhbmQgcmVzcG9uZCB0byBmZXRjaCBldmVudHMuXG4gICAgICovXG4gICAgZ2V0IHN0cmF0ZWd5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RyYXRlZ3k7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgaXRlbXMgdG8gdGhlIHByZWNhY2hlIGxpc3QsIHJlbW92aW5nIGFueSBkdXBsaWNhdGVzIGFuZFxuICAgICAqIHN0b3JlcyB0aGUgZmlsZXMgaW4gdGhlXG4gICAgICogW1wicHJlY2FjaGUgY2FjaGVcIl17QGxpbmsgbW9kdWxlOndvcmtib3gtY29yZS5jYWNoZU5hbWVzfSB3aGVuIHRoZSBzZXJ2aWNlXG4gICAgICogd29ya2VyIGluc3RhbGxzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0fHN0cmluZz59IFtlbnRyaWVzPVtdXSBBcnJheSBvZiBlbnRyaWVzIHRvIHByZWNhY2hlLlxuICAgICAqL1xuICAgIHByZWNhY2hlKGVudHJpZXMpIHtcbiAgICAgICAgdGhpcy5hZGRUb0NhY2hlTGlzdChlbnRyaWVzKTtcbiAgICAgICAgaWYgKCF0aGlzLl9pbnN0YWxsQW5kQWN0aXZlTGlzdGVuZXJzQWRkZWQpIHtcbiAgICAgICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignaW5zdGFsbCcsIHRoaXMuaW5zdGFsbCk7XG4gICAgICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2FjdGl2YXRlJywgdGhpcy5hY3RpdmF0ZSk7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YWxsQW5kQWN0aXZlTGlzdGVuZXJzQWRkZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYWRkIGl0ZW1zIHRvIHRoZSBwcmVjYWNoZSBsaXN0LCByZW1vdmluZyBkdXBsaWNhdGVzXG4gICAgICogYW5kIGVuc3VyaW5nIHRoZSBpbmZvcm1hdGlvbiBpcyB2YWxpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5QcmVjYWNoZUNvbnRyb2xsZXIuUHJlY2FjaGVFbnRyeXxzdHJpbmc+fSBlbnRyaWVzXG4gICAgICogICAgIEFycmF5IG9mIGVudHJpZXMgdG8gcHJlY2FjaGUuXG4gICAgICovXG4gICAgYWRkVG9DYWNoZUxpc3QoZW50cmllcykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgYXNzZXJ0LmlzQXJyYXkoZW50cmllcywge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXByZWNhY2hpbmcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1ByZWNhY2hlQ29udHJvbGxlcicsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdhZGRUb0NhY2hlTGlzdCcsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnZW50cmllcycsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmxzVG9XYXJuQWJvdXQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8yMjU5XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHVybHNUb1dhcm5BYm91dC5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVudHJ5ICYmIGVudHJ5LnJldmlzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB1cmxzVG9XYXJuQWJvdXQucHVzaChlbnRyeS51cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBjYWNoZUtleSwgdXJsIH0gPSBjcmVhdGVDYWNoZUtleShlbnRyeSk7XG4gICAgICAgICAgICBjb25zdCBjYWNoZU1vZGUgPSAodHlwZW9mIGVudHJ5ICE9PSAnc3RyaW5nJyAmJiBlbnRyeS5yZXZpc2lvbikgP1xuICAgICAgICAgICAgICAgICdyZWxvYWQnIDogJ2RlZmF1bHQnO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VybHNUb0NhY2hlS2V5cy5oYXModXJsKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3VybHNUb0NhY2hlS2V5cy5nZXQodXJsKSAhPT0gY2FjaGVLZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdhZGQtdG8tY2FjaGUtbGlzdC1jb25mbGljdGluZy1lbnRyaWVzJywge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEVudHJ5OiB0aGlzLl91cmxzVG9DYWNoZUtleXMuZ2V0KHVybCksXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZEVudHJ5OiBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09ICdzdHJpbmcnICYmIGVudHJ5LmludGVncml0eSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYWNoZUtleXNUb0ludGVncml0aWVzLmhhcyhjYWNoZUtleSkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXlzVG9JbnRlZ3JpdGllcy5nZXQoY2FjaGVLZXkpICE9PSBlbnRyeS5pbnRlZ3JpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignYWRkLXRvLWNhY2hlLWxpc3QtY29uZmxpY3RpbmctaW50ZWdyaXRpZXMnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUtleXNUb0ludGVncml0aWVzLnNldChjYWNoZUtleSwgZW50cnkuaW50ZWdyaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VybHNUb0NhY2hlS2V5cy5zZXQodXJsLCBjYWNoZUtleSk7XG4gICAgICAgICAgICB0aGlzLl91cmxzVG9DYWNoZU1vZGVzLnNldCh1cmwsIGNhY2hlTW9kZSk7XG4gICAgICAgICAgICBpZiAodXJsc1RvV2FybkFib3V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXJuaW5nTWVzc2FnZSA9IGBXb3JrYm94IGlzIHByZWNhY2hpbmcgVVJMcyB3aXRob3V0IHJldmlzaW9uIGAgK1xuICAgICAgICAgICAgICAgICAgICBgaW5mbzogJHt1cmxzVG9XYXJuQWJvdXQuam9pbignLCAnKX1cXG5UaGlzIGlzIGdlbmVyYWxseSBOT1Qgc2FmZS4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBMZWFybiBtb3JlIGF0IGh0dHBzOi8vYml0Lmx5L3diLXByZWNhY2hlYDtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgY29uc29sZSBkaXJlY3RseSB0byBkaXNwbGF5IHRoaXMgd2FybmluZyB3aXRob3V0IGJsb2F0aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1bmRsZSBzaXplcyBieSBwdWxsaW5nIGluIGFsbCBvZiB0aGUgbG9nZ2VyIGNvZGViYXNlIGluIHByb2QuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2Fybih3YXJuaW5nTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZWNhY2hlcyBuZXcgYW5kIHVwZGF0ZWQgYXNzZXRzLiBDYWxsIHRoaXMgbWV0aG9kIGZyb20gdGhlIHNlcnZpY2Ugd29ya2VyXG4gICAgICogaW5zdGFsbCBldmVudC5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGNhbGxzIGBldmVudC53YWl0VW50aWwoKWAgZm9yIHlvdSwgc28geW91IGRvIG5vdCBuZWVkXG4gICAgICogdG8gY2FsbCBpdCB5b3Vyc2VsZiBpbiB5b3VyIGV2ZW50IGhhbmRsZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBvcHRpb25zLmV2ZW50IFRoZSBpbnN0YWxsIGV2ZW50LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8bW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5JbnN0YWxsUmVzdWx0Pn1cbiAgICAgKi9cbiAgICBpbnN0YWxsKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB3YWl0VW50aWwoZXZlbnQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbGxSZXBvcnRQbHVnaW4gPSBuZXcgUHJlY2FjaGVJbnN0YWxsUmVwb3J0UGx1Z2luKCk7XG4gICAgICAgICAgICB0aGlzLnN0cmF0ZWd5LnBsdWdpbnMucHVzaChpbnN0YWxsUmVwb3J0UGx1Z2luKTtcbiAgICAgICAgICAgIC8vIENhY2hlIGVudHJpZXMgb25lIGF0IGEgdGltZS5cbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL3dvcmtib3gvaXNzdWVzLzI1MjhcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3VybCwgY2FjaGVLZXldIG9mIHRoaXMuX3VybHNUb0NhY2hlS2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVncml0eSA9IHRoaXMuX2NhY2hlS2V5c1RvSW50ZWdyaXRpZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZU1vZGUgPSB0aGlzLl91cmxzVG9DYWNoZU1vZGVzLmdldCh1cmwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZWdyaXR5LFxuICAgICAgICAgICAgICAgICAgICBjYWNoZTogY2FjaGVNb2RlLFxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLnN0cmF0ZWd5LmhhbmRsZUFsbCh7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogeyBjYWNoZUtleSB9LFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHVwZGF0ZWRVUkxzLCBub3RVcGRhdGVkVVJMcyB9ID0gaW5zdGFsbFJlcG9ydFBsdWdpbjtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRJbnN0YWxsRGV0YWlscyh1cGRhdGVkVVJMcywgbm90VXBkYXRlZFVSTHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdXBkYXRlZFVSTHMsIG5vdFVwZGF0ZWRVUkxzIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGFzc2V0cyB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudCBpbiB0aGUgY3VycmVudCBwcmVjYWNoZSBtYW5pZmVzdC5cbiAgICAgKiBDYWxsIHRoaXMgbWV0aG9kIGZyb20gdGhlIHNlcnZpY2Ugd29ya2VyIGFjdGl2YXRlIGV2ZW50LlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgY2FsbHMgYGV2ZW50LndhaXRVbnRpbCgpYCBmb3IgeW91LCBzbyB5b3UgZG8gbm90IG5lZWRcbiAgICAgKiB0byBjYWxsIGl0IHlvdXJzZWxmIGluIHlvdXIgZXZlbnQgaGFuZGxlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V4dGVuZGFibGVFdmVudH1cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuQ2xlYW51cFJlc3VsdD59XG4gICAgICovXG4gICAgYWN0aXZhdGUoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHdhaXRVbnRpbChldmVudCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBzZWxmLmNhY2hlcy5vcGVuKHRoaXMuc3RyYXRlZ3kuY2FjaGVOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRseUNhY2hlZFJlcXVlc3RzID0gYXdhaXQgY2FjaGUua2V5cygpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRDYWNoZUtleXMgPSBuZXcgU2V0KHRoaXMuX3VybHNUb0NhY2hlS2V5cy52YWx1ZXMoKSk7XG4gICAgICAgICAgICBjb25zdCBkZWxldGVkVVJMcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIGN1cnJlbnRseUNhY2hlZFJlcXVlc3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFleHBlY3RlZENhY2hlS2V5cy5oYXMocmVxdWVzdC51cmwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhY2hlLmRlbGV0ZShyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZFVSTHMucHVzaChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBwcmludENsZWFudXBEZXRhaWxzKGRlbGV0ZWRVUkxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRlbGV0ZWRVUkxzIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbWFwcGluZyBvZiBhIHByZWNhY2hlZCBVUkwgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY2FjaGUga2V5LCB0YWtpbmdcbiAgICAgKiBpbnRvIGFjY291bnQgdGhlIHJldmlzaW9uIGluZm9ybWF0aW9uIGZvciB0aGUgVVJMLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TWFwPHN0cmluZywgc3RyaW5nPn0gQSBVUkwgdG8gY2FjaGUga2V5IG1hcHBpbmcuXG4gICAgICovXG4gICAgZ2V0VVJMc1RvQ2FjaGVLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJsc1RvQ2FjaGVLZXlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgdGhlIFVSTHMgdGhhdCBoYXZlIGJlZW4gcHJlY2FjaGVkIGJ5IHRoZSBjdXJyZW50XG4gICAgICogc2VydmljZSB3b3JrZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBUaGUgcHJlY2FjaGVkIFVSTHMuXG4gICAgICovXG4gICAgZ2V0Q2FjaGVkVVJMcygpIHtcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLl91cmxzVG9DYWNoZUtleXMua2V5cygpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2FjaGUga2V5IHVzZWQgZm9yIHN0b3JpbmcgYSBnaXZlbiBVUkwuIElmIHRoYXQgVVJMIGlzXG4gICAgICogdW52ZXJzaW9uZWQsIGxpa2UgYC9pbmRleC5odG1sJywgdGhlbiB0aGUgY2FjaGUga2V5IHdpbGwgYmUgdGhlIG9yaWdpbmFsXG4gICAgICogVVJMIHdpdGggYSBzZWFyY2ggcGFyYW1ldGVyIGFwcGVuZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBBIFVSTCB3aG9zZSBjYWNoZSBrZXkgeW91IHdhbnQgdG8gbG9vayB1cC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB2ZXJzaW9uZWQgVVJMIHRoYXQgY29ycmVzcG9uZHMgdG8gYSBjYWNoZSBrZXlcbiAgICAgKiBmb3IgdGhlIG9yaWdpbmFsIFVSTCwgb3IgdW5kZWZpbmVkIGlmIHRoYXQgVVJMIGlzbid0IHByZWNhY2hlZC5cbiAgICAgKi9cbiAgICBnZXRDYWNoZUtleUZvclVSTCh1cmwpIHtcbiAgICAgICAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLmhyZWYpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJsc1RvQ2FjaGVLZXlzLmdldCh1cmxPYmplY3QuaHJlZik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgYWN0cyBhcyBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yXG4gICAgICogW2BjYWNoZS5tYXRjaCgpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhY2hlL21hdGNoKVxuICAgICAqIHdpdGggdGhlIGZvbGxvd2luZyBkaWZmZXJlbmNlczpcbiAgICAgKlxuICAgICAqIC0gSXQga25vd3Mgd2hhdCB0aGUgbmFtZSBvZiB0aGUgcHJlY2FjaGUgaXMsIGFuZCBvbmx5IGNoZWNrcyBpbiB0aGF0IGNhY2hlLlxuICAgICAqIC0gSXQgYWxsb3dzIHlvdSB0byBwYXNzIGluIGFuIFwib3JpZ2luYWxcIiBVUkwgd2l0aG91dCB2ZXJzaW9uaW5nIHBhcmFtZXRlcnMsXG4gICAgICogYW5kIGl0IHdpbGwgYXV0b21hdGljYWxseSBsb29rIHVwIHRoZSBjb3JyZWN0IGNhY2hlIGtleSBmb3IgdGhlIGN1cnJlbnRseVxuICAgICAqIGFjdGl2ZSByZXZpc2lvbiBvZiB0aGF0IFVSTC5cbiAgICAgKlxuICAgICAqIEUuZy4sIGBtYXRjaFByZWNhY2hlKCdpbmRleC5odG1sJylgIHdpbGwgZmluZCB0aGUgY29ycmVjdCBwcmVjYWNoZWRcbiAgICAgKiByZXNwb25zZSBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2VydmljZSB3b3JrZXIsIGV2ZW4gaWYgdGhlIGFjdHVhbCBjYWNoZVxuICAgICAqIGtleSBpcyBgJy9pbmRleC5odG1sP19fV0JfUkVWSVNJT05fXz0xMjM0YWJjZCdgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UmVxdWVzdH0gcmVxdWVzdCBUaGUga2V5ICh3aXRob3V0IHJldmlzaW9uaW5nIHBhcmFtZXRlcnMpXG4gICAgICogdG8gbG9vayB1cCBpbiB0aGUgcHJlY2FjaGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxSZXNwb25zZXx1bmRlZmluZWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIG1hdGNoUHJlY2FjaGUocmVxdWVzdCkge1xuICAgICAgICBjb25zdCB1cmwgPSByZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCA/IHJlcXVlc3QudXJsIDogcmVxdWVzdDtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmdldENhY2hlS2V5Rm9yVVJMKHVybCk7XG4gICAgICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBzZWxmLmNhY2hlcy5vcGVuKHRoaXMuc3RyYXRlZ3kuY2FjaGVOYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5tYXRjaChjYWNoZUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbG9va3MgdXAgYHVybGAgaW4gdGhlIHByZWNhY2hlICh0YWtpbmcgaW50b1xuICAgICAqIGFjY291bnQgcmV2aXNpb24gaW5mb3JtYXRpb24pLCBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBgUmVzcG9uc2VgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgcHJlY2FjaGVkIFVSTCB3aGljaCB3aWxsIGJlIHVzZWQgdG8gbG9va3VwIHRoZVxuICAgICAqIGBSZXNwb25zZWAuXG4gICAgICogQHJldHVybiB7bW9kdWxlOndvcmtib3gtcm91dGluZ35oYW5kbGVyQ2FsbGJhY2t9XG4gICAgICovXG4gICAgY3JlYXRlSGFuZGxlckJvdW5kVG9VUkwodXJsKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5nZXRDYWNoZUtleUZvclVSTCh1cmwpO1xuICAgICAgICBpZiAoIWNhY2hlS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdub24tcHJlY2FjaGVkLXVybCcsIHsgdXJsIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgb3B0aW9ucy5yZXF1ZXN0ID0gbmV3IFJlcXVlc3QodXJsKTtcbiAgICAgICAgICAgIG9wdGlvbnMucGFyYW1zID0geyBjYWNoZUtleSwgLi4ub3B0aW9ucy5wYXJhbXMgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmF0ZWd5LmhhbmRsZShvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgeyBQcmVjYWNoZUNvbnRyb2xsZXIgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IFByZWNhY2hlQ29udHJvbGxlciB9IGZyb20gJy4uL1ByZWNhY2hlQ29udHJvbGxlci5qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbmxldCBwcmVjYWNoZUNvbnRyb2xsZXI7XG4vKipcbiAqIEByZXR1cm4ge1ByZWNhY2hlQ29udHJvbGxlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRPckNyZWF0ZVByZWNhY2hlQ29udHJvbGxlciA9ICgpID0+IHtcbiAgICBpZiAoIXByZWNhY2hlQ29udHJvbGxlcikge1xuICAgICAgICBwcmVjYWNoZUNvbnRyb2xsZXIgPSBuZXcgUHJlY2FjaGVDb250cm9sbGVyKCk7XG4gICAgfVxuICAgIHJldHVybiBwcmVjYWNoZUNvbnRyb2xsZXI7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBAdHMtaWdub3JlXG50cnkge1xuICAgIHNlbGZbJ3dvcmtib3g6cm91dGluZzo2LjAuMiddICYmIF8oKTtcbn1cbmNhdGNoIChlKSB7IH1cbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBIVFRQIG1ldGhvZCwgJ0dFVCcsIHVzZWQgd2hlbiB0aGVyZSdzIG5vIHNwZWNpZmljIG1ldGhvZFxuICogY29uZmlndXJlZCBmb3IgYSByb3V0ZS5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0TWV0aG9kID0gJ0dFVCc7XG4vKipcbiAqIFRoZSBsaXN0IG9mIHZhbGlkIEhUVFAgbWV0aG9kcyBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdHMgdGhhdCBjb3VsZCBiZSByb3V0ZWQuXG4gKlxuICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IHZhbGlkTWV0aG9kcyA9IFtcbiAgICAnREVMRVRFJyxcbiAgICAnR0VUJyxcbiAgICAnSEVBRCcsXG4gICAgJ1BBVENIJyxcbiAgICAnUE9TVCcsXG4gICAgJ1BVVCcsXG5dO1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2Fzc2VydC5qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbigpfE9iamVjdH0gaGFuZGxlciBFaXRoZXIgYSBmdW5jdGlvbiwgb3IgYW4gb2JqZWN0IHdpdGggYVxuICogJ2hhbmRsZScgbWV0aG9kLlxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIGhhbmRsZSBtZXRob2QuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZUhhbmRsZXIgPSAoaGFuZGxlcikgPT4ge1xuICAgIGlmIChoYW5kbGVyICYmIHR5cGVvZiBoYW5kbGVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgYXNzZXJ0Lmhhc01ldGhvZChoYW5kbGVyLCAnaGFuZGxlJywge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXJvdXRpbmcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1JvdXRlJyxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdoYW5kbGVyJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc1R5cGUoaGFuZGxlciwgJ2Z1bmN0aW9uJywge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXJvdXRpbmcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1JvdXRlJyxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdoYW5kbGVyJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGhhbmRsZTogaGFuZGxlciB9O1xuICAgIH1cbn07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzJztcbmltcG9ydCB7IGRlZmF1bHRNZXRob2QsIHZhbGlkTWV0aG9kcyB9IGZyb20gJy4vdXRpbHMvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IG5vcm1hbGl6ZUhhbmRsZXIgfSBmcm9tICcuL3V0aWxzL25vcm1hbGl6ZUhhbmRsZXIuanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogQSBgUm91dGVgIGNvbnNpc3RzIG9mIGEgcGFpciBvZiBjYWxsYmFjayBmdW5jdGlvbnMsIFwibWF0Y2hcIiBhbmQgXCJoYW5kbGVyXCIuXG4gKiBUaGUgXCJtYXRjaFwiIGNhbGxiYWNrIGRldGVybWluZSBpZiBhIHJvdXRlIHNob3VsZCBiZSB1c2VkIHRvIFwiaGFuZGxlXCIgYVxuICogcmVxdWVzdCBieSByZXR1cm5pbmcgYSBub24tZmFsc3kgdmFsdWUgaWYgaXQgY2FuLiBUaGUgXCJoYW5kbGVyXCIgY2FsbGJhY2tcbiAqIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIGEgbWF0Y2ggYW5kIHNob3VsZCByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXNcbiAqIHRvIGEgYFJlc3BvbnNlYC5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtcm91dGluZ1xuICovXG5jbGFzcyBSb3V0ZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIFJvdXRlIGNsYXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6d29ya2JveC1yb3V0aW5nfm1hdGNoQ2FsbGJhY2t9IG1hdGNoXG4gICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgcm91dGUgbWF0Y2hlcyBhIGdpdmVuXG4gICAgICogYGZldGNoYCBldmVudCBieSByZXR1cm5pbmcgYSBub24tZmFsc3kgdmFsdWUuXG4gICAgICogQHBhcmFtIHttb2R1bGU6d29ya2JveC1yb3V0aW5nfmhhbmRsZXJDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrXG4gICAgICogZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZSByZXNvbHZpbmcgdG8gYSBSZXNwb25zZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21ldGhvZD0nR0VUJ10gVGhlIEhUVFAgbWV0aG9kIHRvIG1hdGNoIHRoZSBSb3V0ZVxuICAgICAqIGFnYWluc3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWF0Y2gsIGhhbmRsZXIsIG1ldGhvZCA9IGRlZmF1bHRNZXRob2QpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc1R5cGUobWF0Y2gsICdmdW5jdGlvbicsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdSb3V0ZScsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnbWF0Y2gnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmlzT25lT2YobWV0aG9kLCB2YWxpZE1ldGhvZHMsIHsgcGFyYW1OYW1lOiAnbWV0aG9kJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVzZSB2YWx1ZXMgYXJlIHJlZmVyZW5jZWQgZGlyZWN0bHkgYnkgUm91dGVyIHNvIGNhbm5vdCBiZVxuICAgICAgICAvLyBhbHRlcmVkIGJ5IG1pbmlmaWNhdG9uLlxuICAgICAgICB0aGlzLmhhbmRsZXIgPSBub3JtYWxpemVIYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB0aGlzLm1hdGNoID0gbWF0Y2g7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgIH1cbn1cbmV4cG9ydCB7IFJvdXRlIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMnO1xuaW1wb3J0IHsgUm91dGUgfSBmcm9tICcuL1JvdXRlLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIFJlZ0V4cFJvdXRlIG1ha2VzIGl0IGVhc3kgdG8gY3JlYXRlIGEgcmVndWxhciBleHByZXNzaW9uIGJhc2VkXG4gKiBbUm91dGVde0BsaW5rIG1vZHVsZTp3b3JrYm94LXJvdXRpbmcuUm91dGV9LlxuICpcbiAqIEZvciBzYW1lLW9yaWdpbiByZXF1ZXN0cyB0aGUgUmVnRXhwIG9ubHkgbmVlZHMgdG8gbWF0Y2ggcGFydCBvZiB0aGUgVVJMLiBGb3JcbiAqIHJlcXVlc3RzIGFnYWluc3QgdGhpcmQtcGFydHkgc2VydmVycywgeW91IG11c3QgZGVmaW5lIGEgUmVnRXhwIHRoYXQgbWF0Y2hlc1xuICogdGhlIHN0YXJ0IG9mIHRoZSBVUkwuXG4gKlxuICogW1NlZSB0aGUgbW9kdWxlIGRvY3MgZm9yIGluZm8uXXtAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdG9vbHMvd29ya2JveC9tb2R1bGVzL3dvcmtib3gtcm91dGluZ31cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtcm91dGluZ1xuICogQGV4dGVuZHMgbW9kdWxlOndvcmtib3gtcm91dGluZy5Sb3V0ZVxuICovXG5jbGFzcyBSZWdFeHBSb3V0ZSBleHRlbmRzIFJvdXRlIHtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgcmVndWxhciBleHByZXNzaW9uIGNvbnRhaW5zXG4gICAgICogW2NhcHR1cmUgZ3JvdXBzXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHAjZ3JvdXBpbmctYmFjay1yZWZlcmVuY2VzfSxcbiAgICAgKiB0aGUgY2FwdHVyZWQgdmFsdWVzIHdpbGwgYmUgcGFzc2VkIHRvIHRoZVxuICAgICAqIFtoYW5kbGVyJ3Nde0BsaW5rIG1vZHVsZTp3b3JrYm94LXJvdXRpbmd+aGFuZGxlckNhbGxiYWNrfSBgcGFyYW1zYFxuICAgICAqIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ0V4cCBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIGFnYWluc3QgVVJMcy5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp3b3JrYm94LXJvdXRpbmd+aGFuZGxlckNhbGxiYWNrfSBoYW5kbGVyIEEgY2FsbGJhY2tcbiAgICAgKiBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBQcm9taXNlIHJlc3VsdGluZyBpbiBhIFJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0aG9kPSdHRVQnXSBUaGUgSFRUUCBtZXRob2QgdG8gbWF0Y2ggdGhlIFJvdXRlXG4gICAgICogYWdhaW5zdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZWdFeHAsIGhhbmRsZXIsIG1ldGhvZCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgYXNzZXJ0LmlzSW5zdGFuY2UocmVnRXhwLCBSZWdFeHAsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdSZWdFeHBSb3V0ZScsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAncGF0dGVybicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaCA9ICh7IHVybCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWdFeHAuZXhlYyh1cmwuaHJlZik7XG4gICAgICAgICAgICAvLyBSZXR1cm4gaW1tZWRpYXRlbHkgaWYgdGhlcmUncyBubyBtYXRjaC5cbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVxdWlyZSB0aGF0IHRoZSBtYXRjaCBzdGFydCBhdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSBVUkwgc3RyaW5nXG4gICAgICAgICAgICAvLyBpZiBpdCdzIGEgY3Jvc3Mtb3JpZ2luIHJlcXVlc3QuXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8yODEgZm9yIHRoZSBjb250ZXh0XG4gICAgICAgICAgICAvLyBiZWhpbmQgdGhpcyBiZWhhdmlvci5cbiAgICAgICAgICAgIGlmICgodXJsLm9yaWdpbiAhPT0gbG9jYXRpb24ub3JpZ2luKSAmJiAocmVzdWx0LmluZGV4ICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAnJHtyZWdFeHB9JyBvbmx5IHBhcnRpYWxseSBtYXRjaGVkIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGFnYWluc3QgdGhlIGNyb3NzLW9yaWdpbiBVUkwgJyR7dXJsfScuIFJlZ0V4cFJvdXRlJ3Mgd2lsbCBvbmx5IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGhhbmRsZSBjcm9zcy1vcmlnaW4gcmVxdWVzdHMgaWYgdGhleSBtYXRjaCB0aGUgZW50aXJlIFVSTC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIHJvdXRlIG1hdGNoZXMsIGJ1dCB0aGVyZSBhcmVuJ3QgYW55IGNhcHR1cmUgZ3JvdXBzIGRlZmluZWQsIHRoZW5cbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCByZXR1cm4gW10sIHdoaWNoIGlzIHRydXRoeSBhbmQgdGhlcmVmb3JlIHN1ZmZpY2llbnQgdG9cbiAgICAgICAgICAgIC8vIGluZGljYXRlIGEgbWF0Y2guXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgY2FwdHVyZSBncm91cHMsIHRoZW4gaXQgd2lsbCByZXR1cm4gdGhlaXIgdmFsdWVzLlxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zbGljZSgxKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIobWF0Y2gsIGhhbmRsZXIsIG1ldGhvZCk7XG4gICAgfVxufVxuZXhwb3J0IHsgUmVnRXhwUm91dGUgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9hc3NlcnQuanMnO1xuaW1wb3J0IHsgZ2V0RnJpZW5kbHlVUkwgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwuanMnO1xuaW1wb3J0IHsgZGVmYXVsdE1ldGhvZCB9IGZyb20gJy4vdXRpbHMvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMnO1xuaW1wb3J0IHsgbm9ybWFsaXplSGFuZGxlciB9IGZyb20gJy4vdXRpbHMvbm9ybWFsaXplSGFuZGxlci5qcyc7XG5pbXBvcnQgeyBXb3JrYm94RXJyb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIFRoZSBSb3V0ZXIgY2FuIGJlIHVzZWQgdG8gcHJvY2VzcyBhIEZldGNoRXZlbnQgdGhyb3VnaCBvbmUgb3IgbW9yZVxuICogW1JvdXRlc117QGxpbmsgbW9kdWxlOndvcmtib3gtcm91dGluZy5Sb3V0ZX0gcmVzcG9uZGluZyAgd2l0aCBhIFJlcXVlc3QgaWZcbiAqIGEgbWF0Y2hpbmcgcm91dGUgZXhpc3RzLlxuICpcbiAqIElmIG5vIHJvdXRlIG1hdGNoZXMgYSBnaXZlbiBhIHJlcXVlc3QsIHRoZSBSb3V0ZXIgd2lsbCB1c2UgYSBcImRlZmF1bHRcIlxuICogaGFuZGxlciBpZiBvbmUgaXMgZGVmaW5lZC5cbiAqXG4gKiBTaG91bGQgdGhlIG1hdGNoaW5nIFJvdXRlIHRocm93IGFuIGVycm9yLCB0aGUgUm91dGVyIHdpbGwgdXNlIGEgXCJjYXRjaFwiXG4gKiBoYW5kbGVyIGlmIG9uZSBpcyBkZWZpbmVkIHRvIGdyYWNlZnVsbHkgZGVhbCB3aXRoIGlzc3VlcyBhbmQgcmVzcG9uZCB3aXRoIGFcbiAqIFJlcXVlc3QuXG4gKlxuICogSWYgYSByZXF1ZXN0IG1hdGNoZXMgbXVsdGlwbGUgcm91dGVzLCB0aGUgKiplYXJsaWVzdCoqIHJlZ2lzdGVyZWQgcm91dGUgd2lsbFxuICogYmUgdXNlZCB0byByZXNwb25kIHRvIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1yb3V0aW5nXG4gKi9cbmNsYXNzIFJvdXRlciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgUm91dGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9yb3V0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRIYW5kbGVyTWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtNYXA8c3RyaW5nLCBBcnJheTxtb2R1bGU6d29ya2JveC1yb3V0aW5nLlJvdXRlPj59IHJvdXRlcyBBIGBNYXBgIG9mIEhUVFBcbiAgICAgKiBtZXRob2QgbmFtZSAoJ0dFVCcsIGV0Yy4pIHRvIGFuIGFycmF5IG9mIGFsbCB0aGUgY29ycmVzcG9uZGluZyBgUm91dGVgXG4gICAgICogaW5zdGFuY2VzIHRoYXQgYXJlIHJlZ2lzdGVyZWQuXG4gICAgICovXG4gICAgZ2V0IHJvdXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvdXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGZldGNoIGV2ZW50IGxpc3RlbmVyIHRvIHJlc3BvbmQgdG8gZXZlbnRzIHdoZW4gYSByb3V0ZSBtYXRjaGVzXG4gICAgICogdGhlIGV2ZW50J3MgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhZGRGZXRjaExpc3RlbmVyKCkge1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yODM1NyNpc3N1ZWNvbW1lbnQtNDM2NDg0NzA1XG4gICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignZmV0Y2gnLCAoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHJlcXVlc3QgfSA9IGV2ZW50O1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gdGhpcy5oYW5kbGVSZXF1ZXN0KHsgcmVxdWVzdCwgZXZlbnQgfSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucmVzcG9uZFdpdGgocmVzcG9uc2VQcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbWVzc2FnZSBldmVudCBsaXN0ZW5lciBmb3IgVVJMcyB0byBjYWNoZSBmcm9tIHRoZSB3aW5kb3cuXG4gICAgICogVGhpcyBpcyB1c2VmdWwgdG8gY2FjaGUgcmVzb3VyY2VzIGxvYWRlZCBvbiB0aGUgcGFnZSBwcmlvciB0byB3aGVuIHRoZVxuICAgICAqIHNlcnZpY2Ugd29ya2VyIHN0YXJ0ZWQgY29udHJvbGxpbmcgaXQuXG4gICAgICpcbiAgICAgKiBUaGUgZm9ybWF0IG9mIHRoZSBtZXNzYWdlIGRhdGEgc2VudCBmcm9tIHRoZSB3aW5kb3cgc2hvdWxkIGJlIGFzIGZvbGxvd3MuXG4gICAgICogV2hlcmUgdGhlIGB1cmxzVG9DYWNoZWAgYXJyYXkgbWF5IGNvbnNpc3Qgb2YgVVJMIHN0cmluZ3Mgb3IgYW4gYXJyYXkgb2ZcbiAgICAgKiBVUkwgc3RyaW5nICsgYHJlcXVlc3RJbml0YCBvYmplY3QgKHRoZSBzYW1lIGFzIHlvdSdkIHBhc3MgdG8gYGZldGNoKClgKS5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHtcbiAgICAgKiAgIHR5cGU6ICdDQUNIRV9VUkxTJyxcbiAgICAgKiAgIHBheWxvYWQ6IHtcbiAgICAgKiAgICAgdXJsc1RvQ2FjaGU6IFtcbiAgICAgKiAgICAgICAnLi9zY3JpcHQxLmpzJyxcbiAgICAgKiAgICAgICAnLi9zY3JpcHQyLmpzJyxcbiAgICAgKiAgICAgICBbJy4vc2NyaXB0My5qcycsIHttb2RlOiAnbm8tY29ycyd9XSxcbiAgICAgKiAgICAgXSxcbiAgICAgKiAgIH0sXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFkZENhY2hlTGlzdGVuZXIoKSB7XG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzI4MzU3I2lzc3VlY29tbWVudC00MzY0ODQ3MDVcbiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS50eXBlID09PSAnQ0FDSEVfVVJMUycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBheWxvYWQgfSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBDYWNoaW5nIFVSTHMgZnJvbSB0aGUgd2luZG93YCwgcGF5bG9hZC51cmxzVG9DYWNoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RQcm9taXNlcyA9IFByb21pc2UuYWxsKHBheWxvYWQudXJsc1RvQ2FjaGUubWFwKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkgPSBbZW50cnldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCguLi5lbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJlcXVlc3QoeyByZXF1ZXN0LCBldmVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhwaGlsaXB3YWx0b24pOiBUeXBlU2NyaXB0IGVycm9ycyB3aXRob3V0IHRoaXMgdHlwZWNhc3QgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvbWUgcmVhc29uIChwcm9iYWJseSBhIGJ1ZykuIFRoZSByZWFsIHR5cGUgaGVyZSBzaG91bGQgd29yayBidXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9lc24ndDogYEFycmF5PFByb21pc2U8UmVzcG9uc2U+IHwgdW5kZWZpbmVkPmAuXG4gICAgICAgICAgICAgICAgfSkpOyAvLyBUeXBlU2NyaXB0XG4gICAgICAgICAgICAgICAgZXZlbnQud2FpdFVudGlsKHJlcXVlc3RQcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBNZXNzYWdlQ2hhbm5lbCB3YXMgdXNlZCwgcmVwbHkgdG8gdGhlIG1lc3NhZ2Ugb24gc3VjY2Vzcy5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQucG9ydHMgJiYgZXZlbnQucG9ydHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFByb21pc2VzLnRoZW4oKCkgPT4gZXZlbnQucG9ydHNbMF0ucG9zdE1lc3NhZ2UodHJ1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgcm91dGluZyBydWxlcyB0byBhIEZldGNoRXZlbnQgb2JqZWN0IHRvIGdldCBhIFJlc3BvbnNlIGZyb20gYW5cbiAgICAgKiBhcHByb3ByaWF0ZSBSb3V0ZSdzIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7UmVxdWVzdH0gb3B0aW9ucy5yZXF1ZXN0IFRoZSByZXF1ZXN0IHRvIGhhbmRsZS5cbiAgICAgKiBAcGFyYW0ge0V4dGVuZGFibGVFdmVudH0gb3B0aW9ucy5ldmVudCBUaGUgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhlXG4gICAgICogICAgIHJlcXVlc3QuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxSZXNwb25zZT58dW5kZWZpbmVkfSBBIHByb21pc2UgaXMgcmV0dXJuZWQgaWYgYVxuICAgICAqICAgICByZWdpc3RlcmVkIHJvdXRlIGNhbiBoYW5kbGUgdGhlIHJlcXVlc3QuIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nXG4gICAgICogICAgIHJvdXRlIGFuZCB0aGVyZSdzIG5vIGBkZWZhdWx0SGFuZGxlcmAsIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGhhbmRsZVJlcXVlc3QoeyByZXF1ZXN0LCBldmVudCB9KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBhc3NlcnQuaXNJbnN0YW5jZShyZXF1ZXN0LCBSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUm91dGVyJyxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ2hhbmRsZVJlcXVlc3QnLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ29wdGlvbnMucmVxdWVzdCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsLCBsb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgaWYgKCF1cmwucHJvdG9jb2wuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgV29ya2JveCBSb3V0ZXIgb25seSBzdXBwb3J0cyBVUkxzIHRoYXQgc3RhcnQgd2l0aCAnaHR0cCcuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2FtZU9yaWdpbiA9IHVybC5vcmlnaW4gPT09IGxvY2F0aW9uLm9yaWdpbjtcbiAgICAgICAgY29uc3QgeyBwYXJhbXMsIHJvdXRlIH0gPSB0aGlzLmZpbmRNYXRjaGluZ1JvdXRlKHtcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHNhbWVPcmlnaW4sXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgaGFuZGxlciA9IHJvdXRlICYmIHJvdXRlLmhhbmRsZXI7XG4gICAgICAgIGNvbnN0IGRlYnVnTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgZGVidWdNZXNzYWdlcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgYEZvdW5kIGEgcm91dGUgdG8gaGFuZGxlIHRoaXMgcmVxdWVzdDpgLCByb3V0ZSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTWVzc2FnZXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBgUGFzc2luZyB0aGUgZm9sbG93aW5nIHBhcmFtcyB0byB0aGUgcm91dGUncyBoYW5kbGVyOmAsIHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBoYW5kbGVyIGJlY2F1c2UgdGhlcmUgd2FzIG5vIG1hdGNoaW5nIHJvdXRlLCB0aGVuXG4gICAgICAgIC8vIGZhbGwgYmFjayB0byBkZWZhdWx0SGFuZGxlciBpZiB0aGF0J3MgZGVmaW5lZC5cbiAgICAgICAgY29uc3QgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgICAgIGlmICghaGFuZGxlciAmJiB0aGlzLl9kZWZhdWx0SGFuZGxlck1hcC5oYXMobWV0aG9kKSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z01lc3NhZ2VzLnB1c2goYEZhaWxlZCB0byBmaW5kIGEgbWF0Y2hpbmcgcm91dGUuIEZhbGxpbmcgYCArXG4gICAgICAgICAgICAgICAgICAgIGBiYWNrIHRvIHRoZSBkZWZhdWx0IGhhbmRsZXIgZm9yICR7bWV0aG9kfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZXIgPSB0aGlzLl9kZWZhdWx0SGFuZGxlck1hcC5nZXQobWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gaGFuZGxlciBzbyBXb3JrYm94IHdpbGwgZG8gbm90aGluZy4gSWYgbG9ncyBpcyBzZXQgb2YgZGVidWdcbiAgICAgICAgICAgICAgICAvLyBpLmUuIHZlcmJvc2UsIHdlIHNob3VsZCBwcmludCBvdXQgdGhpcyBpbmZvcm1hdGlvbi5cbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYE5vIHJvdXRlIGZvdW5kIGZvcjogJHtnZXRGcmllbmRseVVSTCh1cmwpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGEgaGFuZGxlciwgbWVhbmluZyBXb3JrYm94IGlzIGdvaW5nIHRvIGhhbmRsZSB0aGUgcm91dGUuXG4gICAgICAgICAgICAvLyBwcmludCB0aGUgcm91dGluZyBkZXRhaWxzIHRvIHRoZSBjb25zb2xlLlxuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBSb3V0ZXIgaXMgcmVzcG9uZGluZyB0bzogJHtnZXRGcmllbmRseVVSTCh1cmwpfWApO1xuICAgICAgICAgICAgZGVidWdNZXNzYWdlcy5mb3JFYWNoKChtc2cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtc2cpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coLi4ubXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2cobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdyYXAgaW4gdHJ5IGFuZCBjYXRjaCBpbiBjYXNlIHRoZSBoYW5kbGUgbWV0aG9kIHRocm93cyBhIHN5bmNocm9ub3VzXG4gICAgICAgIC8vIGVycm9yLiBJdCBzaG91bGQgc3RpbGwgY2FsbGJhY2sgdG8gdGhlIGNhdGNoIGhhbmRsZXIuXG4gICAgICAgIGxldCByZXNwb25zZVByb21pc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2UgPSBoYW5kbGVyLmhhbmRsZSh7IHVybCwgcmVxdWVzdCwgZXZlbnQsIHBhcmFtcyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2UgPSBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlICYmIHRoaXMuX2NhdGNoSGFuZGxlcikge1xuICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlID0gcmVzcG9uc2VQcm9taXNlLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGlsbCBpbmNsdWRlIFVSTCBoZXJlIGFzIGl0IHdpbGwgYmUgYXN5bmMgZnJvbSB0aGUgY29uc29sZSBncm91cFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbWF5IG5vdCBtYWtlIHNlbnNlIHdpdGhvdXQgdGhlIFVSTFxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoYEVycm9yIHRocm93biB3aGVuIHJlc3BvbmRpbmcgdG86IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCAke2dldEZyaWVuZGx5VVJMKHVybCl9LiBGYWxsaW5nIGJhY2sgdG8gQ2F0Y2ggSGFuZGxlci5gKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBFcnJvciB0aHJvd24gYnk6YCwgcm91dGUpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYXRjaEhhbmRsZXIuaGFuZGxlKHsgdXJsLCByZXF1ZXN0LCBldmVudCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBhIHJlcXVlc3QgYW5kIFVSTCAoYW5kIG9wdGlvbmFsbHkgYW4gZXZlbnQpIGFnYWluc3QgdGhlIGxpc3Qgb2ZcbiAgICAgKiByZWdpc3RlcmVkIHJvdXRlcywgYW5kIGlmIHRoZXJlJ3MgYSBtYXRjaCwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqIHJvdXRlIGFsb25nIHdpdGggYW55IHBhcmFtcyBnZW5lcmF0ZWQgYnkgdGhlIG1hdGNoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1VSTH0gb3B0aW9ucy51cmxcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R9IG9wdGlvbnMucmVxdWVzdCBUaGUgcmVxdWVzdCB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBvcHRpb25zLmV2ZW50IFRoZSBjb3JyZXNwb25kaW5nIGV2ZW50LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggYHJvdXRlYCBhbmQgYHBhcmFtc2AgcHJvcGVydGllcy5cbiAgICAgKiAgICAgVGhleSBhcmUgcG9wdWxhdGVkIGlmIGEgbWF0Y2hpbmcgcm91dGUgd2FzIGZvdW5kIG9yIGB1bmRlZmluZWRgXG4gICAgICogICAgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBmaW5kTWF0Y2hpbmdSb3V0ZSh7IHVybCwgc2FtZU9yaWdpbiwgcmVxdWVzdCwgZXZlbnQgfSkge1xuICAgICAgICBjb25zdCByb3V0ZXMgPSB0aGlzLl9yb3V0ZXMuZ2V0KHJlcXVlc3QubWV0aG9kKSB8fCBbXTtcbiAgICAgICAgZm9yIChjb25zdCByb3V0ZSBvZiByb3V0ZXMpIHtcbiAgICAgICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgICAgICBjb25zdCBtYXRjaFJlc3VsdCA9IHJvdXRlLm1hdGNoKHsgdXJsLCBzYW1lT3JpZ2luLCByZXF1ZXN0LCBldmVudCB9KTtcbiAgICAgICAgICAgIGlmIChtYXRjaFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdhcm4gZGV2ZWxvcGVycyB0aGF0IHVzaW5nIGFuIGFzeW5jIG1hdGNoQ2FsbGJhY2sgaXMgYWxtb3N0IGFsd2F5c1xuICAgICAgICAgICAgICAgICAgICAvLyBub3QgdGhlIHJpZ2h0IHRoaW5nIHRvIGRvLiBcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoUmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFdoaWxlIHJvdXRpbmcgJHtnZXRGcmllbmRseVVSTCh1cmwpfSwgYW4gYXN5bmMgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYG1hdGNoQ2FsbGJhY2sgZnVuY3Rpb24gd2FzIHVzZWQuIFBsZWFzZSBjb252ZXJ0IHRoZSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgZm9sbG93aW5nIHJvdXRlIHRvIHVzZSBhIHN5bmNocm9ub3VzIG1hdGNoQ2FsbGJhY2sgZnVuY3Rpb246YCwgcm91dGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL3dvcmtib3gvaXNzdWVzLzIwNzlcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBtYXRjaFJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRjaFJlc3VsdCkgJiYgbWF0Y2hSZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgcGFzc2luZyBhbiBlbXB0eSBhcnJheSBpbiBhcyBwYXJhbXMsIHVzZSB1bmRlZmluZWQuXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKG1hdGNoUmVzdWx0LmNvbnN0cnVjdG9yID09PSBPYmplY3QgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMobWF0Y2hSZXN1bHQpLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiBwYXNzaW5nIGFuIGVtcHR5IG9iamVjdCBpbiBhcyBwYXJhbXMsIHVzZSB1bmRlZmluZWQuXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1hdGNoUmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHRoZSBib29sZWFuIHZhbHVlIHRydWUgKHJhdGhlciB0aGFuIGp1c3Qgc29tZXRoaW5nIHRydXRoLXkpLFxuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzZXQgcGFyYW1zLlxuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L3B1bGwvMjEzNCNpc3N1ZWNvbW1lbnQtNTEzOTI0MzUzXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGlmIGhhdmUgYSBtYXRjaC5cbiAgICAgICAgICAgICAgICByZXR1cm4geyByb3V0ZSwgcGFyYW1zIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gbWF0Y2ggd2FzIGZvdW5kIGFib3ZlLCByZXR1cm4gYW5kIGVtcHR5IG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgYSBkZWZhdWx0IGBoYW5kbGVyYCB0aGF0J3MgY2FsbGVkIHdoZW4gbm8gcm91dGVzIGV4cGxpY2l0bHlcbiAgICAgKiBtYXRjaCB0aGUgaW5jb21pbmcgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEVhY2ggSFRUUCBtZXRob2QgKCdHRVQnLCAnUE9TVCcsIGV0Yy4pIGdldHMgaXRzIG93biBkZWZhdWx0IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBXaXRob3V0IGEgZGVmYXVsdCBoYW5kbGVyLCB1bm1hdGNoZWQgcmVxdWVzdHMgd2lsbCBnbyBhZ2FpbnN0IHRoZVxuICAgICAqIG5ldHdvcmsgYXMgaWYgdGhlcmUgd2VyZSBubyBzZXJ2aWNlIHdvcmtlciBwcmVzZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6d29ya2JveC1yb3V0aW5nfmhhbmRsZXJDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrXG4gICAgICogZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZSByZXN1bHRpbmcgaW4gYSBSZXNwb25zZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21ldGhvZD0nR0VUJ10gVGhlIEhUVFAgbWV0aG9kIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXNcbiAgICAgKiBkZWZhdWx0IGhhbmRsZXIuIEVhY2ggbWV0aG9kIGhhcyBpdHMgb3duIGRlZmF1bHQuXG4gICAgICovXG4gICAgc2V0RGVmYXVsdEhhbmRsZXIoaGFuZGxlciwgbWV0aG9kID0gZGVmYXVsdE1ldGhvZCkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0SGFuZGxlck1hcC5zZXQobWV0aG9kLCBub3JtYWxpemVIYW5kbGVyKGhhbmRsZXIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgYSBSb3V0ZSB0aHJvd3MgYW4gZXJyb3Igd2hpbGUgaGFuZGxpbmcgYSByZXF1ZXN0LCB0aGlzIGBoYW5kbGVyYFxuICAgICAqIHdpbGwgYmUgY2FsbGVkIGFuZCBnaXZlbiBhIGNoYW5jZSB0byBwcm92aWRlIGEgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp3b3JrYm94LXJvdXRpbmd+aGFuZGxlckNhbGxiYWNrfSBoYW5kbGVyIEEgY2FsbGJhY2tcbiAgICAgKiBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBQcm9taXNlIHJlc3VsdGluZyBpbiBhIFJlc3BvbnNlLlxuICAgICAqL1xuICAgIHNldENhdGNoSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX2NhdGNoSGFuZGxlciA9IG5vcm1hbGl6ZUhhbmRsZXIoaGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIHJvdXRlIHdpdGggdGhlIHJvdXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtcm91dGluZy5Sb3V0ZX0gcm91dGUgVGhlIHJvdXRlIHRvIHJlZ2lzdGVyLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyUm91dGUocm91dGUpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc1R5cGUocm91dGUsICdvYmplY3QnLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUm91dGVyJyxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ3JlZ2lzdGVyUm91dGUnLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ3JvdXRlJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXNzZXJ0Lmhhc01ldGhvZChyb3V0ZSwgJ21hdGNoJywge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXJvdXRpbmcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1JvdXRlcicsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdyZWdpc3RlclJvdXRlJyxcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdyb3V0ZScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFzc2VydC5pc1R5cGUocm91dGUuaGFuZGxlciwgJ29iamVjdCcsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdSb3V0ZXInLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAncmVnaXN0ZXJSb3V0ZScsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAncm91dGUnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3NlcnQuaGFzTWV0aG9kKHJvdXRlLmhhbmRsZXIsICdoYW5kbGUnLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUm91dGVyJyxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ3JlZ2lzdGVyUm91dGUnLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ3JvdXRlLmhhbmRsZXInLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3NlcnQuaXNUeXBlKHJvdXRlLm1ldGhvZCwgJ3N0cmluZycsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdSb3V0ZXInLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAncmVnaXN0ZXJSb3V0ZScsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAncm91dGUubWV0aG9kJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fcm91dGVzLmhhcyhyb3V0ZS5tZXRob2QpKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3V0ZXMuc2V0KHJvdXRlLm1ldGhvZCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdpdmUgcHJlY2VkZW5jZSB0byBhbGwgb2YgdGhlIGVhcmxpZXIgcm91dGVzIGJ5IGFkZGluZyB0aGlzIGFkZGl0aW9uYWxcbiAgICAgICAgLy8gcm91dGUgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICAgIHRoaXMuX3JvdXRlcy5nZXQocm91dGUubWV0aG9kKS5wdXNoKHJvdXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlcnMgYSByb3V0ZSB3aXRoIHRoZSByb3V0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp3b3JrYm94LXJvdXRpbmcuUm91dGV9IHJvdXRlIFRoZSByb3V0ZSB0byB1bnJlZ2lzdGVyLlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXJSb3V0ZShyb3V0ZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3JvdXRlcy5oYXMocm91dGUubWV0aG9kKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcigndW5yZWdpc3Rlci1yb3V0ZS1idXQtbm90LWZvdW5kLXdpdGgtbWV0aG9kJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcm91dGUubWV0aG9kLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGVJbmRleCA9IHRoaXMuX3JvdXRlcy5nZXQocm91dGUubWV0aG9kKS5pbmRleE9mKHJvdXRlKTtcbiAgICAgICAgaWYgKHJvdXRlSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fcm91dGVzLmdldChyb3V0ZS5tZXRob2QpLnNwbGljZShyb3V0ZUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ3VucmVnaXN0ZXItcm91dGUtcm91dGUtbm90LXJlZ2lzdGVyZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCB7IFJvdXRlciB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgUm91dGVyIH0gZnJvbSAnLi4vUm91dGVyLmpzJztcbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xubGV0IGRlZmF1bHRSb3V0ZXI7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIHNpbmdsZXRvbiBSb3V0ZXIgaW5zdGFuY2UgaWYgb25lIGRvZXMgbm90IGV4aXN0LiBJZiBvbmVcbiAqIGRvZXMgYWxyZWFkeSBleGlzdCwgdGhhdCBpbnN0YW5jZSBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7Um91dGVyfVxuICovXG5leHBvcnQgY29uc3QgZ2V0T3JDcmVhdGVEZWZhdWx0Um91dGVyID0gKCkgPT4ge1xuICAgIGlmICghZGVmYXVsdFJvdXRlcikge1xuICAgICAgICBkZWZhdWx0Um91dGVyID0gbmV3IFJvdXRlcigpO1xuICAgICAgICAvLyBUaGUgaGVscGVycyB0aGF0IHVzZSB0aGUgZGVmYXVsdCBSb3V0ZXIgYXNzdW1lIHRoZXNlIGxpc3RlbmVycyBleGlzdC5cbiAgICAgICAgZGVmYXVsdFJvdXRlci5hZGRGZXRjaExpc3RlbmVyKCk7XG4gICAgICAgIGRlZmF1bHRSb3V0ZXIuYWRkQ2FjaGVMaXN0ZW5lcigpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFJvdXRlcjtcbn07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IFdvcmtib3hFcnJvciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9Xb3JrYm94RXJyb3IuanMnO1xuaW1wb3J0IHsgUm91dGUgfSBmcm9tICcuL1JvdXRlLmpzJztcbmltcG9ydCB7IFJlZ0V4cFJvdXRlIH0gZnJvbSAnLi9SZWdFeHBSb3V0ZS5qcyc7XG5pbXBvcnQgeyBnZXRPckNyZWF0ZURlZmF1bHRSb3V0ZXIgfSBmcm9tICcuL3V0aWxzL2dldE9yQ3JlYXRlRGVmYXVsdFJvdXRlci5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBFYXNpbHkgcmVnaXN0ZXIgYSBSZWdFeHAsIHN0cmluZywgb3IgZnVuY3Rpb24gd2l0aCBhIGNhY2hpbmdcbiAqIHN0cmF0ZWd5IHRvIGEgc2luZ2xldG9uIFJvdXRlciBpbnN0YW5jZS5cbiAqXG4gKiBUaGlzIG1ldGhvZCB3aWxsIGdlbmVyYXRlIGEgUm91dGUgZm9yIHlvdSBpZiBuZWVkZWQgYW5kXG4gKiBjYWxsIFtyZWdpc3RlclJvdXRlKClde0BsaW5rIG1vZHVsZTp3b3JrYm94LXJvdXRpbmcuUm91dGVyI3JlZ2lzdGVyUm91dGV9LlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ3xtb2R1bGU6d29ya2JveC1yb3V0aW5nLlJvdXRlfm1hdGNoQ2FsbGJhY2t8bW9kdWxlOndvcmtib3gtcm91dGluZy5Sb3V0ZX0gY2FwdHVyZVxuICogSWYgdGhlIGNhcHR1cmUgcGFyYW0gaXMgYSBgUm91dGVgLCBhbGwgb3RoZXIgYXJndW1lbnRzIHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtcm91dGluZ35oYW5kbGVyQ2FsbGJhY2t9IFtoYW5kbGVyXSBBIGNhbGxiYWNrXG4gKiBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBQcm9taXNlIHJlc3VsdGluZyBpbiBhIFJlc3BvbnNlLiBUaGlzIHBhcmFtZXRlclxuICogaXMgcmVxdWlyZWQgaWYgYGNhcHR1cmVgIGlzIG5vdCBhIGBSb3V0ZWAgb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IFttZXRob2Q9J0dFVCddIFRoZSBIVFRQIG1ldGhvZCB0byBtYXRjaCB0aGUgUm91dGVcbiAqIGFnYWluc3QuXG4gKiBAcmV0dXJuIHttb2R1bGU6d29ya2JveC1yb3V0aW5nLlJvdXRlfSBUaGUgZ2VuZXJhdGVkIGBSb3V0ZWAoVXNlZnVsIGZvclxuICogdW5yZWdpc3RlcmluZykuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXJvdXRpbmdcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJSb3V0ZShjYXB0dXJlLCBoYW5kbGVyLCBtZXRob2QpIHtcbiAgICBsZXQgcm91dGU7XG4gICAgaWYgKHR5cGVvZiBjYXB0dXJlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBjYXB0dXJlVXJsID0gbmV3IFVSTChjYXB0dXJlLCBsb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGlmICghKGNhcHR1cmUuc3RhcnRzV2l0aCgnLycpIHx8IGNhcHR1cmUuc3RhcnRzV2l0aCgnaHR0cCcpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2ludmFsaWQtc3RyaW5nJywge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6ICdyZWdpc3RlclJvdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnY2FwdHVyZScsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSB3YW50IHRvIGNoZWNrIGlmIEV4cHJlc3Mtc3R5bGUgd2lsZGNhcmRzIGFyZSBpbiB0aGUgcGF0aG5hbWUgb25seS5cbiAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIGxvZyBtZXNzYWdlIGluIHY0LlxuICAgICAgICAgICAgY29uc3QgdmFsdWVUb0NoZWNrID0gY2FwdHVyZS5zdGFydHNXaXRoKCdodHRwJykgP1xuICAgICAgICAgICAgICAgIGNhcHR1cmVVcmwucGF0aG5hbWUgOiBjYXB0dXJlO1xuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waWxsYXJqcy9wYXRoLXRvLXJlZ2V4cCNwYXJhbWV0ZXJzXG4gICAgICAgICAgICBjb25zdCB3aWxkY2FyZHMgPSAnWyo6PytdJztcbiAgICAgICAgICAgIGlmICgobmV3IFJlZ0V4cChgJHt3aWxkY2FyZHN9YCkpLmV4ZWModmFsdWVUb0NoZWNrKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgVGhlICckY2FwdHVyZScgcGFyYW1ldGVyIGNvbnRhaW5zIGFuIEV4cHJlc3Mtc3R5bGUgd2lsZGNhcmQgYCArXG4gICAgICAgICAgICAgICAgICAgIGBjaGFyYWN0ZXIgKCR7d2lsZGNhcmRzfSkuIFN0cmluZ3MgYXJlIG5vdyBhbHdheXMgaW50ZXJwcmV0ZWQgYXMgYCArXG4gICAgICAgICAgICAgICAgICAgIGBleGFjdCBtYXRjaGVzOyB1c2UgYSBSZWdFeHAgZm9yIHBhcnRpYWwgb3Igd2lsZGNhcmQgbWF0Y2hlcy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaENhbGxiYWNrID0gKHsgdXJsIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh1cmwucGF0aG5hbWUgPT09IGNhcHR1cmVVcmwucGF0aG5hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgICh1cmwub3JpZ2luICE9PSBjYXB0dXJlVXJsLm9yaWdpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGAke2NhcHR1cmV9IG9ubHkgcGFydGlhbGx5IG1hdGNoZXMgdGhlIGNyb3NzLW9yaWdpbiBVUkwgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHt1cmx9LiBUaGlzIHJvdXRlIHdpbGwgb25seSBoYW5kbGUgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGlmIHRoZXkgbWF0Y2ggdGhlIGVudGlyZSBVUkwuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVybC5ocmVmID09PSBjYXB0dXJlVXJsLmhyZWY7XG4gICAgICAgIH07XG4gICAgICAgIC8vIElmIGBjYXB0dXJlYCBpcyBhIHN0cmluZyB0aGVuIGBoYW5kbGVyYCBhbmQgYG1ldGhvZGAgbXVzdCBiZSBwcmVzZW50LlxuICAgICAgICByb3V0ZSA9IG5ldyBSb3V0ZShtYXRjaENhbGxiYWNrLCBoYW5kbGVyLCBtZXRob2QpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjYXB0dXJlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIC8vIElmIGBjYXB0dXJlYCBpcyBhIGBSZWdFeHBgIHRoZW4gYGhhbmRsZXJgIGFuZCBgbWV0aG9kYCBtdXN0IGJlIHByZXNlbnQuXG4gICAgICAgIHJvdXRlID0gbmV3IFJlZ0V4cFJvdXRlKGNhcHR1cmUsIGhhbmRsZXIsIG1ldGhvZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBjYXB0dXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIElmIGBjYXB0dXJlYCBpcyBhIGZ1bmN0aW9uIHRoZW4gYGhhbmRsZXJgIGFuZCBgbWV0aG9kYCBtdXN0IGJlIHByZXNlbnQuXG4gICAgICAgIHJvdXRlID0gbmV3IFJvdXRlKGNhcHR1cmUsIGhhbmRsZXIsIG1ldGhvZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNhcHR1cmUgaW5zdGFuY2VvZiBSb3V0ZSkge1xuICAgICAgICByb3V0ZSA9IGNhcHR1cmU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCd1bnN1cHBvcnRlZC1yb3V0ZS10eXBlJywge1xuICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgICAgICBmdW5jTmFtZTogJ3JlZ2lzdGVyUm91dGUnLFxuICAgICAgICAgICAgcGFyYW1OYW1lOiAnY2FwdHVyZScsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0Um91dGVyID0gZ2V0T3JDcmVhdGVEZWZhdWx0Um91dGVyKCk7XG4gICAgZGVmYXVsdFJvdXRlci5yZWdpc3RlclJvdXRlKHJvdXRlKTtcbiAgICByZXR1cm4gcm91dGU7XG59XG5leHBvcnQgeyByZWdpc3RlclJvdXRlIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogUmVtb3ZlcyBhbnkgVVJMIHNlYXJjaCBwYXJhbWV0ZXJzIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHtVUkx9IHVybE9iamVjdCBUaGUgb3JpZ2luYWwgVVJMLlxuICogQHBhcmFtIHtBcnJheTxSZWdFeHA+fSBpZ25vcmVVUkxQYXJhbWV0ZXJzTWF0Y2hpbmcgUmVnRXhwcyB0byB0ZXN0IGFnYWluc3RcbiAqIGVhY2ggc2VhcmNoIHBhcmFtZXRlciBuYW1lLiBNYXRjaGVzIG1lYW4gdGhhdCB0aGUgc2VhcmNoIHBhcmFtZXRlciBzaG91bGQgYmVcbiAqIGlnbm9yZWQuXG4gKiBAcmV0dXJuIHtVUkx9IFRoZSBVUkwgd2l0aCBhbnkgaWdub3JlZCBzZWFyY2ggcGFyYW1ldGVycyByZW1vdmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlSWdub3JlZFNlYXJjaFBhcmFtcyh1cmxPYmplY3QsIGlnbm9yZVVSTFBhcmFtZXRlcnNNYXRjaGluZyA9IFtdKSB7XG4gICAgLy8gQ29udmVydCB0aGUgaXRlcmFibGUgaW50byBhbiBhcnJheSBhdCB0aGUgc3RhcnQgb2YgdGhlIGxvb3AgdG8gbWFrZSBzdXJlXG4gICAgLy8gZGVsZXRpb24gZG9lc24ndCBtZXNzIHVwIGl0ZXJhdGlvbi5cbiAgICBmb3IgKGNvbnN0IHBhcmFtTmFtZSBvZiBbLi4udXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5rZXlzKCldKSB7XG4gICAgICAgIGlmIChpZ25vcmVVUkxQYXJhbWV0ZXJzTWF0Y2hpbmcuc29tZSgocmVnRXhwKSA9PiByZWdFeHAudGVzdChwYXJhbU5hbWUpKSkge1xuICAgICAgICAgICAgdXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5kZWxldGUocGFyYW1OYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXJsT2JqZWN0O1xufVxuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgcmVtb3ZlSWdub3JlZFNlYXJjaFBhcmFtcyB9IGZyb20gJy4vcmVtb3ZlSWdub3JlZFNlYXJjaFBhcmFtcy5qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogR2VuZXJhdG9yIGZ1bmN0aW9uIHRoYXQgeWllbGRzIHBvc3NpYmxlIHZhcmlhdGlvbnMgb24gdGhlIG9yaWdpbmFsIFVSTCB0b1xuICogY2hlY2ssIG9uZSBhdCBhIHRpbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uKiBnZW5lcmF0ZVVSTFZhcmlhdGlvbnModXJsLCB7IGlnbm9yZVVSTFBhcmFtZXRlcnNNYXRjaGluZyA9IFsvXnV0bV8vLCAvXmZiY2xpZCQvXSwgZGlyZWN0b3J5SW5kZXggPSAnaW5kZXguaHRtbCcsIGNsZWFuVVJMcyA9IHRydWUsIHVybE1hbmlwdWxhdGlvbiwgfSA9IHt9KSB7XG4gICAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLmhyZWYpO1xuICAgIHVybE9iamVjdC5oYXNoID0gJyc7XG4gICAgeWllbGQgdXJsT2JqZWN0LmhyZWY7XG4gICAgY29uc3QgdXJsV2l0aG91dElnbm9yZWRQYXJhbXMgPSByZW1vdmVJZ25vcmVkU2VhcmNoUGFyYW1zKHVybE9iamVjdCwgaWdub3JlVVJMUGFyYW1ldGVyc01hdGNoaW5nKTtcbiAgICB5aWVsZCB1cmxXaXRob3V0SWdub3JlZFBhcmFtcy5ocmVmO1xuICAgIGlmIChkaXJlY3RvcnlJbmRleCAmJiB1cmxXaXRob3V0SWdub3JlZFBhcmFtcy5wYXRobmFtZS5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgIGNvbnN0IGRpcmVjdG9yeVVSTCA9IG5ldyBVUkwodXJsV2l0aG91dElnbm9yZWRQYXJhbXMuaHJlZik7XG4gICAgICAgIGRpcmVjdG9yeVVSTC5wYXRobmFtZSArPSBkaXJlY3RvcnlJbmRleDtcbiAgICAgICAgeWllbGQgZGlyZWN0b3J5VVJMLmhyZWY7XG4gICAgfVxuICAgIGlmIChjbGVhblVSTHMpIHtcbiAgICAgICAgY29uc3QgY2xlYW5VUkwgPSBuZXcgVVJMKHVybFdpdGhvdXRJZ25vcmVkUGFyYW1zLmhyZWYpO1xuICAgICAgICBjbGVhblVSTC5wYXRobmFtZSArPSAnLmh0bWwnO1xuICAgICAgICB5aWVsZCBjbGVhblVSTC5ocmVmO1xuICAgIH1cbiAgICBpZiAodXJsTWFuaXB1bGF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uYWxVUkxzID0gdXJsTWFuaXB1bGF0aW9uKHsgdXJsOiB1cmxPYmplY3QgfSk7XG4gICAgICAgIGZvciAoY29uc3QgdXJsVG9BdHRlbXB0IG9mIGFkZGl0aW9uYWxVUkxzKSB7XG4gICAgICAgICAgICB5aWVsZCB1cmxUb0F0dGVtcHQuaHJlZjtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qXG4gIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMnO1xuaW1wb3J0IHsgZ2V0RnJpZW5kbHlVUkwgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwuanMnO1xuaW1wb3J0IHsgUm91dGUgfSBmcm9tICd3b3JrYm94LXJvdXRpbmcvUm91dGUuanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVVUkxWYXJpYXRpb25zIH0gZnJvbSAnLi91dGlscy9nZW5lcmF0ZVVSTFZhcmlhdGlvbnMuanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogQSBzdWJjbGFzcyBvZiBbUm91dGVde0BsaW5rIG1vZHVsZTp3b3JrYm94LXJvdXRpbmcuUm91dGV9IHRoYXQgdGFrZXMgYVxuICogW1ByZWNhY2hlQ29udHJvbGxlcl17QGxpbmsgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5QcmVjYWNoZUNvbnRyb2xsZXJ9XG4gKiBpbnN0YW5jZSBhbmQgdXNlcyBpdCB0byBtYXRjaCBpbmNvbWluZyByZXF1ZXN0cyBhbmQgaGFuZGxlIGZldGNoaW5nXG4gKiByZXNwb25zZXMgZnJvbSB0aGUgcHJlY2FjaGUuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmdcbiAqIEBleHRlbmRzIG1vZHVsZTp3b3JrYm94LXJvdXRpbmcuUm91dGVcbiAqL1xuY2xhc3MgUHJlY2FjaGVSb3V0ZSBleHRlbmRzIFJvdXRlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1ByZWNhY2hlQ29udHJvbGxlcn0gcHJlY2FjaGVDb250cm9sbGVyIEEgYFByZWNhY2hlQ29udHJvbGxlcmBcbiAgICAgKiBpbnN0YW5jZSB1c2VkIHRvIGJvdGggbWF0Y2ggcmVxdWVzdHMgYW5kIHJlc3BvbmQgdG8gZmV0Y2ggZXZlbnRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBjb250cm9sIGhvdyByZXF1ZXN0cyBhcmUgbWF0Y2hlZFxuICAgICAqIGFnYWluc3QgdGhlIGxpc3Qgb2YgcHJlY2FjaGVkIFVSTHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRpcmVjdG9yeUluZGV4PWluZGV4Lmh0bWxdIFRoZSBgZGlyZWN0b3J5SW5kZXhgIHdpbGxcbiAgICAgKiBjaGVjayBjYWNoZSBlbnRyaWVzIGZvciBhIFVSTHMgZW5kaW5nIHdpdGggJy8nIHRvIHNlZSBpZiB0aGVyZSBpcyBhIGhpdCB3aGVuXG4gICAgICogYXBwZW5kaW5nIHRoZSBgZGlyZWN0b3J5SW5kZXhgIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8UmVnRXhwPn0gW29wdGlvbnMuaWdub3JlVVJMUGFyYW1ldGVyc01hdGNoaW5nPVsvXnV0bV8vLCAvXmZiY2xpZCQvXV0gQW5cbiAgICAgKiBhcnJheSBvZiByZWdleCdzIHRvIHJlbW92ZSBzZWFyY2ggcGFyYW1zIHdoZW4gbG9va2luZyBmb3IgYSBjYWNoZSBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsZWFuVVJMcz10cnVlXSBUaGUgYGNsZWFuVVJMc2Agb3B0aW9uIHdpbGxcbiAgICAgKiBjaGVjayB0aGUgY2FjaGUgZm9yIHRoZSBVUkwgd2l0aCBhIGAuaHRtbGAgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgZW5kLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtcHJlY2FjaGluZ351cmxNYW5pcHVsYXRpb259IFtvcHRpb25zLnVybE1hbmlwdWxhdGlvbl1cbiAgICAgKiBUaGlzIGlzIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgdGFrZSBhIFVSTCBhbmQgcmV0dXJuIGFuIGFycmF5IG9mXG4gICAgICogYWx0ZXJuYXRpdmUgVVJMcyB0aGF0IHNob3VsZCBiZSBjaGVja2VkIGZvciBwcmVjYWNoZSBtYXRjaGVzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByZWNhY2hlQ29udHJvbGxlciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtYXRjaCA9ICh7IHJlcXVlc3QgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXJsc1RvQ2FjaGVLZXlzID0gcHJlY2FjaGVDb250cm9sbGVyLmdldFVSTHNUb0NhY2hlS2V5cygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwb3NzaWJsZVVSTCBvZiBnZW5lcmF0ZVVSTFZhcmlhdGlvbnMocmVxdWVzdC51cmwsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSB1cmxzVG9DYWNoZUtleXMuZ2V0KHBvc3NpYmxlVVJMKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY2FjaGVLZXkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgUHJlY2FjaGluZyBkaWQgbm90IGZpbmQgYSBtYXRjaCBmb3IgYCArXG4gICAgICAgICAgICAgICAgICAgIGdldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKG1hdGNoLCBwcmVjYWNoZUNvbnRyb2xsZXIuc3RyYXRlZ3kpO1xuICAgIH1cbn1cbmV4cG9ydCB7IFByZWNhY2hlUm91dGUgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyByZWdpc3RlclJvdXRlIH0gZnJvbSAnd29ya2JveC1yb3V0aW5nL3JlZ2lzdGVyUm91dGUuanMnO1xuaW1wb3J0IHsgZ2V0T3JDcmVhdGVQcmVjYWNoZUNvbnRyb2xsZXIgfSBmcm9tICcuL3V0aWxzL2dldE9yQ3JlYXRlUHJlY2FjaGVDb250cm9sbGVyLmpzJztcbmltcG9ydCB7IFByZWNhY2hlUm91dGUgfSBmcm9tICcuL1ByZWNhY2hlUm91dGUuanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogQWRkIGEgYGZldGNoYCBsaXN0ZW5lciB0byB0aGUgc2VydmljZSB3b3JrZXIgdGhhdCB3aWxsXG4gKiByZXNwb25kIHRvXG4gKiBbbmV0d29yayByZXF1ZXN0c117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZpY2VfV29ya2VyX0FQSS9Vc2luZ19TZXJ2aWNlX1dvcmtlcnMjQ3VzdG9tX3Jlc3BvbnNlc190b19yZXF1ZXN0c31cbiAqIHdpdGggcHJlY2FjaGVkIGFzc2V0cy5cbiAqXG4gKiBSZXF1ZXN0cyBmb3IgYXNzZXRzIHRoYXQgYXJlbid0IHByZWNhY2hlZCwgdGhlIGBGZXRjaEV2ZW50YCB3aWxsIG5vdCBiZVxuICogcmVzcG9uZGVkIHRvLCBhbGxvd2luZyB0aGUgZXZlbnQgdG8gZmFsbCB0aHJvdWdoIHRvIG90aGVyIGBmZXRjaGAgZXZlbnRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFNlZVxuICogW1ByZWNhY2hlUm91dGUgb3B0aW9uc117QGxpbmsgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5QcmVjYWNoZVJvdXRlfS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZ1xuICovXG5mdW5jdGlvbiBhZGRSb3V0ZShvcHRpb25zKSB7XG4gICAgY29uc3QgcHJlY2FjaGVDb250cm9sbGVyID0gZ2V0T3JDcmVhdGVQcmVjYWNoZUNvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBwcmVjYWNoZVJvdXRlID0gbmV3IFByZWNhY2hlUm91dGUocHJlY2FjaGVDb250cm9sbGVyLCBvcHRpb25zKTtcbiAgICByZWdpc3RlclJvdXRlKHByZWNhY2hlUm91dGUpO1xufVxuZXhwb3J0IHsgYWRkUm91dGUgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGdldE9yQ3JlYXRlUHJlY2FjaGVDb250cm9sbGVyIH0gZnJvbSAnLi91dGlscy9nZXRPckNyZWF0ZVByZWNhY2hlQ29udHJvbGxlci5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBBZGRzIGl0ZW1zIHRvIHRoZSBwcmVjYWNoZSBsaXN0LCByZW1vdmluZyBhbnkgZHVwbGljYXRlcyBhbmRcbiAqIHN0b3JlcyB0aGUgZmlsZXMgaW4gdGhlXG4gKiBbXCJwcmVjYWNoZSBjYWNoZVwiXXtAbGluayBtb2R1bGU6d29ya2JveC1jb3JlLmNhY2hlTmFtZXN9IHdoZW4gdGhlIHNlcnZpY2VcbiAqIHdvcmtlciBpbnN0YWxscy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBsZWFzZSBub3RlOiBUaGlzIG1ldGhvZCAqKndpbGwgbm90Kiogc2VydmUgYW55IG9mIHRoZSBjYWNoZWQgZmlsZXMgZm9yIHlvdS5cbiAqIEl0IG9ubHkgcHJlY2FjaGVzIGZpbGVzLiBUbyByZXNwb25kIHRvIGEgbmV0d29yayByZXF1ZXN0IHlvdSBjYWxsXG4gKiBbYWRkUm91dGUoKV17QGxpbmsgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5hZGRSb3V0ZX0uXG4gKlxuICogSWYgeW91IGhhdmUgYSBzaW5nbGUgYXJyYXkgb2YgZmlsZXMgdG8gcHJlY2FjaGUsIHlvdSBjYW4ganVzdCBjYWxsXG4gKiBbcHJlY2FjaGVBbmRSb3V0ZSgpXXtAbGluayBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nLnByZWNhY2hlQW5kUm91dGV9LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0fHN0cmluZz59IFtlbnRyaWVzPVtdXSBBcnJheSBvZiBlbnRyaWVzIHRvIHByZWNhY2hlLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nXG4gKi9cbmZ1bmN0aW9uIHByZWNhY2hlKGVudHJpZXMpIHtcbiAgICBjb25zdCBwcmVjYWNoZUNvbnRyb2xsZXIgPSBnZXRPckNyZWF0ZVByZWNhY2hlQ29udHJvbGxlcigpO1xuICAgIHByZWNhY2hlQ29udHJvbGxlci5wcmVjYWNoZShlbnRyaWVzKTtcbn1cbmV4cG9ydCB7IHByZWNhY2hlIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBhZGRSb3V0ZSB9IGZyb20gJy4vYWRkUm91dGUuanMnO1xuaW1wb3J0IHsgcHJlY2FjaGUgfSBmcm9tICcuL3ByZWNhY2hlLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIFRoaXMgbWV0aG9kIHdpbGwgYWRkIGVudHJpZXMgdG8gdGhlIHByZWNhY2hlIGxpc3QgYW5kIGFkZCBhIHJvdXRlIHRvXG4gKiByZXNwb25kIHRvIGZldGNoIGV2ZW50cy5cbiAqXG4gKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIHRoYXQgd2lsbCBjYWxsXG4gKiBbcHJlY2FjaGUoKV17QGxpbmsgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5wcmVjYWNoZX0gYW5kXG4gKiBbYWRkUm91dGUoKV17QGxpbmsgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5hZGRSb3V0ZX0gaW4gYSBzaW5nbGUgY2FsbC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdHxzdHJpbmc+fSBlbnRyaWVzIEFycmF5IG9mIGVudHJpZXMgdG8gcHJlY2FjaGUuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFNlZVxuICogW1ByZWNhY2hlUm91dGUgb3B0aW9uc117QGxpbmsgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5QcmVjYWNoZVJvdXRlfS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZ1xuICovXG5mdW5jdGlvbiBwcmVjYWNoZUFuZFJvdXRlKGVudHJpZXMsIG9wdGlvbnMpIHtcbiAgICBwcmVjYWNoZShlbnRyaWVzKTtcbiAgICBhZGRSb3V0ZShvcHRpb25zKTtcbn1cbmV4cG9ydCB7IHByZWNhY2hlQW5kUm91dGUgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMnO1xuaW1wb3J0IHsgZ2V0RnJpZW5kbHlVUkwgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwuanMnO1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG5leHBvcnQgY29uc3QgbWVzc2FnZXMgPSB7XG4gICAgc3RyYXRlZ3lTdGFydDogKHN0cmF0ZWd5TmFtZSwgcmVxdWVzdCkgPT4gYFVzaW5nICR7c3RyYXRlZ3lOYW1lfSB0byByZXNwb25kIHRvICcke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0nYCxcbiAgICBwcmludEZpbmFsUmVzcG9uc2U6IChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgVmlldyB0aGUgZmluYWwgcmVzcG9uc2UgaGVyZS5gKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2cocmVzcG9uc2UgfHwgJ1tObyByZXNwb25zZSByZXR1cm5lZF0nKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMnO1xuaW1wb3J0IHsgV29ya2JveEVycm9yIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5qcyc7XG5pbXBvcnQgeyBTdHJhdGVneSB9IGZyb20gJy4vU3RyYXRlZ3kuanMnO1xuaW1wb3J0IHsgbWVzc2FnZXMgfSBmcm9tICcuL3V0aWxzL21lc3NhZ2VzLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGEgW2NhY2hlLWZpcnN0XXtAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL2luc3RhbnQtYW5kLW9mZmxpbmUvb2ZmbGluZS1jb29rYm9vay8jY2FjaGUtZmFsbGluZy1iYWNrLXRvLW5ldHdvcmt9XG4gKiByZXF1ZXN0IHN0cmF0ZWd5LlxuICpcbiAqIEEgY2FjaGUgZmlyc3Qgc3RyYXRlZ3kgaXMgdXNlZnVsIGZvciBhc3NldHMgdGhhdCBoYXZlIGJlZW4gcmV2aXNpb25lZCxcbiAqIHN1Y2ggYXMgVVJMcyBsaWtlIGAvc3R5bGVzL2V4YW1wbGUuYThmNWYxLmNzc2AsIHNpbmNlIHRoZXlcbiAqIGNhbiBiZSBjYWNoZWQgZm9yIGxvbmcgcGVyaW9kcyBvZiB0aW1lLlxuICpcbiAqIElmIHRoZSBuZXR3b3JrIHJlcXVlc3QgZmFpbHMsIGFuZCB0aGVyZSBpcyBubyBjYWNoZSBtYXRjaCwgdGhpcyB3aWxsIHRocm93XG4gKiBhIGBXb3JrYm94RXJyb3JgIGV4Y2VwdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5XG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llc1xuICovXG5jbGFzcyBDYWNoZUZpcnN0IGV4dGVuZHMgU3RyYXRlZ3kge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fHN0cmluZ30gcmVxdWVzdCBBIHJlcXVlc3QgdG8gcnVuIHRoaXMgc3RyYXRlZ3kgZm9yLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneUhhbmRsZXJ9IGhhbmRsZXIgVGhlIGV2ZW50IHRoYXRcbiAgICAgKiAgICAgdHJpZ2dlcmVkIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8UmVzcG9uc2U+fVxuICAgICAqL1xuICAgIGFzeW5jIF9oYW5kbGUocmVxdWVzdCwgaGFuZGxlcikge1xuICAgICAgICBjb25zdCBsb2dzID0gW107XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBhc3NlcnQuaXNJbnN0YW5jZShyZXF1ZXN0LCBSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtc3RyYXRlZ2llcycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdtYWtlUmVxdWVzdCcsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAncmVxdWVzdCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmNhY2hlTWF0Y2gocmVxdWVzdCk7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2dzLnB1c2goYE5vIHJlc3BvbnNlIGZvdW5kIGluIHRoZSAnJHt0aGlzLmNhY2hlTmFtZX0nIGNhY2hlLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYFdpbGwgcmVzcG9uZCB3aXRoIGEgbmV0d29yayByZXF1ZXN0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGhhbmRsZXIuZmV0Y2hBbmRDYWNoZVB1dChyZXF1ZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ3MucHVzaChgR290IHJlc3BvbnNlIGZyb20gbmV0d29yay5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ3MucHVzaChgVW5hYmxlIHRvIGdldCBhIHJlc3BvbnNlIGZyb20gdGhlIG5ldHdvcmsuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2dzLnB1c2goYEZvdW5kIGEgY2FjaGVkIHJlc3BvbnNlIGluIHRoZSAnJHt0aGlzLmNhY2hlTmFtZX0nIGNhY2hlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQobWVzc2FnZXMuc3RyYXRlZ3lTdGFydCh0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIHJlcXVlc3QpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbG9nIG9mIGxvZ3MpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGxvZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXNzYWdlcy5wcmludEZpbmFsUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignbm8tcmVzcG9uc2UnLCB7IHVybDogcmVxdWVzdC51cmwsIGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG5leHBvcnQgeyBDYWNoZUZpcnN0IH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgcHJldmVudHMgYSBwcm9taXNlIGZyb20gYmVpbmcgZmxhZ2dlZCBhcyB1bnVzZWQuXG4gKlxuICogQHByaXZhdGVcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBkb250V2FpdEZvcihwcm9taXNlKSB7XG4gICAgLy8gRWZmZWN0aXZlIG5vLW9wLlxuICAgIHByb21pc2UudGhlbigoKSA9PiB7IH0pO1xufVxuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEEgY2xhc3MgdGhhdCB3cmFwcyBjb21tb24gSW5kZXhlZERCIGZ1bmN0aW9uYWxpdHkgaW4gYSBwcm9taXNlLWJhc2VkIEFQSS5cbiAqIEl0IGV4cG9zZXMgYWxsIHRoZSB1bmRlcmx5aW5nIHBvd2VyIGFuZCBmdW5jdGlvbmFsaXR5IG9mIEluZGV4ZWREQiwgYnV0XG4gKiB3cmFwcyB0aGUgbW9zdCBjb21tb25seSB1c2VkIGZlYXR1cmVzIGluIGEgd2F5IHRoYXQncyBtdWNoIHNpbXBsZXIgdG8gdXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBEQldyYXBwZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZlcnNpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdD19IFtjYWxsYmFja11cbiAgICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbnVwZ3JhZGVuZWVkZWRdXG4gICAgICogQHBhcmFtIHshRnVuY3Rpb259IFtjYWxsYmFja3Mub252ZXJzaW9uY2hhbmdlXSBEZWZhdWx0cyB0b1xuICAgICAqICAgICBEQldyYXBwZXIucHJvdG90eXBlLl9vbnZlcnNpb25jaGFuZ2Ugd2hlbiBub3Qgc3BlY2lmaWVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgdmVyc2lvbiwgeyBvbnVwZ3JhZGVuZWVkZWQsIG9udmVyc2lvbmNoYW5nZSwgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuX2RiID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLl9vbnVwZ3JhZGVuZWVkZWQgPSBvbnVwZ3JhZGVuZWVkZWQ7XG4gICAgICAgIHRoaXMuX29udmVyc2lvbmNoYW5nZSA9IG9udmVyc2lvbmNoYW5nZSB8fCAoKCkgPT4gdGhpcy5jbG9zZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSURCRGF0YWJhc2UgaW5zdGFuY2UgKG5vdCBub3JtYWxseSBuZWVkZWQpLlxuICAgICAqIEByZXR1cm4ge0lEQkRhdGFiYXNlfHVuZGVmaW5lZH1cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0IGRiKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIGEgY29ubmVjdGVkIHRvIGFuIElEQkRhdGFiYXNlLCBpbnZva2VzIGFueSBvbnVwZ3JhZGVkbmVlZGVkXG4gICAgICogY2FsbGJhY2ssIGFuZCBhZGRlZCBhbiBvbnZlcnNpb25jaGFuZ2UgY2FsbGJhY2sgdG8gdGhlIGRhdGFiYXNlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SURCRGF0YWJhc2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBvcGVuKCkge1xuICAgICAgICBpZiAodGhpcy5fZGIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX2RiID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gVGhpcyBmbGFnIGlzIGZsaXBwZWQgdG8gdHJ1ZSBpZiB0aGUgdGltZW91dCBjYWxsYmFjayBydW5zIHByaW9yXG4gICAgICAgICAgICAvLyB0byB0aGUgcmVxdWVzdCBmYWlsaW5nIG9yIHN1Y2NlZWRpbmcuIE5vdGU6IHdlIHVzZSBhIHRpbWVvdXQgaW5zdGVhZFxuICAgICAgICAgICAgLy8gb2YgYW4gb25ibG9ja2VkIGhhbmRsZXIgc2luY2UgdGhlcmUgYXJlIGNhc2VzIHdoZXJlIG9uYmxvY2tlZCB3aWxsXG4gICAgICAgICAgICAvLyBuZXZlciBuZXZlciBydW4uIEEgdGltZW91dCBiZXR0ZXIgaGFuZGxlcyBhbGwgcG9zc2libGUgc2NlbmFyaW9zOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3czYy9JbmRleGVkREIvaXNzdWVzLzIyM1xuICAgICAgICAgICAgbGV0IG9wZW5SZXF1ZXN0VGltZWRPdXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9wZW5SZXF1ZXN0VGltZWRPdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RoZSBvcGVuIHJlcXVlc3Qgd2FzIGJsb2NrZWQgYW5kIHRpbWVkIG91dCcpKTtcbiAgICAgICAgICAgIH0sIHRoaXMuT1BFTl9USU1FT1VUKTtcbiAgICAgICAgICAgIGNvbnN0IG9wZW5SZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4odGhpcy5fbmFtZSwgdGhpcy5fdmVyc2lvbik7XG4gICAgICAgICAgICBvcGVuUmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG9wZW5SZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICAgIG9wZW5SZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IChldnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3BlblJlcXVlc3RUaW1lZE91dCkge1xuICAgICAgICAgICAgICAgICAgICBvcGVuUmVxdWVzdC50cmFuc2FjdGlvbi5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICBvcGVuUmVxdWVzdC5yZXN1bHQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuX29udXBncmFkZW5lZWRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbnVwZ3JhZGVuZWVkZWQoZXZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb3BlblJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRiID0gb3BlblJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChvcGVuUmVxdWVzdFRpbWVkT3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYi5vbnZlcnNpb25jaGFuZ2UgPSB0aGlzLl9vbnZlcnNpb25jaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb2x5ZmlsbHMgdGhlIG5hdGl2ZSBgZ2V0S2V5KClgIG1ldGhvZC4gTm90ZSwgdGhpcyBpcyBvdmVycmlkZGVuIGF0XG4gICAgICogcnVudGltZSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgbmF0aXZlIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZU5hbWVcbiAgICAgKiBAcGFyYW0geyp9IHF1ZXJ5XG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBnZXRLZXkoc3RvcmVOYW1lLCBxdWVyeSkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0QWxsS2V5cyhzdG9yZU5hbWUsIHF1ZXJ5LCAxKSlbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvbHlmaWxscyB0aGUgbmF0aXZlIGBnZXRBbGwoKWAgbWV0aG9kLiBOb3RlLCB0aGlzIGlzIG92ZXJyaWRkZW4gYXRcbiAgICAgKiBydW50aW1lIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBuYXRpdmUgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0b3JlTmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gcXVlcnlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIGdldEFsbChzdG9yZU5hbWUsIHF1ZXJ5LCBjb3VudCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRBbGxNYXRjaGluZyhzdG9yZU5hbWUsIHsgcXVlcnksIGNvdW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb2x5ZmlsbHMgdGhlIG5hdGl2ZSBgZ2V0QWxsS2V5cygpYCBtZXRob2QuIE5vdGUsIHRoaXMgaXMgb3ZlcnJpZGRlbiBhdFxuICAgICAqIHJ1bnRpbWUgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIG5hdGl2ZSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVOYW1lXG4gICAgICogQHBhcmFtIHsqfSBxdWVyeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWxsS2V5cyhzdG9yZU5hbWUsIHF1ZXJ5LCBjb3VudCkge1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgdGhpcy5nZXRBbGxNYXRjaGluZyhzdG9yZU5hbWUsIHsgcXVlcnksIGNvdW50LCBpbmNsdWRlS2V5czogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIGVudHJpZXMubWFwKChlbnRyeSkgPT4gZW50cnkua2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VwcG9ydHMgZmxleGlibGUgbG9va3VwIGluIGFuIG9iamVjdCBzdG9yZSBieSBzcGVjaWZ5aW5nIGFuIGluZGV4LFxuICAgICAqIHF1ZXJ5LCBkaXJlY3Rpb24sIGFuZCBjb3VudC4gVGhpcyBtZXRob2QgcmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzXG4gICAgICogd2l0aCB0aGUgc2lnbmF0dXJlIC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZU5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmluZGV4XSBUaGUgaW5kZXggdG8gdXNlIChpZiBzcGVjaWZpZWQpLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdHMucXVlcnldXG4gICAgICogQHBhcmFtIHtJREJDdXJzb3JEaXJlY3Rpb259IFtvcHRzLmRpcmVjdGlvbl1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuY291bnRdIFRoZSBtYXggbnVtYmVyIG9mIHJlc3VsdHMgdG8gcmV0dXJuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZUtleXNdIFdoZW4gdHJ1ZSwgdGhlIHN0cnVjdHVyZSBvZiB0aGVcbiAgICAgKiAgICAgcmV0dXJuZWQgb2JqZWN0cyBpcyBjaGFuZ2VkIGZyb20gYW4gYXJyYXkgb2YgdmFsdWVzIHRvIGFuIGFycmF5IG9mXG4gICAgICogICAgIG9iamVjdHMgaW4gdGhlIGZvcm0ge2tleSwgcHJpbWFyeUtleSwgdmFsdWV9LlxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWxsTWF0Y2hpbmcoc3RvcmVOYW1lLCB7IGluZGV4LCBxdWVyeSA9IG51bGwsIC8vIElFL0VkZ2UgZXJyb3JzIGlmIHF1ZXJ5ID09PSBgdW5kZWZpbmVkYC5cbiAgICBkaXJlY3Rpb24gPSAnbmV4dCcsIGNvdW50LCBpbmNsdWRlS2V5cyA9IGZhbHNlLCB9ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNhY3Rpb24oW3N0b3JlTmFtZV0sICdyZWFkb25seScsICh0eG4sIGRvbmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHhuLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBpbmRleCA/IHN0b3JlLmluZGV4KGluZGV4KSA6IHN0b3JlO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRhcmdldC5vcGVuQ3Vyc29yKHF1ZXJ5LCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gcmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goaW5jbHVkZUtleXMgPyBjdXJzb3IgOiBjdXJzb3IudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgJiYgcmVzdWx0cy5sZW5ndGggPj0gY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZShyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNjZXB0cyBhIGxpc3Qgb2Ygc3RvcmVzLCBhIHRyYW5zYWN0aW9uIHR5cGUsIGFuZCBhIGNhbGxiYWNrIGFuZFxuICAgICAqIHBlcmZvcm1zIGEgdHJhbnNhY3Rpb24uIEEgcHJvbWlzZSBpcyByZXR1cm5lZCB0aGF0IHJlc29sdmVzIHRvIHdoYXRldmVyXG4gICAgICogdmFsdWUgdGhlIGNhbGxiYWNrIGNob29zZXMuIFRoZSBjYWxsYmFjayBob2xkcyBhbGwgdGhlIHRyYW5zYWN0aW9uIGxvZ2ljXG4gICAgICogYW5kIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuICAgICAqICAgMS4gVGhlIElEQlRyYW5zYWN0aW9uIG9iamVjdFxuICAgICAqICAgMi4gQSBgZG9uZWAgZnVuY3Rpb24sIHRoYXQncyB1c2VkIHRvIHJlc29sdmUgdGhlIHByb21pc2Ugd2hlblxuICAgICAqICAgICAgd2hlbiB0aGUgdHJhbnNhY3Rpb24gaXMgZG9uZSwgaWYgcGFzc2VkIGEgdmFsdWUsIHRoZSBwcm9taXNlIGlzXG4gICAgICogICAgICByZXNvbHZlZCB0byB0aGF0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBzdG9yZU5hbWVzIEFuIGFycmF5IG9mIG9iamVjdCBzdG9yZSBuYW1lc1xuICAgICAqICAgICBpbnZvbHZlZCBpbiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgQ2FuIGJlIGByZWFkb25seWAgb3IgYHJlYWR3cml0ZWAuXG4gICAgICogQHBhcmFtIHshRnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7Kn0gVGhlIHJlc3VsdCBvZiB0aGUgdHJhbnNhY3Rpb24gcmFuIGJ5IHRoZSBjYWxsYmFjay5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIHRyYW5zYWN0aW9uKHN0b3JlTmFtZXMsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGF3YWl0IHRoaXMub3BlbigpO1xuICAgICAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHhuID0gdGhpcy5fZGIudHJhbnNhY3Rpb24oc3RvcmVOYW1lcywgdHlwZSk7XG4gICAgICAgICAgICB0eG4ub25hYm9ydCA9ICgpID0+IHJlamVjdCh0eG4uZXJyb3IpO1xuICAgICAgICAgICAgdHhuLm9uY29tcGxldGUgPSAoKSA9PiByZXNvbHZlKCk7XG4gICAgICAgICAgICBjYWxsYmFjayh0eG4sICh2YWx1ZSkgPT4gcmVzb2x2ZSh2YWx1ZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZWdhdGVzIGFzeW5jIHRvIGEgbmF0aXZlIElEQk9iamVjdFN0b3JlIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgVGhlIG1ldGhvZCBuYW1lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZU5hbWUgVGhlIG9iamVjdCBzdG9yZSBuYW1lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIENhbiBiZSBgcmVhZG9ubHlgIG9yIGByZWFkd3JpdGVgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBUaGUgbGlzdCBvZiBhcmdzIHRvIHBhc3MgdG8gdGhlIG5hdGl2ZSBtZXRob2QuXG4gICAgICogQHJldHVybiB7Kn0gVGhlIHJlc3VsdCBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtZXRob2QsIHN0b3JlTmFtZSwgdHlwZSwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9ICh0eG4sIGRvbmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9ialN0b3JlID0gdHhuLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICAgICAgICAvLyBUT0RPKHBoaWxpcHdhbHRvbik6IEZpeCB0aGlzIHVuZGVybHlpbmcgVFMyNjg0IGVycm9yLlxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG9ialN0b3JlW21ldGhvZF0uYXBwbHkob2JqU3RvcmUsIGFyZ3MpO1xuICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiBkb25lKHJlcXVlc3QucmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNhY3Rpb24oW3N0b3JlTmFtZV0sIHR5cGUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uIG9wZW5lZCBieSBgREJXcmFwcGVyLm9wZW4oKWAuIEdlbmVyYWxseSB0aGlzIG1ldGhvZFxuICAgICAqIGRvZXNuJ3QgbmVlZCB0byBiZSBjYWxsZWQgc2luY2U6XG4gICAgICogICAxLiBJdCdzIHVzdWFsbHkgYmV0dGVyIHRvIGtlZXAgYSBjb25uZWN0aW9uIG9wZW4gc2luY2Ugb3BlbmluZ1xuICAgICAqICAgICAgYSBuZXcgY29ubmVjdGlvbiBpcyBzb21ld2hhdCBzbG93LlxuICAgICAqICAgMi4gQ29ubmVjdGlvbnMgYXJlIGF1dG9tYXRpY2FsbHkgY2xvc2VkIHdoZW4gdGhlIHJlZmVyZW5jZSBpc1xuICAgICAqICAgICAgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAgICogVGhlIHByaW1hcnkgdXNlIGNhc2UgZm9yIG5lZWRpbmcgdG8gY2xvc2UgYSBjb25uZWN0aW9uIGlzIHdoZW4gYW5vdGhlclxuICAgICAqIHJlZmVyZW5jZSAodHlwaWNhbGx5IGluIGFub3RoZXIgdGFiKSBuZWVkcyB0byB1cGdyYWRlIGl0IGFuZCB3b3VsZCBiZVxuICAgICAqIGJsb2NrZWQgYnkgdGhlIGN1cnJlbnQsIG9wZW4gY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kYikge1xuICAgICAgICAgICAgdGhpcy5fZGIuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2RiID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIEV4cG9zZWQgb24gdGhlIHByb3RvdHlwZSB0byBsZXQgdXNlcnMgbW9kaWZ5IHRoZSBkZWZhdWx0IHRpbWVvdXQgb24gYVxuLy8gcGVyLWluc3RhbmNlIG9yIGdsb2JhbCBiYXNpcy5cbkRCV3JhcHBlci5wcm90b3R5cGUuT1BFTl9USU1FT1VUID0gMjAwMDtcbi8vIFdyYXAgbmF0aXZlIElEQk9iamVjdFN0b3JlIG1ldGhvZHMgYWNjb3JkaW5nIHRvIHRoZWlyIG1vZGUuXG5jb25zdCBtZXRob2RzVG9XcmFwID0ge1xuICAgIHJlYWRvbmx5OiBbJ2dldCcsICdjb3VudCcsICdnZXRLZXknLCAnZ2V0QWxsJywgJ2dldEFsbEtleXMnXSxcbiAgICByZWFkd3JpdGU6IFsnYWRkJywgJ3B1dCcsICdjbGVhcicsICdkZWxldGUnXSxcbn07XG5mb3IgKGNvbnN0IFttb2RlLCBtZXRob2RzXSBvZiBPYmplY3QuZW50cmllcyhtZXRob2RzVG9XcmFwKSkge1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICAgICAgaWYgKG1ldGhvZCBpbiBJREJPYmplY3RTdG9yZS5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIC8vIERvbid0IHVzZSBhcnJvdyBmdW5jdGlvbnMgaGVyZSBzaW5jZSB3ZSdyZSBvdXRzaWRlIG9mIHRoZSBjbGFzcy5cbiAgICAgICAgICAgIERCV3JhcHBlci5wcm90b3R5cGVbbWV0aG9kXSA9XG4gICAgICAgICAgICAgICAgYXN5bmMgZnVuY3Rpb24gKHN0b3JlTmFtZSwgLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fY2FsbChtZXRob2QsIHN0b3JlTmFtZSwgbW9kZSwgLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBEZWxldGVzIHRoZSBkYXRhYmFzZS5cbiAqIE5vdGU6IHRoaXMgaXMgZXhwb3J0ZWQgc2VwYXJhdGVseSBmcm9tIHRoZSBEQldyYXBwZXIgbW9kdWxlIGJlY2F1c2UgbW9zdFxuICogdXNhZ2VzIG9mIEluZGV4ZWREQiBpbiB3b3JrYm94IGRvbnQgbmVlZCBkZWxldGluZywgYW5kIHRoaXMgd2F5IGl0IGNhbiBiZVxuICogcmV1c2VkIGluIHRlc3RzIHRvIGRlbGV0ZSBkYXRhYmFzZXMgd2l0aG91dCBjcmVhdGluZyBEQldyYXBwZXIgaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBkYXRhYmFzZSBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGRlbGV0ZURhdGFiYXNlID0gYXN5bmMgKG5hbWUpID0+IHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UobmFtZSk7XG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5vbmJsb2NrZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdEZWxldGUgYmxvY2tlZCcpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBAdHMtaWdub3JlXG50cnkge1xuICAgIHNlbGZbJ3dvcmtib3g6ZXhwaXJhdGlvbjo2LjAuMiddICYmIF8oKTtcbn1cbmNhdGNoIChlKSB7IH1cbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IERCV3JhcHBlciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9EQldyYXBwZXIuanMnO1xuaW1wb3J0IHsgZGVsZXRlRGF0YWJhc2UgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZGVsZXRlRGF0YWJhc2UuanMnO1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG5jb25zdCBEQl9OQU1FID0gJ3dvcmtib3gtZXhwaXJhdGlvbic7XG5jb25zdCBPQkpFQ1RfU1RPUkVfTkFNRSA9ICdjYWNoZS1lbnRyaWVzJztcbmNvbnN0IG5vcm1hbGl6ZVVSTCA9ICh1bk5vcm1hbGl6ZWRVcmwpID0+IHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHVuTm9ybWFsaXplZFVybCwgbG9jYXRpb24uaHJlZik7XG4gICAgdXJsLmhhc2ggPSAnJztcbiAgICByZXR1cm4gdXJsLmhyZWY7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSB0aW1lc3RhbXAgbW9kZWwuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ2FjaGVUaW1lc3RhbXBzTW9kZWwge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjYWNoZU5hbWUpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVOYW1lID0gY2FjaGVOYW1lO1xuICAgICAgICB0aGlzLl9kYiA9IG5ldyBEQldyYXBwZXIoREJfTkFNRSwgMSwge1xuICAgICAgICAgICAgb251cGdyYWRlbmVlZGVkOiAoZXZlbnQpID0+IHRoaXMuX2hhbmRsZVVwZ3JhZGUoZXZlbnQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdWxkIHBlcmZvcm0gYW4gdXBncmFkZSBvZiBpbmRleGVkREIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGFuZGxlVXBncmFkZShldmVudCkge1xuICAgICAgICBjb25zdCBkYiA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgIC8vIFRPRE8ocGhpbGlwd2FsdG9uKTogRWRnZUhUTUwgZG9lc24ndCBzdXBwb3J0IGFycmF5cyBhcyBhIGtleVBhdGgsIHNvIHdlXG4gICAgICAgIC8vIGhhdmUgdG8gdXNlIHRoZSBgaWRgIGtleVBhdGggaGVyZSBhbmQgY3JlYXRlIG91ciBvd24gdmFsdWVzIChhXG4gICAgICAgIC8vIGNvbmNhdGVuYXRpb24gb2YgYHVybCArIGNhY2hlTmFtZWApIGluc3RlYWQgb2Ygc2ltcGx5IHVzaW5nXG4gICAgICAgIC8vIGBrZXlQYXRoOiBbJ3VybCcsICdjYWNoZU5hbWUnXWAsIHdoaWNoIGlzIHN1cHBvcnRlZCBpbiBvdGhlciBicm93c2Vycy5cbiAgICAgICAgY29uc3Qgb2JqU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShPQkpFQ1RfU1RPUkVfTkFNRSwgeyBrZXlQYXRoOiAnaWQnIH0pO1xuICAgICAgICAvLyBUT0RPKHBoaWxpcHdhbHRvbik6IG9uY2Ugd2UgZG9uJ3QgaGF2ZSB0byBzdXBwb3J0IEVkZ2VIVE1MLCB3ZSBjYW5cbiAgICAgICAgLy8gY3JlYXRlIGEgc2luZ2xlIGluZGV4IHdpdGggdGhlIGtleVBhdGggYFsnY2FjaGVOYW1lJywgJ3RpbWVzdGFtcCddYFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIGRvaW5nIGJvdGggdGhlc2UgaW5kZXhlcy5cbiAgICAgICAgb2JqU3RvcmUuY3JlYXRlSW5kZXgoJ2NhY2hlTmFtZScsICdjYWNoZU5hbWUnLCB7IHVuaXF1ZTogZmFsc2UgfSk7XG4gICAgICAgIG9ialN0b3JlLmNyZWF0ZUluZGV4KCd0aW1lc3RhbXAnLCAndGltZXN0YW1wJywgeyB1bmlxdWU6IGZhbHNlIH0pO1xuICAgICAgICAvLyBQcmV2aW91cyB2ZXJzaW9ucyBvZiBgd29ya2JveC1leHBpcmF0aW9uYCB1c2VkIGB0aGlzLl9jYWNoZU5hbWVgXG4gICAgICAgIC8vIGFzIHRoZSBJREJEYXRhYmFzZSBuYW1lLlxuICAgICAgICBkZWxldGVEYXRhYmFzZSh0aGlzLl9jYWNoZU5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBzZXRUaW1lc3RhbXAodXJsLCB0aW1lc3RhbXApIHtcbiAgICAgICAgdXJsID0gbm9ybWFsaXplVVJMKHVybCk7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgICAgY2FjaGVOYW1lOiB0aGlzLl9jYWNoZU5hbWUsXG4gICAgICAgICAgICAvLyBDcmVhdGluZyBhbiBJRCBmcm9tIHRoZSBVUkwgYW5kIGNhY2hlIG5hbWUgd29uJ3QgYmUgbmVjZXNzYXJ5IG9uY2VcbiAgICAgICAgICAgIC8vIEVkZ2Ugc3dpdGNoZXMgdG8gQ2hyb21pdW0gYW5kIGFsbCBicm93c2VycyB3ZSBzdXBwb3J0IHdvcmsgd2l0aFxuICAgICAgICAgICAgLy8gYXJyYXkga2V5UGF0aHMuXG4gICAgICAgICAgICBpZDogdGhpcy5fZ2V0SWQodXJsKSxcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZGIucHV0KE9CSkVDVF9TVE9SRV9OQU1FLCBlbnRyeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRpbWVzdGFtcCBzdG9yZWQgZm9yIGEgZ2l2ZW4gVVJMLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VGltZXN0YW1wKHVybCkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IHRoaXMuX2RiLmdldChPQkpFQ1RfU1RPUkVfTkFNRSwgdGhpcy5fZ2V0SWQodXJsKSk7XG4gICAgICAgIHJldHVybiBlbnRyeS50aW1lc3RhbXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIHRocm91Z2ggYWxsIHRoZSBlbnRyaWVzIGluIHRoZSBvYmplY3Qgc3RvcmUgKGZyb20gbmV3ZXN0IHRvXG4gICAgICogb2xkZXN0KSBhbmQgcmVtb3ZlcyBlbnRyaWVzIG9uY2UgZWl0aGVyIGBtYXhDb3VudGAgaXMgcmVhY2hlZCBvciB0aGVcbiAgICAgKiBlbnRyeSdzIHRpbWVzdGFtcCBpcyBsZXNzIHRoYW4gYG1pblRpbWVzdGFtcGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluVGltZXN0YW1wXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heENvdW50XG4gICAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn1cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgZXhwaXJlRW50cmllcyhtaW5UaW1lc3RhbXAsIG1heENvdW50KSB7XG4gICAgICAgIGNvbnN0IGVudHJpZXNUb0RlbGV0ZSA9IGF3YWl0IHRoaXMuX2RiLnRyYW5zYWN0aW9uKE9CSkVDVF9TVE9SRV9OQU1FLCAncmVhZHdyaXRlJywgKHR4biwgZG9uZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSB0eG4ub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX05BTUUpO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmluZGV4KCd0aW1lc3RhbXAnKS5vcGVuQ3Vyc29yKG51bGwsICdwcmV2Jyk7XG4gICAgICAgICAgICBjb25zdCBlbnRyaWVzVG9EZWxldGUgPSBbXTtcbiAgICAgICAgICAgIGxldCBlbnRyaWVzTm90RGVsZXRlZENvdW50ID0gMDtcbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IHJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKHBoaWxpcHdhbHRvbik6IG9uY2Ugd2UgY2FuIHVzZSBhIG11bHRpLWtleSBpbmRleCwgd2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd29uJ3QgaGF2ZSB0byBjaGVjayBgY2FjaGVOYW1lYCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmNhY2hlTmFtZSA9PT0gdGhpcy5fY2FjaGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgYW4gZW50cnkgaWYgaXQncyBvbGRlciB0aGFuIHRoZSBtYXggYWdlIG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIG1heCBudW1iZXIgYWxsb3dlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobWluVGltZXN0YW1wICYmIHJlc3VsdC50aW1lc3RhbXAgPCBtaW5UaW1lc3RhbXApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1heENvdW50ICYmIGVudHJpZXNOb3REZWxldGVkQ291bnQgPj0gbWF4Q291bnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhwaGlsaXB3YWx0b24pOiB3ZSBzaG91bGQgYmUgYWJsZSB0byBkZWxldGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW50cnkgcmlnaHQgaGVyZSwgYnV0IGRvaW5nIHNvIGNhdXNlcyBhbiBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidWcgaW4gU2FmYXJpIHN0YWJsZSAoZml4ZWQgaW4gVFApLiBJbnN0ZWFkIHdlIGNhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBrZXlzIG9mIHRoZSBlbnRyaWVzIHRvIGRlbGV0ZSwgYW5kIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUgdGhlIHNlcGFyYXRlIHRyYW5zYWN0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL3dvcmtib3gvaXNzdWVzLzE5NzhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJzb3IuZGVsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIHJldHVybiB0aGUgVVJMLCBub3QgdGhlIHdob2xlIGVudHJ5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXNUb0RlbGV0ZS5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzTm90RGVsZXRlZENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb25lKGVudHJpZXNUb0RlbGV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE8ocGhpbGlwd2FsdG9uKTogb25jZSB0aGUgU2FmYXJpIGJ1ZyBpbiB0aGUgZm9sbG93aW5nIGlzc3VlIGlzIGZpeGVkLFxuICAgICAgICAvLyB3ZSBzaG91bGQgYmUgYWJsZSB0byByZW1vdmUgdGhpcyBsb29wIGFuZCBkbyB0aGUgZW50cnkgZGVsZXRpb24gaW4gdGhlXG4gICAgICAgIC8vIGN1cnNvciBsb29wIGFib3ZlOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL3dvcmtib3gvaXNzdWVzLzE5NzhcbiAgICAgICAgY29uc3QgdXJsc0RlbGV0ZWQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzVG9EZWxldGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2RiLmRlbGV0ZShPQkpFQ1RfU1RPUkVfTkFNRSwgZW50cnkuaWQpO1xuICAgICAgICAgICAgdXJsc0RlbGV0ZWQucHVzaChlbnRyeS51cmwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmxzRGVsZXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBVUkwgYW5kIHJldHVybnMgYW4gSUQgdGhhdCB3aWxsIGJlIHVuaXF1ZSBpbiB0aGUgb2JqZWN0IHN0b3JlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldElkKHVybCkge1xuICAgICAgICAvLyBDcmVhdGluZyBhbiBJRCBmcm9tIHRoZSBVUkwgYW5kIGNhY2hlIG5hbWUgd29uJ3QgYmUgbmVjZXNzYXJ5IG9uY2VcbiAgICAgICAgLy8gRWRnZSBzd2l0Y2hlcyB0byBDaHJvbWl1bSBhbmQgYWxsIGJyb3dzZXJzIHdlIHN1cHBvcnQgd29yayB3aXRoXG4gICAgICAgIC8vIGFycmF5IGtleVBhdGhzLlxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVOYW1lICsgJ3wnICsgbm9ybWFsaXplVVJMKHVybCk7XG4gICAgfVxufVxuZXhwb3J0IHsgQ2FjaGVUaW1lc3RhbXBzTW9kZWwgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9hc3NlcnQuanMnO1xuaW1wb3J0IHsgZG9udFdhaXRGb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZG9udFdhaXRGb3IuanMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5qcyc7XG5pbXBvcnQgeyBXb3JrYm94RXJyb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCB7IENhY2hlVGltZXN0YW1wc01vZGVsIH0gZnJvbSAnLi9tb2RlbHMvQ2FjaGVUaW1lc3RhbXBzTW9kZWwuanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogVGhlIGBDYWNoZUV4cGlyYXRpb25gIGNsYXNzIGFsbG93cyB5b3UgZGVmaW5lIGFuIGV4cGlyYXRpb24gYW5kIC8gb3JcbiAqIGxpbWl0IG9uIHRoZSBudW1iZXIgb2YgcmVzcG9uc2VzIHN0b3JlZCBpbiBhXG4gKiBbYENhY2hlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhY2hlKS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtZXhwaXJhdGlvblxuICovXG5jbGFzcyBDYWNoZUV4cGlyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIFRvIGNvbnN0cnVjdCBhIG5ldyBDYWNoZUV4cGlyYXRpb24gaW5zdGFuY2UgeW91IG11c3QgcHJvdmlkZSBhdCBsZWFzdFxuICAgICAqIG9uZSBvZiB0aGUgYGNvbmZpZ2AgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgTmFtZSBvZiB0aGUgY2FjaGUgdG8gYXBwbHkgcmVzdHJpY3Rpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5tYXhFbnRyaWVzXSBUaGUgbWF4aW11bSBudW1iZXIgb2YgZW50cmllcyB0byBjYWNoZS5cbiAgICAgKiBFbnRyaWVzIHVzZWQgdGhlIGxlYXN0IHdpbGwgYmUgcmVtb3ZlZCBhcyB0aGUgbWF4aW11bSBpcyByZWFjaGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLm1heEFnZVNlY29uZHNdIFRoZSBtYXhpbXVtIGFnZSBvZiBhbiBlbnRyeSBiZWZvcmVcbiAgICAgKiBpdCdzIHRyZWF0ZWQgYXMgc3RhbGUgYW5kIHJlbW92ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcubWF0Y2hPcHRpb25zXSBUaGUgW2BDYWNoZVF1ZXJ5T3B0aW9uc2BdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYWNoZS9kZWxldGUjUGFyYW1ldGVycylcbiAgICAgKiB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIGNhbGxpbmcgYGRlbGV0ZSgpYCBvbiB0aGUgY2FjaGUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2FjaGVOYW1lLCBjb25maWcgPSB7fSkge1xuICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVydW5SZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc1R5cGUoY2FjaGVOYW1lLCAnc3RyaW5nJywge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LWV4cGlyYXRpb24nLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ0NhY2hlRXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnY2FjaGVOYW1lJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCEoY29uZmlnLm1heEVudHJpZXMgfHwgY29uZmlnLm1heEFnZVNlY29uZHMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignbWF4LWVudHJpZXMtb3ItYWdlLXJlcXVpcmVkJywge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1leHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnQ2FjaGVFeHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLm1heEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuaXNUeXBlKGNvbmZpZy5tYXhFbnRyaWVzLCAnbnVtYmVyJywge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1leHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnQ2FjaGVFeHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ2NvbmZpZy5tYXhFbnRyaWVzJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcubWF4QWdlU2Vjb25kcykge1xuICAgICAgICAgICAgICAgIGFzc2VydC5pc1R5cGUoY29uZmlnLm1heEFnZVNlY29uZHMsICdudW1iZXInLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LWV4cGlyYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdDYWNoZUV4cGlyYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnY29uZmlnLm1heEFnZVNlY29uZHMnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21heEVudHJpZXMgPSBjb25maWcubWF4RW50cmllcztcbiAgICAgICAgdGhpcy5fbWF4QWdlU2Vjb25kcyA9IGNvbmZpZy5tYXhBZ2VTZWNvbmRzO1xuICAgICAgICB0aGlzLl9tYXRjaE9wdGlvbnMgPSBjb25maWcubWF0Y2hPcHRpb25zO1xuICAgICAgICB0aGlzLl9jYWNoZU5hbWUgPSBjYWNoZU5hbWU7XG4gICAgICAgIHRoaXMuX3RpbWVzdGFtcE1vZGVsID0gbmV3IENhY2hlVGltZXN0YW1wc01vZGVsKGNhY2hlTmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cGlyZXMgZW50cmllcyBmb3IgdGhlIGdpdmVuIGNhY2hlIGFuZCBnaXZlbiBjcml0ZXJpYS5cbiAgICAgKi9cbiAgICBhc3luYyBleHBpcmVFbnRyaWVzKCkge1xuICAgICAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXJ1blJlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgbWluVGltZXN0YW1wID0gdGhpcy5fbWF4QWdlU2Vjb25kcyA/XG4gICAgICAgICAgICBEYXRlLm5vdygpIC0gKHRoaXMuX21heEFnZVNlY29uZHMgKiAxMDAwKSA6IDA7XG4gICAgICAgIGNvbnN0IHVybHNFeHBpcmVkID0gYXdhaXQgdGhpcy5fdGltZXN0YW1wTW9kZWwuZXhwaXJlRW50cmllcyhtaW5UaW1lc3RhbXAsIHRoaXMuX21heEVudHJpZXMpO1xuICAgICAgICAvLyBEZWxldGUgVVJMcyBmcm9tIHRoZSBjYWNoZVxuICAgICAgICBjb25zdCBjYWNoZSA9IGF3YWl0IHNlbGYuY2FjaGVzLm9wZW4odGhpcy5fY2FjaGVOYW1lKTtcbiAgICAgICAgZm9yIChjb25zdCB1cmwgb2YgdXJsc0V4cGlyZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlLmRlbGV0ZSh1cmwsIHRoaXMuX21hdGNoT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh1cmxzRXhwaXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBFeHBpcmVkICR7dXJsc0V4cGlyZWQubGVuZ3RofSBgICtcbiAgICAgICAgICAgICAgICAgICAgYCR7dXJsc0V4cGlyZWQubGVuZ3RoID09PSAxID8gJ2VudHJ5JyA6ICdlbnRyaWVzJ30gYW5kIHJlbW92ZWQgYCArXG4gICAgICAgICAgICAgICAgICAgIGAke3VybHNFeHBpcmVkLmxlbmd0aCA9PT0gMSA/ICdpdCcgOiAndGhlbSd9IGZyb20gdGhlIGAgK1xuICAgICAgICAgICAgICAgICAgICBgJyR7dGhpcy5fY2FjaGVOYW1lfScgY2FjaGUuYCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgRXhwaXJlZCB0aGUgZm9sbG93aW5nICR7dXJsc0V4cGlyZWQubGVuZ3RoID09PSAxID9cbiAgICAgICAgICAgICAgICAgICAgJ1VSTCcgOiAnVVJMcyd9OmApO1xuICAgICAgICAgICAgICAgIHVybHNFeHBpcmVkLmZvckVhY2goKHVybCkgPT4gbG9nZ2VyLmxvZyhgICAgICR7dXJsfWApKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgQ2FjaGUgZXhwaXJhdGlvbiByYW4gYW5kIGZvdW5kIG5vIGVudHJpZXMgdG8gcmVtb3ZlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fcmVydW5SZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcnVuUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBkb250V2FpdEZvcih0aGlzLmV4cGlyZUVudHJpZXMoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSB0aW1lc3RhbXAgZm9yIHRoZSBnaXZlbiBVUkwuIFRoaXMgZW5zdXJlcyB0aGUgd2hlblxuICAgICAqIHJlbW92aW5nIGVudHJpZXMgYmFzZWQgb24gbWF4aW11bSBlbnRyaWVzLCBtb3N0IHJlY2VudGx5IHVzZWRcbiAgICAgKiBpcyBhY2N1cmF0ZSBvciB3aGVuIGV4cGlyaW5nLCB0aGUgdGltZXN0YW1wIGlzIHVwLXRvLWRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlVGltZXN0YW1wKHVybCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgYXNzZXJ0LmlzVHlwZSh1cmwsICdzdHJpbmcnLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtZXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnQ2FjaGVFeHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ3VwZGF0ZVRpbWVzdGFtcCcsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAndXJsJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuX3RpbWVzdGFtcE1vZGVsLnNldFRpbWVzdGFtcCh1cmwsIERhdGUubm93KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW4gYmUgdXNlZCB0byBjaGVjayBpZiBhIFVSTCBoYXMgZXhwaXJlZCBvciBub3QgYmVmb3JlIGl0J3MgdXNlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgcmVxdWlyZXMgYSBsb29rIHVwIGZyb20gSW5kZXhlZERCLCBzbyBjYW4gYmUgc2xvdy5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIHdpbGwgbm90IHJlbW92ZSB0aGUgY2FjaGVkIGVudHJ5LCBjYWxsXG4gICAgICogYGV4cGlyZUVudHJpZXMoKWAgdG8gcmVtb3ZlIGluZGV4ZWREQiBhbmQgQ2FjaGUgZW50cmllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGFzeW5jIGlzVVJMRXhwaXJlZCh1cmwpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tYXhBZ2VTZWNvbmRzKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoYGV4cGlyZWQtdGVzdC13aXRob3V0LW1heC1hZ2VgLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWU6ICdpc1VSTEV4cGlyZWQnLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdtYXhBZ2VTZWNvbmRzJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IGF3YWl0IHRoaXMuX3RpbWVzdGFtcE1vZGVsLmdldFRpbWVzdGFtcCh1cmwpO1xuICAgICAgICAgICAgY29uc3QgZXhwaXJlT2xkZXJUaGFuID0gRGF0ZS5ub3coKSAtICh0aGlzLl9tYXhBZ2VTZWNvbmRzICogMTAwMCk7XG4gICAgICAgICAgICByZXR1cm4gKHRpbWVzdGFtcCA8IGV4cGlyZU9sZGVyVGhhbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgSW5kZXhlZERCIG9iamVjdCBzdG9yZSB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgY2FjaGUgZXhwaXJhdGlvblxuICAgICAqIG1ldGFkYXRhLlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZSgpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IGF0dGVtcHQgYW5vdGhlciByZXJ1biBpZiB3ZSdyZSBjYWxsZWQgaW4gdGhlIG1pZGRsZSBvZlxuICAgICAgICAvLyBhIGNhY2hlIGV4cGlyYXRpb24uXG4gICAgICAgIHRoaXMuX3JlcnVuUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIGF3YWl0IHRoaXMuX3RpbWVzdGFtcE1vZGVsLmV4cGlyZUVudHJpZXMoSW5maW5pdHkpOyAvLyBFeHBpcmVzIGFsbC5cbiAgICB9XG59XG5leHBvcnQgeyBDYWNoZUV4cGlyYXRpb24gfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4vX3ByaXZhdGUvYXNzZXJ0LmpzJztcbmltcG9ydCB7IHF1b3RhRXJyb3JDYWxsYmFja3MgfSBmcm9tICcuL21vZGVscy9xdW90YUVycm9yQ2FsbGJhY2tzLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEFkZHMgYSBmdW5jdGlvbiB0byB0aGUgc2V0IG9mIHF1b3RhRXJyb3JDYWxsYmFja3MgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGlmXG4gKiB0aGVyZSdzIGEgcXVvdGEgZXJyb3IuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1jb3JlXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyUXVvdGFFcnJvckNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0LmlzVHlwZShjYWxsYmFjaywgJ2Z1bmN0aW9uJywge1xuICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtY29yZScsXG4gICAgICAgICAgICBmdW5jTmFtZTogJ3JlZ2lzdGVyJyxcbiAgICAgICAgICAgIHBhcmFtTmFtZTogJ2NhbGxiYWNrJyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHF1b3RhRXJyb3JDYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBsb2dnZXIubG9nKCdSZWdpc3RlcmVkIGEgY2FsbGJhY2sgdG8gcmVzcG9uZCB0byBxdW90YSBlcnJvcnMuJywgY2FsbGJhY2spO1xuICAgIH1cbn1cbmV4cG9ydCB7IHJlZ2lzdGVyUXVvdGFFcnJvckNhbGxiYWNrIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzJztcbmltcG9ydCB7IGNhY2hlTmFtZXMgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvY2FjaGVOYW1lcy5qcyc7XG5pbXBvcnQgeyBkb250V2FpdEZvciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9kb250V2FpdEZvci5qcyc7XG5pbXBvcnQgeyBnZXRGcmllbmRseVVSTCB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9nZXRGcmllbmRseVVSTC5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IHJlZ2lzdGVyUXVvdGFFcnJvckNhbGxiYWNrIH0gZnJvbSAnd29ya2JveC1jb3JlL3JlZ2lzdGVyUXVvdGFFcnJvckNhbGxiYWNrLmpzJztcbmltcG9ydCB7IFdvcmtib3hFcnJvciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9Xb3JrYm94RXJyb3IuanMnO1xuaW1wb3J0IHsgQ2FjaGVFeHBpcmF0aW9uIH0gZnJvbSAnLi9DYWNoZUV4cGlyYXRpb24uanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogVGhpcyBwbHVnaW4gY2FuIGJlIHVzZWQgaW4gYSBgd29ya2JveC1zdHJhdGVneWAgdG8gcmVndWxhcmx5IGVuZm9yY2UgYVxuICogbGltaXQgb24gdGhlIGFnZSBhbmQgLyBvciB0aGUgbnVtYmVyIG9mIGNhY2hlZCByZXF1ZXN0cy5cbiAqXG4gKiBJdCBjYW4gb25seSBiZSB1c2VkIHdpdGggYHdvcmtib3gtc3RyYXRlZ3lgIGluc3RhbmNlcyB0aGF0IGhhdmUgYVxuICogW2N1c3RvbSBgY2FjaGVOYW1lYCBwcm9wZXJ0eSBzZXRdKC93ZWIvdG9vbHMvd29ya2JveC9ndWlkZXMvY29uZmlndXJlLXdvcmtib3gjY3VzdG9tX2NhY2hlX25hbWVzX2luX3N0cmF0ZWdpZXMpLlxuICogSW4gb3RoZXIgd29yZHMsIGl0IGNhbid0IGJlIHVzZWQgdG8gZXhwaXJlIGVudHJpZXMgaW4gc3RyYXRlZ3kgdGhhdCB1c2VzIHRoZVxuICogZGVmYXVsdCBydW50aW1lIGNhY2hlIG5hbWUuXG4gKlxuICogV2hlbmV2ZXIgYSBjYWNoZWQgcmVxdWVzdCBpcyB1c2VkIG9yIHVwZGF0ZWQsIHRoaXMgcGx1Z2luIHdpbGwgbG9va1xuICogYXQgdGhlIGFzc29jaWF0ZWQgY2FjaGUgYW5kIHJlbW92ZSBhbnkgb2xkIG9yIGV4dHJhIHJlcXVlc3RzLlxuICpcbiAqIFdoZW4gdXNpbmcgYG1heEFnZVNlY29uZHNgLCByZXF1ZXN0cyBtYXkgYmUgdXNlZCAqb25jZSogYWZ0ZXIgZXhwaXJpbmdcbiAqIGJlY2F1c2UgdGhlIGV4cGlyYXRpb24gY2xlYW4gdXAgd2lsbCBub3QgaGF2ZSBvY2N1cnJlZCB1bnRpbCAqYWZ0ZXIqIHRoZVxuICogY2FjaGVkIHJlcXVlc3QgaGFzIGJlZW4gdXNlZC4gSWYgdGhlIHJlcXVlc3QgaGFzIGEgXCJEYXRlXCIgaGVhZGVyLCB0aGVuXG4gKiBhIGxpZ2h0IHdlaWdodCBleHBpcmF0aW9uIGNoZWNrIGlzIHBlcmZvcm1lZCBhbmQgdGhlIHJlcXVlc3Qgd2lsbCBub3QgYmVcbiAqIHVzZWQgaW1tZWRpYXRlbHkuXG4gKlxuICogV2hlbiB1c2luZyBgbWF4RW50cmllc2AsIHRoZSBlbnRyeSBsZWFzdC1yZWNlbnRseSByZXF1ZXN0ZWQgd2lsbCBiZSByZW1vdmVkXG4gKiBmcm9tIHRoZSBjYWNoZSBmaXJzdC5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtZXhwaXJhdGlvblxuICovXG5jbGFzcyBFeHBpcmF0aW9uUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubWF4RW50cmllc10gVGhlIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgdG8gY2FjaGUuXG4gICAgICogRW50cmllcyB1c2VkIHRoZSBsZWFzdCB3aWxsIGJlIHJlbW92ZWQgYXMgdGhlIG1heGltdW0gaXMgcmVhY2hlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5tYXhBZ2VTZWNvbmRzXSBUaGUgbWF4aW11bSBhZ2Ugb2YgYW4gZW50cnkgYmVmb3JlXG4gICAgICogaXQncyB0cmVhdGVkIGFzIHN0YWxlIGFuZCByZW1vdmVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm1hdGNoT3B0aW9uc10gVGhlIFtgQ2FjaGVRdWVyeU9wdGlvbnNgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FjaGUvZGVsZXRlI1BhcmFtZXRlcnMpXG4gICAgICogdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiBjYWxsaW5nIGBkZWxldGUoKWAgb24gdGhlIGNhY2hlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbmZpZy5wdXJnZU9uUXVvdGFFcnJvcl0gV2hldGhlciB0byBvcHQgdGhpcyBjYWNoZSBpbiB0b1xuICAgICAqIGF1dG9tYXRpYyBkZWxldGlvbiBpZiB0aGUgYXZhaWxhYmxlIHN0b3JhZ2UgcXVvdGEgaGFzIGJlZW4gZXhjZWVkZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgXCJsaWZlY3ljbGVcIiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgdHJpZ2dlcmVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlXG4gICAgICAgICAqIGB3b3JrYm94LXN0cmF0ZWdpZXNgIGhhbmRsZXJzIHdoZW4gYSBgUmVzcG9uc2VgIGlzIGFib3V0IHRvIGJlIHJldHVybmVkXG4gICAgICAgICAqIGZyb20gYSBbQ2FjaGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYWNoZSkgdG9cbiAgICAgICAgICogdGhlIGhhbmRsZXIuIEl0IGFsbG93cyB0aGUgYFJlc3BvbnNlYCB0byBiZSBpbnNwZWN0ZWQgZm9yIGZyZXNobmVzcyBhbmRcbiAgICAgICAgICogcHJldmVudHMgaXQgZnJvbSBiZWluZyB1c2VkIGlmIHRoZSBgUmVzcG9uc2VgJ3MgYERhdGVgIGhlYWRlciB2YWx1ZSBpc1xuICAgICAgICAgKiBvbGRlciB0aGFuIHRoZSBjb25maWd1cmVkIGBtYXhBZ2VTZWNvbmRzYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2FjaGVOYW1lIE5hbWUgb2YgdGhlIGNhY2hlIHRoZSByZXNwb25zZSBpcyBpbi5cbiAgICAgICAgICogQHBhcmFtIHtSZXNwb25zZX0gb3B0aW9ucy5jYWNoZWRSZXNwb25zZSBUaGUgYFJlc3BvbnNlYCBvYmplY3QgdGhhdCdzIGJlZW5cbiAgICAgICAgICogICAgIHJlYWQgZnJvbSBhIGNhY2hlIGFuZCB3aG9zZSBmcmVzaG5lc3Mgc2hvdWxkIGJlIGNoZWNrZWQuXG4gICAgICAgICAqIEByZXR1cm4ge1Jlc3BvbnNlfSBFaXRoZXIgdGhlIGBjYWNoZWRSZXNwb25zZWAsIGlmIGl0J3NcbiAgICAgICAgICogICAgIGZyZXNoLCBvciBgbnVsbGAgaWYgdGhlIGBSZXNwb25zZWAgaXMgb2xkZXIgdGhhbiBgbWF4QWdlU2Vjb25kc2AuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhY2hlZFJlc3BvbnNlV2lsbEJlVXNlZCA9IGFzeW5jICh7IGV2ZW50LCByZXF1ZXN0LCBjYWNoZU5hbWUsIGNhY2hlZFJlc3BvbnNlIH0pID0+IHtcbiAgICAgICAgICAgIGlmICghY2FjaGVkUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzRnJlc2ggPSB0aGlzLl9pc1Jlc3BvbnNlRGF0ZUZyZXNoKGNhY2hlZFJlc3BvbnNlKTtcbiAgICAgICAgICAgIC8vIEV4cGlyZSBlbnRyaWVzIHRvIGVuc3VyZSB0aGF0IGV2ZW4gaWYgdGhlIGV4cGlyYXRpb24gZGF0ZSBoYXNcbiAgICAgICAgICAgIC8vIGV4cGlyZWQsIGl0J2xsIG9ubHkgYmUgdXNlZCBvbmNlLlxuICAgICAgICAgICAgY29uc3QgY2FjaGVFeHBpcmF0aW9uID0gdGhpcy5fZ2V0Q2FjaGVFeHBpcmF0aW9uKGNhY2hlTmFtZSk7XG4gICAgICAgICAgICBkb250V2FpdEZvcihjYWNoZUV4cGlyYXRpb24uZXhwaXJlRW50cmllcygpKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbWV0YWRhdGEgZm9yIHRoZSByZXF1ZXN0IFVSTCB0byB0aGUgY3VycmVudCB0aW1lc3RhbXAsXG4gICAgICAgICAgICAvLyBidXQgZG9uJ3QgYGF3YWl0YCBpdCBhcyB3ZSBkb24ndCB3YW50IHRvIGJsb2NrIHRoZSByZXNwb25zZS5cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVRpbWVzdGFtcERvbmUgPSBjYWNoZUV4cGlyYXRpb24udXBkYXRlVGltZXN0YW1wKHJlcXVlc3QudXJsKTtcbiAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LndhaXRVbnRpbCh1cGRhdGVUaW1lc3RhbXBEb25lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZXZlbnQgbWF5IG5vdCBiZSBhIGZldGNoIGV2ZW50OyBvbmx5IGxvZyB0aGUgVVJMIGlmIGl0IGlzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdyZXF1ZXN0JyBpbiBldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBVbmFibGUgdG8gZW5zdXJlIHNlcnZpY2Ugd29ya2VyIHN0YXlzIGFsaXZlIHdoZW4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB1cGRhdGluZyBjYWNoZSBlbnRyeSBmb3IgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAnJHtnZXRGcmllbmRseVVSTChldmVudC5yZXF1ZXN0LnVybCl9Jy5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc0ZyZXNoID8gY2FjaGVkUmVzcG9uc2UgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBcImxpZmVjeWNsZVwiIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgYXV0b21hdGljYWxseSBieSB0aGVcbiAgICAgICAgICogYHdvcmtib3gtc3RyYXRlZ2llc2AgaGFuZGxlcnMgd2hlbiBhbiBlbnRyeSBpcyBhZGRlZCB0byBhIGNhY2hlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jYWNoZU5hbWUgTmFtZSBvZiB0aGUgY2FjaGUgdGhhdCB3YXMgdXBkYXRlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucmVxdWVzdCBUaGUgUmVxdWVzdCBmb3IgdGhlIGNhY2hlZCBlbnRyeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FjaGVEaWRVcGRhdGUgPSBhc3luYyAoeyBjYWNoZU5hbWUsIHJlcXVlc3QgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuaXNUeXBlKGNhY2hlTmFtZSwgJ3N0cmluZycsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtZXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1BsdWdpbicsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnY2FjaGVEaWRVcGRhdGUnLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdjYWNoZU5hbWUnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFzc2VydC5pc0luc3RhbmNlKHJlcXVlc3QsIFJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtZXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1BsdWdpbicsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnY2FjaGVEaWRVcGRhdGUnLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdyZXF1ZXN0JyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhY2hlRXhwaXJhdGlvbiA9IHRoaXMuX2dldENhY2hlRXhwaXJhdGlvbihjYWNoZU5hbWUpO1xuICAgICAgICAgICAgYXdhaXQgY2FjaGVFeHBpcmF0aW9uLnVwZGF0ZVRpbWVzdGFtcChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgICBhd2FpdCBjYWNoZUV4cGlyYXRpb24uZXhwaXJlRW50cmllcygpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgaWYgKCEoY29uZmlnLm1heEVudHJpZXMgfHwgY29uZmlnLm1heEFnZVNlY29uZHMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignbWF4LWVudHJpZXMtb3ItYWdlLXJlcXVpcmVkJywge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1leHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUGx1Z2luJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLm1heEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuaXNUeXBlKGNvbmZpZy5tYXhFbnRyaWVzLCAnbnVtYmVyJywge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1leHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUGx1Z2luJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ2NvbmZpZy5tYXhFbnRyaWVzJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcubWF4QWdlU2Vjb25kcykge1xuICAgICAgICAgICAgICAgIGFzc2VydC5pc1R5cGUoY29uZmlnLm1heEFnZVNlY29uZHMsICdudW1iZXInLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LWV4cGlyYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdQbHVnaW4nLFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnY29uZmlnLm1heEFnZVNlY29uZHMnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5fbWF4QWdlU2Vjb25kcyA9IGNvbmZpZy5tYXhBZ2VTZWNvbmRzO1xuICAgICAgICB0aGlzLl9jYWNoZUV4cGlyYXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoY29uZmlnLnB1cmdlT25RdW90YUVycm9yKSB7XG4gICAgICAgICAgICByZWdpc3RlclF1b3RhRXJyb3JDYWxsYmFjaygoKSA9PiB0aGlzLmRlbGV0ZUNhY2hlQW5kTWV0YWRhdGEoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgaGVscGVyIG1ldGhvZCB0byByZXR1cm4gYSBDYWNoZUV4cGlyYXRpb24gaW5zdGFuY2UgZm9yIGEgZ2l2ZW5cbiAgICAgKiBjYWNoZSBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZVxuICAgICAqIEByZXR1cm4ge0NhY2hlRXhwaXJhdGlvbn1cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldENhY2hlRXhwaXJhdGlvbihjYWNoZU5hbWUpIHtcbiAgICAgICAgaWYgKGNhY2hlTmFtZSA9PT0gY2FjaGVOYW1lcy5nZXRSdW50aW1lTmFtZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdleHBpcmUtY3VzdG9tLWNhY2hlcy1vbmx5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhY2hlRXhwaXJhdGlvbiA9IHRoaXMuX2NhY2hlRXhwaXJhdGlvbnMuZ2V0KGNhY2hlTmFtZSk7XG4gICAgICAgIGlmICghY2FjaGVFeHBpcmF0aW9uKSB7XG4gICAgICAgICAgICBjYWNoZUV4cGlyYXRpb24gPSBuZXcgQ2FjaGVFeHBpcmF0aW9uKGNhY2hlTmFtZSwgdGhpcy5fY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlRXhwaXJhdGlvbnMuc2V0KGNhY2hlTmFtZSwgY2FjaGVFeHBpcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVFeHBpcmF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1Jlc3BvbnNlfSBjYWNoZWRSZXNwb25zZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc1Jlc3BvbnNlRGF0ZUZyZXNoKGNhY2hlZFJlc3BvbnNlKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWF4QWdlU2Vjb25kcykge1xuICAgICAgICAgICAgLy8gV2UgYXJlbid0IGV4cGlyaW5nIGJ5IGFnZSwgc28gcmV0dXJuIHRydWUsIGl0J3MgZnJlc2hcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSAnZGF0ZScgaGVhZGVyIHdpbGwgc3VmZmljZSBhIHF1aWNrIGV4cGlyYXRpb24gY2hlY2suXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lTGFicy9zdy10b29sYm94L2lzc3Vlcy8xNjQgZm9yXG4gICAgICAgIC8vIGRpc2N1c3Npb24uXG4gICAgICAgIGNvbnN0IGRhdGVIZWFkZXJUaW1lc3RhbXAgPSB0aGlzLl9nZXREYXRlSGVhZGVyVGltZXN0YW1wKGNhY2hlZFJlc3BvbnNlKTtcbiAgICAgICAgaWYgKGRhdGVIZWFkZXJUaW1lc3RhbXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFVuYWJsZSB0byBwYXJzZSBkYXRlLCBzbyBhc3N1bWUgaXQncyBmcmVzaC5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSB2YWxpZCBoZWFkZXJUaW1lLCB0aGVuIG91ciByZXNwb25zZSBpcyBmcmVzaCBpZmYgdGhlXG4gICAgICAgIC8vIGhlYWRlclRpbWUgcGx1cyBtYXhBZ2VTZWNvbmRzIGlzIGdyZWF0ZXIgdGhhbiB0aGUgY3VycmVudCB0aW1lLlxuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gZGF0ZUhlYWRlclRpbWVzdGFtcCA+PSBub3cgLSAodGhpcy5fbWF4QWdlU2Vjb25kcyAqIDEwMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGV4dHJhY3QgdGhlIGRhdGEgaGVhZGVyIGFuZCBwYXJzZSBpdCBpbnRvIGEgdXNlZnVsXG4gICAgICogdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1Jlc3BvbnNlfSBjYWNoZWRSZXNwb25zZVxuICAgICAqIEByZXR1cm4ge251bWJlcnxudWxsfVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0RGF0ZUhlYWRlclRpbWVzdGFtcChjYWNoZWRSZXNwb25zZSkge1xuICAgICAgICBpZiAoIWNhY2hlZFJlc3BvbnNlLmhlYWRlcnMuaGFzKCdkYXRlJykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGVIZWFkZXIgPSBjYWNoZWRSZXNwb25zZS5oZWFkZXJzLmdldCgnZGF0ZScpO1xuICAgICAgICBjb25zdCBwYXJzZWREYXRlID0gbmV3IERhdGUoZGF0ZUhlYWRlcik7XG4gICAgICAgIGNvbnN0IGhlYWRlclRpbWUgPSBwYXJzZWREYXRlLmdldFRpbWUoKTtcbiAgICAgICAgLy8gSWYgdGhlIERhdGUgaGVhZGVyIHdhcyBpbnZhbGlkIGZvciBzb21lIHJlYXNvbiwgcGFyc2VkRGF0ZS5nZXRUaW1lKClcbiAgICAgICAgLy8gd2lsbCByZXR1cm4gTmFOLlxuICAgICAgICBpZiAoaXNOYU4oaGVhZGVyVGltZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJUaW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgaGVscGVyIG1ldGhvZCB0aGF0IHBlcmZvcm1zIHR3byBvcGVyYXRpb25zOlxuICAgICAqXG4gICAgICogLSBEZWxldGVzICphbGwqIHRoZSB1bmRlcmx5aW5nIENhY2hlIGluc3RhbmNlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBwbHVnaW5cbiAgICAgKiBpbnN0YW5jZSwgYnkgY2FsbGluZyBjYWNoZXMuZGVsZXRlKCkgb24geW91ciBiZWhhbGYuXG4gICAgICogLSBEZWxldGVzIHRoZSBtZXRhZGF0YSBmcm9tIEluZGV4ZWREQiB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgZXhwaXJhdGlvblxuICAgICAqIGRldGFpbHMgZm9yIGVhY2ggQ2FjaGUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBXaGVuIHVzaW5nIGNhY2hlIGV4cGlyYXRpb24sIGNhbGxpbmcgdGhpcyBtZXRob2QgaXMgcHJlZmVyYWJsZSB0byBjYWxsaW5nXG4gICAgICogYGNhY2hlcy5kZWxldGUoKWAgZGlyZWN0bHksIHNpbmNlIHRoaXMgd2lsbCBlbnN1cmUgdGhhdCB0aGUgSW5kZXhlZERCXG4gICAgICogbWV0YWRhdGEgaXMgYWxzbyBjbGVhbmx5IHJlbW92ZWQgYW5kIG9wZW4gSW5kZXhlZERCIGluc3RhbmNlcyBhcmUgZGVsZXRlZC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBpZiB5b3UncmUgKm5vdCogdXNpbmcgY2FjaGUgZXhwaXJhdGlvbiBmb3IgYSBnaXZlbiBjYWNoZSwgY2FsbGluZ1xuICAgICAqIGBjYWNoZXMuZGVsZXRlKClgIGFuZCBwYXNzaW5nIGluIHRoZSBjYWNoZSdzIG5hbWUgc2hvdWxkIGJlIHN1ZmZpY2llbnQuXG4gICAgICogVGhlcmUgaXMgbm8gV29ya2JveC1zcGVjaWZpYyBtZXRob2QgbmVlZGVkIGZvciBjbGVhbnVwIGluIHRoYXQgY2FzZS5cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVDYWNoZUFuZE1ldGFkYXRhKCkge1xuICAgICAgICAvLyBEbyB0aGlzIG9uZSBhdCBhIHRpbWUgaW5zdGVhZCBvZiBhbGwgYXQgb25jZSB2aWEgYFByb21pc2UuYWxsKClgIHRvXG4gICAgICAgIC8vIHJlZHVjZSB0aGUgY2hhbmNlIG9mIGluY29uc2lzdGVuY3kgaWYgYSBwcm9taXNlIHJlamVjdHMuXG4gICAgICAgIGZvciAoY29uc3QgW2NhY2hlTmFtZSwgY2FjaGVFeHBpcmF0aW9uXSBvZiB0aGlzLl9jYWNoZUV4cGlyYXRpb25zKSB7XG4gICAgICAgICAgICBhd2FpdCBzZWxmLmNhY2hlcy5kZWxldGUoY2FjaGVOYW1lKTtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlRXhwaXJhdGlvbi5kZWxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNldCB0aGlzLl9jYWNoZUV4cGlyYXRpb25zIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuICAgICAgICB0aGlzLl9jYWNoZUV4cGlyYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIH1cbn1cbmV4cG9ydCB7IEV4cGlyYXRpb25QbHVnaW4gfTtcbiIsImltcG9ydCB7IHRpbWVzdGFtcCwgZmlsZXMsIHNoZWxsIH0gZnJvbSAnQHNhcHBlci9zZXJ2aWNlLXdvcmtlcic7XG5pbXBvcnQgeyBwcmVjYWNoZUFuZFJvdXRlIH0gZnJvbSAnd29ya2JveC1wcmVjYWNoaW5nJztcbmltcG9ydCB7IENhY2hlRmlyc3QgfSBmcm9tICd3b3JrYm94LXN0cmF0ZWdpZXMnO1xuaW1wb3J0IHsgcmVnaXN0ZXJSb3V0ZSB9IGZyb20gJ3dvcmtib3gtcm91dGluZyc7XG5pbXBvcnQgeyBFeHBpcmF0aW9uUGx1Z2luIH0gZnJvbSAnd29ya2JveC1leHBpcmF0aW9uJztcblxuY29uc3QgQVNTRVRTID0gYGNhY2hlJHt0aW1lc3RhbXB9YDtcblxuLy8gYHNoZWxsYCBpcyBhbiBhcnJheSBvZiBhbGwgdGhlIGZpbGVzIGdlbmVyYXRlZCBieSB0aGUgYnVuZGxlcixcbi8vIGBmaWxlc2AgaXMgYW4gYXJyYXkgb2YgZXZlcnl0aGluZyBpbiB0aGUgYHN0YXRpY2AgZGlyZWN0b3J5XG5jb25zdCB0b19jYWNoZSA9IHNoZWxsLmNvbmNhdChmaWxlcyk7XG5jb25zdCBzdGF0aWNBc3NldHMgPSBuZXcgU2V0KHRvX2NhY2hlKTtcblxuc2VsZi5fX1dCX0RJU0FCTEVfREVWX0xPR1MgPSB0cnVlO1xuXG5wcmVjYWNoZUFuZFJvdXRlKHNoZWxsKTtcbnByZWNhY2hlQW5kUm91dGUoZmlsZXMpO1xuXG5yZWdpc3RlclJvdXRlKFxuLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICovXG4gIG5ldyBSZWdFeHAoJ2h0dHBzOlxcL1xcL3Byb2R1Y3RldXJzYWdyaVxcLm9wZW5kYXRhc29mdFxcLmNvbScpLFxuICBuZXcgQ2FjaGVGaXJzdCh7XG4gICAgY2FjaGVOYW1lOiBgb2RzLXJlcXVlc3RzLSR7dGltZXN0YW1wfWAsXG4gICAgcGx1Z2luczogW1xuICAgICAgbmV3IEV4cGlyYXRpb25QbHVnaW4oe1xuICAgICAgICBtYXhFbnRyaWVzOiA1MCxcbiAgICAgICAgbWF4QWdlU2Vjb25kczogMzYwMCAqIDI0LFxuICAgICAgfSksXG4gICAgXSxcbiAgfSksXG4pO1xuIl0sIm5hbWVzIjpbImFzc2VydCIsIm1lc3NhZ2VzIl0sIm1hcHBpbmdzIjoiOzs7Q0FBQTtDQUNPLE1BQU0sU0FBUyxHQUFHLGFBQWEsQ0FBQztBQUN2QztDQUNPLE1BQU0sS0FBSyxHQUFHO0NBQ3JCLENBQUMsNEJBQTRCO0NBQzdCLENBQUMsNkJBQTZCO0NBQzlCLENBQUMsNkJBQTZCO0NBQzlCLENBQUMsdUJBQXVCO0NBQ3hCLENBQUMsb0JBQW9CO0NBQ3JCLENBQUMsb0JBQW9CO0NBQ3JCLENBQUMsb0JBQW9CO0NBQ3JCLENBQUMsY0FBYztDQUNmLENBQUMsY0FBYztDQUNmLENBQUMsYUFBYTtDQUNkLENBQUMsZUFBZTtDQUNoQixDQUFDLGVBQWU7Q0FDaEIsQ0FBQyxlQUFlO0NBQ2hCLENBQUMsdUJBQXVCO0NBQ3hCLENBQUMscUJBQXFCO0NBQ3RCLENBQUMscUJBQXFCO0NBQ3RCLENBQUMscUJBQXFCO0NBQ3RCLENBQUMscUJBQXFCO0NBQ3RCLENBQUMsbUJBQW1CO0NBQ3BCLENBQUMsd0JBQXdCO0NBQ3pCLENBQUMsQ0FBQztBQUVGO0NBQ08sTUFBTSxLQUFLLEdBQUc7Q0FDckIsQ0FBQyw0QkFBNEI7Q0FDN0IsQ0FBQyxtQ0FBbUM7Q0FDcEMsQ0FBQywyQkFBMkI7Q0FDNUIsQ0FBQyw4QkFBOEI7Q0FDL0IsQ0FBQyw4QkFBOEI7Q0FDL0IsQ0FBQywyQkFBMkI7Q0FDNUIsQ0FBQywyQkFBMkI7Q0FDNUIsQ0FBQywwQkFBMEI7Q0FDM0IsQ0FBQyxzQ0FBc0M7Q0FDdkMsQ0FBQyx1Q0FBdUM7Q0FDeEMsQ0FBQyxzQ0FBc0M7Q0FDdkMsQ0FBQzs7Q0N0Q0Q7Q0FDQSxJQUFJO0NBQ0osSUFBSSxJQUFJLENBQUMsb0JBQW9C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
