(function () {
	'use strict';

	// This file is generated by Sapper â€” do not edit it!
	const timestamp = 1608027032560;

	const files = [
		"/service-worker-index.html",
		"/android-chrome-192x192.png",
		"/android-chrome-512x512.png",
		"/apple-touch-icon.png",
		"/browserconfig.xml",
		"/favicon-16x16.png",
		"/favicon-32x32.png",
		"/favicon.ico",
		"/favicon.png",
		"/global.css",
		"/location.svg",
		"/logo-192.png",
		"/logo-512.png",
		"/manifest.webmanifest",
		"/mstile-144x144.png",
		"/mstile-150x150.png",
		"/mstile-310x150.png",
		"/mstile-310x310.png",
		"/mstile-70x70.png",
		"/safari-pinned-tab.svg"
	];

	const shell = [
		
	];

	// @ts-ignore
	try {
	    self['workbox:core:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const messages = {
	    'invalid-value': ({ paramName, validValueDescription, value }) => {
	        if (!paramName || !validValueDescription) {
	            throw new Error(`Unexpected input to 'invalid-value' error.`);
	        }
	        return `The '${paramName}' parameter was given a value with an ` +
	            `unexpected value. ${validValueDescription} Received a value of ` +
	            `${JSON.stringify(value)}.`;
	    },
	    'not-an-array': ({ moduleName, className, funcName, paramName }) => {
	        if (!moduleName || !className || !funcName || !paramName) {
	            throw new Error(`Unexpected input to 'not-an-array' error.`);
	        }
	        return `The parameter '${paramName}' passed into ` +
	            `'${moduleName}.${className}.${funcName}()' must be an array.`;
	    },
	    'incorrect-type': ({ expectedType, paramName, moduleName, className, funcName }) => {
	        if (!expectedType || !paramName || !moduleName || !funcName) {
	            throw new Error(`Unexpected input to 'incorrect-type' error.`);
	        }
	        return `The parameter '${paramName}' passed into ` +
	            `'${moduleName}.${className ? (className + '.') : ''}` +
	            `${funcName}()' must be of type ${expectedType}.`;
	    },
	    'incorrect-class': ({ expectedClass, paramName, moduleName, className, funcName, isReturnValueProblem }) => {
	        if (!expectedClass || !moduleName || !funcName) {
	            throw new Error(`Unexpected input to 'incorrect-class' error.`);
	        }
	        if (isReturnValueProblem) {
	            return `The return value from ` +
	                `'${moduleName}.${className ? (className + '.') : ''}${funcName}()' ` +
	                `must be an instance of class ${expectedClass.name}.`;
	        }
	        return `The parameter '${paramName}' passed into ` +
	            `'${moduleName}.${className ? (className + '.') : ''}${funcName}()' ` +
	            `must be an instance of class ${expectedClass.name}.`;
	    },
	    'missing-a-method': ({ expectedMethod, paramName, moduleName, className, funcName }) => {
	        if (!expectedMethod || !paramName || !moduleName || !className
	            || !funcName) {
	            throw new Error(`Unexpected input to 'missing-a-method' error.`);
	        }
	        return `${moduleName}.${className}.${funcName}() expected the ` +
	            `'${paramName}' parameter to expose a '${expectedMethod}' method.`;
	    },
	    'add-to-cache-list-unexpected-type': ({ entry }) => {
	        return `An unexpected entry was passed to ` +
	            `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` +
	            `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` +
	            `strings with one or more characters, objects with a url property or ` +
	            `Request objects.`;
	    },
	    'add-to-cache-list-conflicting-entries': ({ firstEntry, secondEntry }) => {
	        if (!firstEntry || !secondEntry) {
	            throw new Error(`Unexpected input to ` +
	                `'add-to-cache-list-duplicate-entries' error.`);
	        }
	        return `Two of the entries passed to ` +
	            `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` +
	            `${firstEntry._entryId} but different revision details. Workbox is ` +
	            `unable to cache and version the asset correctly. Please remove one ` +
	            `of the entries.`;
	    },
	    'plugin-error-request-will-fetch': ({ thrownError }) => {
	        if (!thrownError) {
	            throw new Error(`Unexpected input to ` +
	                `'plugin-error-request-will-fetch', error.`);
	        }
	        return `An error was thrown by a plugins 'requestWillFetch()' method. ` +
	            `The thrown error message was: '${thrownError.message}'.`;
	    },
	    'invalid-cache-name': ({ cacheNameId, value }) => {
	        if (!cacheNameId) {
	            throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);
	        }
	        return `You must provide a name containing at least one character for ` +
	            `setCacheDetails({${cacheNameId}: '...'}). Received a value of ` +
	            `'${JSON.stringify(value)}'`;
	    },
	    'unregister-route-but-not-found-with-method': ({ method }) => {
	        if (!method) {
	            throw new Error(`Unexpected input to ` +
	                `'unregister-route-but-not-found-with-method' error.`);
	        }
	        return `The route you're trying to unregister was not  previously ` +
	            `registered for the method type '${method}'.`;
	    },
	    'unregister-route-route-not-registered': () => {
	        return `The route you're trying to unregister was not previously ` +
	            `registered.`;
	    },
	    'queue-replay-failed': ({ name }) => {
	        return `Replaying the background sync queue '${name}' failed.`;
	    },
	    'duplicate-queue-name': ({ name }) => {
	        return `The Queue name '${name}' is already being used. ` +
	            `All instances of backgroundSync.Queue must be given unique names.`;
	    },
	    'expired-test-without-max-age': ({ methodName, paramName }) => {
	        return `The '${methodName}()' method can only be used when the ` +
	            `'${paramName}' is used in the constructor.`;
	    },
	    'unsupported-route-type': ({ moduleName, className, funcName, paramName }) => {
	        return `The supplied '${paramName}' parameter was an unsupported type. ` +
	            `Please check the docs for ${moduleName}.${className}.${funcName} for ` +
	            `valid input types.`;
	    },
	    'not-array-of-class': ({ value, expectedClass, moduleName, className, funcName, paramName }) => {
	        return `The supplied '${paramName}' parameter must be an array of ` +
	            `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` +
	            `Please check the call to ${moduleName}.${className}.${funcName}() ` +
	            `to fix the issue.`;
	    },
	    'max-entries-or-age-required': ({ moduleName, className, funcName }) => {
	        return `You must define either config.maxEntries or config.maxAgeSeconds` +
	            `in ${moduleName}.${className}.${funcName}`;
	    },
	    'statuses-or-headers-required': ({ moduleName, className, funcName }) => {
	        return `You must define either config.statuses or config.headers` +
	            `in ${moduleName}.${className}.${funcName}`;
	    },
	    'invalid-string': ({ moduleName, funcName, paramName }) => {
	        if (!paramName || !moduleName || !funcName) {
	            throw new Error(`Unexpected input to 'invalid-string' error.`);
	        }
	        return `When using strings, the '${paramName}' parameter must start with ` +
	            `'http' (for cross-origin matches) or '/' (for same-origin matches). ` +
	            `Please see the docs for ${moduleName}.${funcName}() for ` +
	            `more info.`;
	    },
	    'channel-name-required': () => {
	        return `You must provide a channelName to construct a ` +
	            `BroadcastCacheUpdate instance.`;
	    },
	    'invalid-responses-are-same-args': () => {
	        return `The arguments passed into responsesAreSame() appear to be ` +
	            `invalid. Please ensure valid Responses are used.`;
	    },
	    'expire-custom-caches-only': () => {
	        return `You must provide a 'cacheName' property when using the ` +
	            `expiration plugin with a runtime caching strategy.`;
	    },
	    'unit-must-be-bytes': ({ normalizedRangeHeader }) => {
	        if (!normalizedRangeHeader) {
	            throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);
	        }
	        return `The 'unit' portion of the Range header must be set to 'bytes'. ` +
	            `The Range header provided was "${normalizedRangeHeader}"`;
	    },
	    'single-range-only': ({ normalizedRangeHeader }) => {
	        if (!normalizedRangeHeader) {
	            throw new Error(`Unexpected input to 'single-range-only' error.`);
	        }
	        return `Multiple ranges are not supported. Please use a  single start ` +
	            `value, and optional end value. The Range header provided was ` +
	            `"${normalizedRangeHeader}"`;
	    },
	    'invalid-range-values': ({ normalizedRangeHeader }) => {
	        if (!normalizedRangeHeader) {
	            throw new Error(`Unexpected input to 'invalid-range-values' error.`);
	        }
	        return `The Range header is missing both start and end values. At least ` +
	            `one of those values is needed. The Range header provided was ` +
	            `"${normalizedRangeHeader}"`;
	    },
	    'no-range-header': () => {
	        return `No Range header was found in the Request provided.`;
	    },
	    'range-not-satisfiable': ({ size, start, end }) => {
	        return `The start (${start}) and end (${end}) values in the Range are ` +
	            `not satisfiable by the cached response, which is ${size} bytes.`;
	    },
	    'attempt-to-cache-non-get-request': ({ url, method }) => {
	        return `Unable to cache '${url}' because it is a '${method}' request and ` +
	            `only 'GET' requests can be cached.`;
	    },
	    'cache-put-with-no-response': ({ url }) => {
	        return `There was an attempt to cache '${url}' but the response was not ` +
	            `defined.`;
	    },
	    'no-response': ({ url, error }) => {
	        let message = `The strategy could not generate a response for '${url}'.`;
	        if (error) {
	            message += ` The underlying error is ${error}.`;
	        }
	        return message;
	    },
	    'bad-precaching-response': ({ url, status }) => {
	        return `The precaching request for '${url}' failed` +
	            (status ? ` with an HTTP status of ${status}.` : `.`);
	    },
	    'non-precached-url': ({ url }) => {
	        return `createHandlerBoundToURL('${url}') was called, but that URL is ` +
	            `not precached. Please pass in a URL that is precached instead.`;
	    },
	    'add-to-cache-list-conflicting-integrities': ({ url }) => {
	        return `Two of the entries passed to ` +
	            `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` +
	            `${url} with different integrity values. Please remove one of them.`;
	    },
	    'missing-precache-entry': ({ cacheName, url }) => {
	        return `Unable to find a precached response in ${cacheName} for ${url}.`;
	    },
	    'cross-origin-copy-response': ({ origin }) => {
	        return `workbox-core.copyResponse() can only be used with same-origin ` +
	            `responses. It was passed a response with origin ${origin}.`;
	    },
	};

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const generatorFunction = (code, details = {}) => {
	    const message = messages[code];
	    if (!message) {
	        throw new Error(`Unable to find message for code '${code}'.`);
	    }
	    return message(details);
	};
	const messageGenerator =  generatorFunction;

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Workbox errors should be thrown with this class.
	 * This allows use to ensure the type easily in tests,
	 * helps developers identify errors from workbox
	 * easily and allows use to optimise error
	 * messages correctly.
	 *
	 * @private
	 */
	class WorkboxError extends Error {
	    /**
	     *
	     * @param {string} errorCode The error code that
	     * identifies this particular error.
	     * @param {Object=} details Any relevant arguments
	     * that will help developers identify issues should
	     * be added as a key on the context object.
	     */
	    constructor(errorCode, details) {
	        const message = messageGenerator(errorCode, details);
	        super(message);
	        this.name = errorCode;
	        this.details = details;
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/*
	 * This method throws if the supplied value is not an array.
	 * The destructed values are required to produce a meaningful error for users.
	 * The destructed and restructured object is so it's clear what is
	 * needed.
	 */
	const isArray = (value, details) => {
	    if (!Array.isArray(value)) {
	        throw new WorkboxError('not-an-array', details);
	    }
	};
	const hasMethod = (object, expectedMethod, details) => {
	    const type = typeof object[expectedMethod];
	    if (type !== 'function') {
	        details['expectedMethod'] = expectedMethod;
	        throw new WorkboxError('missing-a-method', details);
	    }
	};
	const isType = (object, expectedType, details) => {
	    if (typeof object !== expectedType) {
	        details['expectedType'] = expectedType;
	        throw new WorkboxError('incorrect-type', details);
	    }
	};
	const isInstance = (object, expectedClass, details) => {
	    if (!(object instanceof expectedClass)) {
	        details['expectedClass'] = expectedClass;
	        throw new WorkboxError('incorrect-class', details);
	    }
	};
	const isOneOf = (value, validValues, details) => {
	    if (!validValues.includes(value)) {
	        details['validValueDescription'] =
	            `Valid values are ${JSON.stringify(validValues)}.`;
	        throw new WorkboxError('invalid-value', details);
	    }
	};
	const isArrayOfClass = (value, expectedClass, details) => {
	    const error = new WorkboxError('not-array-of-class', details);
	    if (!Array.isArray(value)) {
	        throw error;
	    }
	    for (const item of value) {
	        if (!(item instanceof expectedClass)) {
	            throw error;
	        }
	    }
	};
	const finalAssertExports =  {
	    hasMethod,
	    isArray,
	    isInstance,
	    isOneOf,
	    isType,
	    isArrayOfClass,
	};

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const _cacheNameDetails = {
	    googleAnalytics: 'googleAnalytics',
	    precache: 'precache-v2',
	    prefix: 'workbox',
	    runtime: 'runtime',
	    suffix: typeof registration !== 'undefined' ? registration.scope : '',
	};
	const _createCacheName = (cacheName) => {
	    return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix]
	        .filter((value) => value && value.length > 0)
	        .join('-');
	};
	const eachCacheNameDetail = (fn) => {
	    for (const key of Object.keys(_cacheNameDetails)) {
	        fn(key);
	    }
	};
	const cacheNames = {
	    updateDetails: (details) => {
	        eachCacheNameDetail((key) => {
	            if (typeof details[key] === 'string') {
	                _cacheNameDetails[key] = details[key];
	            }
	        });
	    },
	    getGoogleAnalyticsName: (userCacheName) => {
	        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);
	    },
	    getPrecacheName: (userCacheName) => {
	        return userCacheName || _createCacheName(_cacheNameDetails.precache);
	    },
	    getPrefix: () => {
	        return _cacheNameDetails.prefix;
	    },
	    getRuntimeName: (userCacheName) => {
	        return userCacheName || _createCacheName(_cacheNameDetails.runtime);
	    },
	    getSuffix: () => {
	        return _cacheNameDetails.suffix;
	    },
	};

	/*
	  Copyright 2019 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const logger = ( (() => {
	    // Don't overwrite this value if it's already set.
	    // See https://github.com/GoogleChrome/workbox/pull/2284#issuecomment-560470923
	    if (!('__WB_DISABLE_DEV_LOGS' in self)) {
	        self.__WB_DISABLE_DEV_LOGS = false;
	    }
	    let inGroup = false;
	    const methodToColorMap = {
	        debug: `#7f8c8d`,
	        log: `#2ecc71`,
	        warn: `#f39c12`,
	        error: `#c0392b`,
	        groupCollapsed: `#3498db`,
	        groupEnd: null,
	    };
	    const print = function (method, args) {
	        if (self.__WB_DISABLE_DEV_LOGS) {
	            return;
	        }
	        if (method === 'groupCollapsed') {
	            // Safari doesn't print all console.groupCollapsed() arguments:
	            // https://bugs.webkit.org/show_bug.cgi?id=182754
	            if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
	                console[method](...args);
	                return;
	            }
	        }
	        const styles = [
	            `background: ${methodToColorMap[method]}`,
	            `border-radius: 0.5em`,
	            `color: white`,
	            `font-weight: bold`,
	            `padding: 2px 0.5em`,
	        ];
	        // When in a group, the workbox prefix is not displayed.
	        const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];
	        console[method](...logPrefix, ...args);
	        if (method === 'groupCollapsed') {
	            inGroup = true;
	        }
	        if (method === 'groupEnd') {
	            inGroup = false;
	        }
	    };
	    const api = {};
	    const loggerMethods = Object.keys(methodToColorMap);
	    for (const key of loggerMethods) {
	        const method = key;
	        api[method] = (...args) => {
	            print(method, args);
	        };
	    }
	    return api;
	})());

	/*
	  Copyright 2020 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A utility method that makes it easier to use `event.waitUntil` with
	 * async functions and return the result.
	 *
	 * @param {ExtendableEvent} event
	 * @param {Function} asyncFn
	 * @return {Function}
	 * @private
	 */
	function waitUntil(event, asyncFn) {
	    const returnPromise = asyncFn();
	    event.waitUntil(returnPromise);
	    return returnPromise;
	}

	// @ts-ignore
	try {
	    self['workbox:precaching:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	// Name of the search parameter used to store revision info.
	const REVISION_SEARCH_PARAM = '__WB_REVISION__';
	/**
	 * Converts a manifest entry into a versioned URL suitable for precaching.
	 *
	 * @param {Object|string} entry
	 * @return {string} A URL with versioning info.
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function createCacheKey(entry) {
	    if (!entry) {
	        throw new WorkboxError('add-to-cache-list-unexpected-type', { entry });
	    }
	    // If a precache manifest entry is a string, it's assumed to be a versioned
	    // URL, like '/app.abcd1234.js'. Return as-is.
	    if (typeof entry === 'string') {
	        const urlObject = new URL(entry, location.href);
	        return {
	            cacheKey: urlObject.href,
	            url: urlObject.href,
	        };
	    }
	    const { revision, url } = entry;
	    if (!url) {
	        throw new WorkboxError('add-to-cache-list-unexpected-type', { entry });
	    }
	    // If there's just a URL and no revision, then it's also assumed to be a
	    // versioned URL.
	    if (!revision) {
	        const urlObject = new URL(url, location.href);
	        return {
	            cacheKey: urlObject.href,
	            url: urlObject.href,
	        };
	    }
	    // Otherwise, construct a properly versioned URL using the custom Workbox
	    // search parameter along with the revision info.
	    const cacheKeyURL = new URL(url, location.href);
	    const originalURL = new URL(url, location.href);
	    cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);
	    return {
	        cacheKey: cacheKeyURL.href,
	        url: originalURL.href,
	    };
	}

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A plugin, designed to be used with PrecacheController, to determine the
	 * of assets that were updated (or not updated) during the install event.
	 *
	 * @private
	 */
	class PrecacheInstallReportPlugin {
	    constructor() {
	        this.updatedURLs = [];
	        this.notUpdatedURLs = [];
	        this.handlerWillStart = async ({ request, state, }) => {
	            // TODO: `state` should never be undefined...
	            if (state) {
	                state.originalRequest = request;
	            }
	        };
	        this.cachedResponseWillBeUsed = async ({ event, state, cachedResponse, }) => {
	            if (event.type === 'install') {
	                // TODO: `state` should never be undefined...
	                const url = state.originalRequest.url;
	                if (cachedResponse) {
	                    this.notUpdatedURLs.push(url);
	                }
	                else {
	                    this.updatedURLs.push(url);
	                }
	            }
	            return cachedResponse;
	        };
	    }
	}

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A plugin, designed to be used with PrecacheController, to translate URLs into
	 * the corresponding cache key, based on the current revision info.
	 *
	 * @private
	 */
	class PrecacheCacheKeyPlugin {
	    constructor({ precacheController }) {
	        this.cacheKeyWillBeUsed = async ({ request, params, }) => {
	            const cacheKey = params && params.cacheKey ||
	                this._precacheController.getCacheKeyForURL(request.url);
	            return cacheKey ? new Request(cacheKey) : request;
	        };
	        this._precacheController = precacheController;
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * @param {string} groupTitle
	 * @param {Array<string>} deletedURLs
	 *
	 * @private
	 */
	const logGroup = (groupTitle, deletedURLs) => {
	    logger.groupCollapsed(groupTitle);
	    for (const url of deletedURLs) {
	        logger.log(url);
	    }
	    logger.groupEnd();
	};
	/**
	 * @param {Array<string>} deletedURLs
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function printCleanupDetails(deletedURLs) {
	    const deletionCount = deletedURLs.length;
	    if (deletionCount > 0) {
	        logger.groupCollapsed(`During precaching cleanup, ` +
	            `${deletionCount} cached ` +
	            `request${deletionCount === 1 ? ' was' : 's were'} deleted.`);
	        logGroup('Deleted Cache Requests', deletedURLs);
	        logger.groupEnd();
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * @param {string} groupTitle
	 * @param {Array<string>} urls
	 *
	 * @private
	 */
	function _nestedGroup(groupTitle, urls) {
	    if (urls.length === 0) {
	        return;
	    }
	    logger.groupCollapsed(groupTitle);
	    for (const url of urls) {
	        logger.log(url);
	    }
	    logger.groupEnd();
	}
	/**
	 * @param {Array<string>} urlsToPrecache
	 * @param {Array<string>} urlsAlreadyPrecached
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function printInstallDetails(urlsToPrecache, urlsAlreadyPrecached) {
	    const precachedCount = urlsToPrecache.length;
	    const alreadyPrecachedCount = urlsAlreadyPrecached.length;
	    if (precachedCount || alreadyPrecachedCount) {
	        let message = `Precaching ${precachedCount} file${precachedCount === 1 ? '' : 's'}.`;
	        if (alreadyPrecachedCount > 0) {
	            message += ` ${alreadyPrecachedCount} ` +
	                `file${alreadyPrecachedCount === 1 ? ' is' : 's are'} already cached.`;
	        }
	        logger.groupCollapsed(message);
	        _nestedGroup(`View newly precached URLs.`, urlsToPrecache);
	        _nestedGroup(`View previously precached URLs.`, urlsAlreadyPrecached);
	        logger.groupEnd();
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	let supportStatus;
	/**
	 * A utility function that determines whether the current browser supports
	 * constructing a new `Response` from a `response.body` stream.
	 *
	 * @return {boolean} `true`, if the current browser can successfully
	 *     construct a `Response` from a `response.body` stream, `false` otherwise.
	 *
	 * @private
	 */
	function canConstructResponseFromBodyStream() {
	    if (supportStatus === undefined) {
	        const testResponse = new Response('');
	        if ('body' in testResponse) {
	            try {
	                new Response(testResponse.body);
	                supportStatus = true;
	            }
	            catch (error) {
	                supportStatus = false;
	            }
	        }
	        supportStatus = false;
	    }
	    return supportStatus;
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Allows developers to copy a response and modify its `headers`, `status`,
	 * or `statusText` values (the values settable via a
	 * [`ResponseInit`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#Syntax}
	 * object in the constructor).
	 * To modify these values, pass a function as the second argument. That
	 * function will be invoked with a single object with the response properties
	 * `{headers, status, statusText}`. The return value of this function will
	 * be used as the `ResponseInit` for the new `Response`. To change the values
	 * either modify the passed parameter(s) and return it, or return a totally
	 * new object.
	 *
	 * This method is intentionally limited to same-origin responses, regardless of
	 * whether CORS was used or not.
	 *
	 * @param {Response} response
	 * @param {Function} modifier
	 * @memberof module:workbox-core
	 */
	async function copyResponse(response, modifier) {
	    let origin = null;
	    // If response.url isn't set, assume it's cross-origin and keep origin null.
	    if (response.url) {
	        const responseURL = new URL(response.url);
	        origin = responseURL.origin;
	    }
	    if (origin !== self.location.origin) {
	        throw new WorkboxError('cross-origin-copy-response', { origin });
	    }
	    const clonedResponse = response.clone();
	    // Create a fresh `ResponseInit` object by cloning the headers.
	    const responseInit = {
	        headers: new Headers(clonedResponse.headers),
	        status: clonedResponse.status,
	        statusText: clonedResponse.statusText,
	    };
	    // Apply any user modifications.
	    const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;
	    // Create the new response from the body stream and `ResponseInit`
	    // modifications. Note: not all browsers support the Response.body stream,
	    // so fall back to reading the entire body into memory as a blob.
	    const body = canConstructResponseFromBodyStream() ?
	        clonedResponse.body : await clonedResponse.blob();
	    return new Response(body, modifiedResponseInit);
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const getFriendlyURL = (url) => {
	    const urlObj = new URL(String(url), location.href);
	    // See https://github.com/GoogleChrome/workbox/issues/2323
	    // We want to include everything, except for the origin if it's same-origin.
	    return urlObj.href.replace(new RegExp(`^${location.origin}`), '');
	};

	/*
	  Copyright 2020 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	function stripParams(fullURL, ignoreParams) {
	    const strippedURL = new URL(fullURL);
	    for (const param of ignoreParams) {
	        strippedURL.searchParams.delete(param);
	    }
	    return strippedURL.href;
	}
	/**
	 * Matches an item in the cache, ignoring specific URL params. This is similar
	 * to the `ignoreSearch` option, but it allows you to ignore just specific
	 * params (while continuing to match on the others).
	 *
	 * @private
	 * @param {Cache} cache
	 * @param {Request} request
	 * @param {Object} matchOptions
	 * @param {Array<string>} ignoreParams
	 * @return {Promise<Response|undefined>}
	 */
	async function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {
	    const strippedRequestURL = stripParams(request.url, ignoreParams);
	    // If the request doesn't include any ignored params, match as normal.
	    if (request.url === strippedRequestURL) {
	        return cache.match(request, matchOptions);
	    }
	    // Otherwise, match by comparing keys
	    const keysOptions = { ...matchOptions, ignoreSearch: true };
	    const cacheKeys = await cache.keys(request, keysOptions);
	    for (const cacheKey of cacheKeys) {
	        const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);
	        if (strippedRequestURL === strippedCacheKeyURL) {
	            return cache.match(cacheKey, matchOptions);
	        }
	    }
	    return;
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * The Deferred class composes Promises in a way that allows for them to be
	 * resolved or rejected from outside the constructor. In most cases promises
	 * should be used directly, but Deferreds can be necessary when the logic to
	 * resolve a promise must be separate.
	 *
	 * @private
	 */
	class Deferred {
	    /**
	     * Creates a promise and exposes its resolve and reject functions as methods.
	     */
	    constructor() {
	        this.promise = new Promise((resolve, reject) => {
	            this.resolve = resolve;
	            this.reject = reject;
	        });
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	// Callbacks to be executed whenever there's a quota error.
	const quotaErrorCallbacks = new Set();

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Runs all of the callback functions, one at a time sequentially, in the order
	 * in which they were registered.
	 *
	 * @memberof module:workbox-core
	 * @private
	 */
	async function executeQuotaErrorCallbacks() {
	    {
	        logger.log(`About to run ${quotaErrorCallbacks.size} ` +
	            `callbacks to clean up caches.`);
	    }
	    for (const callback of quotaErrorCallbacks) {
	        await callback();
	        {
	            logger.log(callback, 'is complete.');
	        }
	    }
	    {
	        logger.log('Finished running callbacks.');
	    }
	}

	/*
	  Copyright 2019 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Returns a promise that resolves and the passed number of milliseconds.
	 * This utility is an async/await-friendly version of `setTimeout`.
	 *
	 * @param {number} ms
	 * @return {Promise}
	 * @private
	 */
	function timeout(ms) {
	    return new Promise((resolve) => setTimeout(resolve, ms));
	}

	// @ts-ignore
	try {
	    self['workbox:strategies:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	function toRequest(input) {
	    return (typeof input === 'string') ? new Request(input) : input;
	}
	/**
	 * A class created every time a Strategy instance instance calls
	 * [handle()]{@link module:workbox-strategies.Strategy~handle} or
	 * [handleAll()]{@link module:workbox-strategies.Strategy~handleAll} that wraps all fetch and
	 * cache actions around plugin callbacks and keeps track of when the strategy
	 * is "done" (i.e. all added `event.waitUntil()` promises have resolved).
	 *
	 * @memberof module:workbox-strategies
	 */
	class StrategyHandler {
	    /**
	     * Creates a new instance associated with the passed strategy and event
	     * that's handling the request.
	     *
	     * The constructor also initializes the state that will be passed to each of
	     * the plugins handling this request.
	     *
	     * @param {module:workbox-strategies.Strategy} strategy
	     * @param {Object} options
	     * @param {Request|string} options.request A request to run this strategy for.
	     * @param {ExtendableEvent} options.event The event associated with the
	     *     request.
	     * @param {URL} [options.url]
	     * @param {*} [options.params]
	     *     [match callback]{@link module:workbox-routing~matchCallback},
	     *     (if applicable).
	     */
	    constructor(strategy, options) {
	        this._cacheKeys = {};
	        /**
	         * The request the strategy is performing (passed to the strategy's
	         * `handle()` or `handleAll()` method).
	         * @name request
	         * @instance
	         * @type {Request}
	         * @memberof module:workbox-strategies.StrategyHandler
	         */
	        /**
	         * The event associated with this request.
	         * @name event
	         * @instance
	         * @type {ExtendableEvent}
	         * @memberof module:workbox-strategies.StrategyHandler
	         */
	        /**
	         * A `URL` instance of `request.url` (if passed to the strategy's
	         * `handle()` or `handleAll()` method).
	         * Note: the `url` param will be present if the strategy was invoked
	         * from a workbox `Route` object.
	         * @name url
	         * @instance
	         * @type {URL|undefined}
	         * @memberof module:workbox-strategies.StrategyHandler
	         */
	        /**
	         * A `param` value (if passed to the strategy's
	         * `handle()` or `handleAll()` method).
	         * Note: the `param` param will be present if the strategy was invoked
	         * from a workbox `Route` object and the
	         * [match callback]{@link module:workbox-routing~matchCallback} returned
	         * a truthy value (it will be that value).
	         * @name params
	         * @instance
	         * @type {*|undefined}
	         * @memberof module:workbox-strategies.StrategyHandler
	         */
	        {
	            finalAssertExports.isInstance(options.event, ExtendableEvent, {
	                moduleName: 'workbox-strategies',
	                className: 'StrategyHandler',
	                funcName: 'constructor',
	                paramName: 'options.event',
	            });
	        }
	        Object.assign(this, options);
	        this.event = options.event;
	        this._strategy = strategy;
	        this._handlerDeferred = new Deferred();
	        this._extendLifetimePromises = [];
	        // Copy the plugins list (since it's mutable on the strategy),
	        // so any mutations don't affect this handler instance.
	        this._plugins = [...strategy.plugins];
	        this._pluginStateMap = new Map();
	        for (const plugin of this._plugins) {
	            this._pluginStateMap.set(plugin, {});
	        }
	        this.event.waitUntil(this._handlerDeferred.promise);
	    }
	    /**
	     * Fetches a given request (and invokes any applicable plugin callback
	     * methods) using the `fetchOptions` and `plugins` defined on the strategy
	     * object.
	     *
	     * The following plugin lifecycle methods are invoked when using this method:
	     * - `requestWillFetch()`
	     * - `fetchDidSucceed()`
	     * - `fetchDidFail()`
	     *
	     * @param {Request|string} input The URL or request to fetch.
	     * @return {Promise<Response>}
	     */
	    fetch(input) {
	        return this.waitUntil((async () => {
	            const { event } = this;
	            let request = toRequest(input);
	            if (request.mode === 'navigate' &&
	                event instanceof FetchEvent &&
	                event.preloadResponse) {
	                const possiblePreloadResponse = await event.preloadResponse;
	                if (possiblePreloadResponse) {
	                    {
	                        logger.log(`Using a preloaded navigation response for ` +
	                            `'${getFriendlyURL(request.url)}'`);
	                    }
	                    return possiblePreloadResponse;
	                }
	            }
	            // If there is a fetchDidFail plugin, we need to save a clone of the
	            // original request before it's either modified by a requestWillFetch
	            // plugin or before the original request's body is consumed via fetch().
	            const originalRequest = this.hasCallback('fetchDidFail') ?
	                request.clone() : null;
	            try {
	                for (const cb of this.iterateCallbacks('requestWillFetch')) {
	                    request = await cb({ request: request.clone(), event });
	                }
	            }
	            catch (err) {
	                throw new WorkboxError('plugin-error-request-will-fetch', {
	                    thrownError: err,
	                });
	            }
	            // The request can be altered by plugins with `requestWillFetch` making
	            // the original request (most likely from a `fetch` event) different
	            // from the Request we make. Pass both to `fetchDidFail` to aid debugging.
	            const pluginFilteredRequest = request.clone();
	            try {
	                let fetchResponse;
	                // See https://github.com/GoogleChrome/workbox/issues/1796
	                fetchResponse = await fetch(request, request.mode === 'navigate' ?
	                    undefined : this._strategy.fetchOptions);
	                if ("development" !== 'production') {
	                    logger.debug(`Network request for ` +
	                        `'${getFriendlyURL(request.url)}' returned a response with ` +
	                        `status '${fetchResponse.status}'.`);
	                }
	                for (const callback of this.iterateCallbacks('fetchDidSucceed')) {
	                    fetchResponse = await callback({
	                        event,
	                        request: pluginFilteredRequest,
	                        response: fetchResponse,
	                    });
	                }
	                return fetchResponse;
	            }
	            catch (error) {
	                {
	                    logger.error(`Network request for ` +
	                        `'${getFriendlyURL(request.url)}' threw an error.`, error);
	                }
	                // `originalRequest` will only exist if a `fetchDidFail` callback
	                // is being used (see above).
	                if (originalRequest) {
	                    await this.runCallbacks('fetchDidFail', {
	                        error,
	                        event,
	                        originalRequest: originalRequest.clone(),
	                        request: pluginFilteredRequest.clone(),
	                    });
	                }
	                throw error;
	            }
	        })());
	    }
	    /**
	     * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on
	     * the response generated by `this.fetch()`.
	     *
	     * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,
	     * so you do not have to manually call `waitUntil()` on the event.
	     *
	     * @param {Request|string} input The request or URL to fetch and cache.
	     * @return {Promise<Response>}
	     */
	    async fetchAndCachePut(input) {
	        const response = await this.fetch(input);
	        const responseClone = response.clone();
	        this.waitUntil(this.cachePut(input, responseClone));
	        return response;
	    }
	    /**
	     * Matches a request from the cache (and invokes any applicable plugin
	     * callback methods) using the `cacheName`, `matchOptions`, and `plugins`
	     * defined on the strategy object.
	     *
	     * The following plugin lifecycle methods are invoked when using this method:
	     * - cacheKeyWillByUsed()
	     * - cachedResponseWillByUsed()
	     *
	     * @param {Request|string} key The Request or URL to use as the cache key.
	     * @return {Promise<Response|undefined>} A matching response, if found.
	     */
	    cacheMatch(key) {
	        return this.waitUntil((async () => {
	            const request = toRequest(key);
	            let cachedResponse;
	            const { cacheName, matchOptions } = this._strategy;
	            const effectiveRequest = await this.getCacheKey(request, 'read');
	            const multiMatchOptions = { ...matchOptions, ...{ cacheName } };
	            cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);
	            {
	                if (cachedResponse) {
	                    logger.debug(`Found a cached response in '${cacheName}'.`);
	                }
	                else {
	                    logger.debug(`No cached response found in '${cacheName}'.`);
	                }
	            }
	            for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {
	                cachedResponse = (await callback({
	                    cacheName,
	                    matchOptions,
	                    cachedResponse,
	                    request: effectiveRequest,
	                    event: this.event,
	                })) || undefined;
	            }
	            return cachedResponse;
	        })());
	    }
	    /**
	     * Puts a request/response pair in the cache (and invokes any applicable
	     * plugin callback methods) using the `cacheName` and `plugins` defined on
	     * the strategy object.
	     *
	     * The following plugin lifecycle methods are invoked when using this method:
	     * - cacheKeyWillByUsed()
	     * - cacheWillUpdate()
	     * - cacheDidUpdate()
	     *
	     * @param {Request|string} key The request or URL to use as the cache key.
	     * @param {Promise<void>} response The response to cache.
	     */
	    async cachePut(key, response) {
	        const request = toRequest(key);
	        // Run in the next task to avoid blocking other cache reads.
	        // https://github.com/w3c/ServiceWorker/issues/1397
	        await timeout(0);
	        const effectiveRequest = await this.getCacheKey(request, 'write');
	        {
	            if (effectiveRequest.method && effectiveRequest.method !== 'GET') {
	                throw new WorkboxError('attempt-to-cache-non-get-request', {
	                    url: getFriendlyURL(effectiveRequest.url),
	                    method: effectiveRequest.method,
	                });
	            }
	        }
	        if (!response) {
	            {
	                logger.error(`Cannot cache non-existent response for ` +
	                    `'${getFriendlyURL(effectiveRequest.url)}'.`);
	            }
	            throw new WorkboxError('cache-put-with-no-response', {
	                url: getFriendlyURL(effectiveRequest.url),
	            });
	        }
	        const responseToCache = await this._ensureResponseSafeToCache(response);
	        if (!responseToCache) {
	            {
	                logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` +
	                    `will not be cached.`, responseToCache);
	            }
	            return;
	        }
	        const { cacheName, matchOptions } = this._strategy;
	        const cache = await self.caches.open(cacheName);
	        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');
	        const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams(
	        // TODO(philipwalton): the `__WB_REVISION__` param is a precaching
	        // feature. Consider into ways to only add this behavior if using
	        // precaching.
	        cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions) :
	            null;
	        {
	            logger.debug(`Updating the '${cacheName}' cache with a new Response ` +
	                `for ${getFriendlyURL(effectiveRequest.url)}.`);
	        }
	        try {
	            await cache.put(effectiveRequest, hasCacheUpdateCallback ?
	                responseToCache.clone() : responseToCache);
	        }
	        catch (error) {
	            // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError
	            if (error.name === 'QuotaExceededError') {
	                await executeQuotaErrorCallbacks();
	            }
	            throw error;
	        }
	        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {
	            await callback({
	                cacheName,
	                oldResponse,
	                newResponse: responseToCache.clone(),
	                request: effectiveRequest,
	                event: this.event,
	            });
	        }
	    }
	    /**
	     * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and
	     * executes any of those callbacks found in sequence. The final `Request`
	     * object returned by the last plugin is treated as the cache key for cache
	     * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have
	     * been registered, the passed request is returned unmodified
	     *
	     * @param {Request} request
	     * @param {string} mode
	     * @return {Promise<Request>}
	     */
	    async getCacheKey(request, mode) {
	        if (!this._cacheKeys[mode]) {
	            let effectiveRequest = request;
	            for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {
	                effectiveRequest = toRequest(await callback({
	                    mode,
	                    request: effectiveRequest,
	                    event: this.event,
	                    params: this.params,
	                }));
	            }
	            this._cacheKeys[mode] = effectiveRequest;
	        }
	        return this._cacheKeys[mode];
	    }
	    /**
	     * Returns true if the strategy has at least one plugin with the given
	     * callback.
	     *
	     * @param {string} name The name of the callback to check for.
	     * @return {boolean}
	     */
	    hasCallback(name) {
	        for (const plugin of this._strategy.plugins) {
	            if (name in plugin) {
	                return true;
	            }
	        }
	        return false;
	    }
	    /**
	     * Runs all plugin callbacks matching the given name, in order, passing the
	     * given param object (merged ith the current plugin state) as the only
	     * argument.
	     *
	     * Note: since this method runs all plugins, it's not suitable for cases
	     * where the return value of a callback needs to be applied prior to calling
	     * the next callback. See
	     * [`iterateCallbacks()`]{@link module:workbox-strategies.StrategyHandler#iterateCallbacks}
	     * below for how to handle that case.
	     *
	     * @param {string} name The name of the callback to run within each plugin.
	     * @param {Object} param The object to pass as the first (and only) param
	     *     when executing each callback. This object will be merged with the
	     *     current plugin state prior to callback execution.
	     */
	    async runCallbacks(name, param) {
	        for (const callback of this.iterateCallbacks(name)) {
	            // TODO(philipwalton): not sure why `any` is needed. It seems like
	            // this should work with `as WorkboxPluginCallbackParam[C]`.
	            await callback(param);
	        }
	    }
	    /**
	     * Accepts a callback and returns an iterable of matching plugin callbacks,
	     * where each callback is wrapped with the current handler state (i.e. when
	     * you call each callback, whatever object parameter you pass it will
	     * be merged with the plugin's current state).
	     *
	     * @param {string} name The name fo the callback to run
	     * @return {Array<Function>}
	     */
	    *iterateCallbacks(name) {
	        for (const plugin of this._strategy.plugins) {
	            if (typeof plugin[name] === 'function') {
	                const state = this._pluginStateMap.get(plugin);
	                const statefulCallback = (param) => {
	                    const statefulParam = { ...param, state };
	                    // TODO(philipwalton): not sure why `any` is needed. It seems like
	                    // this should work with `as WorkboxPluginCallbackParam[C]`.
	                    return plugin[name](statefulParam);
	                };
	                yield statefulCallback;
	            }
	        }
	    }
	    /**
	     * Adds a promise to the
	     * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}
	     * of the event event associated with the request being handled (usually a
	     * `FetchEvent`).
	     *
	     * Note: you can await
	     * [`doneWaiting()`]{@link module:workbox-strategies.StrategyHandler~doneWaiting}
	     * to know when all added promises have settled.
	     *
	     * @param {Promise} promise A promise to add to the extend lifetime promises
	     *     of the event that triggered the request.
	     */
	    waitUntil(promise) {
	        this._extendLifetimePromises.push(promise);
	        return promise;
	    }
	    /**
	     * Returns a promise that resolves once all promises passed to
	     * [`waitUntil()`]{@link module:workbox-strategies.StrategyHandler~waitUntil}
	     * have settled.
	     *
	     * Note: any work done after `doneWaiting()` settles should be manually
	     * passed to an event's `waitUntil()` method (not this handler's
	     * `waitUntil()` method), otherwise the service worker thread my be killed
	     * prior to your work completing.
	     */
	    async doneWaiting() {
	        let promise;
	        while (promise = this._extendLifetimePromises.shift()) {
	            await promise;
	        }
	    }
	    /**
	     * Stops running the strategy and immediately resolves any pending
	     * `waitUntil()` promises.
	     */
	    destroy() {
	        this._handlerDeferred.resolve();
	    }
	    /**
	     * This method will call cacheWillUpdate on the available plugins (or use
	     * status === 200) to determine if the Response is safe and valid to cache.
	     *
	     * @param {Request} options.request
	     * @param {Response} options.response
	     * @return {Promise<Response|undefined>}
	     *
	     * @private
	     */
	    async _ensureResponseSafeToCache(response) {
	        let responseToCache = response;
	        let pluginsUsed = false;
	        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {
	            responseToCache = (await callback({
	                request: this.request,
	                response: responseToCache,
	                event: this.event,
	            })) || undefined;
	            pluginsUsed = true;
	            if (!responseToCache) {
	                break;
	            }
	        }
	        if (!pluginsUsed) {
	            if (responseToCache && responseToCache.status !== 200) {
	                responseToCache = undefined;
	            }
	            {
	                if (responseToCache) {
	                    if (responseToCache.status !== 200) {
	                        if (responseToCache.status === 0) {
	                            logger.warn(`The response for '${this.request.url}' ` +
	                                `is an opaque response. The caching strategy that you're ` +
	                                `using will not cache opaque responses by default.`);
	                        }
	                        else {
	                            logger.debug(`The response for '${this.request.url}' ` +
	                                `returned a status code of '${response.status}' and won't ` +
	                                `be cached as a result.`);
	                        }
	                    }
	                }
	            }
	        }
	        return responseToCache;
	    }
	}

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * An abstract base class that all other strategy classes must extend from:
	 *
	 * @memberof module:workbox-strategies
	 */
	class Strategy {
	    /**
	     * Creates a new instance of the strategy and sets all documented option
	     * properties as public instance properties.
	     *
	     * Note: if a custom strategy class extends the base Strategy class and does
	     * not need more than these properties, it does not need to define its own
	     * constructor.
	     *
	     * @param {Object} [options]
	     * @param {string} [options.cacheName] Cache name to store and retrieve
	     * requests. Defaults to the cache names provided by
	     * [workbox-core]{@link module:workbox-core.cacheNames}.
	     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
	     * to use in conjunction with this caching strategy.
	     * @param {Object} [options.fetchOptions] Values passed along to the
	     * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}
	     * of all fetch() requests made by this strategy.
	     * @param {Object} [options.matchOptions] The
	     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
	     * for any `cache.match()` or `cache.put()` calls made by this strategy.
	     */
	    constructor(options = {}) {
	        /**
	         * Cache name to store and retrieve
	         * requests. Defaults to the cache names provided by
	         * [workbox-core]{@link module:workbox-core.cacheNames}.
	         *
	         * @type {string}
	         */
	        this.cacheName = cacheNames.getRuntimeName(options.cacheName);
	        /**
	         * The list
	         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
	         * used by this strategy.
	         *
	         * @type {Array<Object>}
	         */
	        this.plugins = options.plugins || [];
	        /**
	         * Values passed along to the
	         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}
	         * of all fetch() requests made by this strategy.
	         *
	         * @type {Object}
	         */
	        this.fetchOptions = options.fetchOptions;
	        /**
	         * The
	         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
	         * for any `cache.match()` or `cache.put()` calls made by this strategy.
	         *
	         * @type {Object}
	         */
	        this.matchOptions = options.matchOptions;
	    }
	    /**
	     * Perform a request strategy and returns a `Promise` that will resolve with
	     * a `Response`, invoking all relevant plugin callbacks.
	     *
	     * When a strategy instance is registered with a Workbox
	     * [route]{@link module:workbox-routing.Route}, this method is automatically
	     * called when the route matches.
	     *
	     * Alternatively, this method can be used in a standalone `FetchEvent`
	     * listener by passing it to `event.respondWith()`.
	     *
	     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
	     *     properties listed below.
	     * @param {Request|string} options.request A request to run this strategy for.
	     * @param {ExtendableEvent} options.event The event associated with the
	     *     request.
	     * @param {URL} [options.url]
	     * @param {*} [options.params]
	     */
	    handle(options) {
	        const [responseDone] = this.handleAll(options);
	        return responseDone;
	    }
	    /**
	     * Similar to [`handle()`]{@link module:workbox-strategies.Strategy~handle}, but
	     * instead of just returning a `Promise` that resolves to a `Response` it
	     * it will return an tuple of [response, done] promises, where the former
	     * (`response`) is equivalent to what `handle()` returns, and the latter is a
	     * Promise that will resolve once any promises that were added to
	     * `event.waitUntil()` as part of performing the strategy have completed.
	     *
	     * You can await the `done` promise to ensure any extra work performed by
	     * the strategy (usually caching responses) completes successfully.
	     *
	     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
	     *     properties listed below.
	     * @param {Request|string} options.request A request to run this strategy for.
	     * @param {ExtendableEvent} options.event The event associated with the
	     *     request.
	     * @param {URL} [options.url]
	     * @param {*} [options.params]
	     * @return {Array<Promise>} A tuple of [response, done]
	     *     promises that can be used to determine when the response resolves as
	     *     well as when the handler has completed all its work.
	     */
	    handleAll(options) {
	        // Allow for flexible options to be passed.
	        if (options instanceof FetchEvent) {
	            options = {
	                event: options,
	                request: options.request,
	            };
	        }
	        const event = options.event;
	        const request = typeof options.request === 'string' ?
	            new Request(options.request) :
	            options.request;
	        const params = 'params' in options ? options.params : undefined;
	        const handler = new StrategyHandler(this, { event, request, params });
	        const responseDone = this._getResponse(handler, request, event);
	        const handlerDone = this._awaitComplete(responseDone, handler, request, event);
	        // Return an array of promises, suitable for use with Promise.all().
	        return [responseDone, handlerDone];
	    }
	    async _getResponse(handler, request, event) {
	        await handler.runCallbacks('handlerWillStart', { event, request });
	        let response = undefined;
	        try {
	            response = await this._handle(request, handler);
	            // The "official" Strategy subclasses all throw this error automatically,
	            // but in case a third-party Strategy doesn't, ensure that we have a
	            // consistent failure when there's no response or an error response.
	            if (!response || response.type === 'error') {
	                throw new WorkboxError('no-response', { url: request.url });
	            }
	        }
	        catch (error) {
	            for (const callback of handler.iterateCallbacks('handlerDidError')) {
	                response = await callback({ error, event, request });
	                if (response) {
	                    break;
	                }
	            }
	            if (!response) {
	                throw error;
	            }
	            else {
	                logger.log(`While responding to '${getFriendlyURL(request.url)}', ` +
	                    `an ${error} error occurred. Using a fallback response provided by ` +
	                    `a handlerDidError plugin.`);
	            }
	        }
	        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {
	            response = await callback({ event, request, response });
	        }
	        return response;
	    }
	    async _awaitComplete(responseDone, handler, request, event) {
	        let response;
	        let error;
	        try {
	            response = await responseDone;
	        }
	        catch (error) {
	            // Ignore errors, as response errors should be caught via the `response`
	            // promise above. The `done` promise will only throw for errors in
	            // promises passed to `handler.waitUntil()`.
	        }
	        try {
	            await handler.runCallbacks('handlerDidRespond', {
	                event,
	                request,
	                response,
	            });
	            await handler.doneWaiting();
	        }
	        catch (waitUntilError) {
	            error = waitUntilError;
	        }
	        await handler.runCallbacks('handlerDidComplete', {
	            event,
	            request,
	            response,
	            error,
	        });
	        handler.destroy();
	        if (error) {
	            throw error;
	        }
	    }
	}
	/**
	 * Classes extending the `Strategy` based class should implement this method,
	 * and leverage the [`handler`]{@link module:workbox-strategies.StrategyHandler}
	 * arg to perform all fetching and cache logic, which will ensure all relevant
	 * cache, cache options, fetch options and plugins are used (per the current
	 * strategy instance).
	 *
	 * @name _handle
	 * @instance
	 * @abstract
	 * @function
	 * @param {Request} request
	 * @param {module:workbox-strategies.StrategyHandler} handler
	 * @return {Promise<Response>}
	 *
	 * @memberof module:workbox-strategies.Strategy
	 */

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const copyRedirectedCacheableResponsesPlugin = {
	    async cacheWillUpdate({ response }) {
	        return response.redirected ? await copyResponse(response) : response;
	    }
	};
	/**
	 * A [Strategy]{@link module:workbox-strategies.Strategy} implementation
	 * specifically designed to work with
	 * [PrecacheController]{@link module:workbox-precaching.PrecacheController}
	 * to both cache and fetch precached assets.
	 *
	 * Note: an instance of this class is created automatically when creating a
	 * `PrecacheController`; it's generally not necessary to create this yourself.
	 *
	 * @extends module:workbox-strategies.Strategy
	 * @memberof module:workbox-precaching
	 */
	class PrecacheStrategy extends Strategy {
	    /**
	     *
	     * @param {Object} [options]
	     * @param {string} [options.cacheName] Cache name to store and retrieve
	     * requests. Defaults to the cache names provided by
	     * [workbox-core]{@link module:workbox-core.cacheNames}.
	     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
	     * to use in conjunction with this caching strategy.
	     * @param {Object} [options.fetchOptions] Values passed along to the
	     * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}
	     * of all fetch() requests made by this strategy.
	     * @param {Object} [options.matchOptions] The
	     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
	     * for any `cache.match()` or `cache.put()` calls made by this strategy.
	     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
	     * get the response from the network if there's a precache miss.
	     */
	    constructor(options = {}) {
	        options.cacheName = cacheNames.getPrecacheName(options.cacheName);
	        super(options);
	        this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true;
	        // Redirected responses cannot be used to satisfy a navigation request, so
	        // any redirected response must be "copied" rather than cloned, so the new
	        // response doesn't contain the `redirected` flag. See:
	        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1
	        this.plugins.push(copyRedirectedCacheableResponsesPlugin);
	    }
	    /**
	     * @private
	     * @param {Request|string} request A request to run this strategy for.
	     * @param {module:workbox-strategies.StrategyHandler} handler The event that
	     *     triggered the request.
	     * @return {Promise<Response>}
	     */
	    async _handle(request, handler) {
	        const response = await handler.cacheMatch(request);
	        if (!response) {
	            // If this is an `install` event then populate the cache. If this is a
	            // `fetch` event (or any other event) then respond with the cached
	            // response.
	            if (handler.event && handler.event.type === 'install') {
	                return await this._handleInstall(request, handler);
	            }
	            return await this._handleFetch(request, handler);
	        }
	        return response;
	    }
	    async _handleFetch(request, handler) {
	        let response;
	        // Fall back to the network if we don't have a cached response
	        // (perhaps due to manual cache cleanup).
	        if (this._fallbackToNetwork) {
	            {
	                logger.warn(`The precached response for ` +
	                    `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` +
	                    `found. Falling back to the network instead.`);
	            }
	            response = await handler.fetch(request);
	        }
	        else {
	            // This shouldn't normally happen, but there are edge cases:
	            // https://github.com/GoogleChrome/workbox/issues/1441
	            throw new WorkboxError('missing-precache-entry', {
	                cacheName: this.cacheName,
	                url: request.url,
	            });
	        }
	        {
	            const cacheKey = handler.params && handler.params.cacheKey ||
	                await handler.getCacheKey(request, 'read');
	            // Workbox is going to handle the route.
	            // print the routing details to the console.
	            logger.groupCollapsed(`Precaching is responding to: ` +
	                getFriendlyURL(request.url));
	            logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey.url)}`);
	            logger.groupCollapsed(`View request details here.`);
	            logger.log(request);
	            logger.groupEnd();
	            logger.groupCollapsed(`View response details here.`);
	            logger.log(response);
	            logger.groupEnd();
	            logger.groupEnd();
	        }
	        return response;
	    }
	    async _handleInstall(request, handler) {
	        const response = await handler.fetchAndCachePut(request);
	        // Any time there's no response, consider it a precaching error.
	        let responseSafeToPrecache = Boolean(response);
	        // Also consider it an error if the user didn't pass their own
	        // cacheWillUpdate plugin, and the response is a 400+ (note: this means
	        // that by default opaque responses can be precached).
	        if (response && response.status >= 400 &&
	            !this._usesCustomCacheableResponseLogic()) {
	            responseSafeToPrecache = false;
	        }
	        if (!responseSafeToPrecache) {
	            // Throwing here will lead to the `install` handler failing, which
	            // we want to do if *any* of the responses aren't safe to cache.
	            throw new WorkboxError('bad-precaching-response', {
	                url: request.url,
	                status: response.status,
	            });
	        }
	        return response;
	    }
	    /**
	     * Returns true if any users plugins were added containing their own
	     * `cacheWillUpdate` callback.
	     *
	     * This method indicates whether the default cacheable response logic (i.e.
	     * <400, including opaque responses) should be used. If a custom plugin
	     * with a `cacheWillUpdate` callback is passed, then the strategy should
	     * defer to that plugin's logic.
	     *
	     * @private
	     */
	    _usesCustomCacheableResponseLogic() {
	        return this.plugins.some((plugin) => plugin.cacheWillUpdate &&
	            plugin !== copyRedirectedCacheableResponsesPlugin);
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Performs efficient precaching of assets.
	 *
	 * @memberof module:workbox-precaching
	 */
	class PrecacheController {
	    /**
	     * Create a new PrecacheController.
	     *
	     * @param {Object} [options]
	     * @param {string} [options.cacheName] The cache to use for precaching.
	     * @param {string} [options.plugins] Plugins to use when precaching as well
	     * as responding to fetch events for precached assets.
	     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
	     * get the response from the network if there's a precache miss.
	     */
	    constructor({ cacheName, plugins = [], fallbackToNetwork = true } = {}) {
	        this._urlsToCacheKeys = new Map();
	        this._urlsToCacheModes = new Map();
	        this._cacheKeysToIntegrities = new Map();
	        this._strategy = new PrecacheStrategy({
	            cacheName: cacheNames.getPrecacheName(cacheName),
	            plugins: [
	                ...plugins,
	                new PrecacheCacheKeyPlugin({ precacheController: this }),
	            ],
	            fallbackToNetwork,
	        });
	        // Bind the install and activate methods to the instance.
	        this.install = this.install.bind(this);
	        this.activate = this.activate.bind(this);
	    }
	    /**
	     * @type {module:workbox-precaching.PrecacheStrategy} The strategy created by this controller and
	     * used to cache assets and respond to fetch events.
	     */
	    get strategy() {
	        return this._strategy;
	    }
	    /**
	     * Adds items to the precache list, removing any duplicates and
	     * stores the files in the
	     * ["precache cache"]{@link module:workbox-core.cacheNames} when the service
	     * worker installs.
	     *
	     * This method can be called multiple times.
	     *
	     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.
	     */
	    precache(entries) {
	        this.addToCacheList(entries);
	        if (!this._installAndActiveListenersAdded) {
	            self.addEventListener('install', this.install);
	            self.addEventListener('activate', this.activate);
	            this._installAndActiveListenersAdded = true;
	        }
	    }
	    /**
	     * This method will add items to the precache list, removing duplicates
	     * and ensuring the information is valid.
	     *
	     * @param {Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>} entries
	     *     Array of entries to precache.
	     */
	    addToCacheList(entries) {
	        {
	            finalAssertExports.isArray(entries, {
	                moduleName: 'workbox-precaching',
	                className: 'PrecacheController',
	                funcName: 'addToCacheList',
	                paramName: 'entries',
	            });
	        }
	        const urlsToWarnAbout = [];
	        for (const entry of entries) {
	            // See https://github.com/GoogleChrome/workbox/issues/2259
	            if (typeof entry === 'string') {
	                urlsToWarnAbout.push(entry);
	            }
	            else if (entry && entry.revision === undefined) {
	                urlsToWarnAbout.push(entry.url);
	            }
	            const { cacheKey, url } = createCacheKey(entry);
	            const cacheMode = (typeof entry !== 'string' && entry.revision) ?
	                'reload' : 'default';
	            if (this._urlsToCacheKeys.has(url) &&
	                this._urlsToCacheKeys.get(url) !== cacheKey) {
	                throw new WorkboxError('add-to-cache-list-conflicting-entries', {
	                    firstEntry: this._urlsToCacheKeys.get(url),
	                    secondEntry: cacheKey,
	                });
	            }
	            if (typeof entry !== 'string' && entry.integrity) {
	                if (this._cacheKeysToIntegrities.has(cacheKey) &&
	                    this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {
	                    throw new WorkboxError('add-to-cache-list-conflicting-integrities', {
	                        url,
	                    });
	                }
	                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);
	            }
	            this._urlsToCacheKeys.set(url, cacheKey);
	            this._urlsToCacheModes.set(url, cacheMode);
	            if (urlsToWarnAbout.length > 0) {
	                const warningMessage = `Workbox is precaching URLs without revision ` +
	                    `info: ${urlsToWarnAbout.join(', ')}\nThis is generally NOT safe. ` +
	                    `Learn more at https://bit.ly/wb-precache`;
	                {
	                    logger.warn(warningMessage);
	                }
	            }
	        }
	    }
	    /**
	     * Precaches new and updated assets. Call this method from the service worker
	     * install event.
	     *
	     * Note: this method calls `event.waitUntil()` for you, so you do not need
	     * to call it yourself in your event handlers.
	     *
	     * @param {Object} options
	     * @param {Event} options.event The install event.
	     * @return {Promise<module:workbox-precaching.InstallResult>}
	     */
	    install(event) {
	        return waitUntil(event, async () => {
	            const installReportPlugin = new PrecacheInstallReportPlugin();
	            this.strategy.plugins.push(installReportPlugin);
	            // Cache entries one at a time.
	            // See https://github.com/GoogleChrome/workbox/issues/2528
	            for (const [url, cacheKey] of this._urlsToCacheKeys) {
	                const integrity = this._cacheKeysToIntegrities.get(cacheKey);
	                const cacheMode = this._urlsToCacheModes.get(url);
	                const request = new Request(url, {
	                    integrity,
	                    cache: cacheMode,
	                    credentials: 'same-origin',
	                });
	                await Promise.all(this.strategy.handleAll({
	                    params: { cacheKey },
	                    request,
	                    event,
	                }));
	            }
	            const { updatedURLs, notUpdatedURLs } = installReportPlugin;
	            {
	                printInstallDetails(updatedURLs, notUpdatedURLs);
	            }
	            return { updatedURLs, notUpdatedURLs };
	        });
	    }
	    /**
	     * Deletes assets that are no longer present in the current precache manifest.
	     * Call this method from the service worker activate event.
	     *
	     * Note: this method calls `event.waitUntil()` for you, so you do not need
	     * to call it yourself in your event handlers.
	     *
	     * @param {ExtendableEvent}
	     * @return {Promise<module:workbox-precaching.CleanupResult>}
	     */
	    activate(event) {
	        return waitUntil(event, async () => {
	            const cache = await self.caches.open(this.strategy.cacheName);
	            const currentlyCachedRequests = await cache.keys();
	            const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());
	            const deletedURLs = [];
	            for (const request of currentlyCachedRequests) {
	                if (!expectedCacheKeys.has(request.url)) {
	                    await cache.delete(request);
	                    deletedURLs.push(request.url);
	                }
	            }
	            {
	                printCleanupDetails(deletedURLs);
	            }
	            return { deletedURLs };
	        });
	    }
	    /**
	     * Returns a mapping of a precached URL to the corresponding cache key, taking
	     * into account the revision information for the URL.
	     *
	     * @return {Map<string, string>} A URL to cache key mapping.
	     */
	    getURLsToCacheKeys() {
	        return this._urlsToCacheKeys;
	    }
	    /**
	     * Returns a list of all the URLs that have been precached by the current
	     * service worker.
	     *
	     * @return {Array<string>} The precached URLs.
	     */
	    getCachedURLs() {
	        return [...this._urlsToCacheKeys.keys()];
	    }
	    /**
	     * Returns the cache key used for storing a given URL. If that URL is
	     * unversioned, like `/index.html', then the cache key will be the original
	     * URL with a search parameter appended to it.
	     *
	     * @param {string} url A URL whose cache key you want to look up.
	     * @return {string} The versioned URL that corresponds to a cache key
	     * for the original URL, or undefined if that URL isn't precached.
	     */
	    getCacheKeyForURL(url) {
	        const urlObject = new URL(url, location.href);
	        return this._urlsToCacheKeys.get(urlObject.href);
	    }
	    /**
	     * This acts as a drop-in replacement for
	     * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)
	     * with the following differences:
	     *
	     * - It knows what the name of the precache is, and only checks in that cache.
	     * - It allows you to pass in an "original" URL without versioning parameters,
	     * and it will automatically look up the correct cache key for the currently
	     * active revision of that URL.
	     *
	     * E.g., `matchPrecache('index.html')` will find the correct precached
	     * response for the currently active service worker, even if the actual cache
	     * key is `'/index.html?__WB_REVISION__=1234abcd'`.
	     *
	     * @param {string|Request} request The key (without revisioning parameters)
	     * to look up in the precache.
	     * @return {Promise<Response|undefined>}
	     */
	    async matchPrecache(request) {
	        const url = request instanceof Request ? request.url : request;
	        const cacheKey = this.getCacheKeyForURL(url);
	        if (cacheKey) {
	            const cache = await self.caches.open(this.strategy.cacheName);
	            return cache.match(cacheKey);
	        }
	        return undefined;
	    }
	    /**
	     * Returns a function that looks up `url` in the precache (taking into
	     * account revision information), and returns the corresponding `Response`.
	     *
	     * @param {string} url The precached URL which will be used to lookup the
	     * `Response`.
	     * @return {module:workbox-routing~handlerCallback}
	     */
	    createHandlerBoundToURL(url) {
	        const cacheKey = this.getCacheKeyForURL(url);
	        if (!cacheKey) {
	            throw new WorkboxError('non-precached-url', { url });
	        }
	        return (options) => {
	            options.request = new Request(url);
	            options.params = { cacheKey, ...options.params };
	            return this.strategy.handle(options);
	        };
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	let precacheController;
	/**
	 * @return {PrecacheController}
	 * @private
	 */
	const getOrCreatePrecacheController = () => {
	    if (!precacheController) {
	        precacheController = new PrecacheController();
	    }
	    return precacheController;
	};

	// @ts-ignore
	try {
	    self['workbox:routing:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * The default HTTP method, 'GET', used when there's no specific method
	 * configured for a route.
	 *
	 * @type {string}
	 *
	 * @private
	 */
	const defaultMethod = 'GET';
	/**
	 * The list of valid HTTP methods associated with requests that could be routed.
	 *
	 * @type {Array<string>}
	 *
	 * @private
	 */
	const validMethods = [
	    'DELETE',
	    'GET',
	    'HEAD',
	    'PATCH',
	    'POST',
	    'PUT',
	];

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * @param {function()|Object} handler Either a function, or an object with a
	 * 'handle' method.
	 * @return {Object} An object with a handle method.
	 *
	 * @private
	 */
	const normalizeHandler = (handler) => {
	    if (handler && typeof handler === 'object') {
	        {
	            finalAssertExports.hasMethod(handler, 'handle', {
	                moduleName: 'workbox-routing',
	                className: 'Route',
	                funcName: 'constructor',
	                paramName: 'handler',
	            });
	        }
	        return handler;
	    }
	    else {
	        {
	            finalAssertExports.isType(handler, 'function', {
	                moduleName: 'workbox-routing',
	                className: 'Route',
	                funcName: 'constructor',
	                paramName: 'handler',
	            });
	        }
	        return { handle: handler };
	    }
	};

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A `Route` consists of a pair of callback functions, "match" and "handler".
	 * The "match" callback determine if a route should be used to "handle" a
	 * request by returning a non-falsy value if it can. The "handler" callback
	 * is called when there is a match and should return a Promise that resolves
	 * to a `Response`.
	 *
	 * @memberof module:workbox-routing
	 */
	class Route {
	    /**
	     * Constructor for Route class.
	     *
	     * @param {module:workbox-routing~matchCallback} match
	     * A callback function that determines whether the route matches a given
	     * `fetch` event by returning a non-falsy value.
	     * @param {module:workbox-routing~handlerCallback} handler A callback
	     * function that returns a Promise resolving to a Response.
	     * @param {string} [method='GET'] The HTTP method to match the Route
	     * against.
	     */
	    constructor(match, handler, method = defaultMethod) {
	        {
	            finalAssertExports.isType(match, 'function', {
	                moduleName: 'workbox-routing',
	                className: 'Route',
	                funcName: 'constructor',
	                paramName: 'match',
	            });
	            if (method) {
	                finalAssertExports.isOneOf(method, validMethods, { paramName: 'method' });
	            }
	        }
	        // These values are referenced directly by Router so cannot be
	        // altered by minificaton.
	        this.handler = normalizeHandler(handler);
	        this.match = match;
	        this.method = method;
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * RegExpRoute makes it easy to create a regular expression based
	 * [Route]{@link module:workbox-routing.Route}.
	 *
	 * For same-origin requests the RegExp only needs to match part of the URL. For
	 * requests against third-party servers, you must define a RegExp that matches
	 * the start of the URL.
	 *
	 * [See the module docs for info.]{@link https://developers.google.com/web/tools/workbox/modules/workbox-routing}
	 *
	 * @memberof module:workbox-routing
	 * @extends module:workbox-routing.Route
	 */
	class RegExpRoute extends Route {
	    /**
	     * If the regular expression contains
	     * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},
	     * the captured values will be passed to the
	     * [handler's]{@link module:workbox-routing~handlerCallback} `params`
	     * argument.
	     *
	     * @param {RegExp} regExp The regular expression to match against URLs.
	     * @param {module:workbox-routing~handlerCallback} handler A callback
	     * function that returns a Promise resulting in a Response.
	     * @param {string} [method='GET'] The HTTP method to match the Route
	     * against.
	     */
	    constructor(regExp, handler, method) {
	        {
	            finalAssertExports.isInstance(regExp, RegExp, {
	                moduleName: 'workbox-routing',
	                className: 'RegExpRoute',
	                funcName: 'constructor',
	                paramName: 'pattern',
	            });
	        }
	        const match = ({ url }) => {
	            const result = regExp.exec(url.href);
	            // Return immediately if there's no match.
	            if (!result) {
	                return;
	            }
	            // Require that the match start at the first character in the URL string
	            // if it's a cross-origin request.
	            // See https://github.com/GoogleChrome/workbox/issues/281 for the context
	            // behind this behavior.
	            if ((url.origin !== location.origin) && (result.index !== 0)) {
	                {
	                    logger.debug(`The regular expression '${regExp}' only partially matched ` +
	                        `against the cross-origin URL '${url}'. RegExpRoute's will only ` +
	                        `handle cross-origin requests if they match the entire URL.`);
	                }
	                return;
	            }
	            // If the route matches, but there aren't any capture groups defined, then
	            // this will return [], which is truthy and therefore sufficient to
	            // indicate a match.
	            // If there are capture groups, then it will return their values.
	            return result.slice(1);
	        };
	        super(match, handler, method);
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * The Router can be used to process a FetchEvent through one or more
	 * [Routes]{@link module:workbox-routing.Route} responding  with a Request if
	 * a matching route exists.
	 *
	 * If no route matches a given a request, the Router will use a "default"
	 * handler if one is defined.
	 *
	 * Should the matching Route throw an error, the Router will use a "catch"
	 * handler if one is defined to gracefully deal with issues and respond with a
	 * Request.
	 *
	 * If a request matches multiple routes, the **earliest** registered route will
	 * be used to respond to the request.
	 *
	 * @memberof module:workbox-routing
	 */
	class Router {
	    /**
	     * Initializes a new Router.
	     */
	    constructor() {
	        this._routes = new Map();
	        this._defaultHandlerMap = new Map();
	    }
	    /**
	     * @return {Map<string, Array<module:workbox-routing.Route>>} routes A `Map` of HTTP
	     * method name ('GET', etc.) to an array of all the corresponding `Route`
	     * instances that are registered.
	     */
	    get routes() {
	        return this._routes;
	    }
	    /**
	     * Adds a fetch event listener to respond to events when a route matches
	     * the event's request.
	     */
	    addFetchListener() {
	        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
	        self.addEventListener('fetch', ((event) => {
	            const { request } = event;
	            const responsePromise = this.handleRequest({ request, event });
	            if (responsePromise) {
	                event.respondWith(responsePromise);
	            }
	        }));
	    }
	    /**
	     * Adds a message event listener for URLs to cache from the window.
	     * This is useful to cache resources loaded on the page prior to when the
	     * service worker started controlling it.
	     *
	     * The format of the message data sent from the window should be as follows.
	     * Where the `urlsToCache` array may consist of URL strings or an array of
	     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).
	     *
	     * ```
	     * {
	     *   type: 'CACHE_URLS',
	     *   payload: {
	     *     urlsToCache: [
	     *       './script1.js',
	     *       './script2.js',
	     *       ['./script3.js', {mode: 'no-cors'}],
	     *     ],
	     *   },
	     * }
	     * ```
	     */
	    addCacheListener() {
	        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
	        self.addEventListener('message', ((event) => {
	            if (event.data && event.data.type === 'CACHE_URLS') {
	                const { payload } = event.data;
	                {
	                    logger.debug(`Caching URLs from the window`, payload.urlsToCache);
	                }
	                const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {
	                    if (typeof entry === 'string') {
	                        entry = [entry];
	                    }
	                    const request = new Request(...entry);
	                    return this.handleRequest({ request, event });
	                    // TODO(philipwalton): TypeScript errors without this typecast for
	                    // some reason (probably a bug). The real type here should work but
	                    // doesn't: `Array<Promise<Response> | undefined>`.
	                })); // TypeScript
	                event.waitUntil(requestPromises);
	                // If a MessageChannel was used, reply to the message on success.
	                if (event.ports && event.ports[0]) {
	                    requestPromises.then(() => event.ports[0].postMessage(true));
	                }
	            }
	        }));
	    }
	    /**
	     * Apply the routing rules to a FetchEvent object to get a Response from an
	     * appropriate Route's handler.
	     *
	     * @param {Object} options
	     * @param {Request} options.request The request to handle.
	     * @param {ExtendableEvent} options.event The event that triggered the
	     *     request.
	     * @return {Promise<Response>|undefined} A promise is returned if a
	     *     registered route can handle the request. If there is no matching
	     *     route and there's no `defaultHandler`, `undefined` is returned.
	     */
	    handleRequest({ request, event }) {
	        {
	            finalAssertExports.isInstance(request, Request, {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'handleRequest',
	                paramName: 'options.request',
	            });
	        }
	        const url = new URL(request.url, location.href);
	        if (!url.protocol.startsWith('http')) {
	            {
	                logger.debug(`Workbox Router only supports URLs that start with 'http'.`);
	            }
	            return;
	        }
	        const sameOrigin = url.origin === location.origin;
	        const { params, route } = this.findMatchingRoute({
	            event,
	            request,
	            sameOrigin,
	            url,
	        });
	        let handler = route && route.handler;
	        const debugMessages = [];
	        {
	            if (handler) {
	                debugMessages.push([
	                    `Found a route to handle this request:`, route,
	                ]);
	                if (params) {
	                    debugMessages.push([
	                        `Passing the following params to the route's handler:`, params,
	                    ]);
	                }
	            }
	        }
	        // If we don't have a handler because there was no matching route, then
	        // fall back to defaultHandler if that's defined.
	        const method = request.method;
	        if (!handler && this._defaultHandlerMap.has(method)) {
	            {
	                debugMessages.push(`Failed to find a matching route. Falling ` +
	                    `back to the default handler for ${method}.`);
	            }
	            handler = this._defaultHandlerMap.get(method);
	        }
	        if (!handler) {
	            {
	                // No handler so Workbox will do nothing. If logs is set of debug
	                // i.e. verbose, we should print out this information.
	                logger.debug(`No route found for: ${getFriendlyURL(url)}`);
	            }
	            return;
	        }
	        {
	            // We have a handler, meaning Workbox is going to handle the route.
	            // print the routing details to the console.
	            logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);
	            debugMessages.forEach((msg) => {
	                if (Array.isArray(msg)) {
	                    logger.log(...msg);
	                }
	                else {
	                    logger.log(msg);
	                }
	            });
	            logger.groupEnd();
	        }
	        // Wrap in try and catch in case the handle method throws a synchronous
	        // error. It should still callback to the catch handler.
	        let responsePromise;
	        try {
	            responsePromise = handler.handle({ url, request, event, params });
	        }
	        catch (err) {
	            responsePromise = Promise.reject(err);
	        }
	        if (responsePromise instanceof Promise && this._catchHandler) {
	            responsePromise = responsePromise.catch((err) => {
	                {
	                    // Still include URL here as it will be async from the console group
	                    // and may not make sense without the URL
	                    logger.groupCollapsed(`Error thrown when responding to: ` +
	                        ` ${getFriendlyURL(url)}. Falling back to Catch Handler.`);
	                    logger.error(`Error thrown by:`, route);
	                    logger.error(err);
	                    logger.groupEnd();
	                }
	                return this._catchHandler.handle({ url, request, event });
	            });
	        }
	        return responsePromise;
	    }
	    /**
	     * Checks a request and URL (and optionally an event) against the list of
	     * registered routes, and if there's a match, returns the corresponding
	     * route along with any params generated by the match.
	     *
	     * @param {Object} options
	     * @param {URL} options.url
	     * @param {Request} options.request The request to match.
	     * @param {Event} options.event The corresponding event.
	     * @return {Object} An object with `route` and `params` properties.
	     *     They are populated if a matching route was found or `undefined`
	     *     otherwise.
	     */
	    findMatchingRoute({ url, sameOrigin, request, event }) {
	        const routes = this._routes.get(request.method) || [];
	        for (const route of routes) {
	            let params;
	            const matchResult = route.match({ url, sameOrigin, request, event });
	            if (matchResult) {
	                {
	                    // Warn developers that using an async matchCallback is almost always
	                    // not the right thing to do. 
	                    if (matchResult instanceof Promise) {
	                        logger.warn(`While routing ${getFriendlyURL(url)}, an async ` +
	                            `matchCallback function was used. Please convert the ` +
	                            `following route to use a synchronous matchCallback function:`, route);
	                    }
	                }
	                // See https://github.com/GoogleChrome/workbox/issues/2079
	                params = matchResult;
	                if (Array.isArray(matchResult) && matchResult.length === 0) {
	                    // Instead of passing an empty array in as params, use undefined.
	                    params = undefined;
	                }
	                else if ((matchResult.constructor === Object &&
	                    Object.keys(matchResult).length === 0)) {
	                    // Instead of passing an empty object in as params, use undefined.
	                    params = undefined;
	                }
	                else if (typeof matchResult === 'boolean') {
	                    // For the boolean value true (rather than just something truth-y),
	                    // don't set params.
	                    // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353
	                    params = undefined;
	                }
	                // Return early if have a match.
	                return { route, params };
	            }
	        }
	        // If no match was found above, return and empty object.
	        return {};
	    }
	    /**
	     * Define a default `handler` that's called when no routes explicitly
	     * match the incoming request.
	     *
	     * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.
	     *
	     * Without a default handler, unmatched requests will go against the
	     * network as if there were no service worker present.
	     *
	     * @param {module:workbox-routing~handlerCallback} handler A callback
	     * function that returns a Promise resulting in a Response.
	     * @param {string} [method='GET'] The HTTP method to associate with this
	     * default handler. Each method has its own default.
	     */
	    setDefaultHandler(handler, method = defaultMethod) {
	        this._defaultHandlerMap.set(method, normalizeHandler(handler));
	    }
	    /**
	     * If a Route throws an error while handling a request, this `handler`
	     * will be called and given a chance to provide a response.
	     *
	     * @param {module:workbox-routing~handlerCallback} handler A callback
	     * function that returns a Promise resulting in a Response.
	     */
	    setCatchHandler(handler) {
	        this._catchHandler = normalizeHandler(handler);
	    }
	    /**
	     * Registers a route with the router.
	     *
	     * @param {module:workbox-routing.Route} route The route to register.
	     */
	    registerRoute(route) {
	        {
	            finalAssertExports.isType(route, 'object', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route',
	            });
	            finalAssertExports.hasMethod(route, 'match', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route',
	            });
	            finalAssertExports.isType(route.handler, 'object', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route',
	            });
	            finalAssertExports.hasMethod(route.handler, 'handle', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route.handler',
	            });
	            finalAssertExports.isType(route.method, 'string', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route.method',
	            });
	        }
	        if (!this._routes.has(route.method)) {
	            this._routes.set(route.method, []);
	        }
	        // Give precedence to all of the earlier routes by adding this additional
	        // route to the end of the array.
	        this._routes.get(route.method).push(route);
	    }
	    /**
	     * Unregisters a route with the router.
	     *
	     * @param {module:workbox-routing.Route} route The route to unregister.
	     */
	    unregisterRoute(route) {
	        if (!this._routes.has(route.method)) {
	            throw new WorkboxError('unregister-route-but-not-found-with-method', {
	                method: route.method,
	            });
	        }
	        const routeIndex = this._routes.get(route.method).indexOf(route);
	        if (routeIndex > -1) {
	            this._routes.get(route.method).splice(routeIndex, 1);
	        }
	        else {
	            throw new WorkboxError('unregister-route-route-not-registered');
	        }
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	let defaultRouter;
	/**
	 * Creates a new, singleton Router instance if one does not exist. If one
	 * does already exist, that instance is returned.
	 *
	 * @private
	 * @return {Router}
	 */
	const getOrCreateDefaultRouter = () => {
	    if (!defaultRouter) {
	        defaultRouter = new Router();
	        // The helpers that use the default Router assume these listeners exist.
	        defaultRouter.addFetchListener();
	        defaultRouter.addCacheListener();
	    }
	    return defaultRouter;
	};

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Easily register a RegExp, string, or function with a caching
	 * strategy to a singleton Router instance.
	 *
	 * This method will generate a Route for you if needed and
	 * call [registerRoute()]{@link module:workbox-routing.Router#registerRoute}.
	 *
	 * @param {RegExp|string|module:workbox-routing.Route~matchCallback|module:workbox-routing.Route} capture
	 * If the capture param is a `Route`, all other arguments will be ignored.
	 * @param {module:workbox-routing~handlerCallback} [handler] A callback
	 * function that returns a Promise resulting in a Response. This parameter
	 * is required if `capture` is not a `Route` object.
	 * @param {string} [method='GET'] The HTTP method to match the Route
	 * against.
	 * @return {module:workbox-routing.Route} The generated `Route`(Useful for
	 * unregistering).
	 *
	 * @memberof module:workbox-routing
	 */
	function registerRoute(capture, handler, method) {
	    let route;
	    if (typeof capture === 'string') {
	        const captureUrl = new URL(capture, location.href);
	        {
	            if (!(capture.startsWith('/') || capture.startsWith('http'))) {
	                throw new WorkboxError('invalid-string', {
	                    moduleName: 'workbox-routing',
	                    funcName: 'registerRoute',
	                    paramName: 'capture',
	                });
	            }
	            // We want to check if Express-style wildcards are in the pathname only.
	            // TODO: Remove this log message in v4.
	            const valueToCheck = capture.startsWith('http') ?
	                captureUrl.pathname : capture;
	            // See https://github.com/pillarjs/path-to-regexp#parameters
	            const wildcards = '[*:?+]';
	            if ((new RegExp(`${wildcards}`)).exec(valueToCheck)) {
	                logger.debug(`The '$capture' parameter contains an Express-style wildcard ` +
	                    `character (${wildcards}). Strings are now always interpreted as ` +
	                    `exact matches; use a RegExp for partial or wildcard matches.`);
	            }
	        }
	        const matchCallback = ({ url }) => {
	            {
	                if ((url.pathname === captureUrl.pathname) &&
	                    (url.origin !== captureUrl.origin)) {
	                    logger.debug(`${capture} only partially matches the cross-origin URL ` +
	                        `${url}. This route will only handle cross-origin requests ` +
	                        `if they match the entire URL.`);
	                }
	            }
	            return url.href === captureUrl.href;
	        };
	        // If `capture` is a string then `handler` and `method` must be present.
	        route = new Route(matchCallback, handler, method);
	    }
	    else if (capture instanceof RegExp) {
	        // If `capture` is a `RegExp` then `handler` and `method` must be present.
	        route = new RegExpRoute(capture, handler, method);
	    }
	    else if (typeof capture === 'function') {
	        // If `capture` is a function then `handler` and `method` must be present.
	        route = new Route(capture, handler, method);
	    }
	    else if (capture instanceof Route) {
	        route = capture;
	    }
	    else {
	        throw new WorkboxError('unsupported-route-type', {
	            moduleName: 'workbox-routing',
	            funcName: 'registerRoute',
	            paramName: 'capture',
	        });
	    }
	    const defaultRouter = getOrCreateDefaultRouter();
	    defaultRouter.registerRoute(route);
	    return route;
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Removes any URL search parameters that should be ignored.
	 *
	 * @param {URL} urlObject The original URL.
	 * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against
	 * each search parameter name. Matches mean that the search parameter should be
	 * ignored.
	 * @return {URL} The URL with any ignored search parameters removed.
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching = []) {
	    // Convert the iterable into an array at the start of the loop to make sure
	    // deletion doesn't mess up iteration.
	    for (const paramName of [...urlObject.searchParams.keys()]) {
	        if (ignoreURLParametersMatching.some((regExp) => regExp.test(paramName))) {
	            urlObject.searchParams.delete(paramName);
	        }
	    }
	    return urlObject;
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Generator function that yields possible variations on the original URL to
	 * check, one at a time.
	 *
	 * @param {string} url
	 * @param {Object} options
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function* generateURLVariations(url, { ignoreURLParametersMatching = [/^utm_/, /^fbclid$/], directoryIndex = 'index.html', cleanURLs = true, urlManipulation, } = {}) {
	    const urlObject = new URL(url, location.href);
	    urlObject.hash = '';
	    yield urlObject.href;
	    const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);
	    yield urlWithoutIgnoredParams.href;
	    if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {
	        const directoryURL = new URL(urlWithoutIgnoredParams.href);
	        directoryURL.pathname += directoryIndex;
	        yield directoryURL.href;
	    }
	    if (cleanURLs) {
	        const cleanURL = new URL(urlWithoutIgnoredParams.href);
	        cleanURL.pathname += '.html';
	        yield cleanURL.href;
	    }
	    if (urlManipulation) {
	        const additionalURLs = urlManipulation({ url: urlObject });
	        for (const urlToAttempt of additionalURLs) {
	            yield urlToAttempt.href;
	        }
	    }
	}

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A subclass of [Route]{@link module:workbox-routing.Route} that takes a
	 * [PrecacheController]{@link module:workbox-precaching.PrecacheController}
	 * instance and uses it to match incoming requests and handle fetching
	 * responses from the precache.
	 *
	 * @memberof module:workbox-precaching
	 * @extends module:workbox-routing.Route
	 */
	class PrecacheRoute extends Route {
	    /**
	     * @param {PrecacheController} precacheController A `PrecacheController`
	     * instance used to both match requests and respond to fetch events.
	     * @param {Object} [options] Options to control how requests are matched
	     * against the list of precached URLs.
	     * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will
	     * check cache entries for a URLs ending with '/' to see if there is a hit when
	     * appending the `directoryIndex` value.
	     * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An
	     * array of regex's to remove search params when looking for a cache match.
	     * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will
	     * check the cache for the URL with a `.html` added to the end of the end.
	     * @param {module:workbox-precaching~urlManipulation} [options.urlManipulation]
	     * This is a function that should take a URL and return an array of
	     * alternative URLs that should be checked for precache matches.
	     */
	    constructor(precacheController, options) {
	        const match = ({ request }) => {
	            const urlsToCacheKeys = precacheController.getURLsToCacheKeys();
	            for (const possibleURL of generateURLVariations(request.url, options)) {
	                const cacheKey = urlsToCacheKeys.get(possibleURL);
	                if (cacheKey) {
	                    return { cacheKey };
	                }
	            }
	            {
	                logger.debug(`Precaching did not find a match for ` +
	                    getFriendlyURL(request.url));
	            }
	            return;
	        };
	        super(match, precacheController.strategy);
	    }
	}

	/*
	  Copyright 2019 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Add a `fetch` listener to the service worker that will
	 * respond to
	 * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}
	 * with precached assets.
	 *
	 * Requests for assets that aren't precached, the `FetchEvent` will not be
	 * responded to, allowing the event to fall through to other `fetch` event
	 * listeners.
	 *
	 * @param {Object} [options] See
	 * [PrecacheRoute options]{@link module:workbox-precaching.PrecacheRoute}.
	 *
	 * @memberof module:workbox-precaching
	 */
	function addRoute(options) {
	    const precacheController = getOrCreatePrecacheController();
	    const precacheRoute = new PrecacheRoute(precacheController, options);
	    registerRoute(precacheRoute);
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Adds items to the precache list, removing any duplicates and
	 * stores the files in the
	 * ["precache cache"]{@link module:workbox-core.cacheNames} when the service
	 * worker installs.
	 *
	 * This method can be called multiple times.
	 *
	 * Please note: This method **will not** serve any of the cached files for you.
	 * It only precaches files. To respond to a network request you call
	 * [addRoute()]{@link module:workbox-precaching.addRoute}.
	 *
	 * If you have a single array of files to precache, you can just call
	 * [precacheAndRoute()]{@link module:workbox-precaching.precacheAndRoute}.
	 *
	 * @param {Array<Object|string>} [entries=[]] Array of entries to precache.
	 *
	 * @memberof module:workbox-precaching
	 */
	function precache(entries) {
	    const precacheController = getOrCreatePrecacheController();
	    precacheController.precache(entries);
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * This method will add entries to the precache list and add a route to
	 * respond to fetch events.
	 *
	 * This is a convenience method that will call
	 * [precache()]{@link module:workbox-precaching.precache} and
	 * [addRoute()]{@link module:workbox-precaching.addRoute} in a single call.
	 *
	 * @param {Array<Object|string>} entries Array of entries to precache.
	 * @param {Object} [options] See
	 * [PrecacheRoute options]{@link module:workbox-precaching.PrecacheRoute}.
	 *
	 * @memberof module:workbox-precaching
	 */
	function precacheAndRoute(entries, options) {
	    precache(entries);
	    addRoute(options);
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const messages$1 = {
	    strategyStart: (strategyName, request) => `Using ${strategyName} to respond to '${getFriendlyURL(request.url)}'`,
	    printFinalResponse: (response) => {
	        if (response) {
	            logger.groupCollapsed(`View the final response here.`);
	            logger.log(response || '[No response returned]');
	            logger.groupEnd();
	        }
	    },
	};

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}
	 * request strategy.
	 *
	 * A cache first strategy is useful for assets that have been revisioned,
	 * such as URLs like `/styles/example.a8f5f1.css`, since they
	 * can be cached for long periods of time.
	 *
	 * If the network request fails, and there is no cache match, this will throw
	 * a `WorkboxError` exception.
	 *
	 * @extends module:workbox-strategies.Strategy
	 * @memberof module:workbox-strategies
	 */
	class CacheFirst extends Strategy {
	    /**
	     * @private
	     * @param {Request|string} request A request to run this strategy for.
	     * @param {module:workbox-strategies.StrategyHandler} handler The event that
	     *     triggered the request.
	     * @return {Promise<Response>}
	     */
	    async _handle(request, handler) {
	        const logs = [];
	        {
	            finalAssertExports.isInstance(request, Request, {
	                moduleName: 'workbox-strategies',
	                className: this.constructor.name,
	                funcName: 'makeRequest',
	                paramName: 'request',
	            });
	        }
	        let response = await handler.cacheMatch(request);
	        let error;
	        if (!response) {
	            {
	                logs.push(`No response found in the '${this.cacheName}' cache. ` +
	                    `Will respond with a network request.`);
	            }
	            try {
	                response = await handler.fetchAndCachePut(request);
	            }
	            catch (err) {
	                error = err;
	            }
	            {
	                if (response) {
	                    logs.push(`Got response from network.`);
	                }
	                else {
	                    logs.push(`Unable to get a response from the network.`);
	                }
	            }
	        }
	        else {
	            {
	                logs.push(`Found a cached response in the '${this.cacheName}' cache.`);
	            }
	        }
	        {
	            logger.groupCollapsed(messages$1.strategyStart(this.constructor.name, request));
	            for (const log of logs) {
	                logger.log(log);
	            }
	            messages$1.printFinalResponse(response);
	            logger.groupEnd();
	        }
	        if (!response) {
	            throw new WorkboxError('no-response', { url: request.url, error });
	        }
	        return response;
	    }
	}

	/*
	  Copyright 2019 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A helper function that prevents a promise from being flagged as unused.
	 *
	 * @private
	 **/
	function dontWaitFor(promise) {
	    // Effective no-op.
	    promise.then(() => { });
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A class that wraps common IndexedDB functionality in a promise-based API.
	 * It exposes all the underlying power and functionality of IndexedDB, but
	 * wraps the most commonly used features in a way that's much simpler to use.
	 *
	 * @private
	 */
	class DBWrapper {
	    /**
	     * @param {string} name
	     * @param {number} version
	     * @param {Object=} [callback]
	     * @param {!Function} [callbacks.onupgradeneeded]
	     * @param {!Function} [callbacks.onversionchange] Defaults to
	     *     DBWrapper.prototype._onversionchange when not specified.
	     * @private
	     */
	    constructor(name, version, { onupgradeneeded, onversionchange, } = {}) {
	        this._db = null;
	        this._name = name;
	        this._version = version;
	        this._onupgradeneeded = onupgradeneeded;
	        this._onversionchange = onversionchange || (() => this.close());
	    }
	    /**
	     * Returns the IDBDatabase instance (not normally needed).
	     * @return {IDBDatabase|undefined}
	     *
	     * @private
	     */
	    get db() {
	        return this._db;
	    }
	    /**
	     * Opens a connected to an IDBDatabase, invokes any onupgradedneeded
	     * callback, and added an onversionchange callback to the database.
	     *
	     * @return {IDBDatabase}
	     * @private
	     */
	    async open() {
	        if (this._db)
	            return;
	        this._db = await new Promise((resolve, reject) => {
	            // This flag is flipped to true if the timeout callback runs prior
	            // to the request failing or succeeding. Note: we use a timeout instead
	            // of an onblocked handler since there are cases where onblocked will
	            // never never run. A timeout better handles all possible scenarios:
	            // https://github.com/w3c/IndexedDB/issues/223
	            let openRequestTimedOut = false;
	            setTimeout(() => {
	                openRequestTimedOut = true;
	                reject(new Error('The open request was blocked and timed out'));
	            }, this.OPEN_TIMEOUT);
	            const openRequest = indexedDB.open(this._name, this._version);
	            openRequest.onerror = () => reject(openRequest.error);
	            openRequest.onupgradeneeded = (evt) => {
	                if (openRequestTimedOut) {
	                    openRequest.transaction.abort();
	                    openRequest.result.close();
	                }
	                else if (typeof this._onupgradeneeded === 'function') {
	                    this._onupgradeneeded(evt);
	                }
	            };
	            openRequest.onsuccess = () => {
	                const db = openRequest.result;
	                if (openRequestTimedOut) {
	                    db.close();
	                }
	                else {
	                    db.onversionchange = this._onversionchange.bind(this);
	                    resolve(db);
	                }
	            };
	        });
	        return this;
	    }
	    /**
	     * Polyfills the native `getKey()` method. Note, this is overridden at
	     * runtime if the browser supports the native method.
	     *
	     * @param {string} storeName
	     * @param {*} query
	     * @return {Array}
	     * @private
	     */
	    async getKey(storeName, query) {
	        return (await this.getAllKeys(storeName, query, 1))[0];
	    }
	    /**
	     * Polyfills the native `getAll()` method. Note, this is overridden at
	     * runtime if the browser supports the native method.
	     *
	     * @param {string} storeName
	     * @param {*} query
	     * @param {number} count
	     * @return {Array}
	     * @private
	     */
	    async getAll(storeName, query, count) {
	        return await this.getAllMatching(storeName, { query, count });
	    }
	    /**
	     * Polyfills the native `getAllKeys()` method. Note, this is overridden at
	     * runtime if the browser supports the native method.
	     *
	     * @param {string} storeName
	     * @param {*} query
	     * @param {number} count
	     * @return {Array}
	     * @private
	     */
	    async getAllKeys(storeName, query, count) {
	        const entries = await this.getAllMatching(storeName, { query, count, includeKeys: true });
	        return entries.map((entry) => entry.key);
	    }
	    /**
	     * Supports flexible lookup in an object store by specifying an index,
	     * query, direction, and count. This method returns an array of objects
	     * with the signature .
	     *
	     * @param {string} storeName
	     * @param {Object} [opts]
	     * @param {string} [opts.index] The index to use (if specified).
	     * @param {*} [opts.query]
	     * @param {IDBCursorDirection} [opts.direction]
	     * @param {number} [opts.count] The max number of results to return.
	     * @param {boolean} [opts.includeKeys] When true, the structure of the
	     *     returned objects is changed from an array of values to an array of
	     *     objects in the form {key, primaryKey, value}.
	     * @return {Array}
	     * @private
	     */
	    async getAllMatching(storeName, { index, query = null, // IE/Edge errors if query === `undefined`.
	    direction = 'next', count, includeKeys = false, } = {}) {
	        return await this.transaction([storeName], 'readonly', (txn, done) => {
	            const store = txn.objectStore(storeName);
	            const target = index ? store.index(index) : store;
	            const results = [];
	            const request = target.openCursor(query, direction);
	            request.onsuccess = () => {
	                const cursor = request.result;
	                if (cursor) {
	                    results.push(includeKeys ? cursor : cursor.value);
	                    if (count && results.length >= count) {
	                        done(results);
	                    }
	                    else {
	                        cursor.continue();
	                    }
	                }
	                else {
	                    done(results);
	                }
	            };
	        });
	    }
	    /**
	     * Accepts a list of stores, a transaction type, and a callback and
	     * performs a transaction. A promise is returned that resolves to whatever
	     * value the callback chooses. The callback holds all the transaction logic
	     * and is invoked with two arguments:
	     *   1. The IDBTransaction object
	     *   2. A `done` function, that's used to resolve the promise when
	     *      when the transaction is done, if passed a value, the promise is
	     *      resolved to that value.
	     *
	     * @param {Array<string>} storeNames An array of object store names
	     *     involved in the transaction.
	     * @param {string} type Can be `readonly` or `readwrite`.
	     * @param {!Function} callback
	     * @return {*} The result of the transaction ran by the callback.
	     * @private
	     */
	    async transaction(storeNames, type, callback) {
	        await this.open();
	        return await new Promise((resolve, reject) => {
	            const txn = this._db.transaction(storeNames, type);
	            txn.onabort = () => reject(txn.error);
	            txn.oncomplete = () => resolve();
	            callback(txn, (value) => resolve(value));
	        });
	    }
	    /**
	     * Delegates async to a native IDBObjectStore method.
	     *
	     * @param {string} method The method name.
	     * @param {string} storeName The object store name.
	     * @param {string} type Can be `readonly` or `readwrite`.
	     * @param {...*} args The list of args to pass to the native method.
	     * @return {*} The result of the transaction.
	     * @private
	     */
	    async _call(method, storeName, type, ...args) {
	        const callback = (txn, done) => {
	            const objStore = txn.objectStore(storeName);
	            // TODO(philipwalton): Fix this underlying TS2684 error.
	            // @ts-ignore
	            const request = objStore[method].apply(objStore, args);
	            request.onsuccess = () => done(request.result);
	        };
	        return await this.transaction([storeName], type, callback);
	    }
	    /**
	     * Closes the connection opened by `DBWrapper.open()`. Generally this method
	     * doesn't need to be called since:
	     *   1. It's usually better to keep a connection open since opening
	     *      a new connection is somewhat slow.
	     *   2. Connections are automatically closed when the reference is
	     *      garbage collected.
	     * The primary use case for needing to close a connection is when another
	     * reference (typically in another tab) needs to upgrade it and would be
	     * blocked by the current, open connection.
	     *
	     * @private
	     */
	    close() {
	        if (this._db) {
	            this._db.close();
	            this._db = null;
	        }
	    }
	}
	// Exposed on the prototype to let users modify the default timeout on a
	// per-instance or global basis.
	DBWrapper.prototype.OPEN_TIMEOUT = 2000;
	// Wrap native IDBObjectStore methods according to their mode.
	const methodsToWrap = {
	    readonly: ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],
	    readwrite: ['add', 'put', 'clear', 'delete'],
	};
	for (const [mode, methods] of Object.entries(methodsToWrap)) {
	    for (const method of methods) {
	        if (method in IDBObjectStore.prototype) {
	            // Don't use arrow functions here since we're outside of the class.
	            DBWrapper.prototype[method] =
	                async function (storeName, ...args) {
	                    return await this._call(method, storeName, mode, ...args);
	                };
	        }
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Deletes the database.
	 * Note: this is exported separately from the DBWrapper module because most
	 * usages of IndexedDB in workbox dont need deleting, and this way it can be
	 * reused in tests to delete databases without creating DBWrapper instances.
	 *
	 * @param {string} name The database name.
	 * @private
	 */
	const deleteDatabase = async (name) => {
	    await new Promise((resolve, reject) => {
	        const request = indexedDB.deleteDatabase(name);
	        request.onerror = () => {
	            reject(request.error);
	        };
	        request.onblocked = () => {
	            reject(new Error('Delete blocked'));
	        };
	        request.onsuccess = () => {
	            resolve();
	        };
	    });
	};

	// @ts-ignore
	try {
	    self['workbox:expiration:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const DB_NAME = 'workbox-expiration';
	const OBJECT_STORE_NAME = 'cache-entries';
	const normalizeURL = (unNormalizedUrl) => {
	    const url = new URL(unNormalizedUrl, location.href);
	    url.hash = '';
	    return url.href;
	};
	/**
	 * Returns the timestamp model.
	 *
	 * @private
	 */
	class CacheTimestampsModel {
	    /**
	     *
	     * @param {string} cacheName
	     *
	     * @private
	     */
	    constructor(cacheName) {
	        this._cacheName = cacheName;
	        this._db = new DBWrapper(DB_NAME, 1, {
	            onupgradeneeded: (event) => this._handleUpgrade(event),
	        });
	    }
	    /**
	     * Should perform an upgrade of indexedDB.
	     *
	     * @param {Event} event
	     *
	     * @private
	     */
	    _handleUpgrade(event) {
	        const db = event.target.result;
	        // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we
	        // have to use the `id` keyPath here and create our own values (a
	        // concatenation of `url + cacheName`) instead of simply using
	        // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.
	        const objStore = db.createObjectStore(OBJECT_STORE_NAME, { keyPath: 'id' });
	        // TODO(philipwalton): once we don't have to support EdgeHTML, we can
	        // create a single index with the keyPath `['cacheName', 'timestamp']`
	        // instead of doing both these indexes.
	        objStore.createIndex('cacheName', 'cacheName', { unique: false });
	        objStore.createIndex('timestamp', 'timestamp', { unique: false });
	        // Previous versions of `workbox-expiration` used `this._cacheName`
	        // as the IDBDatabase name.
	        deleteDatabase(this._cacheName);
	    }
	    /**
	     * @param {string} url
	     * @param {number} timestamp
	     *
	     * @private
	     */
	    async setTimestamp(url, timestamp) {
	        url = normalizeURL(url);
	        const entry = {
	            url,
	            timestamp,
	            cacheName: this._cacheName,
	            // Creating an ID from the URL and cache name won't be necessary once
	            // Edge switches to Chromium and all browsers we support work with
	            // array keyPaths.
	            id: this._getId(url),
	        };
	        await this._db.put(OBJECT_STORE_NAME, entry);
	    }
	    /**
	     * Returns the timestamp stored for a given URL.
	     *
	     * @param {string} url
	     * @return {number}
	     *
	     * @private
	     */
	    async getTimestamp(url) {
	        const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));
	        return entry.timestamp;
	    }
	    /**
	     * Iterates through all the entries in the object store (from newest to
	     * oldest) and removes entries once either `maxCount` is reached or the
	     * entry's timestamp is less than `minTimestamp`.
	     *
	     * @param {number} minTimestamp
	     * @param {number} maxCount
	     * @return {Array<string>}
	     *
	     * @private
	     */
	    async expireEntries(minTimestamp, maxCount) {
	        const entriesToDelete = await this._db.transaction(OBJECT_STORE_NAME, 'readwrite', (txn, done) => {
	            const store = txn.objectStore(OBJECT_STORE_NAME);
	            const request = store.index('timestamp').openCursor(null, 'prev');
	            const entriesToDelete = [];
	            let entriesNotDeletedCount = 0;
	            request.onsuccess = () => {
	                const cursor = request.result;
	                if (cursor) {
	                    const result = cursor.value;
	                    // TODO(philipwalton): once we can use a multi-key index, we
	                    // won't have to check `cacheName` here.
	                    if (result.cacheName === this._cacheName) {
	                        // Delete an entry if it's older than the max age or
	                        // if we already have the max number allowed.
	                        if ((minTimestamp && result.timestamp < minTimestamp) ||
	                            (maxCount && entriesNotDeletedCount >= maxCount)) {
	                            // TODO(philipwalton): we should be able to delete the
	                            // entry right here, but doing so causes an iteration
	                            // bug in Safari stable (fixed in TP). Instead we can
	                            // store the keys of the entries to delete, and then
	                            // delete the separate transactions.
	                            // https://github.com/GoogleChrome/workbox/issues/1978
	                            // cursor.delete();
	                            // We only need to return the URL, not the whole entry.
	                            entriesToDelete.push(cursor.value);
	                        }
	                        else {
	                            entriesNotDeletedCount++;
	                        }
	                    }
	                    cursor.continue();
	                }
	                else {
	                    done(entriesToDelete);
	                }
	            };
	        });
	        // TODO(philipwalton): once the Safari bug in the following issue is fixed,
	        // we should be able to remove this loop and do the entry deletion in the
	        // cursor loop above:
	        // https://github.com/GoogleChrome/workbox/issues/1978
	        const urlsDeleted = [];
	        for (const entry of entriesToDelete) {
	            await this._db.delete(OBJECT_STORE_NAME, entry.id);
	            urlsDeleted.push(entry.url);
	        }
	        return urlsDeleted;
	    }
	    /**
	     * Takes a URL and returns an ID that will be unique in the object store.
	     *
	     * @param {string} url
	     * @return {string}
	     *
	     * @private
	     */
	    _getId(url) {
	        // Creating an ID from the URL and cache name won't be necessary once
	        // Edge switches to Chromium and all browsers we support work with
	        // array keyPaths.
	        return this._cacheName + '|' + normalizeURL(url);
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * The `CacheExpiration` class allows you define an expiration and / or
	 * limit on the number of responses stored in a
	 * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).
	 *
	 * @memberof module:workbox-expiration
	 */
	class CacheExpiration {
	    /**
	     * To construct a new CacheExpiration instance you must provide at least
	     * one of the `config` properties.
	     *
	     * @param {string} cacheName Name of the cache to apply restrictions to.
	     * @param {Object} config
	     * @param {number} [config.maxEntries] The maximum number of entries to cache.
	     * Entries used the least will be removed as the maximum is reached.
	     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before
	     * it's treated as stale and removed.
	     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)
	     * that will be used when calling `delete()` on the cache.
	     */
	    constructor(cacheName, config = {}) {
	        this._isRunning = false;
	        this._rerunRequested = false;
	        {
	            finalAssertExports.isType(cacheName, 'string', {
	                moduleName: 'workbox-expiration',
	                className: 'CacheExpiration',
	                funcName: 'constructor',
	                paramName: 'cacheName',
	            });
	            if (!(config.maxEntries || config.maxAgeSeconds)) {
	                throw new WorkboxError('max-entries-or-age-required', {
	                    moduleName: 'workbox-expiration',
	                    className: 'CacheExpiration',
	                    funcName: 'constructor',
	                });
	            }
	            if (config.maxEntries) {
	                finalAssertExports.isType(config.maxEntries, 'number', {
	                    moduleName: 'workbox-expiration',
	                    className: 'CacheExpiration',
	                    funcName: 'constructor',
	                    paramName: 'config.maxEntries',
	                });
	            }
	            if (config.maxAgeSeconds) {
	                finalAssertExports.isType(config.maxAgeSeconds, 'number', {
	                    moduleName: 'workbox-expiration',
	                    className: 'CacheExpiration',
	                    funcName: 'constructor',
	                    paramName: 'config.maxAgeSeconds',
	                });
	            }
	        }
	        this._maxEntries = config.maxEntries;
	        this._maxAgeSeconds = config.maxAgeSeconds;
	        this._matchOptions = config.matchOptions;
	        this._cacheName = cacheName;
	        this._timestampModel = new CacheTimestampsModel(cacheName);
	    }
	    /**
	     * Expires entries for the given cache and given criteria.
	     */
	    async expireEntries() {
	        if (this._isRunning) {
	            this._rerunRequested = true;
	            return;
	        }
	        this._isRunning = true;
	        const minTimestamp = this._maxAgeSeconds ?
	            Date.now() - (this._maxAgeSeconds * 1000) : 0;
	        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);
	        // Delete URLs from the cache
	        const cache = await self.caches.open(this._cacheName);
	        for (const url of urlsExpired) {
	            await cache.delete(url, this._matchOptions);
	        }
	        {
	            if (urlsExpired.length > 0) {
	                logger.groupCollapsed(`Expired ${urlsExpired.length} ` +
	                    `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +
	                    `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +
	                    `'${this._cacheName}' cache.`);
	                logger.log(`Expired the following ${urlsExpired.length === 1 ?
                    'URL' : 'URLs'}:`);
	                urlsExpired.forEach((url) => logger.log(`    ${url}`));
	                logger.groupEnd();
	            }
	            else {
	                logger.debug(`Cache expiration ran and found no entries to remove.`);
	            }
	        }
	        this._isRunning = false;
	        if (this._rerunRequested) {
	            this._rerunRequested = false;
	            dontWaitFor(this.expireEntries());
	        }
	    }
	    /**
	     * Update the timestamp for the given URL. This ensures the when
	     * removing entries based on maximum entries, most recently used
	     * is accurate or when expiring, the timestamp is up-to-date.
	     *
	     * @param {string} url
	     */
	    async updateTimestamp(url) {
	        {
	            finalAssertExports.isType(url, 'string', {
	                moduleName: 'workbox-expiration',
	                className: 'CacheExpiration',
	                funcName: 'updateTimestamp',
	                paramName: 'url',
	            });
	        }
	        await this._timestampModel.setTimestamp(url, Date.now());
	    }
	    /**
	     * Can be used to check if a URL has expired or not before it's used.
	     *
	     * This requires a look up from IndexedDB, so can be slow.
	     *
	     * Note: This method will not remove the cached entry, call
	     * `expireEntries()` to remove indexedDB and Cache entries.
	     *
	     * @param {string} url
	     * @return {boolean}
	     */
	    async isURLExpired(url) {
	        if (!this._maxAgeSeconds) {
	            {
	                throw new WorkboxError(`expired-test-without-max-age`, {
	                    methodName: 'isURLExpired',
	                    paramName: 'maxAgeSeconds',
	                });
	            }
	        }
	        else {
	            const timestamp = await this._timestampModel.getTimestamp(url);
	            const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);
	            return (timestamp < expireOlderThan);
	        }
	    }
	    /**
	     * Removes the IndexedDB object store used to keep track of cache expiration
	     * metadata.
	     */
	    async delete() {
	        // Make sure we don't attempt another rerun if we're called in the middle of
	        // a cache expiration.
	        this._rerunRequested = false;
	        await this._timestampModel.expireEntries(Infinity); // Expires all.
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Adds a function to the set of quotaErrorCallbacks that will be executed if
	 * there's a quota error.
	 *
	 * @param {Function} callback
	 * @memberof module:workbox-core
	 */
	function registerQuotaErrorCallback(callback) {
	    {
	        finalAssertExports.isType(callback, 'function', {
	            moduleName: 'workbox-core',
	            funcName: 'register',
	            paramName: 'callback',
	        });
	    }
	    quotaErrorCallbacks.add(callback);
	    {
	        logger.log('Registered a callback to respond to quota errors.', callback);
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * This plugin can be used in a `workbox-strategy` to regularly enforce a
	 * limit on the age and / or the number of cached requests.
	 *
	 * It can only be used with `workbox-strategy` instances that have a
	 * [custom `cacheName` property set](/web/tools/workbox/guides/configure-workbox#custom_cache_names_in_strategies).
	 * In other words, it can't be used to expire entries in strategy that uses the
	 * default runtime cache name.
	 *
	 * Whenever a cached request is used or updated, this plugin will look
	 * at the associated cache and remove any old or extra requests.
	 *
	 * When using `maxAgeSeconds`, requests may be used *once* after expiring
	 * because the expiration clean up will not have occurred until *after* the
	 * cached request has been used. If the request has a "Date" header, then
	 * a light weight expiration check is performed and the request will not be
	 * used immediately.
	 *
	 * When using `maxEntries`, the entry least-recently requested will be removed
	 * from the cache first.
	 *
	 * @memberof module:workbox-expiration
	 */
	class ExpirationPlugin {
	    /**
	     * @param {Object} config
	     * @param {number} [config.maxEntries] The maximum number of entries to cache.
	     * Entries used the least will be removed as the maximum is reached.
	     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before
	     * it's treated as stale and removed.
	     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)
	     * that will be used when calling `delete()` on the cache.
	     * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to
	     * automatic deletion if the available storage quota has been exceeded.
	     */
	    constructor(config = {}) {
	        /**
	         * A "lifecycle" callback that will be triggered automatically by the
	         * `workbox-strategies` handlers when a `Response` is about to be returned
	         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to
	         * the handler. It allows the `Response` to be inspected for freshness and
	         * prevents it from being used if the `Response`'s `Date` header value is
	         * older than the configured `maxAgeSeconds`.
	         *
	         * @param {Object} options
	         * @param {string} options.cacheName Name of the cache the response is in.
	         * @param {Response} options.cachedResponse The `Response` object that's been
	         *     read from a cache and whose freshness should be checked.
	         * @return {Response} Either the `cachedResponse`, if it's
	         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.
	         *
	         * @private
	         */
	        this.cachedResponseWillBeUsed = async ({ event, request, cacheName, cachedResponse }) => {
	            if (!cachedResponse) {
	                return null;
	            }
	            const isFresh = this._isResponseDateFresh(cachedResponse);
	            // Expire entries to ensure that even if the expiration date has
	            // expired, it'll only be used once.
	            const cacheExpiration = this._getCacheExpiration(cacheName);
	            dontWaitFor(cacheExpiration.expireEntries());
	            // Update the metadata for the request URL to the current timestamp,
	            // but don't `await` it as we don't want to block the response.
	            const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);
	            if (event) {
	                try {
	                    event.waitUntil(updateTimestampDone);
	                }
	                catch (error) {
	                    {
	                        // The event may not be a fetch event; only log the URL if it is.
	                        if ('request' in event) {
	                            logger.warn(`Unable to ensure service worker stays alive when ` +
	                                `updating cache entry for ` +
	                                `'${getFriendlyURL(event.request.url)}'.`);
	                        }
	                    }
	                }
	            }
	            return isFresh ? cachedResponse : null;
	        };
	        /**
	         * A "lifecycle" callback that will be triggered automatically by the
	         * `workbox-strategies` handlers when an entry is added to a cache.
	         *
	         * @param {Object} options
	         * @param {string} options.cacheName Name of the cache that was updated.
	         * @param {string} options.request The Request for the cached entry.
	         *
	         * @private
	         */
	        this.cacheDidUpdate = async ({ cacheName, request }) => {
	            {
	                finalAssertExports.isType(cacheName, 'string', {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'cacheDidUpdate',
	                    paramName: 'cacheName',
	                });
	                finalAssertExports.isInstance(request, Request, {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'cacheDidUpdate',
	                    paramName: 'request',
	                });
	            }
	            const cacheExpiration = this._getCacheExpiration(cacheName);
	            await cacheExpiration.updateTimestamp(request.url);
	            await cacheExpiration.expireEntries();
	        };
	        {
	            if (!(config.maxEntries || config.maxAgeSeconds)) {
	                throw new WorkboxError('max-entries-or-age-required', {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'constructor',
	                });
	            }
	            if (config.maxEntries) {
	                finalAssertExports.isType(config.maxEntries, 'number', {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'constructor',
	                    paramName: 'config.maxEntries',
	                });
	            }
	            if (config.maxAgeSeconds) {
	                finalAssertExports.isType(config.maxAgeSeconds, 'number', {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'constructor',
	                    paramName: 'config.maxAgeSeconds',
	                });
	            }
	        }
	        this._config = config;
	        this._maxAgeSeconds = config.maxAgeSeconds;
	        this._cacheExpirations = new Map();
	        if (config.purgeOnQuotaError) {
	            registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());
	        }
	    }
	    /**
	     * A simple helper method to return a CacheExpiration instance for a given
	     * cache name.
	     *
	     * @param {string} cacheName
	     * @return {CacheExpiration}
	     *
	     * @private
	     */
	    _getCacheExpiration(cacheName) {
	        if (cacheName === cacheNames.getRuntimeName()) {
	            throw new WorkboxError('expire-custom-caches-only');
	        }
	        let cacheExpiration = this._cacheExpirations.get(cacheName);
	        if (!cacheExpiration) {
	            cacheExpiration = new CacheExpiration(cacheName, this._config);
	            this._cacheExpirations.set(cacheName, cacheExpiration);
	        }
	        return cacheExpiration;
	    }
	    /**
	     * @param {Response} cachedResponse
	     * @return {boolean}
	     *
	     * @private
	     */
	    _isResponseDateFresh(cachedResponse) {
	        if (!this._maxAgeSeconds) {
	            // We aren't expiring by age, so return true, it's fresh
	            return true;
	        }
	        // Check if the 'date' header will suffice a quick expiration check.
	        // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for
	        // discussion.
	        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);
	        if (dateHeaderTimestamp === null) {
	            // Unable to parse date, so assume it's fresh.
	            return true;
	        }
	        // If we have a valid headerTime, then our response is fresh iff the
	        // headerTime plus maxAgeSeconds is greater than the current time.
	        const now = Date.now();
	        return dateHeaderTimestamp >= now - (this._maxAgeSeconds * 1000);
	    }
	    /**
	     * This method will extract the data header and parse it into a useful
	     * value.
	     *
	     * @param {Response} cachedResponse
	     * @return {number|null}
	     *
	     * @private
	     */
	    _getDateHeaderTimestamp(cachedResponse) {
	        if (!cachedResponse.headers.has('date')) {
	            return null;
	        }
	        const dateHeader = cachedResponse.headers.get('date');
	        const parsedDate = new Date(dateHeader);
	        const headerTime = parsedDate.getTime();
	        // If the Date header was invalid for some reason, parsedDate.getTime()
	        // will return NaN.
	        if (isNaN(headerTime)) {
	            return null;
	        }
	        return headerTime;
	    }
	    /**
	     * This is a helper method that performs two operations:
	     *
	     * - Deletes *all* the underlying Cache instances associated with this plugin
	     * instance, by calling caches.delete() on your behalf.
	     * - Deletes the metadata from IndexedDB used to keep track of expiration
	     * details for each Cache instance.
	     *
	     * When using cache expiration, calling this method is preferable to calling
	     * `caches.delete()` directly, since this will ensure that the IndexedDB
	     * metadata is also cleanly removed and open IndexedDB instances are deleted.
	     *
	     * Note that if you're *not* using cache expiration for a given cache, calling
	     * `caches.delete()` and passing in the cache's name should be sufficient.
	     * There is no Workbox-specific method needed for cleanup in that case.
	     */
	    async deleteCacheAndMetadata() {
	        // Do this one at a time instead of all at once via `Promise.all()` to
	        // reduce the chance of inconsistency if a promise rejects.
	        for (const [cacheName, cacheExpiration] of this._cacheExpirations) {
	            await self.caches.delete(cacheName);
	            await cacheExpiration.delete();
	        }
	        // Reset this._cacheExpirations to its initial state.
	        this._cacheExpirations = new Map();
	    }
	}

	self.__WB_DISABLE_DEV_LOGS = true;

	precacheAndRoute(shell);
	precacheAndRoute(files);

	registerRoute(
	/* eslint-disable-next-line */
	  new RegExp('https:\/\/producteursagri\.opendatasoft\.com'),
	  new CacheFirst({
	    cacheName: `ods-requests-${timestamp}`,
	    plugins: [
	      new ExpirationPlugin({
	        maxEntries: 50,
	        maxAgeSeconds: 3600 * 24,
	      }),
	    ],
	  }),
	);

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VydmljZS13b3JrZXIuanMiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ub2RlX21vZHVsZXMvQHNhcHBlci9zZXJ2aWNlLXdvcmtlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvX3ZlcnNpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL21vZGVscy9tZXNzYWdlcy9tZXNzYWdlcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvbW9kZWxzL21lc3NhZ2VzL21lc3NhZ2VHZW5lcmF0b3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtY29yZS9fcHJpdmF0ZS9jYWNoZU5hbWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL3dhaXRVbnRpbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXByZWNhY2hpbmcvX3ZlcnNpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL2NyZWF0ZUNhY2hlS2V5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy91dGlscy9QcmVjYWNoZUluc3RhbGxSZXBvcnRQbHVnaW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL1ByZWNhY2hlQ2FjaGVLZXlQbHVnaW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL3ByaW50Q2xlYW51cERldGFpbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL3ByaW50SW5zdGFsbERldGFpbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL2NhbkNvbnN0cnVjdFJlc3BvbnNlRnJvbUJvZHlTdHJlYW0uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL2NvcHlSZXNwb25zZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL2NhY2hlTWF0Y2hJZ25vcmVQYXJhbXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL0RlZmVycmVkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtY29yZS9tb2RlbHMvcXVvdGFFcnJvckNhbGxiYWNrcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvX3ByaXZhdGUvZXhlY3V0ZVF1b3RhRXJyb3JDYWxsYmFja3MuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL3RpbWVvdXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1zdHJhdGVnaWVzL192ZXJzaW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtc3RyYXRlZ2llcy9TdHJhdGVneUhhbmRsZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1zdHJhdGVnaWVzL1N0cmF0ZWd5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy9QcmVjYWNoZVN0cmF0ZWd5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy9QcmVjYWNoZUNvbnRyb2xsZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL2dldE9yQ3JlYXRlUHJlY2FjaGVDb250cm9sbGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcm91dGluZy9fdmVyc2lvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXJvdXRpbmcvdXRpbHMvY29uc3RhbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcm91dGluZy91dGlscy9ub3JtYWxpemVIYW5kbGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcm91dGluZy9Sb3V0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXJvdXRpbmcvUmVnRXhwUm91dGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1yb3V0aW5nL1JvdXRlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXJvdXRpbmcvdXRpbHMvZ2V0T3JDcmVhdGVEZWZhdWx0Um91dGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcm91dGluZy9yZWdpc3RlclJvdXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy91dGlscy9yZW1vdmVJZ25vcmVkU2VhcmNoUGFyYW1zLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy91dGlscy9nZW5lcmF0ZVVSTFZhcmlhdGlvbnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL1ByZWNhY2hlUm91dGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL2FkZFJvdXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy9wcmVjYWNoZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXByZWNhY2hpbmcvcHJlY2FjaGVBbmRSb3V0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXN0cmF0ZWdpZXMvdXRpbHMvbWVzc2FnZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1zdHJhdGVnaWVzL0NhY2hlRmlyc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL2RvbnRXYWl0Rm9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtY29yZS9fcHJpdmF0ZS9EQldyYXBwZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL2RlbGV0ZURhdGFiYXNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtZXhwaXJhdGlvbi9fdmVyc2lvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWV4cGlyYXRpb24vbW9kZWxzL0NhY2hlVGltZXN0YW1wc01vZGVsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtZXhwaXJhdGlvbi9DYWNoZUV4cGlyYXRpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL3JlZ2lzdGVyUXVvdGFFcnJvckNhbGxiYWNrLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtZXhwaXJhdGlvbi9FeHBpcmF0aW9uUGx1Z2luLmpzIiwiLi4vLi4vc3JjL3NlcnZpY2Utd29ya2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgU2FwcGVyIOKAlCBkbyBub3QgZWRpdCBpdCFcbmV4cG9ydCBjb25zdCB0aW1lc3RhbXAgPSAxNjA4MDI3MDMyNTYwO1xuXG5leHBvcnQgY29uc3QgZmlsZXMgPSBbXG5cdFwiL3NlcnZpY2Utd29ya2VyLWluZGV4Lmh0bWxcIixcblx0XCIvYW5kcm9pZC1jaHJvbWUtMTkyeDE5Mi5wbmdcIixcblx0XCIvYW5kcm9pZC1jaHJvbWUtNTEyeDUxMi5wbmdcIixcblx0XCIvYXBwbGUtdG91Y2gtaWNvbi5wbmdcIixcblx0XCIvYnJvd3NlcmNvbmZpZy54bWxcIixcblx0XCIvZmF2aWNvbi0xNngxNi5wbmdcIixcblx0XCIvZmF2aWNvbi0zMngzMi5wbmdcIixcblx0XCIvZmF2aWNvbi5pY29cIixcblx0XCIvZmF2aWNvbi5wbmdcIixcblx0XCIvZ2xvYmFsLmNzc1wiLFxuXHRcIi9sb2NhdGlvbi5zdmdcIixcblx0XCIvbG9nby0xOTIucG5nXCIsXG5cdFwiL2xvZ28tNTEyLnBuZ1wiLFxuXHRcIi9tYW5pZmVzdC53ZWJtYW5pZmVzdFwiLFxuXHRcIi9tc3RpbGUtMTQ0eDE0NC5wbmdcIixcblx0XCIvbXN0aWxlLTE1MHgxNTAucG5nXCIsXG5cdFwiL21zdGlsZS0zMTB4MTUwLnBuZ1wiLFxuXHRcIi9tc3RpbGUtMzEweDMxMC5wbmdcIixcblx0XCIvbXN0aWxlLTcweDcwLnBuZ1wiLFxuXHRcIi9zYWZhcmktcGlubmVkLXRhYi5zdmdcIlxuXTtcbmV4cG9ydCB7IGZpbGVzIGFzIGFzc2V0cyB9OyAvLyBsZWdhY3lcblxuZXhwb3J0IGNvbnN0IHNoZWxsID0gW1xuXHRcbl07XG5cbmV4cG9ydCBjb25zdCByb3V0ZXMgPSBbXG5cdHsgcGF0dGVybjogL15cXC8kLyB9LFxuXHR7IHBhdHRlcm46IC9eXFwvcGFydG5lcnNcXC8/JC8gfSxcblx0eyBwYXR0ZXJuOiAvXlxcL2Fib3V0XFwvPyQvIH0sXG5cdHsgcGF0dGVybjogL15cXC9mYXJtc1xcLz8kLyB9LFxuXHR7IHBhdHRlcm46IC9eXFwvZmFybXNcXC8oW14vXSs/KVxcLz8kLyB9XG5dOyIsIlwidXNlIHN0cmljdFwiO1xuLy8gQHRzLWlnbm9yZVxudHJ5IHtcbiAgICBzZWxmWyd3b3JrYm94OmNvcmU6Ni4wLjInXSAmJiBfKCk7XG59XG5jYXRjaCAoZSkgeyB9XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgJy4uLy4uL192ZXJzaW9uLmpzJztcbmV4cG9ydCBjb25zdCBtZXNzYWdlcyA9IHtcbiAgICAnaW52YWxpZC12YWx1ZSc6ICh7IHBhcmFtTmFtZSwgdmFsaWRWYWx1ZURlc2NyaXB0aW9uLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIGlmICghcGFyYW1OYW1lIHx8ICF2YWxpZFZhbHVlRGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAnaW52YWxpZC12YWx1ZScgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBUaGUgJyR7cGFyYW1OYW1lfScgcGFyYW1ldGVyIHdhcyBnaXZlbiBhIHZhbHVlIHdpdGggYW4gYCArXG4gICAgICAgICAgICBgdW5leHBlY3RlZCB2YWx1ZS4gJHt2YWxpZFZhbHVlRGVzY3JpcHRpb259IFJlY2VpdmVkIGEgdmFsdWUgb2YgYCArXG4gICAgICAgICAgICBgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9LmA7XG4gICAgfSxcbiAgICAnbm90LWFuLWFycmF5JzogKHsgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSwgcGFyYW1OYW1lIH0pID0+IHtcbiAgICAgICAgaWYgKCFtb2R1bGVOYW1lIHx8ICFjbGFzc05hbWUgfHwgIWZ1bmNOYW1lIHx8ICFwYXJhbU5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAnbm90LWFuLWFycmF5JyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFRoZSBwYXJhbWV0ZXIgJyR7cGFyYW1OYW1lfScgcGFzc2VkIGludG8gYCArXG4gICAgICAgICAgICBgJyR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWV9LiR7ZnVuY05hbWV9KCknIG11c3QgYmUgYW4gYXJyYXkuYDtcbiAgICB9LFxuICAgICdpbmNvcnJlY3QtdHlwZSc6ICh7IGV4cGVjdGVkVHlwZSwgcGFyYW1OYW1lLCBtb2R1bGVOYW1lLCBjbGFzc05hbWUsIGZ1bmNOYW1lIH0pID0+IHtcbiAgICAgICAgaWYgKCFleHBlY3RlZFR5cGUgfHwgIXBhcmFtTmFtZSB8fCAhbW9kdWxlTmFtZSB8fCAhZnVuY05hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAnaW5jb3JyZWN0LXR5cGUnIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgVGhlIHBhcmFtZXRlciAnJHtwYXJhbU5hbWV9JyBwYXNzZWQgaW50byBgICtcbiAgICAgICAgICAgIGAnJHttb2R1bGVOYW1lfS4ke2NsYXNzTmFtZSA/IChjbGFzc05hbWUgKyAnLicpIDogJyd9YCArXG4gICAgICAgICAgICBgJHtmdW5jTmFtZX0oKScgbXVzdCBiZSBvZiB0eXBlICR7ZXhwZWN0ZWRUeXBlfS5gO1xuICAgIH0sXG4gICAgJ2luY29ycmVjdC1jbGFzcyc6ICh7IGV4cGVjdGVkQ2xhc3MsIHBhcmFtTmFtZSwgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSwgaXNSZXR1cm5WYWx1ZVByb2JsZW0gfSkgPT4ge1xuICAgICAgICBpZiAoIWV4cGVjdGVkQ2xhc3MgfHwgIW1vZHVsZU5hbWUgfHwgIWZ1bmNOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ2luY29ycmVjdC1jbGFzcycgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUmV0dXJuVmFsdWVQcm9ibGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gYFRoZSByZXR1cm4gdmFsdWUgZnJvbSBgICtcbiAgICAgICAgICAgICAgICBgJyR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWUgPyAoY2xhc3NOYW1lICsgJy4nKSA6ICcnfSR7ZnVuY05hbWV9KCknIGAgK1xuICAgICAgICAgICAgICAgIGBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIGNsYXNzICR7ZXhwZWN0ZWRDbGFzcy5uYW1lfS5gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgVGhlIHBhcmFtZXRlciAnJHtwYXJhbU5hbWV9JyBwYXNzZWQgaW50byBgICtcbiAgICAgICAgICAgIGAnJHttb2R1bGVOYW1lfS4ke2NsYXNzTmFtZSA/IChjbGFzc05hbWUgKyAnLicpIDogJyd9JHtmdW5jTmFtZX0oKScgYCArXG4gICAgICAgICAgICBgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBjbGFzcyAke2V4cGVjdGVkQ2xhc3MubmFtZX0uYDtcbiAgICB9LFxuICAgICdtaXNzaW5nLWEtbWV0aG9kJzogKHsgZXhwZWN0ZWRNZXRob2QsIHBhcmFtTmFtZSwgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSB9KSA9PiB7XG4gICAgICAgIGlmICghZXhwZWN0ZWRNZXRob2QgfHwgIXBhcmFtTmFtZSB8fCAhbW9kdWxlTmFtZSB8fCAhY2xhc3NOYW1lXG4gICAgICAgICAgICB8fCAhZnVuY05hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAnbWlzc2luZy1hLW1ldGhvZCcgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lfS4ke2Z1bmNOYW1lfSgpIGV4cGVjdGVkIHRoZSBgICtcbiAgICAgICAgICAgIGAnJHtwYXJhbU5hbWV9JyBwYXJhbWV0ZXIgdG8gZXhwb3NlIGEgJyR7ZXhwZWN0ZWRNZXRob2R9JyBtZXRob2QuYDtcbiAgICB9LFxuICAgICdhZGQtdG8tY2FjaGUtbGlzdC11bmV4cGVjdGVkLXR5cGUnOiAoeyBlbnRyeSB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgQW4gdW5leHBlY3RlZCBlbnRyeSB3YXMgcGFzc2VkIHRvIGAgK1xuICAgICAgICAgICAgYCd3b3JrYm94LXByZWNhY2hpbmcuUHJlY2FjaGVDb250cm9sbGVyLmFkZFRvQ2FjaGVMaXN0KCknIFRoZSBlbnRyeSBgICtcbiAgICAgICAgICAgIGAnJHtKU09OLnN0cmluZ2lmeShlbnRyeSl9JyBpc24ndCBzdXBwb3J0ZWQuIFlvdSBtdXN0IHN1cHBseSBhbiBhcnJheSBvZiBgICtcbiAgICAgICAgICAgIGBzdHJpbmdzIHdpdGggb25lIG9yIG1vcmUgY2hhcmFjdGVycywgb2JqZWN0cyB3aXRoIGEgdXJsIHByb3BlcnR5IG9yIGAgK1xuICAgICAgICAgICAgYFJlcXVlc3Qgb2JqZWN0cy5gO1xuICAgIH0sXG4gICAgJ2FkZC10by1jYWNoZS1saXN0LWNvbmZsaWN0aW5nLWVudHJpZXMnOiAoeyBmaXJzdEVudHJ5LCBzZWNvbmRFbnRyeSB9KSA9PiB7XG4gICAgICAgIGlmICghZmlyc3RFbnRyeSB8fCAhc2Vjb25kRW50cnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byBgICtcbiAgICAgICAgICAgICAgICBgJ2FkZC10by1jYWNoZS1saXN0LWR1cGxpY2F0ZS1lbnRyaWVzJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFR3byBvZiB0aGUgZW50cmllcyBwYXNzZWQgdG8gYCArXG4gICAgICAgICAgICBgJ3dvcmtib3gtcHJlY2FjaGluZy5QcmVjYWNoZUNvbnRyb2xsZXIuYWRkVG9DYWNoZUxpc3QoKScgaGFkIHRoZSBVUkwgYCArXG4gICAgICAgICAgICBgJHtmaXJzdEVudHJ5Ll9lbnRyeUlkfSBidXQgZGlmZmVyZW50IHJldmlzaW9uIGRldGFpbHMuIFdvcmtib3ggaXMgYCArXG4gICAgICAgICAgICBgdW5hYmxlIHRvIGNhY2hlIGFuZCB2ZXJzaW9uIHRoZSBhc3NldCBjb3JyZWN0bHkuIFBsZWFzZSByZW1vdmUgb25lIGAgK1xuICAgICAgICAgICAgYG9mIHRoZSBlbnRyaWVzLmA7XG4gICAgfSxcbiAgICAncGx1Z2luLWVycm9yLXJlcXVlc3Qtd2lsbC1mZXRjaCc6ICh7IHRocm93bkVycm9yIH0pID0+IHtcbiAgICAgICAgaWYgKCF0aHJvd25FcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0IHRvIGAgK1xuICAgICAgICAgICAgICAgIGAncGx1Z2luLWVycm9yLXJlcXVlc3Qtd2lsbC1mZXRjaCcsIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgQW4gZXJyb3Igd2FzIHRocm93biBieSBhIHBsdWdpbnMgJ3JlcXVlc3RXaWxsRmV0Y2goKScgbWV0aG9kLiBgICtcbiAgICAgICAgICAgIGBUaGUgdGhyb3duIGVycm9yIG1lc3NhZ2Ugd2FzOiAnJHt0aHJvd25FcnJvci5tZXNzYWdlfScuYDtcbiAgICB9LFxuICAgICdpbnZhbGlkLWNhY2hlLW5hbWUnOiAoeyBjYWNoZU5hbWVJZCwgdmFsdWUgfSkgPT4ge1xuICAgICAgICBpZiAoIWNhY2hlTmFtZUlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgJ2NhY2hlTmFtZUlkJyBmb3IgZXJyb3IgJ2ludmFsaWQtY2FjaGUtbmFtZSdgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFlvdSBtdXN0IHByb3ZpZGUgYSBuYW1lIGNvbnRhaW5pbmcgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciBmb3IgYCArXG4gICAgICAgICAgICBgc2V0Q2FjaGVEZXRhaWxzKHske2NhY2hlTmFtZUlkfTogJy4uLid9KS4gUmVjZWl2ZWQgYSB2YWx1ZSBvZiBgICtcbiAgICAgICAgICAgIGAnJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9J2A7XG4gICAgfSxcbiAgICAndW5yZWdpc3Rlci1yb3V0ZS1idXQtbm90LWZvdW5kLXdpdGgtbWV0aG9kJzogKHsgbWV0aG9kIH0pID0+IHtcbiAgICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byBgICtcbiAgICAgICAgICAgICAgICBgJ3VucmVnaXN0ZXItcm91dGUtYnV0LW5vdC1mb3VuZC13aXRoLW1ldGhvZCcgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBUaGUgcm91dGUgeW91J3JlIHRyeWluZyB0byB1bnJlZ2lzdGVyIHdhcyBub3QgIHByZXZpb3VzbHkgYCArXG4gICAgICAgICAgICBgcmVnaXN0ZXJlZCBmb3IgdGhlIG1ldGhvZCB0eXBlICcke21ldGhvZH0nLmA7XG4gICAgfSxcbiAgICAndW5yZWdpc3Rlci1yb3V0ZS1yb3V0ZS1ub3QtcmVnaXN0ZXJlZCc6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGBUaGUgcm91dGUgeW91J3JlIHRyeWluZyB0byB1bnJlZ2lzdGVyIHdhcyBub3QgcHJldmlvdXNseSBgICtcbiAgICAgICAgICAgIGByZWdpc3RlcmVkLmA7XG4gICAgfSxcbiAgICAncXVldWUtcmVwbGF5LWZhaWxlZCc6ICh7IG5hbWUgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFJlcGxheWluZyB0aGUgYmFja2dyb3VuZCBzeW5jIHF1ZXVlICcke25hbWV9JyBmYWlsZWQuYDtcbiAgICB9LFxuICAgICdkdXBsaWNhdGUtcXVldWUtbmFtZSc6ICh7IG5hbWUgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFRoZSBRdWV1ZSBuYW1lICcke25hbWV9JyBpcyBhbHJlYWR5IGJlaW5nIHVzZWQuIGAgK1xuICAgICAgICAgICAgYEFsbCBpbnN0YW5jZXMgb2YgYmFja2dyb3VuZFN5bmMuUXVldWUgbXVzdCBiZSBnaXZlbiB1bmlxdWUgbmFtZXMuYDtcbiAgICB9LFxuICAgICdleHBpcmVkLXRlc3Qtd2l0aG91dC1tYXgtYWdlJzogKHsgbWV0aG9kTmFtZSwgcGFyYW1OYW1lIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGBUaGUgJyR7bWV0aG9kTmFtZX0oKScgbWV0aG9kIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiB0aGUgYCArXG4gICAgICAgICAgICBgJyR7cGFyYW1OYW1lfScgaXMgdXNlZCBpbiB0aGUgY29uc3RydWN0b3IuYDtcbiAgICB9LFxuICAgICd1bnN1cHBvcnRlZC1yb3V0ZS10eXBlJzogKHsgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSwgcGFyYW1OYW1lIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGBUaGUgc3VwcGxpZWQgJyR7cGFyYW1OYW1lfScgcGFyYW1ldGVyIHdhcyBhbiB1bnN1cHBvcnRlZCB0eXBlLiBgICtcbiAgICAgICAgICAgIGBQbGVhc2UgY2hlY2sgdGhlIGRvY3MgZm9yICR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWV9LiR7ZnVuY05hbWV9IGZvciBgICtcbiAgICAgICAgICAgIGB2YWxpZCBpbnB1dCB0eXBlcy5gO1xuICAgIH0sXG4gICAgJ25vdC1hcnJheS1vZi1jbGFzcyc6ICh7IHZhbHVlLCBleHBlY3RlZENsYXNzLCBtb2R1bGVOYW1lLCBjbGFzc05hbWUsIGZ1bmNOYW1lLCBwYXJhbU5hbWUgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFRoZSBzdXBwbGllZCAnJHtwYXJhbU5hbWV9JyBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBhcnJheSBvZiBgICtcbiAgICAgICAgICAgIGAnJHtleHBlY3RlZENsYXNzfScgb2JqZWN0cy4gUmVjZWl2ZWQgJyR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSwnLiBgICtcbiAgICAgICAgICAgIGBQbGVhc2UgY2hlY2sgdGhlIGNhbGwgdG8gJHttb2R1bGVOYW1lfS4ke2NsYXNzTmFtZX0uJHtmdW5jTmFtZX0oKSBgICtcbiAgICAgICAgICAgIGB0byBmaXggdGhlIGlzc3VlLmA7XG4gICAgfSxcbiAgICAnbWF4LWVudHJpZXMtb3ItYWdlLXJlcXVpcmVkJzogKHsgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgWW91IG11c3QgZGVmaW5lIGVpdGhlciBjb25maWcubWF4RW50cmllcyBvciBjb25maWcubWF4QWdlU2Vjb25kc2AgK1xuICAgICAgICAgICAgYGluICR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWV9LiR7ZnVuY05hbWV9YDtcbiAgICB9LFxuICAgICdzdGF0dXNlcy1vci1oZWFkZXJzLXJlcXVpcmVkJzogKHsgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgWW91IG11c3QgZGVmaW5lIGVpdGhlciBjb25maWcuc3RhdHVzZXMgb3IgY29uZmlnLmhlYWRlcnNgICtcbiAgICAgICAgICAgIGBpbiAke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lfS4ke2Z1bmNOYW1lfWA7XG4gICAgfSxcbiAgICAnaW52YWxpZC1zdHJpbmcnOiAoeyBtb2R1bGVOYW1lLCBmdW5jTmFtZSwgcGFyYW1OYW1lIH0pID0+IHtcbiAgICAgICAgaWYgKCFwYXJhbU5hbWUgfHwgIW1vZHVsZU5hbWUgfHwgIWZ1bmNOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ2ludmFsaWQtc3RyaW5nJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFdoZW4gdXNpbmcgc3RyaW5ncywgdGhlICcke3BhcmFtTmFtZX0nIHBhcmFtZXRlciBtdXN0IHN0YXJ0IHdpdGggYCArXG4gICAgICAgICAgICBgJ2h0dHAnIChmb3IgY3Jvc3Mtb3JpZ2luIG1hdGNoZXMpIG9yICcvJyAoZm9yIHNhbWUtb3JpZ2luIG1hdGNoZXMpLiBgICtcbiAgICAgICAgICAgIGBQbGVhc2Ugc2VlIHRoZSBkb2NzIGZvciAke21vZHVsZU5hbWV9LiR7ZnVuY05hbWV9KCkgZm9yIGAgK1xuICAgICAgICAgICAgYG1vcmUgaW5mby5gO1xuICAgIH0sXG4gICAgJ2NoYW5uZWwtbmFtZS1yZXF1aXJlZCc6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGBZb3UgbXVzdCBwcm92aWRlIGEgY2hhbm5lbE5hbWUgdG8gY29uc3RydWN0IGEgYCArXG4gICAgICAgICAgICBgQnJvYWRjYXN0Q2FjaGVVcGRhdGUgaW5zdGFuY2UuYDtcbiAgICB9LFxuICAgICdpbnZhbGlkLXJlc3BvbnNlcy1hcmUtc2FtZS1hcmdzJzogKCkgPT4ge1xuICAgICAgICByZXR1cm4gYFRoZSBhcmd1bWVudHMgcGFzc2VkIGludG8gcmVzcG9uc2VzQXJlU2FtZSgpIGFwcGVhciB0byBiZSBgICtcbiAgICAgICAgICAgIGBpbnZhbGlkLiBQbGVhc2UgZW5zdXJlIHZhbGlkIFJlc3BvbnNlcyBhcmUgdXNlZC5gO1xuICAgIH0sXG4gICAgJ2V4cGlyZS1jdXN0b20tY2FjaGVzLW9ubHknOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBgWW91IG11c3QgcHJvdmlkZSBhICdjYWNoZU5hbWUnIHByb3BlcnR5IHdoZW4gdXNpbmcgdGhlIGAgK1xuICAgICAgICAgICAgYGV4cGlyYXRpb24gcGx1Z2luIHdpdGggYSBydW50aW1lIGNhY2hpbmcgc3RyYXRlZ3kuYDtcbiAgICB9LFxuICAgICd1bml0LW11c3QtYmUtYnl0ZXMnOiAoeyBub3JtYWxpemVkUmFuZ2VIZWFkZXIgfSkgPT4ge1xuICAgICAgICBpZiAoIW5vcm1hbGl6ZWRSYW5nZUhlYWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0IHRvICd1bml0LW11c3QtYmUtYnl0ZXMnIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgVGhlICd1bml0JyBwb3J0aW9uIG9mIHRoZSBSYW5nZSBoZWFkZXIgbXVzdCBiZSBzZXQgdG8gJ2J5dGVzJy4gYCArXG4gICAgICAgICAgICBgVGhlIFJhbmdlIGhlYWRlciBwcm92aWRlZCB3YXMgXCIke25vcm1hbGl6ZWRSYW5nZUhlYWRlcn1cImA7XG4gICAgfSxcbiAgICAnc2luZ2xlLXJhbmdlLW9ubHknOiAoeyBub3JtYWxpemVkUmFuZ2VIZWFkZXIgfSkgPT4ge1xuICAgICAgICBpZiAoIW5vcm1hbGl6ZWRSYW5nZUhlYWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0IHRvICdzaW5nbGUtcmFuZ2Utb25seScgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBNdWx0aXBsZSByYW5nZXMgYXJlIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgYSAgc2luZ2xlIHN0YXJ0IGAgK1xuICAgICAgICAgICAgYHZhbHVlLCBhbmQgb3B0aW9uYWwgZW5kIHZhbHVlLiBUaGUgUmFuZ2UgaGVhZGVyIHByb3ZpZGVkIHdhcyBgICtcbiAgICAgICAgICAgIGBcIiR7bm9ybWFsaXplZFJhbmdlSGVhZGVyfVwiYDtcbiAgICB9LFxuICAgICdpbnZhbGlkLXJhbmdlLXZhbHVlcyc6ICh7IG5vcm1hbGl6ZWRSYW5nZUhlYWRlciB9KSA9PiB7XG4gICAgICAgIGlmICghbm9ybWFsaXplZFJhbmdlSGVhZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ2ludmFsaWQtcmFuZ2UtdmFsdWVzJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFRoZSBSYW5nZSBoZWFkZXIgaXMgbWlzc2luZyBib3RoIHN0YXJ0IGFuZCBlbmQgdmFsdWVzLiBBdCBsZWFzdCBgICtcbiAgICAgICAgICAgIGBvbmUgb2YgdGhvc2UgdmFsdWVzIGlzIG5lZWRlZC4gVGhlIFJhbmdlIGhlYWRlciBwcm92aWRlZCB3YXMgYCArXG4gICAgICAgICAgICBgXCIke25vcm1hbGl6ZWRSYW5nZUhlYWRlcn1cImA7XG4gICAgfSxcbiAgICAnbm8tcmFuZ2UtaGVhZGVyJzogKCkgPT4ge1xuICAgICAgICByZXR1cm4gYE5vIFJhbmdlIGhlYWRlciB3YXMgZm91bmQgaW4gdGhlIFJlcXVlc3QgcHJvdmlkZWQuYDtcbiAgICB9LFxuICAgICdyYW5nZS1ub3Qtc2F0aXNmaWFibGUnOiAoeyBzaXplLCBzdGFydCwgZW5kIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGBUaGUgc3RhcnQgKCR7c3RhcnR9KSBhbmQgZW5kICgke2VuZH0pIHZhbHVlcyBpbiB0aGUgUmFuZ2UgYXJlIGAgK1xuICAgICAgICAgICAgYG5vdCBzYXRpc2ZpYWJsZSBieSB0aGUgY2FjaGVkIHJlc3BvbnNlLCB3aGljaCBpcyAke3NpemV9IGJ5dGVzLmA7XG4gICAgfSxcbiAgICAnYXR0ZW1wdC10by1jYWNoZS1ub24tZ2V0LXJlcXVlc3QnOiAoeyB1cmwsIG1ldGhvZCB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgVW5hYmxlIHRvIGNhY2hlICcke3VybH0nIGJlY2F1c2UgaXQgaXMgYSAnJHttZXRob2R9JyByZXF1ZXN0IGFuZCBgICtcbiAgICAgICAgICAgIGBvbmx5ICdHRVQnIHJlcXVlc3RzIGNhbiBiZSBjYWNoZWQuYDtcbiAgICB9LFxuICAgICdjYWNoZS1wdXQtd2l0aC1uby1yZXNwb25zZSc6ICh7IHVybCB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgVGhlcmUgd2FzIGFuIGF0dGVtcHQgdG8gY2FjaGUgJyR7dXJsfScgYnV0IHRoZSByZXNwb25zZSB3YXMgbm90IGAgK1xuICAgICAgICAgICAgYGRlZmluZWQuYDtcbiAgICB9LFxuICAgICduby1yZXNwb25zZSc6ICh7IHVybCwgZXJyb3IgfSkgPT4ge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IGBUaGUgc3RyYXRlZ3kgY291bGQgbm90IGdlbmVyYXRlIGEgcmVzcG9uc2UgZm9yICcke3VybH0nLmA7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBgIFRoZSB1bmRlcmx5aW5nIGVycm9yIGlzICR7ZXJyb3J9LmA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICAnYmFkLXByZWNhY2hpbmctcmVzcG9uc2UnOiAoeyB1cmwsIHN0YXR1cyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgVGhlIHByZWNhY2hpbmcgcmVxdWVzdCBmb3IgJyR7dXJsfScgZmFpbGVkYCArXG4gICAgICAgICAgICAoc3RhdHVzID8gYCB3aXRoIGFuIEhUVFAgc3RhdHVzIG9mICR7c3RhdHVzfS5gIDogYC5gKTtcbiAgICB9LFxuICAgICdub24tcHJlY2FjaGVkLXVybCc6ICh7IHVybCB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgY3JlYXRlSGFuZGxlckJvdW5kVG9VUkwoJyR7dXJsfScpIHdhcyBjYWxsZWQsIGJ1dCB0aGF0IFVSTCBpcyBgICtcbiAgICAgICAgICAgIGBub3QgcHJlY2FjaGVkLiBQbGVhc2UgcGFzcyBpbiBhIFVSTCB0aGF0IGlzIHByZWNhY2hlZCBpbnN0ZWFkLmA7XG4gICAgfSxcbiAgICAnYWRkLXRvLWNhY2hlLWxpc3QtY29uZmxpY3RpbmctaW50ZWdyaXRpZXMnOiAoeyB1cmwgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFR3byBvZiB0aGUgZW50cmllcyBwYXNzZWQgdG8gYCArXG4gICAgICAgICAgICBgJ3dvcmtib3gtcHJlY2FjaGluZy5QcmVjYWNoZUNvbnRyb2xsZXIuYWRkVG9DYWNoZUxpc3QoKScgaGFkIHRoZSBVUkwgYCArXG4gICAgICAgICAgICBgJHt1cmx9IHdpdGggZGlmZmVyZW50IGludGVncml0eSB2YWx1ZXMuIFBsZWFzZSByZW1vdmUgb25lIG9mIHRoZW0uYDtcbiAgICB9LFxuICAgICdtaXNzaW5nLXByZWNhY2hlLWVudHJ5JzogKHsgY2FjaGVOYW1lLCB1cmwgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFVuYWJsZSB0byBmaW5kIGEgcHJlY2FjaGVkIHJlc3BvbnNlIGluICR7Y2FjaGVOYW1lfSBmb3IgJHt1cmx9LmA7XG4gICAgfSxcbiAgICAnY3Jvc3Mtb3JpZ2luLWNvcHktcmVzcG9uc2UnOiAoeyBvcmlnaW4gfSkgPT4ge1xuICAgICAgICByZXR1cm4gYHdvcmtib3gtY29yZS5jb3B5UmVzcG9uc2UoKSBjYW4gb25seSBiZSB1c2VkIHdpdGggc2FtZS1vcmlnaW4gYCArXG4gICAgICAgICAgICBgcmVzcG9uc2VzLiBJdCB3YXMgcGFzc2VkIGEgcmVzcG9uc2Ugd2l0aCBvcmlnaW4gJHtvcmlnaW59LmA7XG4gICAgfSxcbn07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBtZXNzYWdlcyB9IGZyb20gJy4vbWVzc2FnZXMuanMnO1xuaW1wb3J0ICcuLi8uLi9fdmVyc2lvbi5qcyc7XG5jb25zdCBmYWxsYmFjayA9IChjb2RlLCAuLi5hcmdzKSA9PiB7XG4gICAgbGV0IG1zZyA9IGNvZGU7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBtc2cgKz0gYCA6OiAke0pTT04uc3RyaW5naWZ5KGFyZ3MpfWA7XG4gICAgfVxuICAgIHJldHVybiBtc2c7XG59O1xuY29uc3QgZ2VuZXJhdG9yRnVuY3Rpb24gPSAoY29kZSwgZGV0YWlscyA9IHt9KSA9PiB7XG4gICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VzW2NvZGVdO1xuICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIG1lc3NhZ2UgZm9yIGNvZGUgJyR7Y29kZX0nLmApO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZShkZXRhaWxzKTtcbn07XG5leHBvcnQgY29uc3QgbWVzc2FnZUdlbmVyYXRvciA9IChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSA/XG4gICAgZmFsbGJhY2sgOiBnZW5lcmF0b3JGdW5jdGlvbjtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IG1lc3NhZ2VHZW5lcmF0b3IgfSBmcm9tICcuLi9tb2RlbHMvbWVzc2FnZXMvbWVzc2FnZUdlbmVyYXRvci5qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogV29ya2JveCBlcnJvcnMgc2hvdWxkIGJlIHRocm93biB3aXRoIHRoaXMgY2xhc3MuXG4gKiBUaGlzIGFsbG93cyB1c2UgdG8gZW5zdXJlIHRoZSB0eXBlIGVhc2lseSBpbiB0ZXN0cyxcbiAqIGhlbHBzIGRldmVsb3BlcnMgaWRlbnRpZnkgZXJyb3JzIGZyb20gd29ya2JveFxuICogZWFzaWx5IGFuZCBhbGxvd3MgdXNlIHRvIG9wdGltaXNlIGVycm9yXG4gKiBtZXNzYWdlcyBjb3JyZWN0bHkuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgV29ya2JveEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVycm9yQ29kZSBUaGUgZXJyb3IgY29kZSB0aGF0XG4gICAgICogaWRlbnRpZmllcyB0aGlzIHBhcnRpY3VsYXIgZXJyb3IuXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBkZXRhaWxzIEFueSByZWxldmFudCBhcmd1bWVudHNcbiAgICAgKiB0aGF0IHdpbGwgaGVscCBkZXZlbG9wZXJzIGlkZW50aWZ5IGlzc3VlcyBzaG91bGRcbiAgICAgKiBiZSBhZGRlZCBhcyBhIGtleSBvbiB0aGUgY29udGV4dCBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZXJyb3JDb2RlLCBkZXRhaWxzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlR2VuZXJhdG9yKGVycm9yQ29kZSwgZGV0YWlscyk7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnJvckNvZGU7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgfVxufVxuZXhwb3J0IHsgV29ya2JveEVycm9yIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBXb3JrYm94RXJyb3IgfSBmcm9tICcuLi9fcHJpdmF0ZS9Xb3JrYm94RXJyb3IuanMnO1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKlxuICogVGhpcyBtZXRob2QgdGhyb3dzIGlmIHRoZSBzdXBwbGllZCB2YWx1ZSBpcyBub3QgYW4gYXJyYXkuXG4gKiBUaGUgZGVzdHJ1Y3RlZCB2YWx1ZXMgYXJlIHJlcXVpcmVkIHRvIHByb2R1Y2UgYSBtZWFuaW5nZnVsIGVycm9yIGZvciB1c2Vycy5cbiAqIFRoZSBkZXN0cnVjdGVkIGFuZCByZXN0cnVjdHVyZWQgb2JqZWN0IGlzIHNvIGl0J3MgY2xlYXIgd2hhdCBpc1xuICogbmVlZGVkLlxuICovXG5jb25zdCBpc0FycmF5ID0gKHZhbHVlLCBkZXRhaWxzKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdub3QtYW4tYXJyYXknLCBkZXRhaWxzKTtcbiAgICB9XG59O1xuY29uc3QgaGFzTWV0aG9kID0gKG9iamVjdCwgZXhwZWN0ZWRNZXRob2QsIGRldGFpbHMpID0+IHtcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIG9iamVjdFtleHBlY3RlZE1ldGhvZF07XG4gICAgaWYgKHR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGV0YWlsc1snZXhwZWN0ZWRNZXRob2QnXSA9IGV4cGVjdGVkTWV0aG9kO1xuICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdtaXNzaW5nLWEtbWV0aG9kJywgZGV0YWlscyk7XG4gICAgfVxufTtcbmNvbnN0IGlzVHlwZSA9IChvYmplY3QsIGV4cGVjdGVkVHlwZSwgZGV0YWlscykgPT4ge1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgZGV0YWlsc1snZXhwZWN0ZWRUeXBlJ10gPSBleHBlY3RlZFR5cGU7XG4gICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2luY29ycmVjdC10eXBlJywgZGV0YWlscyk7XG4gICAgfVxufTtcbmNvbnN0IGlzSW5zdGFuY2UgPSAob2JqZWN0LCBleHBlY3RlZENsYXNzLCBkZXRhaWxzKSA9PiB7XG4gICAgaWYgKCEob2JqZWN0IGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgZGV0YWlsc1snZXhwZWN0ZWRDbGFzcyddID0gZXhwZWN0ZWRDbGFzcztcbiAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignaW5jb3JyZWN0LWNsYXNzJywgZGV0YWlscyk7XG4gICAgfVxufTtcbmNvbnN0IGlzT25lT2YgPSAodmFsdWUsIHZhbGlkVmFsdWVzLCBkZXRhaWxzKSA9PiB7XG4gICAgaWYgKCF2YWxpZFZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgZGV0YWlsc1sndmFsaWRWYWx1ZURlc2NyaXB0aW9uJ10gPVxuICAgICAgICAgICAgYFZhbGlkIHZhbHVlcyBhcmUgJHtKU09OLnN0cmluZ2lmeSh2YWxpZFZhbHVlcyl9LmA7XG4gICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2ludmFsaWQtdmFsdWUnLCBkZXRhaWxzKTtcbiAgICB9XG59O1xuY29uc3QgaXNBcnJheU9mQ2xhc3MgPSAodmFsdWUsIGV4cGVjdGVkQ2xhc3MsIGRldGFpbHMpID0+IHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBXb3JrYm94RXJyb3IoJ25vdC1hcnJheS1vZi1jbGFzcycsIGRldGFpbHMpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGZpbmFsQXNzZXJ0RXhwb3J0cyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyBudWxsIDoge1xuICAgIGhhc01ldGhvZCxcbiAgICBpc0FycmF5LFxuICAgIGlzSW5zdGFuY2UsXG4gICAgaXNPbmVPZixcbiAgICBpc1R5cGUsXG4gICAgaXNBcnJheU9mQ2xhc3MsXG59O1xuZXhwb3J0IHsgZmluYWxBc3NlcnRFeHBvcnRzIGFzIGFzc2VydCB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG5jb25zdCBfY2FjaGVOYW1lRGV0YWlscyA9IHtcbiAgICBnb29nbGVBbmFseXRpY3M6ICdnb29nbGVBbmFseXRpY3MnLFxuICAgIHByZWNhY2hlOiAncHJlY2FjaGUtdjInLFxuICAgIHByZWZpeDogJ3dvcmtib3gnLFxuICAgIHJ1bnRpbWU6ICdydW50aW1lJyxcbiAgICBzdWZmaXg6IHR5cGVvZiByZWdpc3RyYXRpb24gIT09ICd1bmRlZmluZWQnID8gcmVnaXN0cmF0aW9uLnNjb3BlIDogJycsXG59O1xuY29uc3QgX2NyZWF0ZUNhY2hlTmFtZSA9IChjYWNoZU5hbWUpID0+IHtcbiAgICByZXR1cm4gW19jYWNoZU5hbWVEZXRhaWxzLnByZWZpeCwgY2FjaGVOYW1lLCBfY2FjaGVOYW1lRGV0YWlscy5zdWZmaXhdXG4gICAgICAgIC5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwKVxuICAgICAgICAuam9pbignLScpO1xufTtcbmNvbnN0IGVhY2hDYWNoZU5hbWVEZXRhaWwgPSAoZm4pID0+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhfY2FjaGVOYW1lRGV0YWlscykpIHtcbiAgICAgICAgZm4oa2V5KTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGNhY2hlTmFtZXMgPSB7XG4gICAgdXBkYXRlRGV0YWlsczogKGRldGFpbHMpID0+IHtcbiAgICAgICAgZWFjaENhY2hlTmFtZURldGFpbCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRldGFpbHNba2V5XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBfY2FjaGVOYW1lRGV0YWlsc1trZXldID0gZGV0YWlsc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGdldEdvb2dsZUFuYWx5dGljc05hbWU6ICh1c2VyQ2FjaGVOYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiB1c2VyQ2FjaGVOYW1lIHx8IF9jcmVhdGVDYWNoZU5hbWUoX2NhY2hlTmFtZURldGFpbHMuZ29vZ2xlQW5hbHl0aWNzKTtcbiAgICB9LFxuICAgIGdldFByZWNhY2hlTmFtZTogKHVzZXJDYWNoZU5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHVzZXJDYWNoZU5hbWUgfHwgX2NyZWF0ZUNhY2hlTmFtZShfY2FjaGVOYW1lRGV0YWlscy5wcmVjYWNoZSk7XG4gICAgfSxcbiAgICBnZXRQcmVmaXg6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIF9jYWNoZU5hbWVEZXRhaWxzLnByZWZpeDtcbiAgICB9LFxuICAgIGdldFJ1bnRpbWVOYW1lOiAodXNlckNhY2hlTmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gdXNlckNhY2hlTmFtZSB8fCBfY3JlYXRlQ2FjaGVOYW1lKF9jYWNoZU5hbWVEZXRhaWxzLnJ1bnRpbWUpO1xuICAgIH0sXG4gICAgZ2V0U3VmZml4OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBfY2FjaGVOYW1lRGV0YWlscy5zdWZmaXg7XG4gICAgfSxcbn07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG5jb25zdCBsb2dnZXIgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyA/IG51bGwgOiAoKCkgPT4ge1xuICAgIC8vIERvbid0IG92ZXJ3cml0ZSB0aGlzIHZhbHVlIGlmIGl0J3MgYWxyZWFkeSBzZXQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvd29ya2JveC9wdWxsLzIyODQjaXNzdWVjb21tZW50LTU2MDQ3MDkyM1xuICAgIGlmICghKCdfX1dCX0RJU0FCTEVfREVWX0xPR1MnIGluIHNlbGYpKSB7XG4gICAgICAgIHNlbGYuX19XQl9ESVNBQkxFX0RFVl9MT0dTID0gZmFsc2U7XG4gICAgfVxuICAgIGxldCBpbkdyb3VwID0gZmFsc2U7XG4gICAgY29uc3QgbWV0aG9kVG9Db2xvck1hcCA9IHtcbiAgICAgICAgZGVidWc6IGAjN2Y4YzhkYCxcbiAgICAgICAgbG9nOiBgIzJlY2M3MWAsXG4gICAgICAgIHdhcm46IGAjZjM5YzEyYCxcbiAgICAgICAgZXJyb3I6IGAjYzAzOTJiYCxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGAjMzQ5OGRiYCxcbiAgICAgICAgZ3JvdXBFbmQ6IG51bGwsXG4gICAgfTtcbiAgICBjb25zdCBwcmludCA9IGZ1bmN0aW9uIChtZXRob2QsIGFyZ3MpIHtcbiAgICAgICAgaWYgKHNlbGYuX19XQl9ESVNBQkxFX0RFVl9MT0dTKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ2dyb3VwQ29sbGFwc2VkJykge1xuICAgICAgICAgICAgLy8gU2FmYXJpIGRvZXNuJ3QgcHJpbnQgYWxsIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoKSBhcmd1bWVudHM6XG4gICAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTgyNzU0XG4gICAgICAgICAgICBpZiAoL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGVbbWV0aG9kXSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3R5bGVzID0gW1xuICAgICAgICAgICAgYGJhY2tncm91bmQ6ICR7bWV0aG9kVG9Db2xvck1hcFttZXRob2RdfWAsXG4gICAgICAgICAgICBgYm9yZGVyLXJhZGl1czogMC41ZW1gLFxuICAgICAgICAgICAgYGNvbG9yOiB3aGl0ZWAsXG4gICAgICAgICAgICBgZm9udC13ZWlnaHQ6IGJvbGRgLFxuICAgICAgICAgICAgYHBhZGRpbmc6IDJweCAwLjVlbWAsXG4gICAgICAgIF07XG4gICAgICAgIC8vIFdoZW4gaW4gYSBncm91cCwgdGhlIHdvcmtib3ggcHJlZml4IGlzIG5vdCBkaXNwbGF5ZWQuXG4gICAgICAgIGNvbnN0IGxvZ1ByZWZpeCA9IGluR3JvdXAgPyBbXSA6IFsnJWN3b3JrYm94Jywgc3R5bGVzLmpvaW4oJzsnKV07XG4gICAgICAgIGNvbnNvbGVbbWV0aG9kXSguLi5sb2dQcmVmaXgsIC4uLmFyZ3MpO1xuICAgICAgICBpZiAobWV0aG9kID09PSAnZ3JvdXBDb2xsYXBzZWQnKSB7XG4gICAgICAgICAgICBpbkdyb3VwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kID09PSAnZ3JvdXBFbmQnKSB7XG4gICAgICAgICAgICBpbkdyb3VwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGFwaSA9IHt9O1xuICAgIGNvbnN0IGxvZ2dlck1ldGhvZHMgPSBPYmplY3Qua2V5cyhtZXRob2RUb0NvbG9yTWFwKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBsb2dnZXJNZXRob2RzKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGtleTtcbiAgICAgICAgYXBpW21ldGhvZF0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgcHJpbnQobWV0aG9kLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGFwaTtcbn0pKCkpO1xuZXhwb3J0IHsgbG9nZ2VyIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEEgdXRpbGl0eSBtZXRob2QgdGhhdCBtYWtlcyBpdCBlYXNpZXIgdG8gdXNlIGBldmVudC53YWl0VW50aWxgIHdpdGhcbiAqIGFzeW5jIGZ1bmN0aW9ucyBhbmQgcmV0dXJuIHRoZSByZXN1bHQuXG4gKlxuICogQHBhcmFtIHtFeHRlbmRhYmxlRXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3luY0ZuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHdhaXRVbnRpbChldmVudCwgYXN5bmNGbikge1xuICAgIGNvbnN0IHJldHVyblByb21pc2UgPSBhc3luY0ZuKCk7XG4gICAgZXZlbnQud2FpdFVudGlsKHJldHVyblByb21pc2UpO1xuICAgIHJldHVybiByZXR1cm5Qcm9taXNlO1xufVxuZXhwb3J0IHsgd2FpdFVudGlsIH07XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIEB0cy1pZ25vcmVcbnRyeSB7XG4gICAgc2VsZlsnd29ya2JveDpwcmVjYWNoaW5nOjYuMC4yJ10gJiYgXygpO1xufVxuY2F0Y2ggKGUpIHsgfVxuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgV29ya2JveEVycm9yIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8vIE5hbWUgb2YgdGhlIHNlYXJjaCBwYXJhbWV0ZXIgdXNlZCB0byBzdG9yZSByZXZpc2lvbiBpbmZvLlxuY29uc3QgUkVWSVNJT05fU0VBUkNIX1BBUkFNID0gJ19fV0JfUkVWSVNJT05fXyc7XG4vKipcbiAqIENvbnZlcnRzIGEgbWFuaWZlc3QgZW50cnkgaW50byBhIHZlcnNpb25lZCBVUkwgc3VpdGFibGUgZm9yIHByZWNhY2hpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBlbnRyeVxuICogQHJldHVybiB7c3RyaW5nfSBBIFVSTCB3aXRoIHZlcnNpb25pbmcgaW5mby5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhY2hlS2V5KGVudHJ5KSB7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdhZGQtdG8tY2FjaGUtbGlzdC11bmV4cGVjdGVkLXR5cGUnLCB7IGVudHJ5IH0pO1xuICAgIH1cbiAgICAvLyBJZiBhIHByZWNhY2hlIG1hbmlmZXN0IGVudHJ5IGlzIGEgc3RyaW5nLCBpdCdzIGFzc3VtZWQgdG8gYmUgYSB2ZXJzaW9uZWRcbiAgICAvLyBVUkwsIGxpa2UgJy9hcHAuYWJjZDEyMzQuanMnLiBSZXR1cm4gYXMtaXMuXG4gICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTChlbnRyeSwgbG9jYXRpb24uaHJlZik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYWNoZUtleTogdXJsT2JqZWN0LmhyZWYsXG4gICAgICAgICAgICB1cmw6IHVybE9iamVjdC5ocmVmLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7IHJldmlzaW9uLCB1cmwgfSA9IGVudHJ5O1xuICAgIGlmICghdXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2FkZC10by1jYWNoZS1saXN0LXVuZXhwZWN0ZWQtdHlwZScsIHsgZW50cnkgfSk7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlJ3MganVzdCBhIFVSTCBhbmQgbm8gcmV2aXNpb24sIHRoZW4gaXQncyBhbHNvIGFzc3VtZWQgdG8gYmUgYVxuICAgIC8vIHZlcnNpb25lZCBVUkwuXG4gICAgaWYgKCFyZXZpc2lvbikge1xuICAgICAgICBjb25zdCB1cmxPYmplY3QgPSBuZXcgVVJMKHVybCwgbG9jYXRpb24uaHJlZik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYWNoZUtleTogdXJsT2JqZWN0LmhyZWYsXG4gICAgICAgICAgICB1cmw6IHVybE9iamVjdC5ocmVmLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGNvbnN0cnVjdCBhIHByb3Blcmx5IHZlcnNpb25lZCBVUkwgdXNpbmcgdGhlIGN1c3RvbSBXb3JrYm94XG4gICAgLy8gc2VhcmNoIHBhcmFtZXRlciBhbG9uZyB3aXRoIHRoZSByZXZpc2lvbiBpbmZvLlxuICAgIGNvbnN0IGNhY2hlS2V5VVJMID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLmhyZWYpO1xuICAgIGNvbnN0IG9yaWdpbmFsVVJMID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLmhyZWYpO1xuICAgIGNhY2hlS2V5VVJMLnNlYXJjaFBhcmFtcy5zZXQoUkVWSVNJT05fU0VBUkNIX1BBUkFNLCByZXZpc2lvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2FjaGVLZXk6IGNhY2hlS2V5VVJMLmhyZWYsXG4gICAgICAgIHVybDogb3JpZ2luYWxVUkwuaHJlZixcbiAgICB9O1xufVxuIiwiLypcbiAgQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEEgcGx1Z2luLCBkZXNpZ25lZCB0byBiZSB1c2VkIHdpdGggUHJlY2FjaGVDb250cm9sbGVyLCB0byBkZXRlcm1pbmUgdGhlXG4gKiBvZiBhc3NldHMgdGhhdCB3ZXJlIHVwZGF0ZWQgKG9yIG5vdCB1cGRhdGVkKSBkdXJpbmcgdGhlIGluc3RhbGwgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUHJlY2FjaGVJbnN0YWxsUmVwb3J0UGx1Z2luIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy51cGRhdGVkVVJMcyA9IFtdO1xuICAgICAgICB0aGlzLm5vdFVwZGF0ZWRVUkxzID0gW107XG4gICAgICAgIHRoaXMuaGFuZGxlcldpbGxTdGFydCA9IGFzeW5jICh7IHJlcXVlc3QsIHN0YXRlLCB9KSA9PiB7XG4gICAgICAgICAgICAvLyBUT0RPOiBgc3RhdGVgIHNob3VsZCBuZXZlciBiZSB1bmRlZmluZWQuLi5cbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLm9yaWdpbmFsUmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2FjaGVkUmVzcG9uc2VXaWxsQmVVc2VkID0gYXN5bmMgKHsgZXZlbnQsIHN0YXRlLCBjYWNoZWRSZXNwb25zZSwgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdpbnN0YWxsJykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGBzdGF0ZWAgc2hvdWxkIG5ldmVyIGJlIHVuZGVmaW5lZC4uLlxuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IHN0YXRlLm9yaWdpbmFsUmVxdWVzdC51cmw7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90VXBkYXRlZFVSTHMucHVzaCh1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVkVVJMcy5wdXNoKHVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3BvbnNlO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCB7IFByZWNhY2hlSW5zdGFsbFJlcG9ydFBsdWdpbiB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEEgcGx1Z2luLCBkZXNpZ25lZCB0byBiZSB1c2VkIHdpdGggUHJlY2FjaGVDb250cm9sbGVyLCB0byB0cmFuc2xhdGUgVVJMcyBpbnRvXG4gKiB0aGUgY29ycmVzcG9uZGluZyBjYWNoZSBrZXksIGJhc2VkIG9uIHRoZSBjdXJyZW50IHJldmlzaW9uIGluZm8uXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUHJlY2FjaGVDYWNoZUtleVBsdWdpbiB7XG4gICAgY29uc3RydWN0b3IoeyBwcmVjYWNoZUNvbnRyb2xsZXIgfSkge1xuICAgICAgICB0aGlzLmNhY2hlS2V5V2lsbEJlVXNlZCA9IGFzeW5jICh7IHJlcXVlc3QsIHBhcmFtcywgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBwYXJhbXMgJiYgcGFyYW1zLmNhY2hlS2V5IHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJlY2FjaGVDb250cm9sbGVyLmdldENhY2hlS2V5Rm9yVVJMKHJlcXVlc3QudXJsKTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZUtleSA/IG5ldyBSZXF1ZXN0KGNhY2hlS2V5KSA6IHJlcXVlc3Q7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ByZWNhY2hlQ29udHJvbGxlciA9IHByZWNhY2hlQ29udHJvbGxlcjtcbiAgICB9XG59XG5leHBvcnQgeyBQcmVjYWNoZUNhY2hlS2V5UGx1Z2luIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBUaXRsZVxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBkZWxldGVkVVJMc1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGxvZ0dyb3VwID0gKGdyb3VwVGl0bGUsIGRlbGV0ZWRVUkxzKSA9PiB7XG4gICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGdyb3VwVGl0bGUpO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIGRlbGV0ZWRVUkxzKSB7XG4gICAgICAgIGxvZ2dlci5sb2codXJsKTtcbiAgICB9XG4gICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGRlbGV0ZWRVUkxzXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmludENsZWFudXBEZXRhaWxzKGRlbGV0ZWRVUkxzKSB7XG4gICAgY29uc3QgZGVsZXRpb25Db3VudCA9IGRlbGV0ZWRVUkxzLmxlbmd0aDtcbiAgICBpZiAoZGVsZXRpb25Db3VudCA+IDApIHtcbiAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBEdXJpbmcgcHJlY2FjaGluZyBjbGVhbnVwLCBgICtcbiAgICAgICAgICAgIGAke2RlbGV0aW9uQ291bnR9IGNhY2hlZCBgICtcbiAgICAgICAgICAgIGByZXF1ZXN0JHtkZWxldGlvbkNvdW50ID09PSAxID8gJyB3YXMnIDogJ3Mgd2VyZSd9IGRlbGV0ZWQuYCk7XG4gICAgICAgIGxvZ0dyb3VwKCdEZWxldGVkIENhY2hlIFJlcXVlc3RzJywgZGVsZXRlZFVSTHMpO1xuICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICB9XG59XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBUaXRsZVxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB1cmxzXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX25lc3RlZEdyb3VwKGdyb3VwVGl0bGUsIHVybHMpIHtcbiAgICBpZiAodXJscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoZ3JvdXBUaXRsZSk7XG4gICAgZm9yIChjb25zdCB1cmwgb2YgdXJscykge1xuICAgICAgICBsb2dnZXIubG9nKHVybCk7XG4gICAgfVxuICAgIGxvZ2dlci5ncm91cEVuZCgpO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHVybHNUb1ByZWNhY2hlXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHVybHNBbHJlYWR5UHJlY2FjaGVkXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmludEluc3RhbGxEZXRhaWxzKHVybHNUb1ByZWNhY2hlLCB1cmxzQWxyZWFkeVByZWNhY2hlZCkge1xuICAgIGNvbnN0IHByZWNhY2hlZENvdW50ID0gdXJsc1RvUHJlY2FjaGUubGVuZ3RoO1xuICAgIGNvbnN0IGFscmVhZHlQcmVjYWNoZWRDb3VudCA9IHVybHNBbHJlYWR5UHJlY2FjaGVkLmxlbmd0aDtcbiAgICBpZiAocHJlY2FjaGVkQ291bnQgfHwgYWxyZWFkeVByZWNhY2hlZENvdW50KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gYFByZWNhY2hpbmcgJHtwcmVjYWNoZWRDb3VudH0gZmlsZSR7cHJlY2FjaGVkQ291bnQgPT09IDEgPyAnJyA6ICdzJ30uYDtcbiAgICAgICAgaWYgKGFscmVhZHlQcmVjYWNoZWRDb3VudCA+IDApIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYCAke2FscmVhZHlQcmVjYWNoZWRDb3VudH0gYCArXG4gICAgICAgICAgICAgICAgYGZpbGUke2FscmVhZHlQcmVjYWNoZWRDb3VudCA9PT0gMSA/ICcgaXMnIDogJ3MgYXJlJ30gYWxyZWFkeSBjYWNoZWQuYDtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQobWVzc2FnZSk7XG4gICAgICAgIF9uZXN0ZWRHcm91cChgVmlldyBuZXdseSBwcmVjYWNoZWQgVVJMcy5gLCB1cmxzVG9QcmVjYWNoZSk7XG4gICAgICAgIF9uZXN0ZWRHcm91cChgVmlldyBwcmV2aW91c2x5IHByZWNhY2hlZCBVUkxzLmAsIHVybHNBbHJlYWR5UHJlY2FjaGVkKTtcbiAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgfVxufVxuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG5sZXQgc3VwcG9ydFN0YXR1cztcbi8qKlxuICogQSB1dGlsaXR5IGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHNcbiAqIGNvbnN0cnVjdGluZyBhIG5ldyBgUmVzcG9uc2VgIGZyb20gYSBgcmVzcG9uc2UuYm9keWAgc3RyZWFtLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCwgaWYgdGhlIGN1cnJlbnQgYnJvd3NlciBjYW4gc3VjY2Vzc2Z1bGx5XG4gKiAgICAgY29uc3RydWN0IGEgYFJlc3BvbnNlYCBmcm9tIGEgYHJlc3BvbnNlLmJvZHlgIHN0cmVhbSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2FuQ29uc3RydWN0UmVzcG9uc2VGcm9tQm9keVN0cmVhbSgpIHtcbiAgICBpZiAoc3VwcG9ydFN0YXR1cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRlc3RSZXNwb25zZSA9IG5ldyBSZXNwb25zZSgnJyk7XG4gICAgICAgIGlmICgnYm9keScgaW4gdGVzdFJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ldyBSZXNwb25zZSh0ZXN0UmVzcG9uc2UuYm9keSk7XG4gICAgICAgICAgICAgICAgc3VwcG9ydFN0YXR1cyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzdXBwb3J0U3RhdHVzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwcG9ydFN0YXR1cyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwcG9ydFN0YXR1cztcbn1cbmV4cG9ydCB7IGNhbkNvbnN0cnVjdFJlc3BvbnNlRnJvbUJvZHlTdHJlYW0gfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGNhbkNvbnN0cnVjdFJlc3BvbnNlRnJvbUJvZHlTdHJlYW0gfSBmcm9tICcuL19wcml2YXRlL2NhbkNvbnN0cnVjdFJlc3BvbnNlRnJvbUJvZHlTdHJlYW0uanMnO1xuaW1wb3J0IHsgV29ya2JveEVycm9yIH0gZnJvbSAnLi9fcHJpdmF0ZS9Xb3JrYm94RXJyb3IuanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogQWxsb3dzIGRldmVsb3BlcnMgdG8gY29weSBhIHJlc3BvbnNlIGFuZCBtb2RpZnkgaXRzIGBoZWFkZXJzYCwgYHN0YXR1c2AsXG4gKiBvciBgc3RhdHVzVGV4dGAgdmFsdWVzICh0aGUgdmFsdWVzIHNldHRhYmxlIHZpYSBhXG4gKiBbYFJlc3BvbnNlSW5pdGBde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SZXNwb25zZS9SZXNwb25zZSNTeW50YXh9XG4gKiBvYmplY3QgaW4gdGhlIGNvbnN0cnVjdG9yKS5cbiAqIFRvIG1vZGlmeSB0aGVzZSB2YWx1ZXMsIHBhc3MgYSBmdW5jdGlvbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LiBUaGF0XG4gKiBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgd2l0aCBhIHNpbmdsZSBvYmplY3Qgd2l0aCB0aGUgcmVzcG9uc2UgcHJvcGVydGllc1xuICogYHtoZWFkZXJzLCBzdGF0dXMsIHN0YXR1c1RleHR9YC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIHdpbGxcbiAqIGJlIHVzZWQgYXMgdGhlIGBSZXNwb25zZUluaXRgIGZvciB0aGUgbmV3IGBSZXNwb25zZWAuIFRvIGNoYW5nZSB0aGUgdmFsdWVzXG4gKiBlaXRoZXIgbW9kaWZ5IHRoZSBwYXNzZWQgcGFyYW1ldGVyKHMpIGFuZCByZXR1cm4gaXQsIG9yIHJldHVybiBhIHRvdGFsbHlcbiAqIG5ldyBvYmplY3QuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgaW50ZW50aW9uYWxseSBsaW1pdGVkIHRvIHNhbWUtb3JpZ2luIHJlc3BvbnNlcywgcmVnYXJkbGVzcyBvZlxuICogd2hldGhlciBDT1JTIHdhcyB1c2VkIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNwb25zZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXJcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1jb3JlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvcHlSZXNwb25zZShyZXNwb25zZSwgbW9kaWZpZXIpIHtcbiAgICBsZXQgb3JpZ2luID0gbnVsbDtcbiAgICAvLyBJZiByZXNwb25zZS51cmwgaXNuJ3Qgc2V0LCBhc3N1bWUgaXQncyBjcm9zcy1vcmlnaW4gYW5kIGtlZXAgb3JpZ2luIG51bGwuXG4gICAgaWYgKHJlc3BvbnNlLnVybCkge1xuICAgICAgICBjb25zdCByZXNwb25zZVVSTCA9IG5ldyBVUkwocmVzcG9uc2UudXJsKTtcbiAgICAgICAgb3JpZ2luID0gcmVzcG9uc2VVUkwub3JpZ2luO1xuICAgIH1cbiAgICBpZiAob3JpZ2luICE9PSBzZWxmLmxvY2F0aW9uLm9yaWdpbikge1xuICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdjcm9zcy1vcmlnaW4tY29weS1yZXNwb25zZScsIHsgb3JpZ2luIH0pO1xuICAgIH1cbiAgICBjb25zdCBjbG9uZWRSZXNwb25zZSA9IHJlc3BvbnNlLmNsb25lKCk7XG4gICAgLy8gQ3JlYXRlIGEgZnJlc2ggYFJlc3BvbnNlSW5pdGAgb2JqZWN0IGJ5IGNsb25pbmcgdGhlIGhlYWRlcnMuXG4gICAgY29uc3QgcmVzcG9uc2VJbml0ID0ge1xuICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhjbG9uZWRSZXNwb25zZS5oZWFkZXJzKSxcbiAgICAgICAgc3RhdHVzOiBjbG9uZWRSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IGNsb25lZFJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgfTtcbiAgICAvLyBBcHBseSBhbnkgdXNlciBtb2RpZmljYXRpb25zLlxuICAgIGNvbnN0IG1vZGlmaWVkUmVzcG9uc2VJbml0ID0gbW9kaWZpZXIgPyBtb2RpZmllcihyZXNwb25zZUluaXQpIDogcmVzcG9uc2VJbml0O1xuICAgIC8vIENyZWF0ZSB0aGUgbmV3IHJlc3BvbnNlIGZyb20gdGhlIGJvZHkgc3RyZWFtIGFuZCBgUmVzcG9uc2VJbml0YFxuICAgIC8vIG1vZGlmaWNhdGlvbnMuIE5vdGU6IG5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB0aGUgUmVzcG9uc2UuYm9keSBzdHJlYW0sXG4gICAgLy8gc28gZmFsbCBiYWNrIHRvIHJlYWRpbmcgdGhlIGVudGlyZSBib2R5IGludG8gbWVtb3J5IGFzIGEgYmxvYi5cbiAgICBjb25zdCBib2R5ID0gY2FuQ29uc3RydWN0UmVzcG9uc2VGcm9tQm9keVN0cmVhbSgpID9cbiAgICAgICAgY2xvbmVkUmVzcG9uc2UuYm9keSA6IGF3YWl0IGNsb25lZFJlc3BvbnNlLmJsb2IoKTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHksIG1vZGlmaWVkUmVzcG9uc2VJbml0KTtcbn1cbmV4cG9ydCB7IGNvcHlSZXNwb25zZSB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG5jb25zdCBnZXRGcmllbmRseVVSTCA9ICh1cmwpID0+IHtcbiAgICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKFN0cmluZyh1cmwpLCBsb2NhdGlvbi5ocmVmKTtcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8yMzIzXG4gICAgLy8gV2Ugd2FudCB0byBpbmNsdWRlIGV2ZXJ5dGhpbmcsIGV4Y2VwdCBmb3IgdGhlIG9yaWdpbiBpZiBpdCdzIHNhbWUtb3JpZ2luLlxuICAgIHJldHVybiB1cmxPYmouaHJlZi5yZXBsYWNlKG5ldyBSZWdFeHAoYF4ke2xvY2F0aW9uLm9yaWdpbn1gKSwgJycpO1xufTtcbmV4cG9ydCB7IGdldEZyaWVuZGx5VVJMIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG5mdW5jdGlvbiBzdHJpcFBhcmFtcyhmdWxsVVJMLCBpZ25vcmVQYXJhbXMpIHtcbiAgICBjb25zdCBzdHJpcHBlZFVSTCA9IG5ldyBVUkwoZnVsbFVSTCk7XG4gICAgZm9yIChjb25zdCBwYXJhbSBvZiBpZ25vcmVQYXJhbXMpIHtcbiAgICAgICAgc3RyaXBwZWRVUkwuc2VhcmNoUGFyYW1zLmRlbGV0ZShwYXJhbSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpcHBlZFVSTC5ocmVmO1xufVxuLyoqXG4gKiBNYXRjaGVzIGFuIGl0ZW0gaW4gdGhlIGNhY2hlLCBpZ25vcmluZyBzcGVjaWZpYyBVUkwgcGFyYW1zLiBUaGlzIGlzIHNpbWlsYXJcbiAqIHRvIHRoZSBgaWdub3JlU2VhcmNoYCBvcHRpb24sIGJ1dCBpdCBhbGxvd3MgeW91IHRvIGlnbm9yZSBqdXN0IHNwZWNpZmljXG4gKiBwYXJhbXMgKHdoaWxlIGNvbnRpbnVpbmcgdG8gbWF0Y2ggb24gdGhlIG90aGVycykuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Q2FjaGV9IGNhY2hlXG4gKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRjaE9wdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gaWdub3JlUGFyYW1zXG4gKiBAcmV0dXJuIHtQcm9taXNlPFJlc3BvbnNlfHVuZGVmaW5lZD59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNhY2hlTWF0Y2hJZ25vcmVQYXJhbXMoY2FjaGUsIHJlcXVlc3QsIGlnbm9yZVBhcmFtcywgbWF0Y2hPcHRpb25zKSB7XG4gICAgY29uc3Qgc3RyaXBwZWRSZXF1ZXN0VVJMID0gc3RyaXBQYXJhbXMocmVxdWVzdC51cmwsIGlnbm9yZVBhcmFtcyk7XG4gICAgLy8gSWYgdGhlIHJlcXVlc3QgZG9lc24ndCBpbmNsdWRlIGFueSBpZ25vcmVkIHBhcmFtcywgbWF0Y2ggYXMgbm9ybWFsLlxuICAgIGlmIChyZXF1ZXN0LnVybCA9PT0gc3RyaXBwZWRSZXF1ZXN0VVJMKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5tYXRjaChyZXF1ZXN0LCBtYXRjaE9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIG1hdGNoIGJ5IGNvbXBhcmluZyBrZXlzXG4gICAgY29uc3Qga2V5c09wdGlvbnMgPSB7IC4uLm1hdGNoT3B0aW9ucywgaWdub3JlU2VhcmNoOiB0cnVlIH07XG4gICAgY29uc3QgY2FjaGVLZXlzID0gYXdhaXQgY2FjaGUua2V5cyhyZXF1ZXN0LCBrZXlzT3B0aW9ucyk7XG4gICAgZm9yIChjb25zdCBjYWNoZUtleSBvZiBjYWNoZUtleXMpIHtcbiAgICAgICAgY29uc3Qgc3RyaXBwZWRDYWNoZUtleVVSTCA9IHN0cmlwUGFyYW1zKGNhY2hlS2V5LnVybCwgaWdub3JlUGFyYW1zKTtcbiAgICAgICAgaWYgKHN0cmlwcGVkUmVxdWVzdFVSTCA9PT0gc3RyaXBwZWRDYWNoZUtleVVSTCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlLm1hdGNoKGNhY2hlS2V5LCBtYXRjaE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbn1cbmV4cG9ydCB7IGNhY2hlTWF0Y2hJZ25vcmVQYXJhbXMgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBUaGUgRGVmZXJyZWQgY2xhc3MgY29tcG9zZXMgUHJvbWlzZXMgaW4gYSB3YXkgdGhhdCBhbGxvd3MgZm9yIHRoZW0gdG8gYmVcbiAqIHJlc29sdmVkIG9yIHJlamVjdGVkIGZyb20gb3V0c2lkZSB0aGUgY29uc3RydWN0b3IuIEluIG1vc3QgY2FzZXMgcHJvbWlzZXNcbiAqIHNob3VsZCBiZSB1c2VkIGRpcmVjdGx5LCBidXQgRGVmZXJyZWRzIGNhbiBiZSBuZWNlc3Nhcnkgd2hlbiB0aGUgbG9naWMgdG9cbiAqIHJlc29sdmUgYSBwcm9taXNlIG11c3QgYmUgc2VwYXJhdGUuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgRGVmZXJyZWQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwcm9taXNlIGFuZCBleHBvc2VzIGl0cyByZXNvbHZlIGFuZCByZWplY3QgZnVuY3Rpb25zIGFzIG1ldGhvZHMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IHsgRGVmZXJyZWQgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLy8gQ2FsbGJhY2tzIHRvIGJlIGV4ZWN1dGVkIHdoZW5ldmVyIHRoZXJlJ3MgYSBxdW90YSBlcnJvci5cbmNvbnN0IHF1b3RhRXJyb3JDYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5leHBvcnQgeyBxdW90YUVycm9yQ2FsbGJhY2tzIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi9fcHJpdmF0ZS9sb2dnZXIuanMnO1xuaW1wb3J0IHsgcXVvdGFFcnJvckNhbGxiYWNrcyB9IGZyb20gJy4uL21vZGVscy9xdW90YUVycm9yQ2FsbGJhY2tzLmpzJztcbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBSdW5zIGFsbCBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zLCBvbmUgYXQgYSB0aW1lIHNlcXVlbnRpYWxseSwgaW4gdGhlIG9yZGVyXG4gKiBpbiB3aGljaCB0aGV5IHdlcmUgcmVnaXN0ZXJlZC5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtY29yZVxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZVF1b3RhRXJyb3JDYWxsYmFja3MoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgQWJvdXQgdG8gcnVuICR7cXVvdGFFcnJvckNhbGxiYWNrcy5zaXplfSBgICtcbiAgICAgICAgICAgIGBjYWxsYmFja3MgdG8gY2xlYW4gdXAgY2FjaGVzLmApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHF1b3RhRXJyb3JDYWxsYmFja3MpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2soKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coY2FsbGJhY2ssICdpcyBjb21wbGV0ZS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBsb2dnZXIubG9nKCdGaW5pc2hlZCBydW5uaW5nIGNhbGxiYWNrcy4nKTtcbiAgICB9XG59XG5leHBvcnQgeyBleGVjdXRlUXVvdGFFcnJvckNhbGxiYWNrcyB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFuZCB0aGUgcGFzc2VkIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gKiBUaGlzIHV0aWxpdHkgaXMgYW4gYXN5bmMvYXdhaXQtZnJpZW5kbHkgdmVyc2lvbiBvZiBgc2V0VGltZW91dGAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVvdXQobXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gQHRzLWlnbm9yZVxudHJ5IHtcbiAgICBzZWxmWyd3b3JrYm94OnN0cmF0ZWdpZXM6Ni4wLjInXSAmJiBfKCk7XG59XG5jYXRjaCAoZSkgeyB9XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzJztcbmltcG9ydCB7IGNhY2hlTWF0Y2hJZ25vcmVQYXJhbXMgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvY2FjaGVNYXRjaElnbm9yZVBhcmFtcy5qcyc7XG5pbXBvcnQgeyBEZWZlcnJlZCB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9EZWZlcnJlZC5qcyc7XG5pbXBvcnQgeyBleGVjdXRlUXVvdGFFcnJvckNhbGxiYWNrcyB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9leGVjdXRlUXVvdGFFcnJvckNhbGxiYWNrcy5qcyc7XG5pbXBvcnQgeyBnZXRGcmllbmRseVVSTCB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9nZXRGcmllbmRseVVSTC5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IHRpbWVvdXQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvdGltZW91dC5qcyc7XG5pbXBvcnQgeyBXb3JrYm94RXJyb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG5mdW5jdGlvbiB0b1JlcXVlc3QoaW5wdXQpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpID8gbmV3IFJlcXVlc3QoaW5wdXQpIDogaW5wdXQ7XG59XG4vKipcbiAqIEEgY2xhc3MgY3JlYXRlZCBldmVyeSB0aW1lIGEgU3RyYXRlZ3kgaW5zdGFuY2UgaW5zdGFuY2UgY2FsbHNcbiAqIFtoYW5kbGUoKV17QGxpbmsgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneX5oYW5kbGV9IG9yXG4gKiBbaGFuZGxlQWxsKClde0BsaW5rIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3l+aGFuZGxlQWxsfSB0aGF0IHdyYXBzIGFsbCBmZXRjaCBhbmRcbiAqIGNhY2hlIGFjdGlvbnMgYXJvdW5kIHBsdWdpbiBjYWxsYmFja3MgYW5kIGtlZXBzIHRyYWNrIG9mIHdoZW4gdGhlIHN0cmF0ZWd5XG4gKiBpcyBcImRvbmVcIiAoaS5lLiBhbGwgYWRkZWQgYGV2ZW50LndhaXRVbnRpbCgpYCBwcm9taXNlcyBoYXZlIHJlc29sdmVkKS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llc1xuICovXG5jbGFzcyBTdHJhdGVneUhhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBwYXNzZWQgc3RyYXRlZ3kgYW5kIGV2ZW50XG4gICAgICogdGhhdCdzIGhhbmRsaW5nIHRoZSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIGFsc28gaW5pdGlhbGl6ZXMgdGhlIHN0YXRlIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gZWFjaCBvZlxuICAgICAqIHRoZSBwbHVnaW5zIGhhbmRsaW5nIHRoaXMgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneX0gc3RyYXRlZ3lcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7UmVxdWVzdHxzdHJpbmd9IG9wdGlvbnMucmVxdWVzdCBBIHJlcXVlc3QgdG8gcnVuIHRoaXMgc3RyYXRlZ3kgZm9yLlxuICAgICAqIEBwYXJhbSB7RXh0ZW5kYWJsZUV2ZW50fSBvcHRpb25zLmV2ZW50IFRoZSBldmVudCBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgICogICAgIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHtVUkx9IFtvcHRpb25zLnVybF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLnBhcmFtc11cbiAgICAgKiAgICAgW21hdGNoIGNhbGxiYWNrXXtAbGluayBtb2R1bGU6d29ya2JveC1yb3V0aW5nfm1hdGNoQ2FsbGJhY2t9LFxuICAgICAqICAgICAoaWYgYXBwbGljYWJsZSkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RyYXRlZ3ksIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVLZXlzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVxdWVzdCB0aGUgc3RyYXRlZ3kgaXMgcGVyZm9ybWluZyAocGFzc2VkIHRvIHRoZSBzdHJhdGVneSdzXG4gICAgICAgICAqIGBoYW5kbGUoKWAgb3IgYGhhbmRsZUFsbCgpYCBtZXRob2QpLlxuICAgICAgICAgKiBAbmFtZSByZXF1ZXN0XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7UmVxdWVzdH1cbiAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3lIYW5kbGVyXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGV2ZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJlcXVlc3QuXG4gICAgICAgICAqIEBuYW1lIGV2ZW50XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7RXh0ZW5kYWJsZUV2ZW50fVxuICAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneUhhbmRsZXJcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGBVUkxgIGluc3RhbmNlIG9mIGByZXF1ZXN0LnVybGAgKGlmIHBhc3NlZCB0byB0aGUgc3RyYXRlZ3knc1xuICAgICAgICAgKiBgaGFuZGxlKClgIG9yIGBoYW5kbGVBbGwoKWAgbWV0aG9kKS5cbiAgICAgICAgICogTm90ZTogdGhlIGB1cmxgIHBhcmFtIHdpbGwgYmUgcHJlc2VudCBpZiB0aGUgc3RyYXRlZ3kgd2FzIGludm9rZWRcbiAgICAgICAgICogZnJvbSBhIHdvcmtib3ggYFJvdXRlYCBvYmplY3QuXG4gICAgICAgICAqIEBuYW1lIHVybFxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUge1VSTHx1bmRlZmluZWR9XG4gICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5SGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYHBhcmFtYCB2YWx1ZSAoaWYgcGFzc2VkIHRvIHRoZSBzdHJhdGVneSdzXG4gICAgICAgICAqIGBoYW5kbGUoKWAgb3IgYGhhbmRsZUFsbCgpYCBtZXRob2QpLlxuICAgICAgICAgKiBOb3RlOiB0aGUgYHBhcmFtYCBwYXJhbSB3aWxsIGJlIHByZXNlbnQgaWYgdGhlIHN0cmF0ZWd5IHdhcyBpbnZva2VkXG4gICAgICAgICAqIGZyb20gYSB3b3JrYm94IGBSb3V0ZWAgb2JqZWN0IGFuZCB0aGVcbiAgICAgICAgICogW21hdGNoIGNhbGxiYWNrXXtAbGluayBtb2R1bGU6d29ya2JveC1yb3V0aW5nfm1hdGNoQ2FsbGJhY2t9IHJldHVybmVkXG4gICAgICAgICAqIGEgdHJ1dGh5IHZhbHVlIChpdCB3aWxsIGJlIHRoYXQgdmFsdWUpLlxuICAgICAgICAgKiBAbmFtZSBwYXJhbXNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHsqfHVuZGVmaW5lZH1cbiAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3lIYW5kbGVyXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgYXNzZXJ0LmlzSW5zdGFuY2Uob3B0aW9ucy5ldmVudCwgRXh0ZW5kYWJsZUV2ZW50LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtc3RyYXRlZ2llcycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnU3RyYXRlZ3lIYW5kbGVyJyxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdvcHRpb25zLmV2ZW50JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZXZlbnQgPSBvcHRpb25zLmV2ZW50O1xuICAgICAgICB0aGlzLl9zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICB0aGlzLl9oYW5kbGVyRGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5fZXh0ZW5kTGlmZXRpbWVQcm9taXNlcyA9IFtdO1xuICAgICAgICAvLyBDb3B5IHRoZSBwbHVnaW5zIGxpc3QgKHNpbmNlIGl0J3MgbXV0YWJsZSBvbiB0aGUgc3RyYXRlZ3kpLFxuICAgICAgICAvLyBzbyBhbnkgbXV0YXRpb25zIGRvbid0IGFmZmVjdCB0aGlzIGhhbmRsZXIgaW5zdGFuY2UuXG4gICAgICAgIHRoaXMuX3BsdWdpbnMgPSBbLi4uc3RyYXRlZ3kucGx1Z2luc107XG4gICAgICAgIHRoaXMuX3BsdWdpblN0YXRlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLl9wbHVnaW5zKSB7XG4gICAgICAgICAgICB0aGlzLl9wbHVnaW5TdGF0ZU1hcC5zZXQocGx1Z2luLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudC53YWl0VW50aWwodGhpcy5faGFuZGxlckRlZmVycmVkLnByb21pc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgZ2l2ZW4gcmVxdWVzdCAoYW5kIGludm9rZXMgYW55IGFwcGxpY2FibGUgcGx1Z2luIGNhbGxiYWNrXG4gICAgICogbWV0aG9kcykgdXNpbmcgdGhlIGBmZXRjaE9wdGlvbnNgIGFuZCBgcGx1Z2luc2AgZGVmaW5lZCBvbiB0aGUgc3RyYXRlZ3lcbiAgICAgKiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIHBsdWdpbiBsaWZlY3ljbGUgbWV0aG9kcyBhcmUgaW52b2tlZCB3aGVuIHVzaW5nIHRoaXMgbWV0aG9kOlxuICAgICAqIC0gYHJlcXVlc3RXaWxsRmV0Y2goKWBcbiAgICAgKiAtIGBmZXRjaERpZFN1Y2NlZWQoKWBcbiAgICAgKiAtIGBmZXRjaERpZEZhaWwoKWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVxdWVzdHxzdHJpbmd9IGlucHV0IFRoZSBVUkwgb3IgcmVxdWVzdCB0byBmZXRjaC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJlc3BvbnNlPn1cbiAgICAgKi9cbiAgICBmZXRjaChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy53YWl0VW50aWwoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZXZlbnQgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdCA9IHRvUmVxdWVzdChpbnB1dCk7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5tb2RlID09PSAnbmF2aWdhdGUnICYmXG4gICAgICAgICAgICAgICAgZXZlbnQgaW5zdGFuY2VvZiBGZXRjaEV2ZW50ICYmXG4gICAgICAgICAgICAgICAgZXZlbnQucHJlbG9hZFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zc2libGVQcmVsb2FkUmVzcG9uc2UgPSBhd2FpdCBldmVudC5wcmVsb2FkUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlUHJlbG9hZFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBVc2luZyBhIHByZWxvYWRlZCBuYXZpZ2F0aW9uIHJlc3BvbnNlIGZvciBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJyR7Z2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpfSdgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zc2libGVQcmVsb2FkUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBmZXRjaERpZEZhaWwgcGx1Z2luLCB3ZSBuZWVkIHRvIHNhdmUgYSBjbG9uZSBvZiB0aGVcbiAgICAgICAgICAgIC8vIG9yaWdpbmFsIHJlcXVlc3QgYmVmb3JlIGl0J3MgZWl0aGVyIG1vZGlmaWVkIGJ5IGEgcmVxdWVzdFdpbGxGZXRjaFxuICAgICAgICAgICAgLy8gcGx1Z2luIG9yIGJlZm9yZSB0aGUgb3JpZ2luYWwgcmVxdWVzdCdzIGJvZHkgaXMgY29uc3VtZWQgdmlhIGZldGNoKCkuXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFJlcXVlc3QgPSB0aGlzLmhhc0NhbGxiYWNrKCdmZXRjaERpZEZhaWwnKSA/XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jbG9uZSgpIDogbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYiBvZiB0aGlzLml0ZXJhdGVDYWxsYmFja3MoJ3JlcXVlc3RXaWxsRmV0Y2gnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ID0gYXdhaXQgY2IoeyByZXF1ZXN0OiByZXF1ZXN0LmNsb25lKCksIGV2ZW50IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdwbHVnaW4tZXJyb3ItcmVxdWVzdC13aWxsLWZldGNoJywge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd25FcnJvcjogZXJyLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3QgY2FuIGJlIGFsdGVyZWQgYnkgcGx1Z2lucyB3aXRoIGByZXF1ZXN0V2lsbEZldGNoYCBtYWtpbmdcbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCByZXF1ZXN0IChtb3N0IGxpa2VseSBmcm9tIGEgYGZldGNoYCBldmVudCkgZGlmZmVyZW50XG4gICAgICAgICAgICAvLyBmcm9tIHRoZSBSZXF1ZXN0IHdlIG1ha2UuIFBhc3MgYm90aCB0byBgZmV0Y2hEaWRGYWlsYCB0byBhaWQgZGVidWdnaW5nLlxuICAgICAgICAgICAgY29uc3QgcGx1Z2luRmlsdGVyZWRSZXF1ZXN0ID0gcmVxdWVzdC5jbG9uZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgZmV0Y2hSZXNwb25zZTtcbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8xNzk2XG4gICAgICAgICAgICAgICAgZmV0Y2hSZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QsIHJlcXVlc3QubW9kZSA9PT0gJ25hdmlnYXRlJyA/XG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6IHRoaXMuX3N0cmF0ZWd5LmZldGNoT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBOZXR3b3JrIHJlcXVlc3QgZm9yIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCcke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0nIHJldHVybmVkIGEgcmVzcG9uc2Ugd2l0aCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBzdGF0dXMgJyR7ZmV0Y2hSZXNwb25zZS5zdGF0dXN9Jy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiB0aGlzLml0ZXJhdGVDYWxsYmFja3MoJ2ZldGNoRGlkU3VjY2VlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHBsdWdpbkZpbHRlcmVkUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBmZXRjaFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoUmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5ldHdvcmsgcmVxdWVzdCBmb3IgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgJyR7Z2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpfScgdGhyZXcgYW4gZXJyb3IuYCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBgb3JpZ2luYWxSZXF1ZXN0YCB3aWxsIG9ubHkgZXhpc3QgaWYgYSBgZmV0Y2hEaWRGYWlsYCBjYWxsYmFja1xuICAgICAgICAgICAgICAgIC8vIGlzIGJlaW5nIHVzZWQgKHNlZSBhYm92ZSkuXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJ1bkNhbGxiYWNrcygnZmV0Y2hEaWRGYWlsJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsUmVxdWVzdDogb3JpZ2luYWxSZXF1ZXN0LmNsb25lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBwbHVnaW5GaWx0ZXJlZFJlcXVlc3QuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgYHRoaXMuZmV0Y2goKWAgYW5kIChpbiB0aGUgYmFja2dyb3VuZCkgcnVucyBgdGhpcy5jYWNoZVB1dCgpYCBvblxuICAgICAqIHRoZSByZXNwb25zZSBnZW5lcmF0ZWQgYnkgYHRoaXMuZmV0Y2goKWAuXG4gICAgICpcbiAgICAgKiBUaGUgY2FsbCB0byBgdGhpcy5jYWNoZVB1dCgpYCBhdXRvbWF0aWNhbGx5IGludm9rZXMgYHRoaXMud2FpdFVudGlsKClgLFxuICAgICAqIHNvIHlvdSBkbyBub3QgaGF2ZSB0byBtYW51YWxseSBjYWxsIGB3YWl0VW50aWwoKWAgb24gdGhlIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fHN0cmluZ30gaW5wdXQgVGhlIHJlcXVlc3Qgb3IgVVJMIHRvIGZldGNoIGFuZCBjYWNoZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJlc3BvbnNlPn1cbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaEFuZENhY2hlUHV0KGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaChpbnB1dCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlQ2xvbmUgPSByZXNwb25zZS5jbG9uZSgpO1xuICAgICAgICB0aGlzLndhaXRVbnRpbCh0aGlzLmNhY2hlUHV0KGlucHV0LCByZXNwb25zZUNsb25lKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyBhIHJlcXVlc3QgZnJvbSB0aGUgY2FjaGUgKGFuZCBpbnZva2VzIGFueSBhcHBsaWNhYmxlIHBsdWdpblxuICAgICAqIGNhbGxiYWNrIG1ldGhvZHMpIHVzaW5nIHRoZSBgY2FjaGVOYW1lYCwgYG1hdGNoT3B0aW9uc2AsIGFuZCBgcGx1Z2luc2BcbiAgICAgKiBkZWZpbmVkIG9uIHRoZSBzdHJhdGVneSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIHBsdWdpbiBsaWZlY3ljbGUgbWV0aG9kcyBhcmUgaW52b2tlZCB3aGVuIHVzaW5nIHRoaXMgbWV0aG9kOlxuICAgICAqIC0gY2FjaGVLZXlXaWxsQnlVc2VkKClcbiAgICAgKiAtIGNhY2hlZFJlc3BvbnNlV2lsbEJ5VXNlZCgpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R8c3RyaW5nfSBrZXkgVGhlIFJlcXVlc3Qgb3IgVVJMIHRvIHVzZSBhcyB0aGUgY2FjaGUga2V5LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8UmVzcG9uc2V8dW5kZWZpbmVkPn0gQSBtYXRjaGluZyByZXNwb25zZSwgaWYgZm91bmQuXG4gICAgICovXG4gICAgY2FjaGVNYXRjaChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2FpdFVudGlsKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdG9SZXF1ZXN0KGtleSk7XG4gICAgICAgICAgICBsZXQgY2FjaGVkUmVzcG9uc2U7XG4gICAgICAgICAgICBjb25zdCB7IGNhY2hlTmFtZSwgbWF0Y2hPcHRpb25zIH0gPSB0aGlzLl9zdHJhdGVneTtcbiAgICAgICAgICAgIGNvbnN0IGVmZmVjdGl2ZVJlcXVlc3QgPSBhd2FpdCB0aGlzLmdldENhY2hlS2V5KHJlcXVlc3QsICdyZWFkJyk7XG4gICAgICAgICAgICBjb25zdCBtdWx0aU1hdGNoT3B0aW9ucyA9IHsgLi4ubWF0Y2hPcHRpb25zLCAuLi57IGNhY2hlTmFtZSB9IH07XG4gICAgICAgICAgICBjYWNoZWRSZXNwb25zZSA9IGF3YWl0IGNhY2hlcy5tYXRjaChlZmZlY3RpdmVSZXF1ZXN0LCBtdWx0aU1hdGNoT3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYEZvdW5kIGEgY2FjaGVkIHJlc3BvbnNlIGluICcke2NhY2hlTmFtZX0nLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBObyBjYWNoZWQgcmVzcG9uc2UgZm91bmQgaW4gJyR7Y2FjaGVOYW1lfScuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiB0aGlzLml0ZXJhdGVDYWxsYmFja3MoJ2NhY2hlZFJlc3BvbnNlV2lsbEJlVXNlZCcpKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkUmVzcG9uc2UgPSAoYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICBjYWNoZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGVmZmVjdGl2ZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgICAgICAgICAgIH0pKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzcG9uc2U7XG4gICAgICAgIH0pKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXRzIGEgcmVxdWVzdC9yZXNwb25zZSBwYWlyIGluIHRoZSBjYWNoZSAoYW5kIGludm9rZXMgYW55IGFwcGxpY2FibGVcbiAgICAgKiBwbHVnaW4gY2FsbGJhY2sgbWV0aG9kcykgdXNpbmcgdGhlIGBjYWNoZU5hbWVgIGFuZCBgcGx1Z2luc2AgZGVmaW5lZCBvblxuICAgICAqIHRoZSBzdHJhdGVneSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIHBsdWdpbiBsaWZlY3ljbGUgbWV0aG9kcyBhcmUgaW52b2tlZCB3aGVuIHVzaW5nIHRoaXMgbWV0aG9kOlxuICAgICAqIC0gY2FjaGVLZXlXaWxsQnlVc2VkKClcbiAgICAgKiAtIGNhY2hlV2lsbFVwZGF0ZSgpXG4gICAgICogLSBjYWNoZURpZFVwZGF0ZSgpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R8c3RyaW5nfSBrZXkgVGhlIHJlcXVlc3Qgb3IgVVJMIHRvIHVzZSBhcyB0aGUgY2FjaGUga2V5LlxuICAgICAqIEBwYXJhbSB7UHJvbWlzZTx2b2lkPn0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGFzeW5jIGNhY2hlUHV0KGtleSwgcmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRvUmVxdWVzdChrZXkpO1xuICAgICAgICAvLyBSdW4gaW4gdGhlIG5leHQgdGFzayB0byBhdm9pZCBibG9ja2luZyBvdGhlciBjYWNoZSByZWFkcy5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3czYy9TZXJ2aWNlV29ya2VyL2lzc3Vlcy8xMzk3XG4gICAgICAgIGF3YWl0IHRpbWVvdXQoMCk7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZVJlcXVlc3QgPSBhd2FpdCB0aGlzLmdldENhY2hlS2V5KHJlcXVlc3QsICd3cml0ZScpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdGl2ZVJlcXVlc3QubWV0aG9kICYmIGVmZmVjdGl2ZVJlcXVlc3QubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2F0dGVtcHQtdG8tY2FjaGUtbm9uLWdldC1yZXF1ZXN0Jywge1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGdldEZyaWVuZGx5VVJMKGVmZmVjdGl2ZVJlcXVlc3QudXJsKSxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBlZmZlY3RpdmVSZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgQ2Fubm90IGNhY2hlIG5vbi1leGlzdGVudCByZXNwb25zZSBmb3IgYCArXG4gICAgICAgICAgICAgICAgICAgIGAnJHtnZXRGcmllbmRseVVSTChlZmZlY3RpdmVSZXF1ZXN0LnVybCl9Jy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2NhY2hlLXB1dC13aXRoLW5vLXJlc3BvbnNlJywge1xuICAgICAgICAgICAgICAgIHVybDogZ2V0RnJpZW5kbHlVUkwoZWZmZWN0aXZlUmVxdWVzdC51cmwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2VUb0NhY2hlID0gYXdhaXQgdGhpcy5fZW5zdXJlUmVzcG9uc2VTYWZlVG9DYWNoZShyZXNwb25zZSk7XG4gICAgICAgIGlmICghcmVzcG9uc2VUb0NhY2hlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgUmVzcG9uc2UgJyR7Z2V0RnJpZW5kbHlVUkwoZWZmZWN0aXZlUmVxdWVzdC51cmwpfScgYCArXG4gICAgICAgICAgICAgICAgICAgIGB3aWxsIG5vdCBiZSBjYWNoZWQuYCwgcmVzcG9uc2VUb0NhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNhY2hlTmFtZSwgbWF0Y2hPcHRpb25zIH0gPSB0aGlzLl9zdHJhdGVneTtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBzZWxmLmNhY2hlcy5vcGVuKGNhY2hlTmFtZSk7XG4gICAgICAgIGNvbnN0IGhhc0NhY2hlVXBkYXRlQ2FsbGJhY2sgPSB0aGlzLmhhc0NhbGxiYWNrKCdjYWNoZURpZFVwZGF0ZScpO1xuICAgICAgICBjb25zdCBvbGRSZXNwb25zZSA9IGhhc0NhY2hlVXBkYXRlQ2FsbGJhY2sgPyBhd2FpdCBjYWNoZU1hdGNoSWdub3JlUGFyYW1zKFxuICAgICAgICAvLyBUT0RPKHBoaWxpcHdhbHRvbik6IHRoZSBgX19XQl9SRVZJU0lPTl9fYCBwYXJhbSBpcyBhIHByZWNhY2hpbmdcbiAgICAgICAgLy8gZmVhdHVyZS4gQ29uc2lkZXIgaW50byB3YXlzIHRvIG9ubHkgYWRkIHRoaXMgYmVoYXZpb3IgaWYgdXNpbmdcbiAgICAgICAgLy8gcHJlY2FjaGluZy5cbiAgICAgICAgY2FjaGUsIGVmZmVjdGl2ZVJlcXVlc3QuY2xvbmUoKSwgWydfX1dCX1JFVklTSU9OX18nXSwgbWF0Y2hPcHRpb25zKSA6XG4gICAgICAgICAgICBudWxsO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBVcGRhdGluZyB0aGUgJyR7Y2FjaGVOYW1lfScgY2FjaGUgd2l0aCBhIG5ldyBSZXNwb25zZSBgICtcbiAgICAgICAgICAgICAgICBgZm9yICR7Z2V0RnJpZW5kbHlVUkwoZWZmZWN0aXZlUmVxdWVzdC51cmwpfS5gKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgY2FjaGUucHV0KGVmZmVjdGl2ZVJlcXVlc3QsIGhhc0NhY2hlVXBkYXRlQ2FsbGJhY2sgP1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlVG9DYWNoZS5jbG9uZSgpIDogcmVzcG9uc2VUb0NhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRE9NRXhjZXB0aW9uI2V4Y2VwdGlvbi1RdW90YUV4Y2VlZGVkRXJyb3JcbiAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnUXVvdGFFeGNlZWRlZEVycm9yJykge1xuICAgICAgICAgICAgICAgIGF3YWl0IGV4ZWN1dGVRdW90YUVycm9yQ2FsbGJhY2tzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuaXRlcmF0ZUNhbGxiYWNrcygnY2FjaGVEaWRVcGRhdGUnKSkge1xuICAgICAgICAgICAgYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIGNhY2hlTmFtZSxcbiAgICAgICAgICAgICAgICBvbGRSZXNwb25zZSxcbiAgICAgICAgICAgICAgICBuZXdSZXNwb25zZTogcmVzcG9uc2VUb0NhY2hlLmNsb25lKCksXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogZWZmZWN0aXZlUmVxdWVzdCxcbiAgICAgICAgICAgICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgbGlzdCBvZiBwbHVnaW5zIGZvciB0aGUgYGNhY2hlS2V5V2lsbEJlVXNlZGAgY2FsbGJhY2ssIGFuZFxuICAgICAqIGV4ZWN1dGVzIGFueSBvZiB0aG9zZSBjYWxsYmFja3MgZm91bmQgaW4gc2VxdWVuY2UuIFRoZSBmaW5hbCBgUmVxdWVzdGBcbiAgICAgKiBvYmplY3QgcmV0dXJuZWQgYnkgdGhlIGxhc3QgcGx1Z2luIGlzIHRyZWF0ZWQgYXMgdGhlIGNhY2hlIGtleSBmb3IgY2FjaGVcbiAgICAgKiByZWFkcyBhbmQvb3Igd3JpdGVzLiBJZiBubyBgY2FjaGVLZXlXaWxsQmVVc2VkYCBwbHVnaW4gY2FsbGJhY2tzIGhhdmVcbiAgICAgKiBiZWVuIHJlZ2lzdGVyZWQsIHRoZSBwYXNzZWQgcmVxdWVzdCBpcyByZXR1cm5lZCB1bm1vZGlmaWVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8UmVxdWVzdD59XG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q2FjaGVLZXkocmVxdWVzdCwgbW9kZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlS2V5c1ttb2RlXSkge1xuICAgICAgICAgICAgbGV0IGVmZmVjdGl2ZVJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiB0aGlzLml0ZXJhdGVDYWxsYmFja3MoJ2NhY2hlS2V5V2lsbEJlVXNlZCcpKSB7XG4gICAgICAgICAgICAgICAgZWZmZWN0aXZlUmVxdWVzdCA9IHRvUmVxdWVzdChhd2FpdCBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGVmZmVjdGl2ZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHRoaXMucGFyYW1zLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NhY2hlS2V5c1ttb2RlXSA9IGVmZmVjdGl2ZVJlcXVlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlS2V5c1ttb2RlXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzdHJhdGVneSBoYXMgYXQgbGVhc3Qgb25lIHBsdWdpbiB3aXRoIHRoZSBnaXZlblxuICAgICAqIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNhbGxiYWNrIHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0NhbGxiYWNrKG5hbWUpIHtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5fc3RyYXRlZ3kucGx1Z2lucykge1xuICAgICAgICAgICAgaWYgKG5hbWUgaW4gcGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW5zIGFsbCBwbHVnaW4gY2FsbGJhY2tzIG1hdGNoaW5nIHRoZSBnaXZlbiBuYW1lLCBpbiBvcmRlciwgcGFzc2luZyB0aGVcbiAgICAgKiBnaXZlbiBwYXJhbSBvYmplY3QgKG1lcmdlZCBpdGggdGhlIGN1cnJlbnQgcGx1Z2luIHN0YXRlKSBhcyB0aGUgb25seVxuICAgICAqIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogTm90ZTogc2luY2UgdGhpcyBtZXRob2QgcnVucyBhbGwgcGx1Z2lucywgaXQncyBub3Qgc3VpdGFibGUgZm9yIGNhc2VzXG4gICAgICogd2hlcmUgdGhlIHJldHVybiB2YWx1ZSBvZiBhIGNhbGxiYWNrIG5lZWRzIHRvIGJlIGFwcGxpZWQgcHJpb3IgdG8gY2FsbGluZ1xuICAgICAqIHRoZSBuZXh0IGNhbGxiYWNrLiBTZWVcbiAgICAgKiBbYGl0ZXJhdGVDYWxsYmFja3MoKWBde0BsaW5rIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3lIYW5kbGVyI2l0ZXJhdGVDYWxsYmFja3N9XG4gICAgICogYmVsb3cgZm9yIGhvdyB0byBoYW5kbGUgdGhhdCBjYXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNhbGxiYWNrIHRvIHJ1biB3aXRoaW4gZWFjaCBwbHVnaW4uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtIFRoZSBvYmplY3QgdG8gcGFzcyBhcyB0aGUgZmlyc3QgKGFuZCBvbmx5KSBwYXJhbVxuICAgICAqICAgICB3aGVuIGV4ZWN1dGluZyBlYWNoIGNhbGxiYWNrLiBUaGlzIG9iamVjdCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZVxuICAgICAqICAgICBjdXJyZW50IHBsdWdpbiBzdGF0ZSBwcmlvciB0byBjYWxsYmFjayBleGVjdXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgcnVuQ2FsbGJhY2tzKG5hbWUsIHBhcmFtKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5pdGVyYXRlQ2FsbGJhY2tzKG5hbWUpKSB7XG4gICAgICAgICAgICAvLyBUT0RPKHBoaWxpcHdhbHRvbik6IG5vdCBzdXJlIHdoeSBgYW55YCBpcyBuZWVkZWQuIEl0IHNlZW1zIGxpa2VcbiAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIHdvcmsgd2l0aCBgYXMgV29ya2JveFBsdWdpbkNhbGxiYWNrUGFyYW1bQ11gLlxuICAgICAgICAgICAgYXdhaXQgY2FsbGJhY2socGFyYW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2VwdHMgYSBjYWxsYmFjayBhbmQgcmV0dXJucyBhbiBpdGVyYWJsZSBvZiBtYXRjaGluZyBwbHVnaW4gY2FsbGJhY2tzLFxuICAgICAqIHdoZXJlIGVhY2ggY2FsbGJhY2sgaXMgd3JhcHBlZCB3aXRoIHRoZSBjdXJyZW50IGhhbmRsZXIgc3RhdGUgKGkuZS4gd2hlblxuICAgICAqIHlvdSBjYWxsIGVhY2ggY2FsbGJhY2ssIHdoYXRldmVyIG9iamVjdCBwYXJhbWV0ZXIgeW91IHBhc3MgaXQgd2lsbFxuICAgICAqIGJlIG1lcmdlZCB3aXRoIHRoZSBwbHVnaW4ncyBjdXJyZW50IHN0YXRlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIGZvIHRoZSBjYWxsYmFjayB0byBydW5cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxGdW5jdGlvbj59XG4gICAgICovXG4gICAgKml0ZXJhdGVDYWxsYmFja3MobmFtZSkge1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLl9zdHJhdGVneS5wbHVnaW5zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBsdWdpbltuYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fcGx1Z2luU3RhdGVNYXAuZ2V0KHBsdWdpbik7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGVmdWxDYWxsYmFjayA9IChwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZWZ1bFBhcmFtID0geyAuLi5wYXJhbSwgc3RhdGUgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhwaGlsaXB3YWx0b24pOiBub3Qgc3VyZSB3aHkgYGFueWAgaXMgbmVlZGVkLiBJdCBzZWVtcyBsaWtlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIHdvcmsgd2l0aCBgYXMgV29ya2JveFBsdWdpbkNhbGxiYWNrUGFyYW1bQ11gLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luW25hbWVdKHN0YXRlZnVsUGFyYW0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgeWllbGQgc3RhdGVmdWxDYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcHJvbWlzZSB0byB0aGVcbiAgICAgKiBbZXh0ZW5kIGxpZmV0aW1lIHByb21pc2VzXXtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZXh0ZW5kYWJsZWV2ZW50LWV4dGVuZC1saWZldGltZS1wcm9taXNlc31cbiAgICAgKiBvZiB0aGUgZXZlbnQgZXZlbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSByZXF1ZXN0IGJlaW5nIGhhbmRsZWQgKHVzdWFsbHkgYVxuICAgICAqIGBGZXRjaEV2ZW50YCkuXG4gICAgICpcbiAgICAgKiBOb3RlOiB5b3UgY2FuIGF3YWl0XG4gICAgICogW2Bkb25lV2FpdGluZygpYF17QGxpbmsgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneUhhbmRsZXJ+ZG9uZVdhaXRpbmd9XG4gICAgICogdG8ga25vdyB3aGVuIGFsbCBhZGRlZCBwcm9taXNlcyBoYXZlIHNldHRsZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1Byb21pc2V9IHByb21pc2UgQSBwcm9taXNlIHRvIGFkZCB0byB0aGUgZXh0ZW5kIGxpZmV0aW1lIHByb21pc2VzXG4gICAgICogICAgIG9mIHRoZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICB3YWl0VW50aWwocHJvbWlzZSkge1xuICAgICAgICB0aGlzLl9leHRlbmRMaWZldGltZVByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgYWxsIHByb21pc2VzIHBhc3NlZCB0b1xuICAgICAqIFtgd2FpdFVudGlsKClgXXtAbGluayBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5SGFuZGxlcn53YWl0VW50aWx9XG4gICAgICogaGF2ZSBzZXR0bGVkLlxuICAgICAqXG4gICAgICogTm90ZTogYW55IHdvcmsgZG9uZSBhZnRlciBgZG9uZVdhaXRpbmcoKWAgc2V0dGxlcyBzaG91bGQgYmUgbWFudWFsbHlcbiAgICAgKiBwYXNzZWQgdG8gYW4gZXZlbnQncyBgd2FpdFVudGlsKClgIG1ldGhvZCAobm90IHRoaXMgaGFuZGxlcidzXG4gICAgICogYHdhaXRVbnRpbCgpYCBtZXRob2QpLCBvdGhlcndpc2UgdGhlIHNlcnZpY2Ugd29ya2VyIHRocmVhZCBteSBiZSBraWxsZWRcbiAgICAgKiBwcmlvciB0byB5b3VyIHdvcmsgY29tcGxldGluZy5cbiAgICAgKi9cbiAgICBhc3luYyBkb25lV2FpdGluZygpIHtcbiAgICAgICAgbGV0IHByb21pc2U7XG4gICAgICAgIHdoaWxlIChwcm9taXNlID0gdGhpcy5fZXh0ZW5kTGlmZXRpbWVQcm9taXNlcy5zaGlmdCgpKSB7XG4gICAgICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHJ1bm5pbmcgdGhlIHN0cmF0ZWd5IGFuZCBpbW1lZGlhdGVseSByZXNvbHZlcyBhbnkgcGVuZGluZ1xuICAgICAqIGB3YWl0VW50aWwoKWAgcHJvbWlzZXMuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlckRlZmVycmVkLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYWxsIGNhY2hlV2lsbFVwZGF0ZSBvbiB0aGUgYXZhaWxhYmxlIHBsdWdpbnMgKG9yIHVzZVxuICAgICAqIHN0YXR1cyA9PT0gMjAwKSB0byBkZXRlcm1pbmUgaWYgdGhlIFJlc3BvbnNlIGlzIHNhZmUgYW5kIHZhbGlkIHRvIGNhY2hlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fSBvcHRpb25zLnJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge1Jlc3BvbnNlfSBvcHRpb25zLnJlc3BvbnNlXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxSZXNwb25zZXx1bmRlZmluZWQ+fVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBfZW5zdXJlUmVzcG9uc2VTYWZlVG9DYWNoZShyZXNwb25zZSkge1xuICAgICAgICBsZXQgcmVzcG9uc2VUb0NhY2hlID0gcmVzcG9uc2U7XG4gICAgICAgIGxldCBwbHVnaW5zVXNlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuaXRlcmF0ZUNhbGxiYWNrcygnY2FjaGVXaWxsVXBkYXRlJykpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlVG9DYWNoZSA9IChhd2FpdCBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdDogdGhpcy5yZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZVRvQ2FjaGUsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICAgICAgICB9KSkgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgcGx1Z2luc1VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZVRvQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBsdWdpbnNVc2VkKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VUb0NhY2hlICYmIHJlc3BvbnNlVG9DYWNoZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlVG9DYWNoZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlVG9DYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VUb0NhY2hlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VUb0NhY2hlLnN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBUaGUgcmVzcG9uc2UgZm9yICcke3RoaXMucmVxdWVzdC51cmx9JyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGlzIGFuIG9wYXF1ZSByZXNwb25zZS4gVGhlIGNhY2hpbmcgc3RyYXRlZ3kgdGhhdCB5b3UncmUgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB1c2luZyB3aWxsIG5vdCBjYWNoZSBvcGFxdWUgcmVzcG9uc2VzIGJ5IGRlZmF1bHQuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFRoZSByZXNwb25zZSBmb3IgJyR7dGhpcy5yZXF1ZXN0LnVybH0nIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgcmV0dXJuZWQgYSBzdGF0dXMgY29kZSBvZiAnJHtyZXNwb25zZS5zdGF0dXN9JyBhbmQgd29uJ3QgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBiZSBjYWNoZWQgYXMgYSByZXN1bHQuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlVG9DYWNoZTtcbiAgICB9XG59XG5leHBvcnQgeyBTdHJhdGVneUhhbmRsZXIgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGNhY2hlTmFtZXMgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvY2FjaGVOYW1lcy5qcyc7XG5pbXBvcnQgeyBXb3JrYm94RXJyb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMnO1xuaW1wb3J0IHsgZ2V0RnJpZW5kbHlVUkwgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwuanMnO1xuaW1wb3J0IHsgU3RyYXRlZ3lIYW5kbGVyIH0gZnJvbSAnLi9TdHJhdGVneUhhbmRsZXIuanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogQW4gYWJzdHJhY3QgYmFzZSBjbGFzcyB0aGF0IGFsbCBvdGhlciBzdHJhdGVneSBjbGFzc2VzIG11c3QgZXh0ZW5kIGZyb206XG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXNcbiAqL1xuY2xhc3MgU3RyYXRlZ3kge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIHN0cmF0ZWd5IGFuZCBzZXRzIGFsbCBkb2N1bWVudGVkIG9wdGlvblxuICAgICAqIHByb3BlcnRpZXMgYXMgcHVibGljIGluc3RhbmNlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBpZiBhIGN1c3RvbSBzdHJhdGVneSBjbGFzcyBleHRlbmRzIHRoZSBiYXNlIFN0cmF0ZWd5IGNsYXNzIGFuZCBkb2VzXG4gICAgICogbm90IG5lZWQgbW9yZSB0aGFuIHRoZXNlIHByb3BlcnRpZXMsIGl0IGRvZXMgbm90IG5lZWQgdG8gZGVmaW5lIGl0cyBvd25cbiAgICAgKiBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2FjaGVOYW1lXSBDYWNoZSBuYW1lIHRvIHN0b3JlIGFuZCByZXRyaWV2ZVxuICAgICAqIHJlcXVlc3RzLiBEZWZhdWx0cyB0byB0aGUgY2FjaGUgbmFtZXMgcHJvdmlkZWQgYnlcbiAgICAgKiBbd29ya2JveC1jb3JlXXtAbGluayBtb2R1bGU6d29ya2JveC1jb3JlLmNhY2hlTmFtZXN9LlxuICAgICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gW29wdGlvbnMucGx1Z2luc10gW1BsdWdpbnNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi90b29scy93b3JrYm94L2d1aWRlcy91c2luZy1wbHVnaW5zfVxuICAgICAqIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoaXMgY2FjaGluZyBzdHJhdGVneS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZmV0Y2hPcHRpb25zXSBWYWx1ZXMgcGFzc2VkIGFsb25nIHRvIHRoZVxuICAgICAqIFtgaW5pdGBde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dPcldvcmtlckdsb2JhbFNjb3BlL2ZldGNoI1BhcmFtZXRlcnN9XG4gICAgICogb2YgYWxsIGZldGNoKCkgcmVxdWVzdHMgbWFkZSBieSB0aGlzIHN0cmF0ZWd5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5tYXRjaE9wdGlvbnNdIFRoZVxuICAgICAqIFtgQ2FjaGVRdWVyeU9wdGlvbnNgXXtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZGljdGRlZi1jYWNoZXF1ZXJ5b3B0aW9uc31cbiAgICAgKiBmb3IgYW55IGBjYWNoZS5tYXRjaCgpYCBvciBgY2FjaGUucHV0KClgIGNhbGxzIG1hZGUgYnkgdGhpcyBzdHJhdGVneS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhY2hlIG5hbWUgdG8gc3RvcmUgYW5kIHJldHJpZXZlXG4gICAgICAgICAqIHJlcXVlc3RzLiBEZWZhdWx0cyB0byB0aGUgY2FjaGUgbmFtZXMgcHJvdmlkZWQgYnlcbiAgICAgICAgICogW3dvcmtib3gtY29yZV17QGxpbmsgbW9kdWxlOndvcmtib3gtY29yZS5jYWNoZU5hbWVzfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FjaGVOYW1lID0gY2FjaGVOYW1lcy5nZXRSdW50aW1lTmFtZShvcHRpb25zLmNhY2hlTmFtZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGlzdFxuICAgICAgICAgKiBbUGx1Z2luc117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3Rvb2xzL3dvcmtib3gvZ3VpZGVzL3VzaW5nLXBsdWdpbnN9XG4gICAgICAgICAqIHVzZWQgYnkgdGhpcyBzdHJhdGVneS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0FycmF5PE9iamVjdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnMgfHwgW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZXMgcGFzc2VkIGFsb25nIHRvIHRoZVxuICAgICAgICAgKiBbYGluaXRgXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93T3JXb3JrZXJHbG9iYWxTY29wZS9mZXRjaCNQYXJhbWV0ZXJzfVxuICAgICAgICAgKiBvZiBhbGwgZmV0Y2goKSByZXF1ZXN0cyBtYWRlIGJ5IHRoaXMgc3RyYXRlZ3kuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZldGNoT3B0aW9ucyA9IG9wdGlvbnMuZmV0Y2hPcHRpb25zO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlXG4gICAgICAgICAqIFtgQ2FjaGVRdWVyeU9wdGlvbnNgXXtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZGljdGRlZi1jYWNoZXF1ZXJ5b3B0aW9uc31cbiAgICAgICAgICogZm9yIGFueSBgY2FjaGUubWF0Y2goKWAgb3IgYGNhY2hlLnB1dCgpYCBjYWxscyBtYWRlIGJ5IHRoaXMgc3RyYXRlZ3kuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hdGNoT3B0aW9ucyA9IG9wdGlvbnMubWF0Y2hPcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgcmVxdWVzdCBzdHJhdGVneSBhbmQgcmV0dXJucyBhIGBQcm9taXNlYCB0aGF0IHdpbGwgcmVzb2x2ZSB3aXRoXG4gICAgICogYSBgUmVzcG9uc2VgLCBpbnZva2luZyBhbGwgcmVsZXZhbnQgcGx1Z2luIGNhbGxiYWNrcy5cbiAgICAgKlxuICAgICAqIFdoZW4gYSBzdHJhdGVneSBpbnN0YW5jZSBpcyByZWdpc3RlcmVkIHdpdGggYSBXb3JrYm94XG4gICAgICogW3JvdXRlXXtAbGluayBtb2R1bGU6d29ya2JveC1yb3V0aW5nLlJvdXRlfSwgdGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseVxuICAgICAqIGNhbGxlZCB3aGVuIHRoZSByb3V0ZSBtYXRjaGVzLlxuICAgICAqXG4gICAgICogQWx0ZXJuYXRpdmVseSwgdGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgaW4gYSBzdGFuZGFsb25lIGBGZXRjaEV2ZW50YFxuICAgICAqIGxpc3RlbmVyIGJ5IHBhc3NpbmcgaXQgdG8gYGV2ZW50LnJlc3BvbmRXaXRoKClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGZXRjaEV2ZW50fE9iamVjdH0gb3B0aW9ucyBBIGBGZXRjaEV2ZW50YCBvciBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICAgKiAgICAgcHJvcGVydGllcyBsaXN0ZWQgYmVsb3cuXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fHN0cmluZ30gb3B0aW9ucy5yZXF1ZXN0IEEgcmVxdWVzdCB0byBydW4gdGhpcyBzdHJhdGVneSBmb3IuXG4gICAgICogQHBhcmFtIHtFeHRlbmRhYmxlRXZlbnR9IG9wdGlvbnMuZXZlbnQgVGhlIGV2ZW50IGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICAgKiAgICAgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0ge1VSTH0gW29wdGlvbnMudXJsXVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMucGFyYW1zXVxuICAgICAqL1xuICAgIGhhbmRsZShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IFtyZXNwb25zZURvbmVdID0gdGhpcy5oYW5kbGVBbGwob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZURvbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbWlsYXIgdG8gW2BoYW5kbGUoKWBde0BsaW5rIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3l+aGFuZGxlfSwgYnV0XG4gICAgICogaW5zdGVhZCBvZiBqdXN0IHJldHVybmluZyBhIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHRvIGEgYFJlc3BvbnNlYCBpdFxuICAgICAqIGl0IHdpbGwgcmV0dXJuIGFuIHR1cGxlIG9mIFtyZXNwb25zZSwgZG9uZV0gcHJvbWlzZXMsIHdoZXJlIHRoZSBmb3JtZXJcbiAgICAgKiAoYHJlc3BvbnNlYCkgaXMgZXF1aXZhbGVudCB0byB3aGF0IGBoYW5kbGUoKWAgcmV0dXJucywgYW5kIHRoZSBsYXR0ZXIgaXMgYVxuICAgICAqIFByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgb25jZSBhbnkgcHJvbWlzZXMgdGhhdCB3ZXJlIGFkZGVkIHRvXG4gICAgICogYGV2ZW50LndhaXRVbnRpbCgpYCBhcyBwYXJ0IG9mIHBlcmZvcm1pbmcgdGhlIHN0cmF0ZWd5IGhhdmUgY29tcGxldGVkLlxuICAgICAqXG4gICAgICogWW91IGNhbiBhd2FpdCB0aGUgYGRvbmVgIHByb21pc2UgdG8gZW5zdXJlIGFueSBleHRyYSB3b3JrIHBlcmZvcm1lZCBieVxuICAgICAqIHRoZSBzdHJhdGVneSAodXN1YWxseSBjYWNoaW5nIHJlc3BvbnNlcykgY29tcGxldGVzIHN1Y2Nlc3NmdWxseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmV0Y2hFdmVudHxPYmplY3R9IG9wdGlvbnMgQSBgRmV0Y2hFdmVudGAgb3IgYW4gb2JqZWN0IHdpdGggdGhlXG4gICAgICogICAgIHByb3BlcnRpZXMgbGlzdGVkIGJlbG93LlxuICAgICAqIEBwYXJhbSB7UmVxdWVzdHxzdHJpbmd9IG9wdGlvbnMucmVxdWVzdCBBIHJlcXVlc3QgdG8gcnVuIHRoaXMgc3RyYXRlZ3kgZm9yLlxuICAgICAqIEBwYXJhbSB7RXh0ZW5kYWJsZUV2ZW50fSBvcHRpb25zLmV2ZW50IFRoZSBldmVudCBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgICogICAgIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHtVUkx9IFtvcHRpb25zLnVybF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLnBhcmFtc11cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxQcm9taXNlPn0gQSB0dXBsZSBvZiBbcmVzcG9uc2UsIGRvbmVdXG4gICAgICogICAgIHByb21pc2VzIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIHJlc3BvbnNlIHJlc29sdmVzIGFzXG4gICAgICogICAgIHdlbGwgYXMgd2hlbiB0aGUgaGFuZGxlciBoYXMgY29tcGxldGVkIGFsbCBpdHMgd29yay5cbiAgICAgKi9cbiAgICBoYW5kbGVBbGwob3B0aW9ucykge1xuICAgICAgICAvLyBBbGxvdyBmb3IgZmxleGlibGUgb3B0aW9ucyB0byBiZSBwYXNzZWQuXG4gICAgICAgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgRmV0Y2hFdmVudCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBldmVudDogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBvcHRpb25zLnJlcXVlc3QsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gb3B0aW9ucy5ldmVudDtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHR5cGVvZiBvcHRpb25zLnJlcXVlc3QgPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgIG5ldyBSZXF1ZXN0KG9wdGlvbnMucmVxdWVzdCkgOlxuICAgICAgICAgICAgb3B0aW9ucy5yZXF1ZXN0O1xuICAgICAgICBjb25zdCBwYXJhbXMgPSAncGFyYW1zJyBpbiBvcHRpb25zID8gb3B0aW9ucy5wYXJhbXMgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgU3RyYXRlZ3lIYW5kbGVyKHRoaXMsIHsgZXZlbnQsIHJlcXVlc3QsIHBhcmFtcyB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VEb25lID0gdGhpcy5fZ2V0UmVzcG9uc2UoaGFuZGxlciwgcmVxdWVzdCwgZXZlbnQpO1xuICAgICAgICBjb25zdCBoYW5kbGVyRG9uZSA9IHRoaXMuX2F3YWl0Q29tcGxldGUocmVzcG9uc2VEb25lLCBoYW5kbGVyLCByZXF1ZXN0LCBldmVudCk7XG4gICAgICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiBwcm9taXNlcywgc3VpdGFibGUgZm9yIHVzZSB3aXRoIFByb21pc2UuYWxsKCkuXG4gICAgICAgIHJldHVybiBbcmVzcG9uc2VEb25lLCBoYW5kbGVyRG9uZV07XG4gICAgfVxuICAgIGFzeW5jIF9nZXRSZXNwb25zZShoYW5kbGVyLCByZXF1ZXN0LCBldmVudCkge1xuICAgICAgICBhd2FpdCBoYW5kbGVyLnJ1bkNhbGxiYWNrcygnaGFuZGxlcldpbGxTdGFydCcsIHsgZXZlbnQsIHJlcXVlc3QgfSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5faGFuZGxlKHJlcXVlc3QsIGhhbmRsZXIpO1xuICAgICAgICAgICAgLy8gVGhlIFwib2ZmaWNpYWxcIiBTdHJhdGVneSBzdWJjbGFzc2VzIGFsbCB0aHJvdyB0aGlzIGVycm9yIGF1dG9tYXRpY2FsbHksXG4gICAgICAgICAgICAvLyBidXQgaW4gY2FzZSBhIHRoaXJkLXBhcnR5IFN0cmF0ZWd5IGRvZXNuJ3QsIGVuc3VyZSB0aGF0IHdlIGhhdmUgYVxuICAgICAgICAgICAgLy8gY29uc2lzdGVudCBmYWlsdXJlIHdoZW4gdGhlcmUncyBubyByZXNwb25zZSBvciBhbiBlcnJvciByZXNwb25zZS5cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UgfHwgcmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ25vLXJlc3BvbnNlJywgeyB1cmw6IHJlcXVlc3QudXJsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBoYW5kbGVyLml0ZXJhdGVDYWxsYmFja3MoJ2hhbmRsZXJEaWRFcnJvcicpKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFjayh7IGVycm9yLCBldmVudCwgcmVxdWVzdCB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFdoaWxlIHJlc3BvbmRpbmcgdG8gJyR7Z2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpfScsIGAgK1xuICAgICAgICAgICAgICAgICAgICBgYW4gJHtlcnJvcn0gZXJyb3Igb2NjdXJyZWQuIFVzaW5nIGEgZmFsbGJhY2sgcmVzcG9uc2UgcHJvdmlkZWQgYnkgYCArXG4gICAgICAgICAgICAgICAgICAgIGBhIGhhbmRsZXJEaWRFcnJvciBwbHVnaW4uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBoYW5kbGVyLml0ZXJhdGVDYWxsYmFja3MoJ2hhbmRsZXJXaWxsUmVzcG9uZCcpKSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrKHsgZXZlbnQsIHJlcXVlc3QsIHJlc3BvbnNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgX2F3YWl0Q29tcGxldGUocmVzcG9uc2VEb25lLCBoYW5kbGVyLCByZXF1ZXN0LCBldmVudCkge1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2VEb25lO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWdub3JlIGVycm9ycywgYXMgcmVzcG9uc2UgZXJyb3JzIHNob3VsZCBiZSBjYXVnaHQgdmlhIHRoZSBgcmVzcG9uc2VgXG4gICAgICAgICAgICAvLyBwcm9taXNlIGFib3ZlLiBUaGUgYGRvbmVgIHByb21pc2Ugd2lsbCBvbmx5IHRocm93IGZvciBlcnJvcnMgaW5cbiAgICAgICAgICAgIC8vIHByb21pc2VzIHBhc3NlZCB0byBgaGFuZGxlci53YWl0VW50aWwoKWAuXG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIucnVuQ2FsbGJhY2tzKCdoYW5kbGVyRGlkUmVzcG9uZCcsIHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmRvbmVXYWl0aW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKHdhaXRVbnRpbEVycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IHdhaXRVbnRpbEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGhhbmRsZXIucnVuQ2FsbGJhY2tzKCdoYW5kbGVyRGlkQ29tcGxldGUnLCB7XG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICB9KTtcbiAgICAgICAgaGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgeyBTdHJhdGVneSB9O1xuLyoqXG4gKiBDbGFzc2VzIGV4dGVuZGluZyB0aGUgYFN0cmF0ZWd5YCBiYXNlZCBjbGFzcyBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kLFxuICogYW5kIGxldmVyYWdlIHRoZSBbYGhhbmRsZXJgXXtAbGluayBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5SGFuZGxlcn1cbiAqIGFyZyB0byBwZXJmb3JtIGFsbCBmZXRjaGluZyBhbmQgY2FjaGUgbG9naWMsIHdoaWNoIHdpbGwgZW5zdXJlIGFsbCByZWxldmFudFxuICogY2FjaGUsIGNhY2hlIG9wdGlvbnMsIGZldGNoIG9wdGlvbnMgYW5kIHBsdWdpbnMgYXJlIHVzZWQgKHBlciB0aGUgY3VycmVudFxuICogc3RyYXRlZ3kgaW5zdGFuY2UpLlxuICpcbiAqIEBuYW1lIF9oYW5kbGVcbiAqIEBpbnN0YW5jZVxuICogQGFic3RyYWN0XG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdFxuICogQHBhcmFtIHttb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5SGFuZGxlcn0gaGFuZGxlclxuICogQHJldHVybiB7UHJvbWlzZTxSZXNwb25zZT59XG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3lcbiAqL1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgY29weVJlc3BvbnNlIH0gZnJvbSAnd29ya2JveC1jb3JlL2NvcHlSZXNwb25zZS5qcyc7XG5pbXBvcnQgeyBjYWNoZU5hbWVzIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2NhY2hlTmFtZXMuanMnO1xuaW1wb3J0IHsgZ2V0RnJpZW5kbHlVUkwgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwuanMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5qcyc7XG5pbXBvcnQgeyBXb3JrYm94RXJyb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCB7IFN0cmF0ZWd5IH0gZnJvbSAnd29ya2JveC1zdHJhdGVnaWVzL1N0cmF0ZWd5LmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG5jb25zdCBjb3B5UmVkaXJlY3RlZENhY2hlYWJsZVJlc3BvbnNlc1BsdWdpbiA9IHtcbiAgICBhc3luYyBjYWNoZVdpbGxVcGRhdGUoeyByZXNwb25zZSB9KSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5yZWRpcmVjdGVkID8gYXdhaXQgY29weVJlc3BvbnNlKHJlc3BvbnNlKSA6IHJlc3BvbnNlO1xuICAgIH1cbn07XG4vKipcbiAqIEEgW1N0cmF0ZWd5XXtAbGluayBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5fSBpbXBsZW1lbnRhdGlvblxuICogc3BlY2lmaWNhbGx5IGRlc2lnbmVkIHRvIHdvcmsgd2l0aFxuICogW1ByZWNhY2hlQ29udHJvbGxlcl17QGxpbmsgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5QcmVjYWNoZUNvbnRyb2xsZXJ9XG4gKiB0byBib3RoIGNhY2hlIGFuZCBmZXRjaCBwcmVjYWNoZWQgYXNzZXRzLlxuICpcbiAqIE5vdGU6IGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgaXMgY3JlYXRlZCBhdXRvbWF0aWNhbGx5IHdoZW4gY3JlYXRpbmcgYVxuICogYFByZWNhY2hlQ29udHJvbGxlcmA7IGl0J3MgZ2VuZXJhbGx5IG5vdCBuZWNlc3NhcnkgdG8gY3JlYXRlIHRoaXMgeW91cnNlbGYuXG4gKlxuICogQGV4dGVuZHMgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneVxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmdcbiAqL1xuY2xhc3MgUHJlY2FjaGVTdHJhdGVneSBleHRlbmRzIFN0cmF0ZWd5IHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2FjaGVOYW1lXSBDYWNoZSBuYW1lIHRvIHN0b3JlIGFuZCByZXRyaWV2ZVxuICAgICAqIHJlcXVlc3RzLiBEZWZhdWx0cyB0byB0aGUgY2FjaGUgbmFtZXMgcHJvdmlkZWQgYnlcbiAgICAgKiBbd29ya2JveC1jb3JlXXtAbGluayBtb2R1bGU6d29ya2JveC1jb3JlLmNhY2hlTmFtZXN9LlxuICAgICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gW29wdGlvbnMucGx1Z2luc10gW1BsdWdpbnNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi90b29scy93b3JrYm94L2d1aWRlcy91c2luZy1wbHVnaW5zfVxuICAgICAqIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoaXMgY2FjaGluZyBzdHJhdGVneS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZmV0Y2hPcHRpb25zXSBWYWx1ZXMgcGFzc2VkIGFsb25nIHRvIHRoZVxuICAgICAqIFtgaW5pdGBde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dPcldvcmtlckdsb2JhbFNjb3BlL2ZldGNoI1BhcmFtZXRlcnN9XG4gICAgICogb2YgYWxsIGZldGNoKCkgcmVxdWVzdHMgbWFkZSBieSB0aGlzIHN0cmF0ZWd5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5tYXRjaE9wdGlvbnNdIFRoZVxuICAgICAqIFtgQ2FjaGVRdWVyeU9wdGlvbnNgXXtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZGljdGRlZi1jYWNoZXF1ZXJ5b3B0aW9uc31cbiAgICAgKiBmb3IgYW55IGBjYWNoZS5tYXRjaCgpYCBvciBgY2FjaGUucHV0KClgIGNhbGxzIG1hZGUgYnkgdGhpcyBzdHJhdGVneS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZhbGxiYWNrVG9OZXR3b3JrPXRydWVdIFdoZXRoZXIgdG8gYXR0ZW1wdCB0b1xuICAgICAqIGdldCB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgbmV0d29yayBpZiB0aGVyZSdzIGEgcHJlY2FjaGUgbWlzcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgb3B0aW9ucy5jYWNoZU5hbWUgPSBjYWNoZU5hbWVzLmdldFByZWNhY2hlTmFtZShvcHRpb25zLmNhY2hlTmFtZSk7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9mYWxsYmFja1RvTmV0d29yayA9IG9wdGlvbnMuZmFsbGJhY2tUb05ldHdvcmsgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xuICAgICAgICAvLyBSZWRpcmVjdGVkIHJlc3BvbnNlcyBjYW5ub3QgYmUgdXNlZCB0byBzYXRpc2Z5IGEgbmF2aWdhdGlvbiByZXF1ZXN0LCBzb1xuICAgICAgICAvLyBhbnkgcmVkaXJlY3RlZCByZXNwb25zZSBtdXN0IGJlIFwiY29waWVkXCIgcmF0aGVyIHRoYW4gY2xvbmVkLCBzbyB0aGUgbmV3XG4gICAgICAgIC8vIHJlc3BvbnNlIGRvZXNuJ3QgY29udGFpbiB0aGUgYHJlZGlyZWN0ZWRgIGZsYWcuIFNlZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjY5MzYzJmRlc2M9MiNjMVxuICAgICAgICB0aGlzLnBsdWdpbnMucHVzaChjb3B5UmVkaXJlY3RlZENhY2hlYWJsZVJlc3BvbnNlc1BsdWdpbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fHN0cmluZ30gcmVxdWVzdCBBIHJlcXVlc3QgdG8gcnVuIHRoaXMgc3RyYXRlZ3kgZm9yLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneUhhbmRsZXJ9IGhhbmRsZXIgVGhlIGV2ZW50IHRoYXRcbiAgICAgKiAgICAgdHJpZ2dlcmVkIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8UmVzcG9uc2U+fVxuICAgICAqL1xuICAgIGFzeW5jIF9oYW5kbGUocmVxdWVzdCwgaGFuZGxlcikge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGhhbmRsZXIuY2FjaGVNYXRjaChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhbiBgaW5zdGFsbGAgZXZlbnQgdGhlbiBwb3B1bGF0ZSB0aGUgY2FjaGUuIElmIHRoaXMgaXMgYVxuICAgICAgICAgICAgLy8gYGZldGNoYCBldmVudCAob3IgYW55IG90aGVyIGV2ZW50KSB0aGVuIHJlc3BvbmQgd2l0aCB0aGUgY2FjaGVkXG4gICAgICAgICAgICAvLyByZXNwb25zZS5cbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmV2ZW50ICYmIGhhbmRsZXIuZXZlbnQudHlwZSA9PT0gJ2luc3RhbGwnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2hhbmRsZUluc3RhbGwocmVxdWVzdCwgaGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5faGFuZGxlRmV0Y2gocmVxdWVzdCwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyBfaGFuZGxlRmV0Y2gocmVxdWVzdCwgaGFuZGxlcikge1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIC8vIEZhbGwgYmFjayB0byB0aGUgbmV0d29yayBpZiB3ZSBkb24ndCBoYXZlIGEgY2FjaGVkIHJlc3BvbnNlXG4gICAgICAgIC8vIChwZXJoYXBzIGR1ZSB0byBtYW51YWwgY2FjaGUgY2xlYW51cCkuXG4gICAgICAgIGlmICh0aGlzLl9mYWxsYmFja1RvTmV0d29yaykge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgVGhlIHByZWNhY2hlZCByZXNwb25zZSBmb3IgYCArXG4gICAgICAgICAgICAgICAgICAgIGAke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0gaW4gJHt0aGlzLmNhY2hlTmFtZX0gd2FzIG5vdCBgICtcbiAgICAgICAgICAgICAgICAgICAgYGZvdW5kLiBGYWxsaW5nIGJhY2sgdG8gdGhlIG5ldHdvcmsgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlci5mZXRjaChyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IG5vcm1hbGx5IGhhcHBlbiwgYnV0IHRoZXJlIGFyZSBlZGdlIGNhc2VzOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8xNDQxXG4gICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdtaXNzaW5nLXByZWNhY2hlLWVudHJ5Jywge1xuICAgICAgICAgICAgICAgIGNhY2hlTmFtZTogdGhpcy5jYWNoZU5hbWUsXG4gICAgICAgICAgICAgICAgdXJsOiByZXF1ZXN0LnVybCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IGhhbmRsZXIucGFyYW1zICYmIGhhbmRsZXIucGFyYW1zLmNhY2hlS2V5IHx8XG4gICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5nZXRDYWNoZUtleShyZXF1ZXN0LCAncmVhZCcpO1xuICAgICAgICAgICAgLy8gV29ya2JveCBpcyBnb2luZyB0byBoYW5kbGUgdGhlIHJvdXRlLlxuICAgICAgICAgICAgLy8gcHJpbnQgdGhlIHJvdXRpbmcgZGV0YWlscyB0byB0aGUgY29uc29sZS5cbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgUHJlY2FjaGluZyBpcyByZXNwb25kaW5nIHRvOiBgICtcbiAgICAgICAgICAgICAgICBnZXRGcmllbmRseVVSTChyZXF1ZXN0LnVybCkpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgU2VydmluZyB0aGUgcHJlY2FjaGVkIHVybDogJHtnZXRGcmllbmRseVVSTChjYWNoZUtleS51cmwpfWApO1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBWaWV3IHJlcXVlc3QgZGV0YWlscyBoZXJlLmApO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhyZXF1ZXN0KTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBWaWV3IHJlc3BvbnNlIGRldGFpbHMgaGVyZS5gKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIF9oYW5kbGVJbnN0YWxsKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmZldGNoQW5kQ2FjaGVQdXQocmVxdWVzdCk7XG4gICAgICAgIC8vIEFueSB0aW1lIHRoZXJlJ3Mgbm8gcmVzcG9uc2UsIGNvbnNpZGVyIGl0IGEgcHJlY2FjaGluZyBlcnJvci5cbiAgICAgICAgbGV0IHJlc3BvbnNlU2FmZVRvUHJlY2FjaGUgPSBCb29sZWFuKHJlc3BvbnNlKTtcbiAgICAgICAgLy8gQWxzbyBjb25zaWRlciBpdCBhbiBlcnJvciBpZiB0aGUgdXNlciBkaWRuJ3QgcGFzcyB0aGVpciBvd25cbiAgICAgICAgLy8gY2FjaGVXaWxsVXBkYXRlIHBsdWdpbiwgYW5kIHRoZSByZXNwb25zZSBpcyBhIDQwMCsgKG5vdGU6IHRoaXMgbWVhbnNcbiAgICAgICAgLy8gdGhhdCBieSBkZWZhdWx0IG9wYXF1ZSByZXNwb25zZXMgY2FuIGJlIHByZWNhY2hlZCkuXG4gICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5zdGF0dXMgPj0gNDAwICYmXG4gICAgICAgICAgICAhdGhpcy5fdXNlc0N1c3RvbUNhY2hlYWJsZVJlc3BvbnNlTG9naWMoKSkge1xuICAgICAgICAgICAgcmVzcG9uc2VTYWZlVG9QcmVjYWNoZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzcG9uc2VTYWZlVG9QcmVjYWNoZSkge1xuICAgICAgICAgICAgLy8gVGhyb3dpbmcgaGVyZSB3aWxsIGxlYWQgdG8gdGhlIGBpbnN0YWxsYCBoYW5kbGVyIGZhaWxpbmcsIHdoaWNoXG4gICAgICAgICAgICAvLyB3ZSB3YW50IHRvIGRvIGlmICphbnkqIG9mIHRoZSByZXNwb25zZXMgYXJlbid0IHNhZmUgdG8gY2FjaGUuXG4gICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdiYWQtcHJlY2FjaGluZy1yZXNwb25zZScsIHtcbiAgICAgICAgICAgICAgICB1cmw6IHJlcXVlc3QudXJsLFxuICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYW55IHVzZXJzIHBsdWdpbnMgd2VyZSBhZGRlZCBjb250YWluaW5nIHRoZWlyIG93blxuICAgICAqIGBjYWNoZVdpbGxVcGRhdGVgIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRlZmF1bHQgY2FjaGVhYmxlIHJlc3BvbnNlIGxvZ2ljIChpLmUuXG4gICAgICogPDQwMCwgaW5jbHVkaW5nIG9wYXF1ZSByZXNwb25zZXMpIHNob3VsZCBiZSB1c2VkLiBJZiBhIGN1c3RvbSBwbHVnaW5cbiAgICAgKiB3aXRoIGEgYGNhY2hlV2lsbFVwZGF0ZWAgY2FsbGJhY2sgaXMgcGFzc2VkLCB0aGVuIHRoZSBzdHJhdGVneSBzaG91bGRcbiAgICAgKiBkZWZlciB0byB0aGF0IHBsdWdpbidzIGxvZ2ljLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXNlc0N1c3RvbUNhY2hlYWJsZVJlc3BvbnNlTG9naWMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBsdWdpbnMuc29tZSgocGx1Z2luKSA9PiBwbHVnaW4uY2FjaGVXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICBwbHVnaW4gIT09IGNvcHlSZWRpcmVjdGVkQ2FjaGVhYmxlUmVzcG9uc2VzUGx1Z2luKTtcbiAgICB9XG59XG5leHBvcnQgeyBQcmVjYWNoZVN0cmF0ZWd5IH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzJztcbmltcG9ydCB7IGNhY2hlTmFtZXMgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvY2FjaGVOYW1lcy5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IFdvcmtib3hFcnJvciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9Xb3JrYm94RXJyb3IuanMnO1xuaW1wb3J0IHsgd2FpdFVudGlsIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL3dhaXRVbnRpbC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDYWNoZUtleSB9IGZyb20gJy4vdXRpbHMvY3JlYXRlQ2FjaGVLZXkuanMnO1xuaW1wb3J0IHsgUHJlY2FjaGVJbnN0YWxsUmVwb3J0UGx1Z2luIH0gZnJvbSAnLi91dGlscy9QcmVjYWNoZUluc3RhbGxSZXBvcnRQbHVnaW4uanMnO1xuaW1wb3J0IHsgUHJlY2FjaGVDYWNoZUtleVBsdWdpbiB9IGZyb20gJy4vdXRpbHMvUHJlY2FjaGVDYWNoZUtleVBsdWdpbi5qcyc7XG5pbXBvcnQgeyBwcmludENsZWFudXBEZXRhaWxzIH0gZnJvbSAnLi91dGlscy9wcmludENsZWFudXBEZXRhaWxzLmpzJztcbmltcG9ydCB7IHByaW50SW5zdGFsbERldGFpbHMgfSBmcm9tICcuL3V0aWxzL3ByaW50SW5zdGFsbERldGFpbHMuanMnO1xuaW1wb3J0IHsgUHJlY2FjaGVTdHJhdGVneSB9IGZyb20gJy4vUHJlY2FjaGVTdHJhdGVneS5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBQZXJmb3JtcyBlZmZpY2llbnQgcHJlY2FjaGluZyBvZiBhc3NldHMuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmdcbiAqL1xuY2xhc3MgUHJlY2FjaGVDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgUHJlY2FjaGVDb250cm9sbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jYWNoZU5hbWVdIFRoZSBjYWNoZSB0byB1c2UgZm9yIHByZWNhY2hpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBsdWdpbnNdIFBsdWdpbnMgdG8gdXNlIHdoZW4gcHJlY2FjaGluZyBhcyB3ZWxsXG4gICAgICogYXMgcmVzcG9uZGluZyB0byBmZXRjaCBldmVudHMgZm9yIHByZWNhY2hlZCBhc3NldHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mYWxsYmFja1RvTmV0d29yaz10cnVlXSBXaGV0aGVyIHRvIGF0dGVtcHQgdG9cbiAgICAgKiBnZXQgdGhlIHJlc3BvbnNlIGZyb20gdGhlIG5ldHdvcmsgaWYgdGhlcmUncyBhIHByZWNhY2hlIG1pc3MuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBjYWNoZU5hbWUsIHBsdWdpbnMgPSBbXSwgZmFsbGJhY2tUb05ldHdvcmsgPSB0cnVlIH0gPSB7fSkge1xuICAgICAgICB0aGlzLl91cmxzVG9DYWNoZUtleXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3VybHNUb0NhY2hlTW9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NhY2hlS2V5c1RvSW50ZWdyaXRpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3N0cmF0ZWd5ID0gbmV3IFByZWNhY2hlU3RyYXRlZ3koe1xuICAgICAgICAgICAgY2FjaGVOYW1lOiBjYWNoZU5hbWVzLmdldFByZWNhY2hlTmFtZShjYWNoZU5hbWUpLFxuICAgICAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgICAgIC4uLnBsdWdpbnMsXG4gICAgICAgICAgICAgICAgbmV3IFByZWNhY2hlQ2FjaGVLZXlQbHVnaW4oeyBwcmVjYWNoZUNvbnRyb2xsZXI6IHRoaXMgfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZmFsbGJhY2tUb05ldHdvcmssXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBCaW5kIHRoZSBpbnN0YWxsIGFuZCBhY3RpdmF0ZSBtZXRob2RzIHRvIHRoZSBpbnN0YW5jZS5cbiAgICAgICAgdGhpcy5pbnN0YWxsID0gdGhpcy5pbnN0YWxsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSB0aGlzLmFjdGl2YXRlLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nLlByZWNhY2hlU3RyYXRlZ3l9IFRoZSBzdHJhdGVneSBjcmVhdGVkIGJ5IHRoaXMgY29udHJvbGxlciBhbmRcbiAgICAgKiB1c2VkIHRvIGNhY2hlIGFzc2V0cyBhbmQgcmVzcG9uZCB0byBmZXRjaCBldmVudHMuXG4gICAgICovXG4gICAgZ2V0IHN0cmF0ZWd5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RyYXRlZ3k7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgaXRlbXMgdG8gdGhlIHByZWNhY2hlIGxpc3QsIHJlbW92aW5nIGFueSBkdXBsaWNhdGVzIGFuZFxuICAgICAqIHN0b3JlcyB0aGUgZmlsZXMgaW4gdGhlXG4gICAgICogW1wicHJlY2FjaGUgY2FjaGVcIl17QGxpbmsgbW9kdWxlOndvcmtib3gtY29yZS5jYWNoZU5hbWVzfSB3aGVuIHRoZSBzZXJ2aWNlXG4gICAgICogd29ya2VyIGluc3RhbGxzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0fHN0cmluZz59IFtlbnRyaWVzPVtdXSBBcnJheSBvZiBlbnRyaWVzIHRvIHByZWNhY2hlLlxuICAgICAqL1xuICAgIHByZWNhY2hlKGVudHJpZXMpIHtcbiAgICAgICAgdGhpcy5hZGRUb0NhY2hlTGlzdChlbnRyaWVzKTtcbiAgICAgICAgaWYgKCF0aGlzLl9pbnN0YWxsQW5kQWN0aXZlTGlzdGVuZXJzQWRkZWQpIHtcbiAgICAgICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignaW5zdGFsbCcsIHRoaXMuaW5zdGFsbCk7XG4gICAgICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2FjdGl2YXRlJywgdGhpcy5hY3RpdmF0ZSk7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YWxsQW5kQWN0aXZlTGlzdGVuZXJzQWRkZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYWRkIGl0ZW1zIHRvIHRoZSBwcmVjYWNoZSBsaXN0LCByZW1vdmluZyBkdXBsaWNhdGVzXG4gICAgICogYW5kIGVuc3VyaW5nIHRoZSBpbmZvcm1hdGlvbiBpcyB2YWxpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5QcmVjYWNoZUNvbnRyb2xsZXIuUHJlY2FjaGVFbnRyeXxzdHJpbmc+fSBlbnRyaWVzXG4gICAgICogICAgIEFycmF5IG9mIGVudHJpZXMgdG8gcHJlY2FjaGUuXG4gICAgICovXG4gICAgYWRkVG9DYWNoZUxpc3QoZW50cmllcykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgYXNzZXJ0LmlzQXJyYXkoZW50cmllcywge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXByZWNhY2hpbmcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1ByZWNhY2hlQ29udHJvbGxlcicsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdhZGRUb0NhY2hlTGlzdCcsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnZW50cmllcycsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmxzVG9XYXJuQWJvdXQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8yMjU5XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHVybHNUb1dhcm5BYm91dC5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVudHJ5ICYmIGVudHJ5LnJldmlzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB1cmxzVG9XYXJuQWJvdXQucHVzaChlbnRyeS51cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBjYWNoZUtleSwgdXJsIH0gPSBjcmVhdGVDYWNoZUtleShlbnRyeSk7XG4gICAgICAgICAgICBjb25zdCBjYWNoZU1vZGUgPSAodHlwZW9mIGVudHJ5ICE9PSAnc3RyaW5nJyAmJiBlbnRyeS5yZXZpc2lvbikgP1xuICAgICAgICAgICAgICAgICdyZWxvYWQnIDogJ2RlZmF1bHQnO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VybHNUb0NhY2hlS2V5cy5oYXModXJsKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3VybHNUb0NhY2hlS2V5cy5nZXQodXJsKSAhPT0gY2FjaGVLZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdhZGQtdG8tY2FjaGUtbGlzdC1jb25mbGljdGluZy1lbnRyaWVzJywge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEVudHJ5OiB0aGlzLl91cmxzVG9DYWNoZUtleXMuZ2V0KHVybCksXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZEVudHJ5OiBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09ICdzdHJpbmcnICYmIGVudHJ5LmludGVncml0eSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYWNoZUtleXNUb0ludGVncml0aWVzLmhhcyhjYWNoZUtleSkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXlzVG9JbnRlZ3JpdGllcy5nZXQoY2FjaGVLZXkpICE9PSBlbnRyeS5pbnRlZ3JpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignYWRkLXRvLWNhY2hlLWxpc3QtY29uZmxpY3RpbmctaW50ZWdyaXRpZXMnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUtleXNUb0ludGVncml0aWVzLnNldChjYWNoZUtleSwgZW50cnkuaW50ZWdyaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VybHNUb0NhY2hlS2V5cy5zZXQodXJsLCBjYWNoZUtleSk7XG4gICAgICAgICAgICB0aGlzLl91cmxzVG9DYWNoZU1vZGVzLnNldCh1cmwsIGNhY2hlTW9kZSk7XG4gICAgICAgICAgICBpZiAodXJsc1RvV2FybkFib3V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXJuaW5nTWVzc2FnZSA9IGBXb3JrYm94IGlzIHByZWNhY2hpbmcgVVJMcyB3aXRob3V0IHJldmlzaW9uIGAgK1xuICAgICAgICAgICAgICAgICAgICBgaW5mbzogJHt1cmxzVG9XYXJuQWJvdXQuam9pbignLCAnKX1cXG5UaGlzIGlzIGdlbmVyYWxseSBOT1Qgc2FmZS4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBMZWFybiBtb3JlIGF0IGh0dHBzOi8vYml0Lmx5L3diLXByZWNhY2hlYDtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgY29uc29sZSBkaXJlY3RseSB0byBkaXNwbGF5IHRoaXMgd2FybmluZyB3aXRob3V0IGJsb2F0aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1bmRsZSBzaXplcyBieSBwdWxsaW5nIGluIGFsbCBvZiB0aGUgbG9nZ2VyIGNvZGViYXNlIGluIHByb2QuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2Fybih3YXJuaW5nTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZWNhY2hlcyBuZXcgYW5kIHVwZGF0ZWQgYXNzZXRzLiBDYWxsIHRoaXMgbWV0aG9kIGZyb20gdGhlIHNlcnZpY2Ugd29ya2VyXG4gICAgICogaW5zdGFsbCBldmVudC5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGNhbGxzIGBldmVudC53YWl0VW50aWwoKWAgZm9yIHlvdSwgc28geW91IGRvIG5vdCBuZWVkXG4gICAgICogdG8gY2FsbCBpdCB5b3Vyc2VsZiBpbiB5b3VyIGV2ZW50IGhhbmRsZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBvcHRpb25zLmV2ZW50IFRoZSBpbnN0YWxsIGV2ZW50LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8bW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5JbnN0YWxsUmVzdWx0Pn1cbiAgICAgKi9cbiAgICBpbnN0YWxsKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB3YWl0VW50aWwoZXZlbnQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbGxSZXBvcnRQbHVnaW4gPSBuZXcgUHJlY2FjaGVJbnN0YWxsUmVwb3J0UGx1Z2luKCk7XG4gICAgICAgICAgICB0aGlzLnN0cmF0ZWd5LnBsdWdpbnMucHVzaChpbnN0YWxsUmVwb3J0UGx1Z2luKTtcbiAgICAgICAgICAgIC8vIENhY2hlIGVudHJpZXMgb25lIGF0IGEgdGltZS5cbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL3dvcmtib3gvaXNzdWVzLzI1MjhcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3VybCwgY2FjaGVLZXldIG9mIHRoaXMuX3VybHNUb0NhY2hlS2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVncml0eSA9IHRoaXMuX2NhY2hlS2V5c1RvSW50ZWdyaXRpZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZU1vZGUgPSB0aGlzLl91cmxzVG9DYWNoZU1vZGVzLmdldCh1cmwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZWdyaXR5LFxuICAgICAgICAgICAgICAgICAgICBjYWNoZTogY2FjaGVNb2RlLFxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLnN0cmF0ZWd5LmhhbmRsZUFsbCh7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogeyBjYWNoZUtleSB9LFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHVwZGF0ZWRVUkxzLCBub3RVcGRhdGVkVVJMcyB9ID0gaW5zdGFsbFJlcG9ydFBsdWdpbjtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRJbnN0YWxsRGV0YWlscyh1cGRhdGVkVVJMcywgbm90VXBkYXRlZFVSTHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdXBkYXRlZFVSTHMsIG5vdFVwZGF0ZWRVUkxzIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGFzc2V0cyB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudCBpbiB0aGUgY3VycmVudCBwcmVjYWNoZSBtYW5pZmVzdC5cbiAgICAgKiBDYWxsIHRoaXMgbWV0aG9kIGZyb20gdGhlIHNlcnZpY2Ugd29ya2VyIGFjdGl2YXRlIGV2ZW50LlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgY2FsbHMgYGV2ZW50LndhaXRVbnRpbCgpYCBmb3IgeW91LCBzbyB5b3UgZG8gbm90IG5lZWRcbiAgICAgKiB0byBjYWxsIGl0IHlvdXJzZWxmIGluIHlvdXIgZXZlbnQgaGFuZGxlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V4dGVuZGFibGVFdmVudH1cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuQ2xlYW51cFJlc3VsdD59XG4gICAgICovXG4gICAgYWN0aXZhdGUoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHdhaXRVbnRpbChldmVudCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBzZWxmLmNhY2hlcy5vcGVuKHRoaXMuc3RyYXRlZ3kuY2FjaGVOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRseUNhY2hlZFJlcXVlc3RzID0gYXdhaXQgY2FjaGUua2V5cygpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRDYWNoZUtleXMgPSBuZXcgU2V0KHRoaXMuX3VybHNUb0NhY2hlS2V5cy52YWx1ZXMoKSk7XG4gICAgICAgICAgICBjb25zdCBkZWxldGVkVVJMcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIGN1cnJlbnRseUNhY2hlZFJlcXVlc3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFleHBlY3RlZENhY2hlS2V5cy5oYXMocmVxdWVzdC51cmwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhY2hlLmRlbGV0ZShyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZFVSTHMucHVzaChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBwcmludENsZWFudXBEZXRhaWxzKGRlbGV0ZWRVUkxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRlbGV0ZWRVUkxzIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbWFwcGluZyBvZiBhIHByZWNhY2hlZCBVUkwgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY2FjaGUga2V5LCB0YWtpbmdcbiAgICAgKiBpbnRvIGFjY291bnQgdGhlIHJldmlzaW9uIGluZm9ybWF0aW9uIGZvciB0aGUgVVJMLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TWFwPHN0cmluZywgc3RyaW5nPn0gQSBVUkwgdG8gY2FjaGUga2V5IG1hcHBpbmcuXG4gICAgICovXG4gICAgZ2V0VVJMc1RvQ2FjaGVLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJsc1RvQ2FjaGVLZXlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgdGhlIFVSTHMgdGhhdCBoYXZlIGJlZW4gcHJlY2FjaGVkIGJ5IHRoZSBjdXJyZW50XG4gICAgICogc2VydmljZSB3b3JrZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBUaGUgcHJlY2FjaGVkIFVSTHMuXG4gICAgICovXG4gICAgZ2V0Q2FjaGVkVVJMcygpIHtcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLl91cmxzVG9DYWNoZUtleXMua2V5cygpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2FjaGUga2V5IHVzZWQgZm9yIHN0b3JpbmcgYSBnaXZlbiBVUkwuIElmIHRoYXQgVVJMIGlzXG4gICAgICogdW52ZXJzaW9uZWQsIGxpa2UgYC9pbmRleC5odG1sJywgdGhlbiB0aGUgY2FjaGUga2V5IHdpbGwgYmUgdGhlIG9yaWdpbmFsXG4gICAgICogVVJMIHdpdGggYSBzZWFyY2ggcGFyYW1ldGVyIGFwcGVuZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBBIFVSTCB3aG9zZSBjYWNoZSBrZXkgeW91IHdhbnQgdG8gbG9vayB1cC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB2ZXJzaW9uZWQgVVJMIHRoYXQgY29ycmVzcG9uZHMgdG8gYSBjYWNoZSBrZXlcbiAgICAgKiBmb3IgdGhlIG9yaWdpbmFsIFVSTCwgb3IgdW5kZWZpbmVkIGlmIHRoYXQgVVJMIGlzbid0IHByZWNhY2hlZC5cbiAgICAgKi9cbiAgICBnZXRDYWNoZUtleUZvclVSTCh1cmwpIHtcbiAgICAgICAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLmhyZWYpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJsc1RvQ2FjaGVLZXlzLmdldCh1cmxPYmplY3QuaHJlZik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgYWN0cyBhcyBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yXG4gICAgICogW2BjYWNoZS5tYXRjaCgpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhY2hlL21hdGNoKVxuICAgICAqIHdpdGggdGhlIGZvbGxvd2luZyBkaWZmZXJlbmNlczpcbiAgICAgKlxuICAgICAqIC0gSXQga25vd3Mgd2hhdCB0aGUgbmFtZSBvZiB0aGUgcHJlY2FjaGUgaXMsIGFuZCBvbmx5IGNoZWNrcyBpbiB0aGF0IGNhY2hlLlxuICAgICAqIC0gSXQgYWxsb3dzIHlvdSB0byBwYXNzIGluIGFuIFwib3JpZ2luYWxcIiBVUkwgd2l0aG91dCB2ZXJzaW9uaW5nIHBhcmFtZXRlcnMsXG4gICAgICogYW5kIGl0IHdpbGwgYXV0b21hdGljYWxseSBsb29rIHVwIHRoZSBjb3JyZWN0IGNhY2hlIGtleSBmb3IgdGhlIGN1cnJlbnRseVxuICAgICAqIGFjdGl2ZSByZXZpc2lvbiBvZiB0aGF0IFVSTC5cbiAgICAgKlxuICAgICAqIEUuZy4sIGBtYXRjaFByZWNhY2hlKCdpbmRleC5odG1sJylgIHdpbGwgZmluZCB0aGUgY29ycmVjdCBwcmVjYWNoZWRcbiAgICAgKiByZXNwb25zZSBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2VydmljZSB3b3JrZXIsIGV2ZW4gaWYgdGhlIGFjdHVhbCBjYWNoZVxuICAgICAqIGtleSBpcyBgJy9pbmRleC5odG1sP19fV0JfUkVWSVNJT05fXz0xMjM0YWJjZCdgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UmVxdWVzdH0gcmVxdWVzdCBUaGUga2V5ICh3aXRob3V0IHJldmlzaW9uaW5nIHBhcmFtZXRlcnMpXG4gICAgICogdG8gbG9vayB1cCBpbiB0aGUgcHJlY2FjaGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxSZXNwb25zZXx1bmRlZmluZWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIG1hdGNoUHJlY2FjaGUocmVxdWVzdCkge1xuICAgICAgICBjb25zdCB1cmwgPSByZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCA/IHJlcXVlc3QudXJsIDogcmVxdWVzdDtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmdldENhY2hlS2V5Rm9yVVJMKHVybCk7XG4gICAgICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBzZWxmLmNhY2hlcy5vcGVuKHRoaXMuc3RyYXRlZ3kuY2FjaGVOYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5tYXRjaChjYWNoZUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbG9va3MgdXAgYHVybGAgaW4gdGhlIHByZWNhY2hlICh0YWtpbmcgaW50b1xuICAgICAqIGFjY291bnQgcmV2aXNpb24gaW5mb3JtYXRpb24pLCBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBgUmVzcG9uc2VgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgcHJlY2FjaGVkIFVSTCB3aGljaCB3aWxsIGJlIHVzZWQgdG8gbG9va3VwIHRoZVxuICAgICAqIGBSZXNwb25zZWAuXG4gICAgICogQHJldHVybiB7bW9kdWxlOndvcmtib3gtcm91dGluZ35oYW5kbGVyQ2FsbGJhY2t9XG4gICAgICovXG4gICAgY3JlYXRlSGFuZGxlckJvdW5kVG9VUkwodXJsKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5nZXRDYWNoZUtleUZvclVSTCh1cmwpO1xuICAgICAgICBpZiAoIWNhY2hlS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdub24tcHJlY2FjaGVkLXVybCcsIHsgdXJsIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgb3B0aW9ucy5yZXF1ZXN0ID0gbmV3IFJlcXVlc3QodXJsKTtcbiAgICAgICAgICAgIG9wdGlvbnMucGFyYW1zID0geyBjYWNoZUtleSwgLi4ub3B0aW9ucy5wYXJhbXMgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmF0ZWd5LmhhbmRsZShvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgeyBQcmVjYWNoZUNvbnRyb2xsZXIgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IFByZWNhY2hlQ29udHJvbGxlciB9IGZyb20gJy4uL1ByZWNhY2hlQ29udHJvbGxlci5qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbmxldCBwcmVjYWNoZUNvbnRyb2xsZXI7XG4vKipcbiAqIEByZXR1cm4ge1ByZWNhY2hlQ29udHJvbGxlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRPckNyZWF0ZVByZWNhY2hlQ29udHJvbGxlciA9ICgpID0+IHtcbiAgICBpZiAoIXByZWNhY2hlQ29udHJvbGxlcikge1xuICAgICAgICBwcmVjYWNoZUNvbnRyb2xsZXIgPSBuZXcgUHJlY2FjaGVDb250cm9sbGVyKCk7XG4gICAgfVxuICAgIHJldHVybiBwcmVjYWNoZUNvbnRyb2xsZXI7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBAdHMtaWdub3JlXG50cnkge1xuICAgIHNlbGZbJ3dvcmtib3g6cm91dGluZzo2LjAuMiddICYmIF8oKTtcbn1cbmNhdGNoIChlKSB7IH1cbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBIVFRQIG1ldGhvZCwgJ0dFVCcsIHVzZWQgd2hlbiB0aGVyZSdzIG5vIHNwZWNpZmljIG1ldGhvZFxuICogY29uZmlndXJlZCBmb3IgYSByb3V0ZS5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0TWV0aG9kID0gJ0dFVCc7XG4vKipcbiAqIFRoZSBsaXN0IG9mIHZhbGlkIEhUVFAgbWV0aG9kcyBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdHMgdGhhdCBjb3VsZCBiZSByb3V0ZWQuXG4gKlxuICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IHZhbGlkTWV0aG9kcyA9IFtcbiAgICAnREVMRVRFJyxcbiAgICAnR0VUJyxcbiAgICAnSEVBRCcsXG4gICAgJ1BBVENIJyxcbiAgICAnUE9TVCcsXG4gICAgJ1BVVCcsXG5dO1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2Fzc2VydC5qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbigpfE9iamVjdH0gaGFuZGxlciBFaXRoZXIgYSBmdW5jdGlvbiwgb3IgYW4gb2JqZWN0IHdpdGggYVxuICogJ2hhbmRsZScgbWV0aG9kLlxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIGhhbmRsZSBtZXRob2QuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZUhhbmRsZXIgPSAoaGFuZGxlcikgPT4ge1xuICAgIGlmIChoYW5kbGVyICYmIHR5cGVvZiBoYW5kbGVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgYXNzZXJ0Lmhhc01ldGhvZChoYW5kbGVyLCAnaGFuZGxlJywge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXJvdXRpbmcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1JvdXRlJyxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdoYW5kbGVyJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc1R5cGUoaGFuZGxlciwgJ2Z1bmN0aW9uJywge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXJvdXRpbmcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1JvdXRlJyxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdoYW5kbGVyJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGhhbmRsZTogaGFuZGxlciB9O1xuICAgIH1cbn07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzJztcbmltcG9ydCB7IGRlZmF1bHRNZXRob2QsIHZhbGlkTWV0aG9kcyB9IGZyb20gJy4vdXRpbHMvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IG5vcm1hbGl6ZUhhbmRsZXIgfSBmcm9tICcuL3V0aWxzL25vcm1hbGl6ZUhhbmRsZXIuanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogQSBgUm91dGVgIGNvbnNpc3RzIG9mIGEgcGFpciBvZiBjYWxsYmFjayBmdW5jdGlvbnMsIFwibWF0Y2hcIiBhbmQgXCJoYW5kbGVyXCIuXG4gKiBUaGUgXCJtYXRjaFwiIGNhbGxiYWNrIGRldGVybWluZSBpZiBhIHJvdXRlIHNob3VsZCBiZSB1c2VkIHRvIFwiaGFuZGxlXCIgYVxuICogcmVxdWVzdCBieSByZXR1cm5pbmcgYSBub24tZmFsc3kgdmFsdWUgaWYgaXQgY2FuLiBUaGUgXCJoYW5kbGVyXCIgY2FsbGJhY2tcbiAqIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIGEgbWF0Y2ggYW5kIHNob3VsZCByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXNcbiAqIHRvIGEgYFJlc3BvbnNlYC5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtcm91dGluZ1xuICovXG5jbGFzcyBSb3V0ZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIFJvdXRlIGNsYXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6d29ya2JveC1yb3V0aW5nfm1hdGNoQ2FsbGJhY2t9IG1hdGNoXG4gICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgcm91dGUgbWF0Y2hlcyBhIGdpdmVuXG4gICAgICogYGZldGNoYCBldmVudCBieSByZXR1cm5pbmcgYSBub24tZmFsc3kgdmFsdWUuXG4gICAgICogQHBhcmFtIHttb2R1bGU6d29ya2JveC1yb3V0aW5nfmhhbmRsZXJDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrXG4gICAgICogZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZSByZXNvbHZpbmcgdG8gYSBSZXNwb25zZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21ldGhvZD0nR0VUJ10gVGhlIEhUVFAgbWV0aG9kIHRvIG1hdGNoIHRoZSBSb3V0ZVxuICAgICAqIGFnYWluc3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWF0Y2gsIGhhbmRsZXIsIG1ldGhvZCA9IGRlZmF1bHRNZXRob2QpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc1R5cGUobWF0Y2gsICdmdW5jdGlvbicsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdSb3V0ZScsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnbWF0Y2gnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmlzT25lT2YobWV0aG9kLCB2YWxpZE1ldGhvZHMsIHsgcGFyYW1OYW1lOiAnbWV0aG9kJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVzZSB2YWx1ZXMgYXJlIHJlZmVyZW5jZWQgZGlyZWN0bHkgYnkgUm91dGVyIHNvIGNhbm5vdCBiZVxuICAgICAgICAvLyBhbHRlcmVkIGJ5IG1pbmlmaWNhdG9uLlxuICAgICAgICB0aGlzLmhhbmRsZXIgPSBub3JtYWxpemVIYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB0aGlzLm1hdGNoID0gbWF0Y2g7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgIH1cbn1cbmV4cG9ydCB7IFJvdXRlIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMnO1xuaW1wb3J0IHsgUm91dGUgfSBmcm9tICcuL1JvdXRlLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIFJlZ0V4cFJvdXRlIG1ha2VzIGl0IGVhc3kgdG8gY3JlYXRlIGEgcmVndWxhciBleHByZXNzaW9uIGJhc2VkXG4gKiBbUm91dGVde0BsaW5rIG1vZHVsZTp3b3JrYm94LXJvdXRpbmcuUm91dGV9LlxuICpcbiAqIEZvciBzYW1lLW9yaWdpbiByZXF1ZXN0cyB0aGUgUmVnRXhwIG9ubHkgbmVlZHMgdG8gbWF0Y2ggcGFydCBvZiB0aGUgVVJMLiBGb3JcbiAqIHJlcXVlc3RzIGFnYWluc3QgdGhpcmQtcGFydHkgc2VydmVycywgeW91IG11c3QgZGVmaW5lIGEgUmVnRXhwIHRoYXQgbWF0Y2hlc1xuICogdGhlIHN0YXJ0IG9mIHRoZSBVUkwuXG4gKlxuICogW1NlZSB0aGUgbW9kdWxlIGRvY3MgZm9yIGluZm8uXXtAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdG9vbHMvd29ya2JveC9tb2R1bGVzL3dvcmtib3gtcm91dGluZ31cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtcm91dGluZ1xuICogQGV4dGVuZHMgbW9kdWxlOndvcmtib3gtcm91dGluZy5Sb3V0ZVxuICovXG5jbGFzcyBSZWdFeHBSb3V0ZSBleHRlbmRzIFJvdXRlIHtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgcmVndWxhciBleHByZXNzaW9uIGNvbnRhaW5zXG4gICAgICogW2NhcHR1cmUgZ3JvdXBzXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHAjZ3JvdXBpbmctYmFjay1yZWZlcmVuY2VzfSxcbiAgICAgKiB0aGUgY2FwdHVyZWQgdmFsdWVzIHdpbGwgYmUgcGFzc2VkIHRvIHRoZVxuICAgICAqIFtoYW5kbGVyJ3Nde0BsaW5rIG1vZHVsZTp3b3JrYm94LXJvdXRpbmd+aGFuZGxlckNhbGxiYWNrfSBgcGFyYW1zYFxuICAgICAqIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ0V4cCBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIGFnYWluc3QgVVJMcy5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp3b3JrYm94LXJvdXRpbmd+aGFuZGxlckNhbGxiYWNrfSBoYW5kbGVyIEEgY2FsbGJhY2tcbiAgICAgKiBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBQcm9taXNlIHJlc3VsdGluZyBpbiBhIFJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0aG9kPSdHRVQnXSBUaGUgSFRUUCBtZXRob2QgdG8gbWF0Y2ggdGhlIFJvdXRlXG4gICAgICogYWdhaW5zdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZWdFeHAsIGhhbmRsZXIsIG1ldGhvZCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgYXNzZXJ0LmlzSW5zdGFuY2UocmVnRXhwLCBSZWdFeHAsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdSZWdFeHBSb3V0ZScsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAncGF0dGVybicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaCA9ICh7IHVybCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWdFeHAuZXhlYyh1cmwuaHJlZik7XG4gICAgICAgICAgICAvLyBSZXR1cm4gaW1tZWRpYXRlbHkgaWYgdGhlcmUncyBubyBtYXRjaC5cbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVxdWlyZSB0aGF0IHRoZSBtYXRjaCBzdGFydCBhdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSBVUkwgc3RyaW5nXG4gICAgICAgICAgICAvLyBpZiBpdCdzIGEgY3Jvc3Mtb3JpZ2luIHJlcXVlc3QuXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8yODEgZm9yIHRoZSBjb250ZXh0XG4gICAgICAgICAgICAvLyBiZWhpbmQgdGhpcyBiZWhhdmlvci5cbiAgICAgICAgICAgIGlmICgodXJsLm9yaWdpbiAhPT0gbG9jYXRpb24ub3JpZ2luKSAmJiAocmVzdWx0LmluZGV4ICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAnJHtyZWdFeHB9JyBvbmx5IHBhcnRpYWxseSBtYXRjaGVkIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGFnYWluc3QgdGhlIGNyb3NzLW9yaWdpbiBVUkwgJyR7dXJsfScuIFJlZ0V4cFJvdXRlJ3Mgd2lsbCBvbmx5IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGhhbmRsZSBjcm9zcy1vcmlnaW4gcmVxdWVzdHMgaWYgdGhleSBtYXRjaCB0aGUgZW50aXJlIFVSTC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIHJvdXRlIG1hdGNoZXMsIGJ1dCB0aGVyZSBhcmVuJ3QgYW55IGNhcHR1cmUgZ3JvdXBzIGRlZmluZWQsIHRoZW5cbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCByZXR1cm4gW10sIHdoaWNoIGlzIHRydXRoeSBhbmQgdGhlcmVmb3JlIHN1ZmZpY2llbnQgdG9cbiAgICAgICAgICAgIC8vIGluZGljYXRlIGEgbWF0Y2guXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgY2FwdHVyZSBncm91cHMsIHRoZW4gaXQgd2lsbCByZXR1cm4gdGhlaXIgdmFsdWVzLlxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zbGljZSgxKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIobWF0Y2gsIGhhbmRsZXIsIG1ldGhvZCk7XG4gICAgfVxufVxuZXhwb3J0IHsgUmVnRXhwUm91dGUgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9hc3NlcnQuanMnO1xuaW1wb3J0IHsgZ2V0RnJpZW5kbHlVUkwgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwuanMnO1xuaW1wb3J0IHsgZGVmYXVsdE1ldGhvZCB9IGZyb20gJy4vdXRpbHMvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMnO1xuaW1wb3J0IHsgbm9ybWFsaXplSGFuZGxlciB9IGZyb20gJy4vdXRpbHMvbm9ybWFsaXplSGFuZGxlci5qcyc7XG5pbXBvcnQgeyBXb3JrYm94RXJyb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIFRoZSBSb3V0ZXIgY2FuIGJlIHVzZWQgdG8gcHJvY2VzcyBhIEZldGNoRXZlbnQgdGhyb3VnaCBvbmUgb3IgbW9yZVxuICogW1JvdXRlc117QGxpbmsgbW9kdWxlOndvcmtib3gtcm91dGluZy5Sb3V0ZX0gcmVzcG9uZGluZyAgd2l0aCBhIFJlcXVlc3QgaWZcbiAqIGEgbWF0Y2hpbmcgcm91dGUgZXhpc3RzLlxuICpcbiAqIElmIG5vIHJvdXRlIG1hdGNoZXMgYSBnaXZlbiBhIHJlcXVlc3QsIHRoZSBSb3V0ZXIgd2lsbCB1c2UgYSBcImRlZmF1bHRcIlxuICogaGFuZGxlciBpZiBvbmUgaXMgZGVmaW5lZC5cbiAqXG4gKiBTaG91bGQgdGhlIG1hdGNoaW5nIFJvdXRlIHRocm93IGFuIGVycm9yLCB0aGUgUm91dGVyIHdpbGwgdXNlIGEgXCJjYXRjaFwiXG4gKiBoYW5kbGVyIGlmIG9uZSBpcyBkZWZpbmVkIHRvIGdyYWNlZnVsbHkgZGVhbCB3aXRoIGlzc3VlcyBhbmQgcmVzcG9uZCB3aXRoIGFcbiAqIFJlcXVlc3QuXG4gKlxuICogSWYgYSByZXF1ZXN0IG1hdGNoZXMgbXVsdGlwbGUgcm91dGVzLCB0aGUgKiplYXJsaWVzdCoqIHJlZ2lzdGVyZWQgcm91dGUgd2lsbFxuICogYmUgdXNlZCB0byByZXNwb25kIHRvIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1yb3V0aW5nXG4gKi9cbmNsYXNzIFJvdXRlciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgUm91dGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9yb3V0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRIYW5kbGVyTWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtNYXA8c3RyaW5nLCBBcnJheTxtb2R1bGU6d29ya2JveC1yb3V0aW5nLlJvdXRlPj59IHJvdXRlcyBBIGBNYXBgIG9mIEhUVFBcbiAgICAgKiBtZXRob2QgbmFtZSAoJ0dFVCcsIGV0Yy4pIHRvIGFuIGFycmF5IG9mIGFsbCB0aGUgY29ycmVzcG9uZGluZyBgUm91dGVgXG4gICAgICogaW5zdGFuY2VzIHRoYXQgYXJlIHJlZ2lzdGVyZWQuXG4gICAgICovXG4gICAgZ2V0IHJvdXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvdXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGZldGNoIGV2ZW50IGxpc3RlbmVyIHRvIHJlc3BvbmQgdG8gZXZlbnRzIHdoZW4gYSByb3V0ZSBtYXRjaGVzXG4gICAgICogdGhlIGV2ZW50J3MgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhZGRGZXRjaExpc3RlbmVyKCkge1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yODM1NyNpc3N1ZWNvbW1lbnQtNDM2NDg0NzA1XG4gICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignZmV0Y2gnLCAoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHJlcXVlc3QgfSA9IGV2ZW50O1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gdGhpcy5oYW5kbGVSZXF1ZXN0KHsgcmVxdWVzdCwgZXZlbnQgfSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucmVzcG9uZFdpdGgocmVzcG9uc2VQcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbWVzc2FnZSBldmVudCBsaXN0ZW5lciBmb3IgVVJMcyB0byBjYWNoZSBmcm9tIHRoZSB3aW5kb3cuXG4gICAgICogVGhpcyBpcyB1c2VmdWwgdG8gY2FjaGUgcmVzb3VyY2VzIGxvYWRlZCBvbiB0aGUgcGFnZSBwcmlvciB0byB3aGVuIHRoZVxuICAgICAqIHNlcnZpY2Ugd29ya2VyIHN0YXJ0ZWQgY29udHJvbGxpbmcgaXQuXG4gICAgICpcbiAgICAgKiBUaGUgZm9ybWF0IG9mIHRoZSBtZXNzYWdlIGRhdGEgc2VudCBmcm9tIHRoZSB3aW5kb3cgc2hvdWxkIGJlIGFzIGZvbGxvd3MuXG4gICAgICogV2hlcmUgdGhlIGB1cmxzVG9DYWNoZWAgYXJyYXkgbWF5IGNvbnNpc3Qgb2YgVVJMIHN0cmluZ3Mgb3IgYW4gYXJyYXkgb2ZcbiAgICAgKiBVUkwgc3RyaW5nICsgYHJlcXVlc3RJbml0YCBvYmplY3QgKHRoZSBzYW1lIGFzIHlvdSdkIHBhc3MgdG8gYGZldGNoKClgKS5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHtcbiAgICAgKiAgIHR5cGU6ICdDQUNIRV9VUkxTJyxcbiAgICAgKiAgIHBheWxvYWQ6IHtcbiAgICAgKiAgICAgdXJsc1RvQ2FjaGU6IFtcbiAgICAgKiAgICAgICAnLi9zY3JpcHQxLmpzJyxcbiAgICAgKiAgICAgICAnLi9zY3JpcHQyLmpzJyxcbiAgICAgKiAgICAgICBbJy4vc2NyaXB0My5qcycsIHttb2RlOiAnbm8tY29ycyd9XSxcbiAgICAgKiAgICAgXSxcbiAgICAgKiAgIH0sXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFkZENhY2hlTGlzdGVuZXIoKSB7XG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzI4MzU3I2lzc3VlY29tbWVudC00MzY0ODQ3MDVcbiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS50eXBlID09PSAnQ0FDSEVfVVJMUycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBheWxvYWQgfSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBDYWNoaW5nIFVSTHMgZnJvbSB0aGUgd2luZG93YCwgcGF5bG9hZC51cmxzVG9DYWNoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RQcm9taXNlcyA9IFByb21pc2UuYWxsKHBheWxvYWQudXJsc1RvQ2FjaGUubWFwKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkgPSBbZW50cnldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCguLi5lbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJlcXVlc3QoeyByZXF1ZXN0LCBldmVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhwaGlsaXB3YWx0b24pOiBUeXBlU2NyaXB0IGVycm9ycyB3aXRob3V0IHRoaXMgdHlwZWNhc3QgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvbWUgcmVhc29uIChwcm9iYWJseSBhIGJ1ZykuIFRoZSByZWFsIHR5cGUgaGVyZSBzaG91bGQgd29yayBidXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9lc24ndDogYEFycmF5PFByb21pc2U8UmVzcG9uc2U+IHwgdW5kZWZpbmVkPmAuXG4gICAgICAgICAgICAgICAgfSkpOyAvLyBUeXBlU2NyaXB0XG4gICAgICAgICAgICAgICAgZXZlbnQud2FpdFVudGlsKHJlcXVlc3RQcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBNZXNzYWdlQ2hhbm5lbCB3YXMgdXNlZCwgcmVwbHkgdG8gdGhlIG1lc3NhZ2Ugb24gc3VjY2Vzcy5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQucG9ydHMgJiYgZXZlbnQucG9ydHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFByb21pc2VzLnRoZW4oKCkgPT4gZXZlbnQucG9ydHNbMF0ucG9zdE1lc3NhZ2UodHJ1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgcm91dGluZyBydWxlcyB0byBhIEZldGNoRXZlbnQgb2JqZWN0IHRvIGdldCBhIFJlc3BvbnNlIGZyb20gYW5cbiAgICAgKiBhcHByb3ByaWF0ZSBSb3V0ZSdzIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7UmVxdWVzdH0gb3B0aW9ucy5yZXF1ZXN0IFRoZSByZXF1ZXN0IHRvIGhhbmRsZS5cbiAgICAgKiBAcGFyYW0ge0V4dGVuZGFibGVFdmVudH0gb3B0aW9ucy5ldmVudCBUaGUgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhlXG4gICAgICogICAgIHJlcXVlc3QuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxSZXNwb25zZT58dW5kZWZpbmVkfSBBIHByb21pc2UgaXMgcmV0dXJuZWQgaWYgYVxuICAgICAqICAgICByZWdpc3RlcmVkIHJvdXRlIGNhbiBoYW5kbGUgdGhlIHJlcXVlc3QuIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nXG4gICAgICogICAgIHJvdXRlIGFuZCB0aGVyZSdzIG5vIGBkZWZhdWx0SGFuZGxlcmAsIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGhhbmRsZVJlcXVlc3QoeyByZXF1ZXN0LCBldmVudCB9KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBhc3NlcnQuaXNJbnN0YW5jZShyZXF1ZXN0LCBSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUm91dGVyJyxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ2hhbmRsZVJlcXVlc3QnLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ29wdGlvbnMucmVxdWVzdCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsLCBsb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgaWYgKCF1cmwucHJvdG9jb2wuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgV29ya2JveCBSb3V0ZXIgb25seSBzdXBwb3J0cyBVUkxzIHRoYXQgc3RhcnQgd2l0aCAnaHR0cCcuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2FtZU9yaWdpbiA9IHVybC5vcmlnaW4gPT09IGxvY2F0aW9uLm9yaWdpbjtcbiAgICAgICAgY29uc3QgeyBwYXJhbXMsIHJvdXRlIH0gPSB0aGlzLmZpbmRNYXRjaGluZ1JvdXRlKHtcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHNhbWVPcmlnaW4sXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgaGFuZGxlciA9IHJvdXRlICYmIHJvdXRlLmhhbmRsZXI7XG4gICAgICAgIGNvbnN0IGRlYnVnTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgZGVidWdNZXNzYWdlcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgYEZvdW5kIGEgcm91dGUgdG8gaGFuZGxlIHRoaXMgcmVxdWVzdDpgLCByb3V0ZSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTWVzc2FnZXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBgUGFzc2luZyB0aGUgZm9sbG93aW5nIHBhcmFtcyB0byB0aGUgcm91dGUncyBoYW5kbGVyOmAsIHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBoYW5kbGVyIGJlY2F1c2UgdGhlcmUgd2FzIG5vIG1hdGNoaW5nIHJvdXRlLCB0aGVuXG4gICAgICAgIC8vIGZhbGwgYmFjayB0byBkZWZhdWx0SGFuZGxlciBpZiB0aGF0J3MgZGVmaW5lZC5cbiAgICAgICAgY29uc3QgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgICAgIGlmICghaGFuZGxlciAmJiB0aGlzLl9kZWZhdWx0SGFuZGxlck1hcC5oYXMobWV0aG9kKSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z01lc3NhZ2VzLnB1c2goYEZhaWxlZCB0byBmaW5kIGEgbWF0Y2hpbmcgcm91dGUuIEZhbGxpbmcgYCArXG4gICAgICAgICAgICAgICAgICAgIGBiYWNrIHRvIHRoZSBkZWZhdWx0IGhhbmRsZXIgZm9yICR7bWV0aG9kfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZXIgPSB0aGlzLl9kZWZhdWx0SGFuZGxlck1hcC5nZXQobWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gaGFuZGxlciBzbyBXb3JrYm94IHdpbGwgZG8gbm90aGluZy4gSWYgbG9ncyBpcyBzZXQgb2YgZGVidWdcbiAgICAgICAgICAgICAgICAvLyBpLmUuIHZlcmJvc2UsIHdlIHNob3VsZCBwcmludCBvdXQgdGhpcyBpbmZvcm1hdGlvbi5cbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYE5vIHJvdXRlIGZvdW5kIGZvcjogJHtnZXRGcmllbmRseVVSTCh1cmwpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGEgaGFuZGxlciwgbWVhbmluZyBXb3JrYm94IGlzIGdvaW5nIHRvIGhhbmRsZSB0aGUgcm91dGUuXG4gICAgICAgICAgICAvLyBwcmludCB0aGUgcm91dGluZyBkZXRhaWxzIHRvIHRoZSBjb25zb2xlLlxuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBSb3V0ZXIgaXMgcmVzcG9uZGluZyB0bzogJHtnZXRGcmllbmRseVVSTCh1cmwpfWApO1xuICAgICAgICAgICAgZGVidWdNZXNzYWdlcy5mb3JFYWNoKChtc2cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtc2cpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coLi4ubXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2cobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdyYXAgaW4gdHJ5IGFuZCBjYXRjaCBpbiBjYXNlIHRoZSBoYW5kbGUgbWV0aG9kIHRocm93cyBhIHN5bmNocm9ub3VzXG4gICAgICAgIC8vIGVycm9yLiBJdCBzaG91bGQgc3RpbGwgY2FsbGJhY2sgdG8gdGhlIGNhdGNoIGhhbmRsZXIuXG4gICAgICAgIGxldCByZXNwb25zZVByb21pc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2UgPSBoYW5kbGVyLmhhbmRsZSh7IHVybCwgcmVxdWVzdCwgZXZlbnQsIHBhcmFtcyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2UgPSBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlICYmIHRoaXMuX2NhdGNoSGFuZGxlcikge1xuICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlID0gcmVzcG9uc2VQcm9taXNlLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGlsbCBpbmNsdWRlIFVSTCBoZXJlIGFzIGl0IHdpbGwgYmUgYXN5bmMgZnJvbSB0aGUgY29uc29sZSBncm91cFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbWF5IG5vdCBtYWtlIHNlbnNlIHdpdGhvdXQgdGhlIFVSTFxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoYEVycm9yIHRocm93biB3aGVuIHJlc3BvbmRpbmcgdG86IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCAke2dldEZyaWVuZGx5VVJMKHVybCl9LiBGYWxsaW5nIGJhY2sgdG8gQ2F0Y2ggSGFuZGxlci5gKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBFcnJvciB0aHJvd24gYnk6YCwgcm91dGUpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYXRjaEhhbmRsZXIuaGFuZGxlKHsgdXJsLCByZXF1ZXN0LCBldmVudCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBhIHJlcXVlc3QgYW5kIFVSTCAoYW5kIG9wdGlvbmFsbHkgYW4gZXZlbnQpIGFnYWluc3QgdGhlIGxpc3Qgb2ZcbiAgICAgKiByZWdpc3RlcmVkIHJvdXRlcywgYW5kIGlmIHRoZXJlJ3MgYSBtYXRjaCwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqIHJvdXRlIGFsb25nIHdpdGggYW55IHBhcmFtcyBnZW5lcmF0ZWQgYnkgdGhlIG1hdGNoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1VSTH0gb3B0aW9ucy51cmxcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R9IG9wdGlvbnMucmVxdWVzdCBUaGUgcmVxdWVzdCB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBvcHRpb25zLmV2ZW50IFRoZSBjb3JyZXNwb25kaW5nIGV2ZW50LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggYHJvdXRlYCBhbmQgYHBhcmFtc2AgcHJvcGVydGllcy5cbiAgICAgKiAgICAgVGhleSBhcmUgcG9wdWxhdGVkIGlmIGEgbWF0Y2hpbmcgcm91dGUgd2FzIGZvdW5kIG9yIGB1bmRlZmluZWRgXG4gICAgICogICAgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBmaW5kTWF0Y2hpbmdSb3V0ZSh7IHVybCwgc2FtZU9yaWdpbiwgcmVxdWVzdCwgZXZlbnQgfSkge1xuICAgICAgICBjb25zdCByb3V0ZXMgPSB0aGlzLl9yb3V0ZXMuZ2V0KHJlcXVlc3QubWV0aG9kKSB8fCBbXTtcbiAgICAgICAgZm9yIChjb25zdCByb3V0ZSBvZiByb3V0ZXMpIHtcbiAgICAgICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgICAgICBjb25zdCBtYXRjaFJlc3VsdCA9IHJvdXRlLm1hdGNoKHsgdXJsLCBzYW1lT3JpZ2luLCByZXF1ZXN0LCBldmVudCB9KTtcbiAgICAgICAgICAgIGlmIChtYXRjaFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdhcm4gZGV2ZWxvcGVycyB0aGF0IHVzaW5nIGFuIGFzeW5jIG1hdGNoQ2FsbGJhY2sgaXMgYWxtb3N0IGFsd2F5c1xuICAgICAgICAgICAgICAgICAgICAvLyBub3QgdGhlIHJpZ2h0IHRoaW5nIHRvIGRvLiBcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoUmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFdoaWxlIHJvdXRpbmcgJHtnZXRGcmllbmRseVVSTCh1cmwpfSwgYW4gYXN5bmMgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYG1hdGNoQ2FsbGJhY2sgZnVuY3Rpb24gd2FzIHVzZWQuIFBsZWFzZSBjb252ZXJ0IHRoZSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgZm9sbG93aW5nIHJvdXRlIHRvIHVzZSBhIHN5bmNocm9ub3VzIG1hdGNoQ2FsbGJhY2sgZnVuY3Rpb246YCwgcm91dGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL3dvcmtib3gvaXNzdWVzLzIwNzlcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBtYXRjaFJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRjaFJlc3VsdCkgJiYgbWF0Y2hSZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgcGFzc2luZyBhbiBlbXB0eSBhcnJheSBpbiBhcyBwYXJhbXMsIHVzZSB1bmRlZmluZWQuXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKG1hdGNoUmVzdWx0LmNvbnN0cnVjdG9yID09PSBPYmplY3QgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMobWF0Y2hSZXN1bHQpLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiBwYXNzaW5nIGFuIGVtcHR5IG9iamVjdCBpbiBhcyBwYXJhbXMsIHVzZSB1bmRlZmluZWQuXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1hdGNoUmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHRoZSBib29sZWFuIHZhbHVlIHRydWUgKHJhdGhlciB0aGFuIGp1c3Qgc29tZXRoaW5nIHRydXRoLXkpLFxuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzZXQgcGFyYW1zLlxuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L3B1bGwvMjEzNCNpc3N1ZWNvbW1lbnQtNTEzOTI0MzUzXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGlmIGhhdmUgYSBtYXRjaC5cbiAgICAgICAgICAgICAgICByZXR1cm4geyByb3V0ZSwgcGFyYW1zIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gbWF0Y2ggd2FzIGZvdW5kIGFib3ZlLCByZXR1cm4gYW5kIGVtcHR5IG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgYSBkZWZhdWx0IGBoYW5kbGVyYCB0aGF0J3MgY2FsbGVkIHdoZW4gbm8gcm91dGVzIGV4cGxpY2l0bHlcbiAgICAgKiBtYXRjaCB0aGUgaW5jb21pbmcgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEVhY2ggSFRUUCBtZXRob2QgKCdHRVQnLCAnUE9TVCcsIGV0Yy4pIGdldHMgaXRzIG93biBkZWZhdWx0IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBXaXRob3V0IGEgZGVmYXVsdCBoYW5kbGVyLCB1bm1hdGNoZWQgcmVxdWVzdHMgd2lsbCBnbyBhZ2FpbnN0IHRoZVxuICAgICAqIG5ldHdvcmsgYXMgaWYgdGhlcmUgd2VyZSBubyBzZXJ2aWNlIHdvcmtlciBwcmVzZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6d29ya2JveC1yb3V0aW5nfmhhbmRsZXJDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrXG4gICAgICogZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZSByZXN1bHRpbmcgaW4gYSBSZXNwb25zZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21ldGhvZD0nR0VUJ10gVGhlIEhUVFAgbWV0aG9kIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXNcbiAgICAgKiBkZWZhdWx0IGhhbmRsZXIuIEVhY2ggbWV0aG9kIGhhcyBpdHMgb3duIGRlZmF1bHQuXG4gICAgICovXG4gICAgc2V0RGVmYXVsdEhhbmRsZXIoaGFuZGxlciwgbWV0aG9kID0gZGVmYXVsdE1ldGhvZCkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0SGFuZGxlck1hcC5zZXQobWV0aG9kLCBub3JtYWxpemVIYW5kbGVyKGhhbmRsZXIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgYSBSb3V0ZSB0aHJvd3MgYW4gZXJyb3Igd2hpbGUgaGFuZGxpbmcgYSByZXF1ZXN0LCB0aGlzIGBoYW5kbGVyYFxuICAgICAqIHdpbGwgYmUgY2FsbGVkIGFuZCBnaXZlbiBhIGNoYW5jZSB0byBwcm92aWRlIGEgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp3b3JrYm94LXJvdXRpbmd+aGFuZGxlckNhbGxiYWNrfSBoYW5kbGVyIEEgY2FsbGJhY2tcbiAgICAgKiBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBQcm9taXNlIHJlc3VsdGluZyBpbiBhIFJlc3BvbnNlLlxuICAgICAqL1xuICAgIHNldENhdGNoSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX2NhdGNoSGFuZGxlciA9IG5vcm1hbGl6ZUhhbmRsZXIoaGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIHJvdXRlIHdpdGggdGhlIHJvdXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtcm91dGluZy5Sb3V0ZX0gcm91dGUgVGhlIHJvdXRlIHRvIHJlZ2lzdGVyLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyUm91dGUocm91dGUpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc1R5cGUocm91dGUsICdvYmplY3QnLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUm91dGVyJyxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ3JlZ2lzdGVyUm91dGUnLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ3JvdXRlJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXNzZXJ0Lmhhc01ldGhvZChyb3V0ZSwgJ21hdGNoJywge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXJvdXRpbmcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1JvdXRlcicsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdyZWdpc3RlclJvdXRlJyxcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdyb3V0ZScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFzc2VydC5pc1R5cGUocm91dGUuaGFuZGxlciwgJ29iamVjdCcsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdSb3V0ZXInLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAncmVnaXN0ZXJSb3V0ZScsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAncm91dGUnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3NlcnQuaGFzTWV0aG9kKHJvdXRlLmhhbmRsZXIsICdoYW5kbGUnLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUm91dGVyJyxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ3JlZ2lzdGVyUm91dGUnLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ3JvdXRlLmhhbmRsZXInLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3NlcnQuaXNUeXBlKHJvdXRlLm1ldGhvZCwgJ3N0cmluZycsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdSb3V0ZXInLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAncmVnaXN0ZXJSb3V0ZScsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAncm91dGUubWV0aG9kJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fcm91dGVzLmhhcyhyb3V0ZS5tZXRob2QpKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3V0ZXMuc2V0KHJvdXRlLm1ldGhvZCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdpdmUgcHJlY2VkZW5jZSB0byBhbGwgb2YgdGhlIGVhcmxpZXIgcm91dGVzIGJ5IGFkZGluZyB0aGlzIGFkZGl0aW9uYWxcbiAgICAgICAgLy8gcm91dGUgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICAgIHRoaXMuX3JvdXRlcy5nZXQocm91dGUubWV0aG9kKS5wdXNoKHJvdXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlcnMgYSByb3V0ZSB3aXRoIHRoZSByb3V0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp3b3JrYm94LXJvdXRpbmcuUm91dGV9IHJvdXRlIFRoZSByb3V0ZSB0byB1bnJlZ2lzdGVyLlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXJSb3V0ZShyb3V0ZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3JvdXRlcy5oYXMocm91dGUubWV0aG9kKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcigndW5yZWdpc3Rlci1yb3V0ZS1idXQtbm90LWZvdW5kLXdpdGgtbWV0aG9kJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcm91dGUubWV0aG9kLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGVJbmRleCA9IHRoaXMuX3JvdXRlcy5nZXQocm91dGUubWV0aG9kKS5pbmRleE9mKHJvdXRlKTtcbiAgICAgICAgaWYgKHJvdXRlSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fcm91dGVzLmdldChyb3V0ZS5tZXRob2QpLnNwbGljZShyb3V0ZUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ3VucmVnaXN0ZXItcm91dGUtcm91dGUtbm90LXJlZ2lzdGVyZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCB7IFJvdXRlciB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgUm91dGVyIH0gZnJvbSAnLi4vUm91dGVyLmpzJztcbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xubGV0IGRlZmF1bHRSb3V0ZXI7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIHNpbmdsZXRvbiBSb3V0ZXIgaW5zdGFuY2UgaWYgb25lIGRvZXMgbm90IGV4aXN0LiBJZiBvbmVcbiAqIGRvZXMgYWxyZWFkeSBleGlzdCwgdGhhdCBpbnN0YW5jZSBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7Um91dGVyfVxuICovXG5leHBvcnQgY29uc3QgZ2V0T3JDcmVhdGVEZWZhdWx0Um91dGVyID0gKCkgPT4ge1xuICAgIGlmICghZGVmYXVsdFJvdXRlcikge1xuICAgICAgICBkZWZhdWx0Um91dGVyID0gbmV3IFJvdXRlcigpO1xuICAgICAgICAvLyBUaGUgaGVscGVycyB0aGF0IHVzZSB0aGUgZGVmYXVsdCBSb3V0ZXIgYXNzdW1lIHRoZXNlIGxpc3RlbmVycyBleGlzdC5cbiAgICAgICAgZGVmYXVsdFJvdXRlci5hZGRGZXRjaExpc3RlbmVyKCk7XG4gICAgICAgIGRlZmF1bHRSb3V0ZXIuYWRkQ2FjaGVMaXN0ZW5lcigpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFJvdXRlcjtcbn07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IFdvcmtib3hFcnJvciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9Xb3JrYm94RXJyb3IuanMnO1xuaW1wb3J0IHsgUm91dGUgfSBmcm9tICcuL1JvdXRlLmpzJztcbmltcG9ydCB7IFJlZ0V4cFJvdXRlIH0gZnJvbSAnLi9SZWdFeHBSb3V0ZS5qcyc7XG5pbXBvcnQgeyBnZXRPckNyZWF0ZURlZmF1bHRSb3V0ZXIgfSBmcm9tICcuL3V0aWxzL2dldE9yQ3JlYXRlRGVmYXVsdFJvdXRlci5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBFYXNpbHkgcmVnaXN0ZXIgYSBSZWdFeHAsIHN0cmluZywgb3IgZnVuY3Rpb24gd2l0aCBhIGNhY2hpbmdcbiAqIHN0cmF0ZWd5IHRvIGEgc2luZ2xldG9uIFJvdXRlciBpbnN0YW5jZS5cbiAqXG4gKiBUaGlzIG1ldGhvZCB3aWxsIGdlbmVyYXRlIGEgUm91dGUgZm9yIHlvdSBpZiBuZWVkZWQgYW5kXG4gKiBjYWxsIFtyZWdpc3RlclJvdXRlKClde0BsaW5rIG1vZHVsZTp3b3JrYm94LXJvdXRpbmcuUm91dGVyI3JlZ2lzdGVyUm91dGV9LlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ3xtb2R1bGU6d29ya2JveC1yb3V0aW5nLlJvdXRlfm1hdGNoQ2FsbGJhY2t8bW9kdWxlOndvcmtib3gtcm91dGluZy5Sb3V0ZX0gY2FwdHVyZVxuICogSWYgdGhlIGNhcHR1cmUgcGFyYW0gaXMgYSBgUm91dGVgLCBhbGwgb3RoZXIgYXJndW1lbnRzIHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtcm91dGluZ35oYW5kbGVyQ2FsbGJhY2t9IFtoYW5kbGVyXSBBIGNhbGxiYWNrXG4gKiBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBQcm9taXNlIHJlc3VsdGluZyBpbiBhIFJlc3BvbnNlLiBUaGlzIHBhcmFtZXRlclxuICogaXMgcmVxdWlyZWQgaWYgYGNhcHR1cmVgIGlzIG5vdCBhIGBSb3V0ZWAgb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IFttZXRob2Q9J0dFVCddIFRoZSBIVFRQIG1ldGhvZCB0byBtYXRjaCB0aGUgUm91dGVcbiAqIGFnYWluc3QuXG4gKiBAcmV0dXJuIHttb2R1bGU6d29ya2JveC1yb3V0aW5nLlJvdXRlfSBUaGUgZ2VuZXJhdGVkIGBSb3V0ZWAoVXNlZnVsIGZvclxuICogdW5yZWdpc3RlcmluZykuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXJvdXRpbmdcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJSb3V0ZShjYXB0dXJlLCBoYW5kbGVyLCBtZXRob2QpIHtcbiAgICBsZXQgcm91dGU7XG4gICAgaWYgKHR5cGVvZiBjYXB0dXJlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBjYXB0dXJlVXJsID0gbmV3IFVSTChjYXB0dXJlLCBsb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGlmICghKGNhcHR1cmUuc3RhcnRzV2l0aCgnLycpIHx8IGNhcHR1cmUuc3RhcnRzV2l0aCgnaHR0cCcpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2ludmFsaWQtc3RyaW5nJywge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6ICdyZWdpc3RlclJvdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnY2FwdHVyZScsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSB3YW50IHRvIGNoZWNrIGlmIEV4cHJlc3Mtc3R5bGUgd2lsZGNhcmRzIGFyZSBpbiB0aGUgcGF0aG5hbWUgb25seS5cbiAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIGxvZyBtZXNzYWdlIGluIHY0LlxuICAgICAgICAgICAgY29uc3QgdmFsdWVUb0NoZWNrID0gY2FwdHVyZS5zdGFydHNXaXRoKCdodHRwJykgP1xuICAgICAgICAgICAgICAgIGNhcHR1cmVVcmwucGF0aG5hbWUgOiBjYXB0dXJlO1xuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waWxsYXJqcy9wYXRoLXRvLXJlZ2V4cCNwYXJhbWV0ZXJzXG4gICAgICAgICAgICBjb25zdCB3aWxkY2FyZHMgPSAnWyo6PytdJztcbiAgICAgICAgICAgIGlmICgobmV3IFJlZ0V4cChgJHt3aWxkY2FyZHN9YCkpLmV4ZWModmFsdWVUb0NoZWNrKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgVGhlICckY2FwdHVyZScgcGFyYW1ldGVyIGNvbnRhaW5zIGFuIEV4cHJlc3Mtc3R5bGUgd2lsZGNhcmQgYCArXG4gICAgICAgICAgICAgICAgICAgIGBjaGFyYWN0ZXIgKCR7d2lsZGNhcmRzfSkuIFN0cmluZ3MgYXJlIG5vdyBhbHdheXMgaW50ZXJwcmV0ZWQgYXMgYCArXG4gICAgICAgICAgICAgICAgICAgIGBleGFjdCBtYXRjaGVzOyB1c2UgYSBSZWdFeHAgZm9yIHBhcnRpYWwgb3Igd2lsZGNhcmQgbWF0Y2hlcy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaENhbGxiYWNrID0gKHsgdXJsIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh1cmwucGF0aG5hbWUgPT09IGNhcHR1cmVVcmwucGF0aG5hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgICh1cmwub3JpZ2luICE9PSBjYXB0dXJlVXJsLm9yaWdpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGAke2NhcHR1cmV9IG9ubHkgcGFydGlhbGx5IG1hdGNoZXMgdGhlIGNyb3NzLW9yaWdpbiBVUkwgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHt1cmx9LiBUaGlzIHJvdXRlIHdpbGwgb25seSBoYW5kbGUgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGlmIHRoZXkgbWF0Y2ggdGhlIGVudGlyZSBVUkwuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVybC5ocmVmID09PSBjYXB0dXJlVXJsLmhyZWY7XG4gICAgICAgIH07XG4gICAgICAgIC8vIElmIGBjYXB0dXJlYCBpcyBhIHN0cmluZyB0aGVuIGBoYW5kbGVyYCBhbmQgYG1ldGhvZGAgbXVzdCBiZSBwcmVzZW50LlxuICAgICAgICByb3V0ZSA9IG5ldyBSb3V0ZShtYXRjaENhbGxiYWNrLCBoYW5kbGVyLCBtZXRob2QpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjYXB0dXJlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIC8vIElmIGBjYXB0dXJlYCBpcyBhIGBSZWdFeHBgIHRoZW4gYGhhbmRsZXJgIGFuZCBgbWV0aG9kYCBtdXN0IGJlIHByZXNlbnQuXG4gICAgICAgIHJvdXRlID0gbmV3IFJlZ0V4cFJvdXRlKGNhcHR1cmUsIGhhbmRsZXIsIG1ldGhvZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBjYXB0dXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIElmIGBjYXB0dXJlYCBpcyBhIGZ1bmN0aW9uIHRoZW4gYGhhbmRsZXJgIGFuZCBgbWV0aG9kYCBtdXN0IGJlIHByZXNlbnQuXG4gICAgICAgIHJvdXRlID0gbmV3IFJvdXRlKGNhcHR1cmUsIGhhbmRsZXIsIG1ldGhvZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNhcHR1cmUgaW5zdGFuY2VvZiBSb3V0ZSkge1xuICAgICAgICByb3V0ZSA9IGNhcHR1cmU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCd1bnN1cHBvcnRlZC1yb3V0ZS10eXBlJywge1xuICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgICAgICBmdW5jTmFtZTogJ3JlZ2lzdGVyUm91dGUnLFxuICAgICAgICAgICAgcGFyYW1OYW1lOiAnY2FwdHVyZScsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0Um91dGVyID0gZ2V0T3JDcmVhdGVEZWZhdWx0Um91dGVyKCk7XG4gICAgZGVmYXVsdFJvdXRlci5yZWdpc3RlclJvdXRlKHJvdXRlKTtcbiAgICByZXR1cm4gcm91dGU7XG59XG5leHBvcnQgeyByZWdpc3RlclJvdXRlIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogUmVtb3ZlcyBhbnkgVVJMIHNlYXJjaCBwYXJhbWV0ZXJzIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHtVUkx9IHVybE9iamVjdCBUaGUgb3JpZ2luYWwgVVJMLlxuICogQHBhcmFtIHtBcnJheTxSZWdFeHA+fSBpZ25vcmVVUkxQYXJhbWV0ZXJzTWF0Y2hpbmcgUmVnRXhwcyB0byB0ZXN0IGFnYWluc3RcbiAqIGVhY2ggc2VhcmNoIHBhcmFtZXRlciBuYW1lLiBNYXRjaGVzIG1lYW4gdGhhdCB0aGUgc2VhcmNoIHBhcmFtZXRlciBzaG91bGQgYmVcbiAqIGlnbm9yZWQuXG4gKiBAcmV0dXJuIHtVUkx9IFRoZSBVUkwgd2l0aCBhbnkgaWdub3JlZCBzZWFyY2ggcGFyYW1ldGVycyByZW1vdmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlSWdub3JlZFNlYXJjaFBhcmFtcyh1cmxPYmplY3QsIGlnbm9yZVVSTFBhcmFtZXRlcnNNYXRjaGluZyA9IFtdKSB7XG4gICAgLy8gQ29udmVydCB0aGUgaXRlcmFibGUgaW50byBhbiBhcnJheSBhdCB0aGUgc3RhcnQgb2YgdGhlIGxvb3AgdG8gbWFrZSBzdXJlXG4gICAgLy8gZGVsZXRpb24gZG9lc24ndCBtZXNzIHVwIGl0ZXJhdGlvbi5cbiAgICBmb3IgKGNvbnN0IHBhcmFtTmFtZSBvZiBbLi4udXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5rZXlzKCldKSB7XG4gICAgICAgIGlmIChpZ25vcmVVUkxQYXJhbWV0ZXJzTWF0Y2hpbmcuc29tZSgocmVnRXhwKSA9PiByZWdFeHAudGVzdChwYXJhbU5hbWUpKSkge1xuICAgICAgICAgICAgdXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5kZWxldGUocGFyYW1OYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXJsT2JqZWN0O1xufVxuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgcmVtb3ZlSWdub3JlZFNlYXJjaFBhcmFtcyB9IGZyb20gJy4vcmVtb3ZlSWdub3JlZFNlYXJjaFBhcmFtcy5qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogR2VuZXJhdG9yIGZ1bmN0aW9uIHRoYXQgeWllbGRzIHBvc3NpYmxlIHZhcmlhdGlvbnMgb24gdGhlIG9yaWdpbmFsIFVSTCB0b1xuICogY2hlY2ssIG9uZSBhdCBhIHRpbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uKiBnZW5lcmF0ZVVSTFZhcmlhdGlvbnModXJsLCB7IGlnbm9yZVVSTFBhcmFtZXRlcnNNYXRjaGluZyA9IFsvXnV0bV8vLCAvXmZiY2xpZCQvXSwgZGlyZWN0b3J5SW5kZXggPSAnaW5kZXguaHRtbCcsIGNsZWFuVVJMcyA9IHRydWUsIHVybE1hbmlwdWxhdGlvbiwgfSA9IHt9KSB7XG4gICAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLmhyZWYpO1xuICAgIHVybE9iamVjdC5oYXNoID0gJyc7XG4gICAgeWllbGQgdXJsT2JqZWN0LmhyZWY7XG4gICAgY29uc3QgdXJsV2l0aG91dElnbm9yZWRQYXJhbXMgPSByZW1vdmVJZ25vcmVkU2VhcmNoUGFyYW1zKHVybE9iamVjdCwgaWdub3JlVVJMUGFyYW1ldGVyc01hdGNoaW5nKTtcbiAgICB5aWVsZCB1cmxXaXRob3V0SWdub3JlZFBhcmFtcy5ocmVmO1xuICAgIGlmIChkaXJlY3RvcnlJbmRleCAmJiB1cmxXaXRob3V0SWdub3JlZFBhcmFtcy5wYXRobmFtZS5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgIGNvbnN0IGRpcmVjdG9yeVVSTCA9IG5ldyBVUkwodXJsV2l0aG91dElnbm9yZWRQYXJhbXMuaHJlZik7XG4gICAgICAgIGRpcmVjdG9yeVVSTC5wYXRobmFtZSArPSBkaXJlY3RvcnlJbmRleDtcbiAgICAgICAgeWllbGQgZGlyZWN0b3J5VVJMLmhyZWY7XG4gICAgfVxuICAgIGlmIChjbGVhblVSTHMpIHtcbiAgICAgICAgY29uc3QgY2xlYW5VUkwgPSBuZXcgVVJMKHVybFdpdGhvdXRJZ25vcmVkUGFyYW1zLmhyZWYpO1xuICAgICAgICBjbGVhblVSTC5wYXRobmFtZSArPSAnLmh0bWwnO1xuICAgICAgICB5aWVsZCBjbGVhblVSTC5ocmVmO1xuICAgIH1cbiAgICBpZiAodXJsTWFuaXB1bGF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uYWxVUkxzID0gdXJsTWFuaXB1bGF0aW9uKHsgdXJsOiB1cmxPYmplY3QgfSk7XG4gICAgICAgIGZvciAoY29uc3QgdXJsVG9BdHRlbXB0IG9mIGFkZGl0aW9uYWxVUkxzKSB7XG4gICAgICAgICAgICB5aWVsZCB1cmxUb0F0dGVtcHQuaHJlZjtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qXG4gIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMnO1xuaW1wb3J0IHsgZ2V0RnJpZW5kbHlVUkwgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwuanMnO1xuaW1wb3J0IHsgUm91dGUgfSBmcm9tICd3b3JrYm94LXJvdXRpbmcvUm91dGUuanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVVUkxWYXJpYXRpb25zIH0gZnJvbSAnLi91dGlscy9nZW5lcmF0ZVVSTFZhcmlhdGlvbnMuanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogQSBzdWJjbGFzcyBvZiBbUm91dGVde0BsaW5rIG1vZHVsZTp3b3JrYm94LXJvdXRpbmcuUm91dGV9IHRoYXQgdGFrZXMgYVxuICogW1ByZWNhY2hlQ29udHJvbGxlcl17QGxpbmsgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5QcmVjYWNoZUNvbnRyb2xsZXJ9XG4gKiBpbnN0YW5jZSBhbmQgdXNlcyBpdCB0byBtYXRjaCBpbmNvbWluZyByZXF1ZXN0cyBhbmQgaGFuZGxlIGZldGNoaW5nXG4gKiByZXNwb25zZXMgZnJvbSB0aGUgcHJlY2FjaGUuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmdcbiAqIEBleHRlbmRzIG1vZHVsZTp3b3JrYm94LXJvdXRpbmcuUm91dGVcbiAqL1xuY2xhc3MgUHJlY2FjaGVSb3V0ZSBleHRlbmRzIFJvdXRlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1ByZWNhY2hlQ29udHJvbGxlcn0gcHJlY2FjaGVDb250cm9sbGVyIEEgYFByZWNhY2hlQ29udHJvbGxlcmBcbiAgICAgKiBpbnN0YW5jZSB1c2VkIHRvIGJvdGggbWF0Y2ggcmVxdWVzdHMgYW5kIHJlc3BvbmQgdG8gZmV0Y2ggZXZlbnRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBjb250cm9sIGhvdyByZXF1ZXN0cyBhcmUgbWF0Y2hlZFxuICAgICAqIGFnYWluc3QgdGhlIGxpc3Qgb2YgcHJlY2FjaGVkIFVSTHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRpcmVjdG9yeUluZGV4PWluZGV4Lmh0bWxdIFRoZSBgZGlyZWN0b3J5SW5kZXhgIHdpbGxcbiAgICAgKiBjaGVjayBjYWNoZSBlbnRyaWVzIGZvciBhIFVSTHMgZW5kaW5nIHdpdGggJy8nIHRvIHNlZSBpZiB0aGVyZSBpcyBhIGhpdCB3aGVuXG4gICAgICogYXBwZW5kaW5nIHRoZSBgZGlyZWN0b3J5SW5kZXhgIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8UmVnRXhwPn0gW29wdGlvbnMuaWdub3JlVVJMUGFyYW1ldGVyc01hdGNoaW5nPVsvXnV0bV8vLCAvXmZiY2xpZCQvXV0gQW5cbiAgICAgKiBhcnJheSBvZiByZWdleCdzIHRvIHJlbW92ZSBzZWFyY2ggcGFyYW1zIHdoZW4gbG9va2luZyBmb3IgYSBjYWNoZSBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsZWFuVVJMcz10cnVlXSBUaGUgYGNsZWFuVVJMc2Agb3B0aW9uIHdpbGxcbiAgICAgKiBjaGVjayB0aGUgY2FjaGUgZm9yIHRoZSBVUkwgd2l0aCBhIGAuaHRtbGAgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgZW5kLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtcHJlY2FjaGluZ351cmxNYW5pcHVsYXRpb259IFtvcHRpb25zLnVybE1hbmlwdWxhdGlvbl1cbiAgICAgKiBUaGlzIGlzIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgdGFrZSBhIFVSTCBhbmQgcmV0dXJuIGFuIGFycmF5IG9mXG4gICAgICogYWx0ZXJuYXRpdmUgVVJMcyB0aGF0IHNob3VsZCBiZSBjaGVja2VkIGZvciBwcmVjYWNoZSBtYXRjaGVzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByZWNhY2hlQ29udHJvbGxlciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtYXRjaCA9ICh7IHJlcXVlc3QgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXJsc1RvQ2FjaGVLZXlzID0gcHJlY2FjaGVDb250cm9sbGVyLmdldFVSTHNUb0NhY2hlS2V5cygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwb3NzaWJsZVVSTCBvZiBnZW5lcmF0ZVVSTFZhcmlhdGlvbnMocmVxdWVzdC51cmwsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSB1cmxzVG9DYWNoZUtleXMuZ2V0KHBvc3NpYmxlVVJMKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY2FjaGVLZXkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgUHJlY2FjaGluZyBkaWQgbm90IGZpbmQgYSBtYXRjaCBmb3IgYCArXG4gICAgICAgICAgICAgICAgICAgIGdldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKG1hdGNoLCBwcmVjYWNoZUNvbnRyb2xsZXIuc3RyYXRlZ3kpO1xuICAgIH1cbn1cbmV4cG9ydCB7IFByZWNhY2hlUm91dGUgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyByZWdpc3RlclJvdXRlIH0gZnJvbSAnd29ya2JveC1yb3V0aW5nL3JlZ2lzdGVyUm91dGUuanMnO1xuaW1wb3J0IHsgZ2V0T3JDcmVhdGVQcmVjYWNoZUNvbnRyb2xsZXIgfSBmcm9tICcuL3V0aWxzL2dldE9yQ3JlYXRlUHJlY2FjaGVDb250cm9sbGVyLmpzJztcbmltcG9ydCB7IFByZWNhY2hlUm91dGUgfSBmcm9tICcuL1ByZWNhY2hlUm91dGUuanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogQWRkIGEgYGZldGNoYCBsaXN0ZW5lciB0byB0aGUgc2VydmljZSB3b3JrZXIgdGhhdCB3aWxsXG4gKiByZXNwb25kIHRvXG4gKiBbbmV0d29yayByZXF1ZXN0c117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZpY2VfV29ya2VyX0FQSS9Vc2luZ19TZXJ2aWNlX1dvcmtlcnMjQ3VzdG9tX3Jlc3BvbnNlc190b19yZXF1ZXN0c31cbiAqIHdpdGggcHJlY2FjaGVkIGFzc2V0cy5cbiAqXG4gKiBSZXF1ZXN0cyBmb3IgYXNzZXRzIHRoYXQgYXJlbid0IHByZWNhY2hlZCwgdGhlIGBGZXRjaEV2ZW50YCB3aWxsIG5vdCBiZVxuICogcmVzcG9uZGVkIHRvLCBhbGxvd2luZyB0aGUgZXZlbnQgdG8gZmFsbCB0aHJvdWdoIHRvIG90aGVyIGBmZXRjaGAgZXZlbnRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFNlZVxuICogW1ByZWNhY2hlUm91dGUgb3B0aW9uc117QGxpbmsgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5QcmVjYWNoZVJvdXRlfS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZ1xuICovXG5mdW5jdGlvbiBhZGRSb3V0ZShvcHRpb25zKSB7XG4gICAgY29uc3QgcHJlY2FjaGVDb250cm9sbGVyID0gZ2V0T3JDcmVhdGVQcmVjYWNoZUNvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBwcmVjYWNoZVJvdXRlID0gbmV3IFByZWNhY2hlUm91dGUocHJlY2FjaGVDb250cm9sbGVyLCBvcHRpb25zKTtcbiAgICByZWdpc3RlclJvdXRlKHByZWNhY2hlUm91dGUpO1xufVxuZXhwb3J0IHsgYWRkUm91dGUgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGdldE9yQ3JlYXRlUHJlY2FjaGVDb250cm9sbGVyIH0gZnJvbSAnLi91dGlscy9nZXRPckNyZWF0ZVByZWNhY2hlQ29udHJvbGxlci5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBBZGRzIGl0ZW1zIHRvIHRoZSBwcmVjYWNoZSBsaXN0LCByZW1vdmluZyBhbnkgZHVwbGljYXRlcyBhbmRcbiAqIHN0b3JlcyB0aGUgZmlsZXMgaW4gdGhlXG4gKiBbXCJwcmVjYWNoZSBjYWNoZVwiXXtAbGluayBtb2R1bGU6d29ya2JveC1jb3JlLmNhY2hlTmFtZXN9IHdoZW4gdGhlIHNlcnZpY2VcbiAqIHdvcmtlciBpbnN0YWxscy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBsZWFzZSBub3RlOiBUaGlzIG1ldGhvZCAqKndpbGwgbm90Kiogc2VydmUgYW55IG9mIHRoZSBjYWNoZWQgZmlsZXMgZm9yIHlvdS5cbiAqIEl0IG9ubHkgcHJlY2FjaGVzIGZpbGVzLiBUbyByZXNwb25kIHRvIGEgbmV0d29yayByZXF1ZXN0IHlvdSBjYWxsXG4gKiBbYWRkUm91dGUoKV17QGxpbmsgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5hZGRSb3V0ZX0uXG4gKlxuICogSWYgeW91IGhhdmUgYSBzaW5nbGUgYXJyYXkgb2YgZmlsZXMgdG8gcHJlY2FjaGUsIHlvdSBjYW4ganVzdCBjYWxsXG4gKiBbcHJlY2FjaGVBbmRSb3V0ZSgpXXtAbGluayBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nLnByZWNhY2hlQW5kUm91dGV9LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0fHN0cmluZz59IFtlbnRyaWVzPVtdXSBBcnJheSBvZiBlbnRyaWVzIHRvIHByZWNhY2hlLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nXG4gKi9cbmZ1bmN0aW9uIHByZWNhY2hlKGVudHJpZXMpIHtcbiAgICBjb25zdCBwcmVjYWNoZUNvbnRyb2xsZXIgPSBnZXRPckNyZWF0ZVByZWNhY2hlQ29udHJvbGxlcigpO1xuICAgIHByZWNhY2hlQ29udHJvbGxlci5wcmVjYWNoZShlbnRyaWVzKTtcbn1cbmV4cG9ydCB7IHByZWNhY2hlIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBhZGRSb3V0ZSB9IGZyb20gJy4vYWRkUm91dGUuanMnO1xuaW1wb3J0IHsgcHJlY2FjaGUgfSBmcm9tICcuL3ByZWNhY2hlLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIFRoaXMgbWV0aG9kIHdpbGwgYWRkIGVudHJpZXMgdG8gdGhlIHByZWNhY2hlIGxpc3QgYW5kIGFkZCBhIHJvdXRlIHRvXG4gKiByZXNwb25kIHRvIGZldGNoIGV2ZW50cy5cbiAqXG4gKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIHRoYXQgd2lsbCBjYWxsXG4gKiBbcHJlY2FjaGUoKV17QGxpbmsgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5wcmVjYWNoZX0gYW5kXG4gKiBbYWRkUm91dGUoKV17QGxpbmsgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5hZGRSb3V0ZX0gaW4gYSBzaW5nbGUgY2FsbC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdHxzdHJpbmc+fSBlbnRyaWVzIEFycmF5IG9mIGVudHJpZXMgdG8gcHJlY2FjaGUuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFNlZVxuICogW1ByZWNhY2hlUm91dGUgb3B0aW9uc117QGxpbmsgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5QcmVjYWNoZVJvdXRlfS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZ1xuICovXG5mdW5jdGlvbiBwcmVjYWNoZUFuZFJvdXRlKGVudHJpZXMsIG9wdGlvbnMpIHtcbiAgICBwcmVjYWNoZShlbnRyaWVzKTtcbiAgICBhZGRSb3V0ZShvcHRpb25zKTtcbn1cbmV4cG9ydCB7IHByZWNhY2hlQW5kUm91dGUgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMnO1xuaW1wb3J0IHsgZ2V0RnJpZW5kbHlVUkwgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwuanMnO1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG5leHBvcnQgY29uc3QgbWVzc2FnZXMgPSB7XG4gICAgc3RyYXRlZ3lTdGFydDogKHN0cmF0ZWd5TmFtZSwgcmVxdWVzdCkgPT4gYFVzaW5nICR7c3RyYXRlZ3lOYW1lfSB0byByZXNwb25kIHRvICcke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0nYCxcbiAgICBwcmludEZpbmFsUmVzcG9uc2U6IChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgVmlldyB0aGUgZmluYWwgcmVzcG9uc2UgaGVyZS5gKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2cocmVzcG9uc2UgfHwgJ1tObyByZXNwb25zZSByZXR1cm5lZF0nKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMnO1xuaW1wb3J0IHsgV29ya2JveEVycm9yIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5qcyc7XG5pbXBvcnQgeyBTdHJhdGVneSB9IGZyb20gJy4vU3RyYXRlZ3kuanMnO1xuaW1wb3J0IHsgbWVzc2FnZXMgfSBmcm9tICcuL3V0aWxzL21lc3NhZ2VzLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGEgW2NhY2hlLWZpcnN0XXtAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL2luc3RhbnQtYW5kLW9mZmxpbmUvb2ZmbGluZS1jb29rYm9vay8jY2FjaGUtZmFsbGluZy1iYWNrLXRvLW5ldHdvcmt9XG4gKiByZXF1ZXN0IHN0cmF0ZWd5LlxuICpcbiAqIEEgY2FjaGUgZmlyc3Qgc3RyYXRlZ3kgaXMgdXNlZnVsIGZvciBhc3NldHMgdGhhdCBoYXZlIGJlZW4gcmV2aXNpb25lZCxcbiAqIHN1Y2ggYXMgVVJMcyBsaWtlIGAvc3R5bGVzL2V4YW1wbGUuYThmNWYxLmNzc2AsIHNpbmNlIHRoZXlcbiAqIGNhbiBiZSBjYWNoZWQgZm9yIGxvbmcgcGVyaW9kcyBvZiB0aW1lLlxuICpcbiAqIElmIHRoZSBuZXR3b3JrIHJlcXVlc3QgZmFpbHMsIGFuZCB0aGVyZSBpcyBubyBjYWNoZSBtYXRjaCwgdGhpcyB3aWxsIHRocm93XG4gKiBhIGBXb3JrYm94RXJyb3JgIGV4Y2VwdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5XG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llc1xuICovXG5jbGFzcyBDYWNoZUZpcnN0IGV4dGVuZHMgU3RyYXRlZ3kge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fHN0cmluZ30gcmVxdWVzdCBBIHJlcXVlc3QgdG8gcnVuIHRoaXMgc3RyYXRlZ3kgZm9yLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneUhhbmRsZXJ9IGhhbmRsZXIgVGhlIGV2ZW50IHRoYXRcbiAgICAgKiAgICAgdHJpZ2dlcmVkIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8UmVzcG9uc2U+fVxuICAgICAqL1xuICAgIGFzeW5jIF9oYW5kbGUocmVxdWVzdCwgaGFuZGxlcikge1xuICAgICAgICBjb25zdCBsb2dzID0gW107XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBhc3NlcnQuaXNJbnN0YW5jZShyZXF1ZXN0LCBSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtc3RyYXRlZ2llcycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdtYWtlUmVxdWVzdCcsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAncmVxdWVzdCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmNhY2hlTWF0Y2gocmVxdWVzdCk7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2dzLnB1c2goYE5vIHJlc3BvbnNlIGZvdW5kIGluIHRoZSAnJHt0aGlzLmNhY2hlTmFtZX0nIGNhY2hlLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYFdpbGwgcmVzcG9uZCB3aXRoIGEgbmV0d29yayByZXF1ZXN0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGhhbmRsZXIuZmV0Y2hBbmRDYWNoZVB1dChyZXF1ZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ3MucHVzaChgR290IHJlc3BvbnNlIGZyb20gbmV0d29yay5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ3MucHVzaChgVW5hYmxlIHRvIGdldCBhIHJlc3BvbnNlIGZyb20gdGhlIG5ldHdvcmsuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2dzLnB1c2goYEZvdW5kIGEgY2FjaGVkIHJlc3BvbnNlIGluIHRoZSAnJHt0aGlzLmNhY2hlTmFtZX0nIGNhY2hlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQobWVzc2FnZXMuc3RyYXRlZ3lTdGFydCh0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIHJlcXVlc3QpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbG9nIG9mIGxvZ3MpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGxvZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXNzYWdlcy5wcmludEZpbmFsUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignbm8tcmVzcG9uc2UnLCB7IHVybDogcmVxdWVzdC51cmwsIGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG5leHBvcnQgeyBDYWNoZUZpcnN0IH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgcHJldmVudHMgYSBwcm9taXNlIGZyb20gYmVpbmcgZmxhZ2dlZCBhcyB1bnVzZWQuXG4gKlxuICogQHByaXZhdGVcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBkb250V2FpdEZvcihwcm9taXNlKSB7XG4gICAgLy8gRWZmZWN0aXZlIG5vLW9wLlxuICAgIHByb21pc2UudGhlbigoKSA9PiB7IH0pO1xufVxuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEEgY2xhc3MgdGhhdCB3cmFwcyBjb21tb24gSW5kZXhlZERCIGZ1bmN0aW9uYWxpdHkgaW4gYSBwcm9taXNlLWJhc2VkIEFQSS5cbiAqIEl0IGV4cG9zZXMgYWxsIHRoZSB1bmRlcmx5aW5nIHBvd2VyIGFuZCBmdW5jdGlvbmFsaXR5IG9mIEluZGV4ZWREQiwgYnV0XG4gKiB3cmFwcyB0aGUgbW9zdCBjb21tb25seSB1c2VkIGZlYXR1cmVzIGluIGEgd2F5IHRoYXQncyBtdWNoIHNpbXBsZXIgdG8gdXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBEQldyYXBwZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZlcnNpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdD19IFtjYWxsYmFja11cbiAgICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbnVwZ3JhZGVuZWVkZWRdXG4gICAgICogQHBhcmFtIHshRnVuY3Rpb259IFtjYWxsYmFja3Mub252ZXJzaW9uY2hhbmdlXSBEZWZhdWx0cyB0b1xuICAgICAqICAgICBEQldyYXBwZXIucHJvdG90eXBlLl9vbnZlcnNpb25jaGFuZ2Ugd2hlbiBub3Qgc3BlY2lmaWVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgdmVyc2lvbiwgeyBvbnVwZ3JhZGVuZWVkZWQsIG9udmVyc2lvbmNoYW5nZSwgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuX2RiID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLl9vbnVwZ3JhZGVuZWVkZWQgPSBvbnVwZ3JhZGVuZWVkZWQ7XG4gICAgICAgIHRoaXMuX29udmVyc2lvbmNoYW5nZSA9IG9udmVyc2lvbmNoYW5nZSB8fCAoKCkgPT4gdGhpcy5jbG9zZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSURCRGF0YWJhc2UgaW5zdGFuY2UgKG5vdCBub3JtYWxseSBuZWVkZWQpLlxuICAgICAqIEByZXR1cm4ge0lEQkRhdGFiYXNlfHVuZGVmaW5lZH1cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0IGRiKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIGEgY29ubmVjdGVkIHRvIGFuIElEQkRhdGFiYXNlLCBpbnZva2VzIGFueSBvbnVwZ3JhZGVkbmVlZGVkXG4gICAgICogY2FsbGJhY2ssIGFuZCBhZGRlZCBhbiBvbnZlcnNpb25jaGFuZ2UgY2FsbGJhY2sgdG8gdGhlIGRhdGFiYXNlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SURCRGF0YWJhc2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBvcGVuKCkge1xuICAgICAgICBpZiAodGhpcy5fZGIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX2RiID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gVGhpcyBmbGFnIGlzIGZsaXBwZWQgdG8gdHJ1ZSBpZiB0aGUgdGltZW91dCBjYWxsYmFjayBydW5zIHByaW9yXG4gICAgICAgICAgICAvLyB0byB0aGUgcmVxdWVzdCBmYWlsaW5nIG9yIHN1Y2NlZWRpbmcuIE5vdGU6IHdlIHVzZSBhIHRpbWVvdXQgaW5zdGVhZFxuICAgICAgICAgICAgLy8gb2YgYW4gb25ibG9ja2VkIGhhbmRsZXIgc2luY2UgdGhlcmUgYXJlIGNhc2VzIHdoZXJlIG9uYmxvY2tlZCB3aWxsXG4gICAgICAgICAgICAvLyBuZXZlciBuZXZlciBydW4uIEEgdGltZW91dCBiZXR0ZXIgaGFuZGxlcyBhbGwgcG9zc2libGUgc2NlbmFyaW9zOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3czYy9JbmRleGVkREIvaXNzdWVzLzIyM1xuICAgICAgICAgICAgbGV0IG9wZW5SZXF1ZXN0VGltZWRPdXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9wZW5SZXF1ZXN0VGltZWRPdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RoZSBvcGVuIHJlcXVlc3Qgd2FzIGJsb2NrZWQgYW5kIHRpbWVkIG91dCcpKTtcbiAgICAgICAgICAgIH0sIHRoaXMuT1BFTl9USU1FT1VUKTtcbiAgICAgICAgICAgIGNvbnN0IG9wZW5SZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4odGhpcy5fbmFtZSwgdGhpcy5fdmVyc2lvbik7XG4gICAgICAgICAgICBvcGVuUmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG9wZW5SZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICAgIG9wZW5SZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IChldnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3BlblJlcXVlc3RUaW1lZE91dCkge1xuICAgICAgICAgICAgICAgICAgICBvcGVuUmVxdWVzdC50cmFuc2FjdGlvbi5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICBvcGVuUmVxdWVzdC5yZXN1bHQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuX29udXBncmFkZW5lZWRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbnVwZ3JhZGVuZWVkZWQoZXZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb3BlblJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRiID0gb3BlblJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChvcGVuUmVxdWVzdFRpbWVkT3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYi5vbnZlcnNpb25jaGFuZ2UgPSB0aGlzLl9vbnZlcnNpb25jaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb2x5ZmlsbHMgdGhlIG5hdGl2ZSBgZ2V0S2V5KClgIG1ldGhvZC4gTm90ZSwgdGhpcyBpcyBvdmVycmlkZGVuIGF0XG4gICAgICogcnVudGltZSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgbmF0aXZlIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZU5hbWVcbiAgICAgKiBAcGFyYW0geyp9IHF1ZXJ5XG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBnZXRLZXkoc3RvcmVOYW1lLCBxdWVyeSkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0QWxsS2V5cyhzdG9yZU5hbWUsIHF1ZXJ5LCAxKSlbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvbHlmaWxscyB0aGUgbmF0aXZlIGBnZXRBbGwoKWAgbWV0aG9kLiBOb3RlLCB0aGlzIGlzIG92ZXJyaWRkZW4gYXRcbiAgICAgKiBydW50aW1lIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBuYXRpdmUgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0b3JlTmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gcXVlcnlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIGdldEFsbChzdG9yZU5hbWUsIHF1ZXJ5LCBjb3VudCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRBbGxNYXRjaGluZyhzdG9yZU5hbWUsIHsgcXVlcnksIGNvdW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb2x5ZmlsbHMgdGhlIG5hdGl2ZSBgZ2V0QWxsS2V5cygpYCBtZXRob2QuIE5vdGUsIHRoaXMgaXMgb3ZlcnJpZGRlbiBhdFxuICAgICAqIHJ1bnRpbWUgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIG5hdGl2ZSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVOYW1lXG4gICAgICogQHBhcmFtIHsqfSBxdWVyeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWxsS2V5cyhzdG9yZU5hbWUsIHF1ZXJ5LCBjb3VudCkge1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgdGhpcy5nZXRBbGxNYXRjaGluZyhzdG9yZU5hbWUsIHsgcXVlcnksIGNvdW50LCBpbmNsdWRlS2V5czogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIGVudHJpZXMubWFwKChlbnRyeSkgPT4gZW50cnkua2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VwcG9ydHMgZmxleGlibGUgbG9va3VwIGluIGFuIG9iamVjdCBzdG9yZSBieSBzcGVjaWZ5aW5nIGFuIGluZGV4LFxuICAgICAqIHF1ZXJ5LCBkaXJlY3Rpb24sIGFuZCBjb3VudC4gVGhpcyBtZXRob2QgcmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzXG4gICAgICogd2l0aCB0aGUgc2lnbmF0dXJlIC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZU5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmluZGV4XSBUaGUgaW5kZXggdG8gdXNlIChpZiBzcGVjaWZpZWQpLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdHMucXVlcnldXG4gICAgICogQHBhcmFtIHtJREJDdXJzb3JEaXJlY3Rpb259IFtvcHRzLmRpcmVjdGlvbl1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuY291bnRdIFRoZSBtYXggbnVtYmVyIG9mIHJlc3VsdHMgdG8gcmV0dXJuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZUtleXNdIFdoZW4gdHJ1ZSwgdGhlIHN0cnVjdHVyZSBvZiB0aGVcbiAgICAgKiAgICAgcmV0dXJuZWQgb2JqZWN0cyBpcyBjaGFuZ2VkIGZyb20gYW4gYXJyYXkgb2YgdmFsdWVzIHRvIGFuIGFycmF5IG9mXG4gICAgICogICAgIG9iamVjdHMgaW4gdGhlIGZvcm0ge2tleSwgcHJpbWFyeUtleSwgdmFsdWV9LlxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWxsTWF0Y2hpbmcoc3RvcmVOYW1lLCB7IGluZGV4LCBxdWVyeSA9IG51bGwsIC8vIElFL0VkZ2UgZXJyb3JzIGlmIHF1ZXJ5ID09PSBgdW5kZWZpbmVkYC5cbiAgICBkaXJlY3Rpb24gPSAnbmV4dCcsIGNvdW50LCBpbmNsdWRlS2V5cyA9IGZhbHNlLCB9ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNhY3Rpb24oW3N0b3JlTmFtZV0sICdyZWFkb25seScsICh0eG4sIGRvbmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHhuLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBpbmRleCA/IHN0b3JlLmluZGV4KGluZGV4KSA6IHN0b3JlO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRhcmdldC5vcGVuQ3Vyc29yKHF1ZXJ5LCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gcmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goaW5jbHVkZUtleXMgPyBjdXJzb3IgOiBjdXJzb3IudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgJiYgcmVzdWx0cy5sZW5ndGggPj0gY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZShyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNjZXB0cyBhIGxpc3Qgb2Ygc3RvcmVzLCBhIHRyYW5zYWN0aW9uIHR5cGUsIGFuZCBhIGNhbGxiYWNrIGFuZFxuICAgICAqIHBlcmZvcm1zIGEgdHJhbnNhY3Rpb24uIEEgcHJvbWlzZSBpcyByZXR1cm5lZCB0aGF0IHJlc29sdmVzIHRvIHdoYXRldmVyXG4gICAgICogdmFsdWUgdGhlIGNhbGxiYWNrIGNob29zZXMuIFRoZSBjYWxsYmFjayBob2xkcyBhbGwgdGhlIHRyYW5zYWN0aW9uIGxvZ2ljXG4gICAgICogYW5kIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuICAgICAqICAgMS4gVGhlIElEQlRyYW5zYWN0aW9uIG9iamVjdFxuICAgICAqICAgMi4gQSBgZG9uZWAgZnVuY3Rpb24sIHRoYXQncyB1c2VkIHRvIHJlc29sdmUgdGhlIHByb21pc2Ugd2hlblxuICAgICAqICAgICAgd2hlbiB0aGUgdHJhbnNhY3Rpb24gaXMgZG9uZSwgaWYgcGFzc2VkIGEgdmFsdWUsIHRoZSBwcm9taXNlIGlzXG4gICAgICogICAgICByZXNvbHZlZCB0byB0aGF0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBzdG9yZU5hbWVzIEFuIGFycmF5IG9mIG9iamVjdCBzdG9yZSBuYW1lc1xuICAgICAqICAgICBpbnZvbHZlZCBpbiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgQ2FuIGJlIGByZWFkb25seWAgb3IgYHJlYWR3cml0ZWAuXG4gICAgICogQHBhcmFtIHshRnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7Kn0gVGhlIHJlc3VsdCBvZiB0aGUgdHJhbnNhY3Rpb24gcmFuIGJ5IHRoZSBjYWxsYmFjay5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIHRyYW5zYWN0aW9uKHN0b3JlTmFtZXMsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGF3YWl0IHRoaXMub3BlbigpO1xuICAgICAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHhuID0gdGhpcy5fZGIudHJhbnNhY3Rpb24oc3RvcmVOYW1lcywgdHlwZSk7XG4gICAgICAgICAgICB0eG4ub25hYm9ydCA9ICgpID0+IHJlamVjdCh0eG4uZXJyb3IpO1xuICAgICAgICAgICAgdHhuLm9uY29tcGxldGUgPSAoKSA9PiByZXNvbHZlKCk7XG4gICAgICAgICAgICBjYWxsYmFjayh0eG4sICh2YWx1ZSkgPT4gcmVzb2x2ZSh2YWx1ZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZWdhdGVzIGFzeW5jIHRvIGEgbmF0aXZlIElEQk9iamVjdFN0b3JlIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgVGhlIG1ldGhvZCBuYW1lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZU5hbWUgVGhlIG9iamVjdCBzdG9yZSBuYW1lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIENhbiBiZSBgcmVhZG9ubHlgIG9yIGByZWFkd3JpdGVgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBUaGUgbGlzdCBvZiBhcmdzIHRvIHBhc3MgdG8gdGhlIG5hdGl2ZSBtZXRob2QuXG4gICAgICogQHJldHVybiB7Kn0gVGhlIHJlc3VsdCBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtZXRob2QsIHN0b3JlTmFtZSwgdHlwZSwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9ICh0eG4sIGRvbmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9ialN0b3JlID0gdHhuLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICAgICAgICAvLyBUT0RPKHBoaWxpcHdhbHRvbik6IEZpeCB0aGlzIHVuZGVybHlpbmcgVFMyNjg0IGVycm9yLlxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG9ialN0b3JlW21ldGhvZF0uYXBwbHkob2JqU3RvcmUsIGFyZ3MpO1xuICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiBkb25lKHJlcXVlc3QucmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNhY3Rpb24oW3N0b3JlTmFtZV0sIHR5cGUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uIG9wZW5lZCBieSBgREJXcmFwcGVyLm9wZW4oKWAuIEdlbmVyYWxseSB0aGlzIG1ldGhvZFxuICAgICAqIGRvZXNuJ3QgbmVlZCB0byBiZSBjYWxsZWQgc2luY2U6XG4gICAgICogICAxLiBJdCdzIHVzdWFsbHkgYmV0dGVyIHRvIGtlZXAgYSBjb25uZWN0aW9uIG9wZW4gc2luY2Ugb3BlbmluZ1xuICAgICAqICAgICAgYSBuZXcgY29ubmVjdGlvbiBpcyBzb21ld2hhdCBzbG93LlxuICAgICAqICAgMi4gQ29ubmVjdGlvbnMgYXJlIGF1dG9tYXRpY2FsbHkgY2xvc2VkIHdoZW4gdGhlIHJlZmVyZW5jZSBpc1xuICAgICAqICAgICAgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAgICogVGhlIHByaW1hcnkgdXNlIGNhc2UgZm9yIG5lZWRpbmcgdG8gY2xvc2UgYSBjb25uZWN0aW9uIGlzIHdoZW4gYW5vdGhlclxuICAgICAqIHJlZmVyZW5jZSAodHlwaWNhbGx5IGluIGFub3RoZXIgdGFiKSBuZWVkcyB0byB1cGdyYWRlIGl0IGFuZCB3b3VsZCBiZVxuICAgICAqIGJsb2NrZWQgYnkgdGhlIGN1cnJlbnQsIG9wZW4gY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kYikge1xuICAgICAgICAgICAgdGhpcy5fZGIuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2RiID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIEV4cG9zZWQgb24gdGhlIHByb3RvdHlwZSB0byBsZXQgdXNlcnMgbW9kaWZ5IHRoZSBkZWZhdWx0IHRpbWVvdXQgb24gYVxuLy8gcGVyLWluc3RhbmNlIG9yIGdsb2JhbCBiYXNpcy5cbkRCV3JhcHBlci5wcm90b3R5cGUuT1BFTl9USU1FT1VUID0gMjAwMDtcbi8vIFdyYXAgbmF0aXZlIElEQk9iamVjdFN0b3JlIG1ldGhvZHMgYWNjb3JkaW5nIHRvIHRoZWlyIG1vZGUuXG5jb25zdCBtZXRob2RzVG9XcmFwID0ge1xuICAgIHJlYWRvbmx5OiBbJ2dldCcsICdjb3VudCcsICdnZXRLZXknLCAnZ2V0QWxsJywgJ2dldEFsbEtleXMnXSxcbiAgICByZWFkd3JpdGU6IFsnYWRkJywgJ3B1dCcsICdjbGVhcicsICdkZWxldGUnXSxcbn07XG5mb3IgKGNvbnN0IFttb2RlLCBtZXRob2RzXSBvZiBPYmplY3QuZW50cmllcyhtZXRob2RzVG9XcmFwKSkge1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICAgICAgaWYgKG1ldGhvZCBpbiBJREJPYmplY3RTdG9yZS5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIC8vIERvbid0IHVzZSBhcnJvdyBmdW5jdGlvbnMgaGVyZSBzaW5jZSB3ZSdyZSBvdXRzaWRlIG9mIHRoZSBjbGFzcy5cbiAgICAgICAgICAgIERCV3JhcHBlci5wcm90b3R5cGVbbWV0aG9kXSA9XG4gICAgICAgICAgICAgICAgYXN5bmMgZnVuY3Rpb24gKHN0b3JlTmFtZSwgLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fY2FsbChtZXRob2QsIHN0b3JlTmFtZSwgbW9kZSwgLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBEZWxldGVzIHRoZSBkYXRhYmFzZS5cbiAqIE5vdGU6IHRoaXMgaXMgZXhwb3J0ZWQgc2VwYXJhdGVseSBmcm9tIHRoZSBEQldyYXBwZXIgbW9kdWxlIGJlY2F1c2UgbW9zdFxuICogdXNhZ2VzIG9mIEluZGV4ZWREQiBpbiB3b3JrYm94IGRvbnQgbmVlZCBkZWxldGluZywgYW5kIHRoaXMgd2F5IGl0IGNhbiBiZVxuICogcmV1c2VkIGluIHRlc3RzIHRvIGRlbGV0ZSBkYXRhYmFzZXMgd2l0aG91dCBjcmVhdGluZyBEQldyYXBwZXIgaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBkYXRhYmFzZSBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGRlbGV0ZURhdGFiYXNlID0gYXN5bmMgKG5hbWUpID0+IHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UobmFtZSk7XG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5vbmJsb2NrZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdEZWxldGUgYmxvY2tlZCcpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBAdHMtaWdub3JlXG50cnkge1xuICAgIHNlbGZbJ3dvcmtib3g6ZXhwaXJhdGlvbjo2LjAuMiddICYmIF8oKTtcbn1cbmNhdGNoIChlKSB7IH1cbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IERCV3JhcHBlciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9EQldyYXBwZXIuanMnO1xuaW1wb3J0IHsgZGVsZXRlRGF0YWJhc2UgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZGVsZXRlRGF0YWJhc2UuanMnO1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG5jb25zdCBEQl9OQU1FID0gJ3dvcmtib3gtZXhwaXJhdGlvbic7XG5jb25zdCBPQkpFQ1RfU1RPUkVfTkFNRSA9ICdjYWNoZS1lbnRyaWVzJztcbmNvbnN0IG5vcm1hbGl6ZVVSTCA9ICh1bk5vcm1hbGl6ZWRVcmwpID0+IHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHVuTm9ybWFsaXplZFVybCwgbG9jYXRpb24uaHJlZik7XG4gICAgdXJsLmhhc2ggPSAnJztcbiAgICByZXR1cm4gdXJsLmhyZWY7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSB0aW1lc3RhbXAgbW9kZWwuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ2FjaGVUaW1lc3RhbXBzTW9kZWwge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjYWNoZU5hbWUpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVOYW1lID0gY2FjaGVOYW1lO1xuICAgICAgICB0aGlzLl9kYiA9IG5ldyBEQldyYXBwZXIoREJfTkFNRSwgMSwge1xuICAgICAgICAgICAgb251cGdyYWRlbmVlZGVkOiAoZXZlbnQpID0+IHRoaXMuX2hhbmRsZVVwZ3JhZGUoZXZlbnQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdWxkIHBlcmZvcm0gYW4gdXBncmFkZSBvZiBpbmRleGVkREIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGFuZGxlVXBncmFkZShldmVudCkge1xuICAgICAgICBjb25zdCBkYiA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgIC8vIFRPRE8ocGhpbGlwd2FsdG9uKTogRWRnZUhUTUwgZG9lc24ndCBzdXBwb3J0IGFycmF5cyBhcyBhIGtleVBhdGgsIHNvIHdlXG4gICAgICAgIC8vIGhhdmUgdG8gdXNlIHRoZSBgaWRgIGtleVBhdGggaGVyZSBhbmQgY3JlYXRlIG91ciBvd24gdmFsdWVzIChhXG4gICAgICAgIC8vIGNvbmNhdGVuYXRpb24gb2YgYHVybCArIGNhY2hlTmFtZWApIGluc3RlYWQgb2Ygc2ltcGx5IHVzaW5nXG4gICAgICAgIC8vIGBrZXlQYXRoOiBbJ3VybCcsICdjYWNoZU5hbWUnXWAsIHdoaWNoIGlzIHN1cHBvcnRlZCBpbiBvdGhlciBicm93c2Vycy5cbiAgICAgICAgY29uc3Qgb2JqU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShPQkpFQ1RfU1RPUkVfTkFNRSwgeyBrZXlQYXRoOiAnaWQnIH0pO1xuICAgICAgICAvLyBUT0RPKHBoaWxpcHdhbHRvbik6IG9uY2Ugd2UgZG9uJ3QgaGF2ZSB0byBzdXBwb3J0IEVkZ2VIVE1MLCB3ZSBjYW5cbiAgICAgICAgLy8gY3JlYXRlIGEgc2luZ2xlIGluZGV4IHdpdGggdGhlIGtleVBhdGggYFsnY2FjaGVOYW1lJywgJ3RpbWVzdGFtcCddYFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIGRvaW5nIGJvdGggdGhlc2UgaW5kZXhlcy5cbiAgICAgICAgb2JqU3RvcmUuY3JlYXRlSW5kZXgoJ2NhY2hlTmFtZScsICdjYWNoZU5hbWUnLCB7IHVuaXF1ZTogZmFsc2UgfSk7XG4gICAgICAgIG9ialN0b3JlLmNyZWF0ZUluZGV4KCd0aW1lc3RhbXAnLCAndGltZXN0YW1wJywgeyB1bmlxdWU6IGZhbHNlIH0pO1xuICAgICAgICAvLyBQcmV2aW91cyB2ZXJzaW9ucyBvZiBgd29ya2JveC1leHBpcmF0aW9uYCB1c2VkIGB0aGlzLl9jYWNoZU5hbWVgXG4gICAgICAgIC8vIGFzIHRoZSBJREJEYXRhYmFzZSBuYW1lLlxuICAgICAgICBkZWxldGVEYXRhYmFzZSh0aGlzLl9jYWNoZU5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBzZXRUaW1lc3RhbXAodXJsLCB0aW1lc3RhbXApIHtcbiAgICAgICAgdXJsID0gbm9ybWFsaXplVVJMKHVybCk7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgICAgY2FjaGVOYW1lOiB0aGlzLl9jYWNoZU5hbWUsXG4gICAgICAgICAgICAvLyBDcmVhdGluZyBhbiBJRCBmcm9tIHRoZSBVUkwgYW5kIGNhY2hlIG5hbWUgd29uJ3QgYmUgbmVjZXNzYXJ5IG9uY2VcbiAgICAgICAgICAgIC8vIEVkZ2Ugc3dpdGNoZXMgdG8gQ2hyb21pdW0gYW5kIGFsbCBicm93c2VycyB3ZSBzdXBwb3J0IHdvcmsgd2l0aFxuICAgICAgICAgICAgLy8gYXJyYXkga2V5UGF0aHMuXG4gICAgICAgICAgICBpZDogdGhpcy5fZ2V0SWQodXJsKSxcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZGIucHV0KE9CSkVDVF9TVE9SRV9OQU1FLCBlbnRyeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRpbWVzdGFtcCBzdG9yZWQgZm9yIGEgZ2l2ZW4gVVJMLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VGltZXN0YW1wKHVybCkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IHRoaXMuX2RiLmdldChPQkpFQ1RfU1RPUkVfTkFNRSwgdGhpcy5fZ2V0SWQodXJsKSk7XG4gICAgICAgIHJldHVybiBlbnRyeS50aW1lc3RhbXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIHRocm91Z2ggYWxsIHRoZSBlbnRyaWVzIGluIHRoZSBvYmplY3Qgc3RvcmUgKGZyb20gbmV3ZXN0IHRvXG4gICAgICogb2xkZXN0KSBhbmQgcmVtb3ZlcyBlbnRyaWVzIG9uY2UgZWl0aGVyIGBtYXhDb3VudGAgaXMgcmVhY2hlZCBvciB0aGVcbiAgICAgKiBlbnRyeSdzIHRpbWVzdGFtcCBpcyBsZXNzIHRoYW4gYG1pblRpbWVzdGFtcGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluVGltZXN0YW1wXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heENvdW50XG4gICAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn1cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgZXhwaXJlRW50cmllcyhtaW5UaW1lc3RhbXAsIG1heENvdW50KSB7XG4gICAgICAgIGNvbnN0IGVudHJpZXNUb0RlbGV0ZSA9IGF3YWl0IHRoaXMuX2RiLnRyYW5zYWN0aW9uKE9CSkVDVF9TVE9SRV9OQU1FLCAncmVhZHdyaXRlJywgKHR4biwgZG9uZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSB0eG4ub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX05BTUUpO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmluZGV4KCd0aW1lc3RhbXAnKS5vcGVuQ3Vyc29yKG51bGwsICdwcmV2Jyk7XG4gICAgICAgICAgICBjb25zdCBlbnRyaWVzVG9EZWxldGUgPSBbXTtcbiAgICAgICAgICAgIGxldCBlbnRyaWVzTm90RGVsZXRlZENvdW50ID0gMDtcbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IHJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKHBoaWxpcHdhbHRvbik6IG9uY2Ugd2UgY2FuIHVzZSBhIG11bHRpLWtleSBpbmRleCwgd2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd29uJ3QgaGF2ZSB0byBjaGVjayBgY2FjaGVOYW1lYCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmNhY2hlTmFtZSA9PT0gdGhpcy5fY2FjaGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgYW4gZW50cnkgaWYgaXQncyBvbGRlciB0aGFuIHRoZSBtYXggYWdlIG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIG1heCBudW1iZXIgYWxsb3dlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobWluVGltZXN0YW1wICYmIHJlc3VsdC50aW1lc3RhbXAgPCBtaW5UaW1lc3RhbXApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1heENvdW50ICYmIGVudHJpZXNOb3REZWxldGVkQ291bnQgPj0gbWF4Q291bnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhwaGlsaXB3YWx0b24pOiB3ZSBzaG91bGQgYmUgYWJsZSB0byBkZWxldGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW50cnkgcmlnaHQgaGVyZSwgYnV0IGRvaW5nIHNvIGNhdXNlcyBhbiBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidWcgaW4gU2FmYXJpIHN0YWJsZSAoZml4ZWQgaW4gVFApLiBJbnN0ZWFkIHdlIGNhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBrZXlzIG9mIHRoZSBlbnRyaWVzIHRvIGRlbGV0ZSwgYW5kIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUgdGhlIHNlcGFyYXRlIHRyYW5zYWN0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL3dvcmtib3gvaXNzdWVzLzE5NzhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJzb3IuZGVsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIHJldHVybiB0aGUgVVJMLCBub3QgdGhlIHdob2xlIGVudHJ5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXNUb0RlbGV0ZS5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzTm90RGVsZXRlZENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb25lKGVudHJpZXNUb0RlbGV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE8ocGhpbGlwd2FsdG9uKTogb25jZSB0aGUgU2FmYXJpIGJ1ZyBpbiB0aGUgZm9sbG93aW5nIGlzc3VlIGlzIGZpeGVkLFxuICAgICAgICAvLyB3ZSBzaG91bGQgYmUgYWJsZSB0byByZW1vdmUgdGhpcyBsb29wIGFuZCBkbyB0aGUgZW50cnkgZGVsZXRpb24gaW4gdGhlXG4gICAgICAgIC8vIGN1cnNvciBsb29wIGFib3ZlOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL3dvcmtib3gvaXNzdWVzLzE5NzhcbiAgICAgICAgY29uc3QgdXJsc0RlbGV0ZWQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzVG9EZWxldGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2RiLmRlbGV0ZShPQkpFQ1RfU1RPUkVfTkFNRSwgZW50cnkuaWQpO1xuICAgICAgICAgICAgdXJsc0RlbGV0ZWQucHVzaChlbnRyeS51cmwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmxzRGVsZXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBVUkwgYW5kIHJldHVybnMgYW4gSUQgdGhhdCB3aWxsIGJlIHVuaXF1ZSBpbiB0aGUgb2JqZWN0IHN0b3JlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldElkKHVybCkge1xuICAgICAgICAvLyBDcmVhdGluZyBhbiBJRCBmcm9tIHRoZSBVUkwgYW5kIGNhY2hlIG5hbWUgd29uJ3QgYmUgbmVjZXNzYXJ5IG9uY2VcbiAgICAgICAgLy8gRWRnZSBzd2l0Y2hlcyB0byBDaHJvbWl1bSBhbmQgYWxsIGJyb3dzZXJzIHdlIHN1cHBvcnQgd29yayB3aXRoXG4gICAgICAgIC8vIGFycmF5IGtleVBhdGhzLlxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVOYW1lICsgJ3wnICsgbm9ybWFsaXplVVJMKHVybCk7XG4gICAgfVxufVxuZXhwb3J0IHsgQ2FjaGVUaW1lc3RhbXBzTW9kZWwgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9hc3NlcnQuanMnO1xuaW1wb3J0IHsgZG9udFdhaXRGb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZG9udFdhaXRGb3IuanMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5qcyc7XG5pbXBvcnQgeyBXb3JrYm94RXJyb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCB7IENhY2hlVGltZXN0YW1wc01vZGVsIH0gZnJvbSAnLi9tb2RlbHMvQ2FjaGVUaW1lc3RhbXBzTW9kZWwuanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogVGhlIGBDYWNoZUV4cGlyYXRpb25gIGNsYXNzIGFsbG93cyB5b3UgZGVmaW5lIGFuIGV4cGlyYXRpb24gYW5kIC8gb3JcbiAqIGxpbWl0IG9uIHRoZSBudW1iZXIgb2YgcmVzcG9uc2VzIHN0b3JlZCBpbiBhXG4gKiBbYENhY2hlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhY2hlKS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtZXhwaXJhdGlvblxuICovXG5jbGFzcyBDYWNoZUV4cGlyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIFRvIGNvbnN0cnVjdCBhIG5ldyBDYWNoZUV4cGlyYXRpb24gaW5zdGFuY2UgeW91IG11c3QgcHJvdmlkZSBhdCBsZWFzdFxuICAgICAqIG9uZSBvZiB0aGUgYGNvbmZpZ2AgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgTmFtZSBvZiB0aGUgY2FjaGUgdG8gYXBwbHkgcmVzdHJpY3Rpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5tYXhFbnRyaWVzXSBUaGUgbWF4aW11bSBudW1iZXIgb2YgZW50cmllcyB0byBjYWNoZS5cbiAgICAgKiBFbnRyaWVzIHVzZWQgdGhlIGxlYXN0IHdpbGwgYmUgcmVtb3ZlZCBhcyB0aGUgbWF4aW11bSBpcyByZWFjaGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLm1heEFnZVNlY29uZHNdIFRoZSBtYXhpbXVtIGFnZSBvZiBhbiBlbnRyeSBiZWZvcmVcbiAgICAgKiBpdCdzIHRyZWF0ZWQgYXMgc3RhbGUgYW5kIHJlbW92ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcubWF0Y2hPcHRpb25zXSBUaGUgW2BDYWNoZVF1ZXJ5T3B0aW9uc2BdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYWNoZS9kZWxldGUjUGFyYW1ldGVycylcbiAgICAgKiB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIGNhbGxpbmcgYGRlbGV0ZSgpYCBvbiB0aGUgY2FjaGUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2FjaGVOYW1lLCBjb25maWcgPSB7fSkge1xuICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVydW5SZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc1R5cGUoY2FjaGVOYW1lLCAnc3RyaW5nJywge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LWV4cGlyYXRpb24nLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ0NhY2hlRXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnY2FjaGVOYW1lJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCEoY29uZmlnLm1heEVudHJpZXMgfHwgY29uZmlnLm1heEFnZVNlY29uZHMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignbWF4LWVudHJpZXMtb3ItYWdlLXJlcXVpcmVkJywge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1leHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnQ2FjaGVFeHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLm1heEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuaXNUeXBlKGNvbmZpZy5tYXhFbnRyaWVzLCAnbnVtYmVyJywge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1leHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnQ2FjaGVFeHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ2NvbmZpZy5tYXhFbnRyaWVzJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcubWF4QWdlU2Vjb25kcykge1xuICAgICAgICAgICAgICAgIGFzc2VydC5pc1R5cGUoY29uZmlnLm1heEFnZVNlY29uZHMsICdudW1iZXInLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LWV4cGlyYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdDYWNoZUV4cGlyYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnY29uZmlnLm1heEFnZVNlY29uZHMnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21heEVudHJpZXMgPSBjb25maWcubWF4RW50cmllcztcbiAgICAgICAgdGhpcy5fbWF4QWdlU2Vjb25kcyA9IGNvbmZpZy5tYXhBZ2VTZWNvbmRzO1xuICAgICAgICB0aGlzLl9tYXRjaE9wdGlvbnMgPSBjb25maWcubWF0Y2hPcHRpb25zO1xuICAgICAgICB0aGlzLl9jYWNoZU5hbWUgPSBjYWNoZU5hbWU7XG4gICAgICAgIHRoaXMuX3RpbWVzdGFtcE1vZGVsID0gbmV3IENhY2hlVGltZXN0YW1wc01vZGVsKGNhY2hlTmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cGlyZXMgZW50cmllcyBmb3IgdGhlIGdpdmVuIGNhY2hlIGFuZCBnaXZlbiBjcml0ZXJpYS5cbiAgICAgKi9cbiAgICBhc3luYyBleHBpcmVFbnRyaWVzKCkge1xuICAgICAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXJ1blJlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgbWluVGltZXN0YW1wID0gdGhpcy5fbWF4QWdlU2Vjb25kcyA/XG4gICAgICAgICAgICBEYXRlLm5vdygpIC0gKHRoaXMuX21heEFnZVNlY29uZHMgKiAxMDAwKSA6IDA7XG4gICAgICAgIGNvbnN0IHVybHNFeHBpcmVkID0gYXdhaXQgdGhpcy5fdGltZXN0YW1wTW9kZWwuZXhwaXJlRW50cmllcyhtaW5UaW1lc3RhbXAsIHRoaXMuX21heEVudHJpZXMpO1xuICAgICAgICAvLyBEZWxldGUgVVJMcyBmcm9tIHRoZSBjYWNoZVxuICAgICAgICBjb25zdCBjYWNoZSA9IGF3YWl0IHNlbGYuY2FjaGVzLm9wZW4odGhpcy5fY2FjaGVOYW1lKTtcbiAgICAgICAgZm9yIChjb25zdCB1cmwgb2YgdXJsc0V4cGlyZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlLmRlbGV0ZSh1cmwsIHRoaXMuX21hdGNoT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh1cmxzRXhwaXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBFeHBpcmVkICR7dXJsc0V4cGlyZWQubGVuZ3RofSBgICtcbiAgICAgICAgICAgICAgICAgICAgYCR7dXJsc0V4cGlyZWQubGVuZ3RoID09PSAxID8gJ2VudHJ5JyA6ICdlbnRyaWVzJ30gYW5kIHJlbW92ZWQgYCArXG4gICAgICAgICAgICAgICAgICAgIGAke3VybHNFeHBpcmVkLmxlbmd0aCA9PT0gMSA/ICdpdCcgOiAndGhlbSd9IGZyb20gdGhlIGAgK1xuICAgICAgICAgICAgICAgICAgICBgJyR7dGhpcy5fY2FjaGVOYW1lfScgY2FjaGUuYCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgRXhwaXJlZCB0aGUgZm9sbG93aW5nICR7dXJsc0V4cGlyZWQubGVuZ3RoID09PSAxID9cbiAgICAgICAgICAgICAgICAgICAgJ1VSTCcgOiAnVVJMcyd9OmApO1xuICAgICAgICAgICAgICAgIHVybHNFeHBpcmVkLmZvckVhY2goKHVybCkgPT4gbG9nZ2VyLmxvZyhgICAgICR7dXJsfWApKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgQ2FjaGUgZXhwaXJhdGlvbiByYW4gYW5kIGZvdW5kIG5vIGVudHJpZXMgdG8gcmVtb3ZlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fcmVydW5SZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcnVuUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBkb250V2FpdEZvcih0aGlzLmV4cGlyZUVudHJpZXMoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSB0aW1lc3RhbXAgZm9yIHRoZSBnaXZlbiBVUkwuIFRoaXMgZW5zdXJlcyB0aGUgd2hlblxuICAgICAqIHJlbW92aW5nIGVudHJpZXMgYmFzZWQgb24gbWF4aW11bSBlbnRyaWVzLCBtb3N0IHJlY2VudGx5IHVzZWRcbiAgICAgKiBpcyBhY2N1cmF0ZSBvciB3aGVuIGV4cGlyaW5nLCB0aGUgdGltZXN0YW1wIGlzIHVwLXRvLWRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlVGltZXN0YW1wKHVybCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgYXNzZXJ0LmlzVHlwZSh1cmwsICdzdHJpbmcnLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtZXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnQ2FjaGVFeHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ3VwZGF0ZVRpbWVzdGFtcCcsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAndXJsJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuX3RpbWVzdGFtcE1vZGVsLnNldFRpbWVzdGFtcCh1cmwsIERhdGUubm93KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW4gYmUgdXNlZCB0byBjaGVjayBpZiBhIFVSTCBoYXMgZXhwaXJlZCBvciBub3QgYmVmb3JlIGl0J3MgdXNlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgcmVxdWlyZXMgYSBsb29rIHVwIGZyb20gSW5kZXhlZERCLCBzbyBjYW4gYmUgc2xvdy5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIHdpbGwgbm90IHJlbW92ZSB0aGUgY2FjaGVkIGVudHJ5LCBjYWxsXG4gICAgICogYGV4cGlyZUVudHJpZXMoKWAgdG8gcmVtb3ZlIGluZGV4ZWREQiBhbmQgQ2FjaGUgZW50cmllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGFzeW5jIGlzVVJMRXhwaXJlZCh1cmwpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tYXhBZ2VTZWNvbmRzKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoYGV4cGlyZWQtdGVzdC13aXRob3V0LW1heC1hZ2VgLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWU6ICdpc1VSTEV4cGlyZWQnLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdtYXhBZ2VTZWNvbmRzJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IGF3YWl0IHRoaXMuX3RpbWVzdGFtcE1vZGVsLmdldFRpbWVzdGFtcCh1cmwpO1xuICAgICAgICAgICAgY29uc3QgZXhwaXJlT2xkZXJUaGFuID0gRGF0ZS5ub3coKSAtICh0aGlzLl9tYXhBZ2VTZWNvbmRzICogMTAwMCk7XG4gICAgICAgICAgICByZXR1cm4gKHRpbWVzdGFtcCA8IGV4cGlyZU9sZGVyVGhhbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgSW5kZXhlZERCIG9iamVjdCBzdG9yZSB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgY2FjaGUgZXhwaXJhdGlvblxuICAgICAqIG1ldGFkYXRhLlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZSgpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IGF0dGVtcHQgYW5vdGhlciByZXJ1biBpZiB3ZSdyZSBjYWxsZWQgaW4gdGhlIG1pZGRsZSBvZlxuICAgICAgICAvLyBhIGNhY2hlIGV4cGlyYXRpb24uXG4gICAgICAgIHRoaXMuX3JlcnVuUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIGF3YWl0IHRoaXMuX3RpbWVzdGFtcE1vZGVsLmV4cGlyZUVudHJpZXMoSW5maW5pdHkpOyAvLyBFeHBpcmVzIGFsbC5cbiAgICB9XG59XG5leHBvcnQgeyBDYWNoZUV4cGlyYXRpb24gfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4vX3ByaXZhdGUvYXNzZXJ0LmpzJztcbmltcG9ydCB7IHF1b3RhRXJyb3JDYWxsYmFja3MgfSBmcm9tICcuL21vZGVscy9xdW90YUVycm9yQ2FsbGJhY2tzLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEFkZHMgYSBmdW5jdGlvbiB0byB0aGUgc2V0IG9mIHF1b3RhRXJyb3JDYWxsYmFja3MgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGlmXG4gKiB0aGVyZSdzIGEgcXVvdGEgZXJyb3IuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1jb3JlXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyUXVvdGFFcnJvckNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0LmlzVHlwZShjYWxsYmFjaywgJ2Z1bmN0aW9uJywge1xuICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtY29yZScsXG4gICAgICAgICAgICBmdW5jTmFtZTogJ3JlZ2lzdGVyJyxcbiAgICAgICAgICAgIHBhcmFtTmFtZTogJ2NhbGxiYWNrJyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHF1b3RhRXJyb3JDYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBsb2dnZXIubG9nKCdSZWdpc3RlcmVkIGEgY2FsbGJhY2sgdG8gcmVzcG9uZCB0byBxdW90YSBlcnJvcnMuJywgY2FsbGJhY2spO1xuICAgIH1cbn1cbmV4cG9ydCB7IHJlZ2lzdGVyUXVvdGFFcnJvckNhbGxiYWNrIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzJztcbmltcG9ydCB7IGNhY2hlTmFtZXMgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvY2FjaGVOYW1lcy5qcyc7XG5pbXBvcnQgeyBkb250V2FpdEZvciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9kb250V2FpdEZvci5qcyc7XG5pbXBvcnQgeyBnZXRGcmllbmRseVVSTCB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9nZXRGcmllbmRseVVSTC5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IHJlZ2lzdGVyUXVvdGFFcnJvckNhbGxiYWNrIH0gZnJvbSAnd29ya2JveC1jb3JlL3JlZ2lzdGVyUXVvdGFFcnJvckNhbGxiYWNrLmpzJztcbmltcG9ydCB7IFdvcmtib3hFcnJvciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9Xb3JrYm94RXJyb3IuanMnO1xuaW1wb3J0IHsgQ2FjaGVFeHBpcmF0aW9uIH0gZnJvbSAnLi9DYWNoZUV4cGlyYXRpb24uanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogVGhpcyBwbHVnaW4gY2FuIGJlIHVzZWQgaW4gYSBgd29ya2JveC1zdHJhdGVneWAgdG8gcmVndWxhcmx5IGVuZm9yY2UgYVxuICogbGltaXQgb24gdGhlIGFnZSBhbmQgLyBvciB0aGUgbnVtYmVyIG9mIGNhY2hlZCByZXF1ZXN0cy5cbiAqXG4gKiBJdCBjYW4gb25seSBiZSB1c2VkIHdpdGggYHdvcmtib3gtc3RyYXRlZ3lgIGluc3RhbmNlcyB0aGF0IGhhdmUgYVxuICogW2N1c3RvbSBgY2FjaGVOYW1lYCBwcm9wZXJ0eSBzZXRdKC93ZWIvdG9vbHMvd29ya2JveC9ndWlkZXMvY29uZmlndXJlLXdvcmtib3gjY3VzdG9tX2NhY2hlX25hbWVzX2luX3N0cmF0ZWdpZXMpLlxuICogSW4gb3RoZXIgd29yZHMsIGl0IGNhbid0IGJlIHVzZWQgdG8gZXhwaXJlIGVudHJpZXMgaW4gc3RyYXRlZ3kgdGhhdCB1c2VzIHRoZVxuICogZGVmYXVsdCBydW50aW1lIGNhY2hlIG5hbWUuXG4gKlxuICogV2hlbmV2ZXIgYSBjYWNoZWQgcmVxdWVzdCBpcyB1c2VkIG9yIHVwZGF0ZWQsIHRoaXMgcGx1Z2luIHdpbGwgbG9va1xuICogYXQgdGhlIGFzc29jaWF0ZWQgY2FjaGUgYW5kIHJlbW92ZSBhbnkgb2xkIG9yIGV4dHJhIHJlcXVlc3RzLlxuICpcbiAqIFdoZW4gdXNpbmcgYG1heEFnZVNlY29uZHNgLCByZXF1ZXN0cyBtYXkgYmUgdXNlZCAqb25jZSogYWZ0ZXIgZXhwaXJpbmdcbiAqIGJlY2F1c2UgdGhlIGV4cGlyYXRpb24gY2xlYW4gdXAgd2lsbCBub3QgaGF2ZSBvY2N1cnJlZCB1bnRpbCAqYWZ0ZXIqIHRoZVxuICogY2FjaGVkIHJlcXVlc3QgaGFzIGJlZW4gdXNlZC4gSWYgdGhlIHJlcXVlc3QgaGFzIGEgXCJEYXRlXCIgaGVhZGVyLCB0aGVuXG4gKiBhIGxpZ2h0IHdlaWdodCBleHBpcmF0aW9uIGNoZWNrIGlzIHBlcmZvcm1lZCBhbmQgdGhlIHJlcXVlc3Qgd2lsbCBub3QgYmVcbiAqIHVzZWQgaW1tZWRpYXRlbHkuXG4gKlxuICogV2hlbiB1c2luZyBgbWF4RW50cmllc2AsIHRoZSBlbnRyeSBsZWFzdC1yZWNlbnRseSByZXF1ZXN0ZWQgd2lsbCBiZSByZW1vdmVkXG4gKiBmcm9tIHRoZSBjYWNoZSBmaXJzdC5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtZXhwaXJhdGlvblxuICovXG5jbGFzcyBFeHBpcmF0aW9uUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubWF4RW50cmllc10gVGhlIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgdG8gY2FjaGUuXG4gICAgICogRW50cmllcyB1c2VkIHRoZSBsZWFzdCB3aWxsIGJlIHJlbW92ZWQgYXMgdGhlIG1heGltdW0gaXMgcmVhY2hlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5tYXhBZ2VTZWNvbmRzXSBUaGUgbWF4aW11bSBhZ2Ugb2YgYW4gZW50cnkgYmVmb3JlXG4gICAgICogaXQncyB0cmVhdGVkIGFzIHN0YWxlIGFuZCByZW1vdmVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm1hdGNoT3B0aW9uc10gVGhlIFtgQ2FjaGVRdWVyeU9wdGlvbnNgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FjaGUvZGVsZXRlI1BhcmFtZXRlcnMpXG4gICAgICogdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiBjYWxsaW5nIGBkZWxldGUoKWAgb24gdGhlIGNhY2hlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbmZpZy5wdXJnZU9uUXVvdGFFcnJvcl0gV2hldGhlciB0byBvcHQgdGhpcyBjYWNoZSBpbiB0b1xuICAgICAqIGF1dG9tYXRpYyBkZWxldGlvbiBpZiB0aGUgYXZhaWxhYmxlIHN0b3JhZ2UgcXVvdGEgaGFzIGJlZW4gZXhjZWVkZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgXCJsaWZlY3ljbGVcIiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgdHJpZ2dlcmVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlXG4gICAgICAgICAqIGB3b3JrYm94LXN0cmF0ZWdpZXNgIGhhbmRsZXJzIHdoZW4gYSBgUmVzcG9uc2VgIGlzIGFib3V0IHRvIGJlIHJldHVybmVkXG4gICAgICAgICAqIGZyb20gYSBbQ2FjaGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYWNoZSkgdG9cbiAgICAgICAgICogdGhlIGhhbmRsZXIuIEl0IGFsbG93cyB0aGUgYFJlc3BvbnNlYCB0byBiZSBpbnNwZWN0ZWQgZm9yIGZyZXNobmVzcyBhbmRcbiAgICAgICAgICogcHJldmVudHMgaXQgZnJvbSBiZWluZyB1c2VkIGlmIHRoZSBgUmVzcG9uc2VgJ3MgYERhdGVgIGhlYWRlciB2YWx1ZSBpc1xuICAgICAgICAgKiBvbGRlciB0aGFuIHRoZSBjb25maWd1cmVkIGBtYXhBZ2VTZWNvbmRzYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2FjaGVOYW1lIE5hbWUgb2YgdGhlIGNhY2hlIHRoZSByZXNwb25zZSBpcyBpbi5cbiAgICAgICAgICogQHBhcmFtIHtSZXNwb25zZX0gb3B0aW9ucy5jYWNoZWRSZXNwb25zZSBUaGUgYFJlc3BvbnNlYCBvYmplY3QgdGhhdCdzIGJlZW5cbiAgICAgICAgICogICAgIHJlYWQgZnJvbSBhIGNhY2hlIGFuZCB3aG9zZSBmcmVzaG5lc3Mgc2hvdWxkIGJlIGNoZWNrZWQuXG4gICAgICAgICAqIEByZXR1cm4ge1Jlc3BvbnNlfSBFaXRoZXIgdGhlIGBjYWNoZWRSZXNwb25zZWAsIGlmIGl0J3NcbiAgICAgICAgICogICAgIGZyZXNoLCBvciBgbnVsbGAgaWYgdGhlIGBSZXNwb25zZWAgaXMgb2xkZXIgdGhhbiBgbWF4QWdlU2Vjb25kc2AuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhY2hlZFJlc3BvbnNlV2lsbEJlVXNlZCA9IGFzeW5jICh7IGV2ZW50LCByZXF1ZXN0LCBjYWNoZU5hbWUsIGNhY2hlZFJlc3BvbnNlIH0pID0+IHtcbiAgICAgICAgICAgIGlmICghY2FjaGVkUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzRnJlc2ggPSB0aGlzLl9pc1Jlc3BvbnNlRGF0ZUZyZXNoKGNhY2hlZFJlc3BvbnNlKTtcbiAgICAgICAgICAgIC8vIEV4cGlyZSBlbnRyaWVzIHRvIGVuc3VyZSB0aGF0IGV2ZW4gaWYgdGhlIGV4cGlyYXRpb24gZGF0ZSBoYXNcbiAgICAgICAgICAgIC8vIGV4cGlyZWQsIGl0J2xsIG9ubHkgYmUgdXNlZCBvbmNlLlxuICAgICAgICAgICAgY29uc3QgY2FjaGVFeHBpcmF0aW9uID0gdGhpcy5fZ2V0Q2FjaGVFeHBpcmF0aW9uKGNhY2hlTmFtZSk7XG4gICAgICAgICAgICBkb250V2FpdEZvcihjYWNoZUV4cGlyYXRpb24uZXhwaXJlRW50cmllcygpKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbWV0YWRhdGEgZm9yIHRoZSByZXF1ZXN0IFVSTCB0byB0aGUgY3VycmVudCB0aW1lc3RhbXAsXG4gICAgICAgICAgICAvLyBidXQgZG9uJ3QgYGF3YWl0YCBpdCBhcyB3ZSBkb24ndCB3YW50IHRvIGJsb2NrIHRoZSByZXNwb25zZS5cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVRpbWVzdGFtcERvbmUgPSBjYWNoZUV4cGlyYXRpb24udXBkYXRlVGltZXN0YW1wKHJlcXVlc3QudXJsKTtcbiAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LndhaXRVbnRpbCh1cGRhdGVUaW1lc3RhbXBEb25lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZXZlbnQgbWF5IG5vdCBiZSBhIGZldGNoIGV2ZW50OyBvbmx5IGxvZyB0aGUgVVJMIGlmIGl0IGlzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdyZXF1ZXN0JyBpbiBldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBVbmFibGUgdG8gZW5zdXJlIHNlcnZpY2Ugd29ya2VyIHN0YXlzIGFsaXZlIHdoZW4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB1cGRhdGluZyBjYWNoZSBlbnRyeSBmb3IgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAnJHtnZXRGcmllbmRseVVSTChldmVudC5yZXF1ZXN0LnVybCl9Jy5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc0ZyZXNoID8gY2FjaGVkUmVzcG9uc2UgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBcImxpZmVjeWNsZVwiIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgYXV0b21hdGljYWxseSBieSB0aGVcbiAgICAgICAgICogYHdvcmtib3gtc3RyYXRlZ2llc2AgaGFuZGxlcnMgd2hlbiBhbiBlbnRyeSBpcyBhZGRlZCB0byBhIGNhY2hlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jYWNoZU5hbWUgTmFtZSBvZiB0aGUgY2FjaGUgdGhhdCB3YXMgdXBkYXRlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucmVxdWVzdCBUaGUgUmVxdWVzdCBmb3IgdGhlIGNhY2hlZCBlbnRyeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FjaGVEaWRVcGRhdGUgPSBhc3luYyAoeyBjYWNoZU5hbWUsIHJlcXVlc3QgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuaXNUeXBlKGNhY2hlTmFtZSwgJ3N0cmluZycsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtZXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1BsdWdpbicsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnY2FjaGVEaWRVcGRhdGUnLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdjYWNoZU5hbWUnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFzc2VydC5pc0luc3RhbmNlKHJlcXVlc3QsIFJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtZXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1BsdWdpbicsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnY2FjaGVEaWRVcGRhdGUnLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdyZXF1ZXN0JyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhY2hlRXhwaXJhdGlvbiA9IHRoaXMuX2dldENhY2hlRXhwaXJhdGlvbihjYWNoZU5hbWUpO1xuICAgICAgICAgICAgYXdhaXQgY2FjaGVFeHBpcmF0aW9uLnVwZGF0ZVRpbWVzdGFtcChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgICBhd2FpdCBjYWNoZUV4cGlyYXRpb24uZXhwaXJlRW50cmllcygpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgaWYgKCEoY29uZmlnLm1heEVudHJpZXMgfHwgY29uZmlnLm1heEFnZVNlY29uZHMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignbWF4LWVudHJpZXMtb3ItYWdlLXJlcXVpcmVkJywge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1leHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUGx1Z2luJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLm1heEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuaXNUeXBlKGNvbmZpZy5tYXhFbnRyaWVzLCAnbnVtYmVyJywge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1leHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUGx1Z2luJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ2NvbmZpZy5tYXhFbnRyaWVzJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcubWF4QWdlU2Vjb25kcykge1xuICAgICAgICAgICAgICAgIGFzc2VydC5pc1R5cGUoY29uZmlnLm1heEFnZVNlY29uZHMsICdudW1iZXInLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LWV4cGlyYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdQbHVnaW4nLFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnY29uZmlnLm1heEFnZVNlY29uZHMnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5fbWF4QWdlU2Vjb25kcyA9IGNvbmZpZy5tYXhBZ2VTZWNvbmRzO1xuICAgICAgICB0aGlzLl9jYWNoZUV4cGlyYXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoY29uZmlnLnB1cmdlT25RdW90YUVycm9yKSB7XG4gICAgICAgICAgICByZWdpc3RlclF1b3RhRXJyb3JDYWxsYmFjaygoKSA9PiB0aGlzLmRlbGV0ZUNhY2hlQW5kTWV0YWRhdGEoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgaGVscGVyIG1ldGhvZCB0byByZXR1cm4gYSBDYWNoZUV4cGlyYXRpb24gaW5zdGFuY2UgZm9yIGEgZ2l2ZW5cbiAgICAgKiBjYWNoZSBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZVxuICAgICAqIEByZXR1cm4ge0NhY2hlRXhwaXJhdGlvbn1cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldENhY2hlRXhwaXJhdGlvbihjYWNoZU5hbWUpIHtcbiAgICAgICAgaWYgKGNhY2hlTmFtZSA9PT0gY2FjaGVOYW1lcy5nZXRSdW50aW1lTmFtZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdleHBpcmUtY3VzdG9tLWNhY2hlcy1vbmx5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhY2hlRXhwaXJhdGlvbiA9IHRoaXMuX2NhY2hlRXhwaXJhdGlvbnMuZ2V0KGNhY2hlTmFtZSk7XG4gICAgICAgIGlmICghY2FjaGVFeHBpcmF0aW9uKSB7XG4gICAgICAgICAgICBjYWNoZUV4cGlyYXRpb24gPSBuZXcgQ2FjaGVFeHBpcmF0aW9uKGNhY2hlTmFtZSwgdGhpcy5fY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlRXhwaXJhdGlvbnMuc2V0KGNhY2hlTmFtZSwgY2FjaGVFeHBpcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVFeHBpcmF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1Jlc3BvbnNlfSBjYWNoZWRSZXNwb25zZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc1Jlc3BvbnNlRGF0ZUZyZXNoKGNhY2hlZFJlc3BvbnNlKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWF4QWdlU2Vjb25kcykge1xuICAgICAgICAgICAgLy8gV2UgYXJlbid0IGV4cGlyaW5nIGJ5IGFnZSwgc28gcmV0dXJuIHRydWUsIGl0J3MgZnJlc2hcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSAnZGF0ZScgaGVhZGVyIHdpbGwgc3VmZmljZSBhIHF1aWNrIGV4cGlyYXRpb24gY2hlY2suXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lTGFicy9zdy10b29sYm94L2lzc3Vlcy8xNjQgZm9yXG4gICAgICAgIC8vIGRpc2N1c3Npb24uXG4gICAgICAgIGNvbnN0IGRhdGVIZWFkZXJUaW1lc3RhbXAgPSB0aGlzLl9nZXREYXRlSGVhZGVyVGltZXN0YW1wKGNhY2hlZFJlc3BvbnNlKTtcbiAgICAgICAgaWYgKGRhdGVIZWFkZXJUaW1lc3RhbXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFVuYWJsZSB0byBwYXJzZSBkYXRlLCBzbyBhc3N1bWUgaXQncyBmcmVzaC5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSB2YWxpZCBoZWFkZXJUaW1lLCB0aGVuIG91ciByZXNwb25zZSBpcyBmcmVzaCBpZmYgdGhlXG4gICAgICAgIC8vIGhlYWRlclRpbWUgcGx1cyBtYXhBZ2VTZWNvbmRzIGlzIGdyZWF0ZXIgdGhhbiB0aGUgY3VycmVudCB0aW1lLlxuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gZGF0ZUhlYWRlclRpbWVzdGFtcCA+PSBub3cgLSAodGhpcy5fbWF4QWdlU2Vjb25kcyAqIDEwMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGV4dHJhY3QgdGhlIGRhdGEgaGVhZGVyIGFuZCBwYXJzZSBpdCBpbnRvIGEgdXNlZnVsXG4gICAgICogdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1Jlc3BvbnNlfSBjYWNoZWRSZXNwb25zZVxuICAgICAqIEByZXR1cm4ge251bWJlcnxudWxsfVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0RGF0ZUhlYWRlclRpbWVzdGFtcChjYWNoZWRSZXNwb25zZSkge1xuICAgICAgICBpZiAoIWNhY2hlZFJlc3BvbnNlLmhlYWRlcnMuaGFzKCdkYXRlJykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGVIZWFkZXIgPSBjYWNoZWRSZXNwb25zZS5oZWFkZXJzLmdldCgnZGF0ZScpO1xuICAgICAgICBjb25zdCBwYXJzZWREYXRlID0gbmV3IERhdGUoZGF0ZUhlYWRlcik7XG4gICAgICAgIGNvbnN0IGhlYWRlclRpbWUgPSBwYXJzZWREYXRlLmdldFRpbWUoKTtcbiAgICAgICAgLy8gSWYgdGhlIERhdGUgaGVhZGVyIHdhcyBpbnZhbGlkIGZvciBzb21lIHJlYXNvbiwgcGFyc2VkRGF0ZS5nZXRUaW1lKClcbiAgICAgICAgLy8gd2lsbCByZXR1cm4gTmFOLlxuICAgICAgICBpZiAoaXNOYU4oaGVhZGVyVGltZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJUaW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgaGVscGVyIG1ldGhvZCB0aGF0IHBlcmZvcm1zIHR3byBvcGVyYXRpb25zOlxuICAgICAqXG4gICAgICogLSBEZWxldGVzICphbGwqIHRoZSB1bmRlcmx5aW5nIENhY2hlIGluc3RhbmNlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBwbHVnaW5cbiAgICAgKiBpbnN0YW5jZSwgYnkgY2FsbGluZyBjYWNoZXMuZGVsZXRlKCkgb24geW91ciBiZWhhbGYuXG4gICAgICogLSBEZWxldGVzIHRoZSBtZXRhZGF0YSBmcm9tIEluZGV4ZWREQiB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgZXhwaXJhdGlvblxuICAgICAqIGRldGFpbHMgZm9yIGVhY2ggQ2FjaGUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBXaGVuIHVzaW5nIGNhY2hlIGV4cGlyYXRpb24sIGNhbGxpbmcgdGhpcyBtZXRob2QgaXMgcHJlZmVyYWJsZSB0byBjYWxsaW5nXG4gICAgICogYGNhY2hlcy5kZWxldGUoKWAgZGlyZWN0bHksIHNpbmNlIHRoaXMgd2lsbCBlbnN1cmUgdGhhdCB0aGUgSW5kZXhlZERCXG4gICAgICogbWV0YWRhdGEgaXMgYWxzbyBjbGVhbmx5IHJlbW92ZWQgYW5kIG9wZW4gSW5kZXhlZERCIGluc3RhbmNlcyBhcmUgZGVsZXRlZC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBpZiB5b3UncmUgKm5vdCogdXNpbmcgY2FjaGUgZXhwaXJhdGlvbiBmb3IgYSBnaXZlbiBjYWNoZSwgY2FsbGluZ1xuICAgICAqIGBjYWNoZXMuZGVsZXRlKClgIGFuZCBwYXNzaW5nIGluIHRoZSBjYWNoZSdzIG5hbWUgc2hvdWxkIGJlIHN1ZmZpY2llbnQuXG4gICAgICogVGhlcmUgaXMgbm8gV29ya2JveC1zcGVjaWZpYyBtZXRob2QgbmVlZGVkIGZvciBjbGVhbnVwIGluIHRoYXQgY2FzZS5cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVDYWNoZUFuZE1ldGFkYXRhKCkge1xuICAgICAgICAvLyBEbyB0aGlzIG9uZSBhdCBhIHRpbWUgaW5zdGVhZCBvZiBhbGwgYXQgb25jZSB2aWEgYFByb21pc2UuYWxsKClgIHRvXG4gICAgICAgIC8vIHJlZHVjZSB0aGUgY2hhbmNlIG9mIGluY29uc2lzdGVuY3kgaWYgYSBwcm9taXNlIHJlamVjdHMuXG4gICAgICAgIGZvciAoY29uc3QgW2NhY2hlTmFtZSwgY2FjaGVFeHBpcmF0aW9uXSBvZiB0aGlzLl9jYWNoZUV4cGlyYXRpb25zKSB7XG4gICAgICAgICAgICBhd2FpdCBzZWxmLmNhY2hlcy5kZWxldGUoY2FjaGVOYW1lKTtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlRXhwaXJhdGlvbi5kZWxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNldCB0aGlzLl9jYWNoZUV4cGlyYXRpb25zIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuICAgICAgICB0aGlzLl9jYWNoZUV4cGlyYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIH1cbn1cbmV4cG9ydCB7IEV4cGlyYXRpb25QbHVnaW4gfTtcbiIsImltcG9ydCB7IHRpbWVzdGFtcCwgZmlsZXMsIHNoZWxsIH0gZnJvbSAnQHNhcHBlci9zZXJ2aWNlLXdvcmtlcic7XG5pbXBvcnQgeyBwcmVjYWNoZUFuZFJvdXRlIH0gZnJvbSAnd29ya2JveC1wcmVjYWNoaW5nJztcbmltcG9ydCB7IENhY2hlRmlyc3QgfSBmcm9tICd3b3JrYm94LXN0cmF0ZWdpZXMnO1xuaW1wb3J0IHsgcmVnaXN0ZXJSb3V0ZSB9IGZyb20gJ3dvcmtib3gtcm91dGluZyc7XG5pbXBvcnQgeyBFeHBpcmF0aW9uUGx1Z2luIH0gZnJvbSAnd29ya2JveC1leHBpcmF0aW9uJztcblxuY29uc3QgQVNTRVRTID0gYGNhY2hlJHt0aW1lc3RhbXB9YDtcblxuLy8gYHNoZWxsYCBpcyBhbiBhcnJheSBvZiBhbGwgdGhlIGZpbGVzIGdlbmVyYXRlZCBieSB0aGUgYnVuZGxlcixcbi8vIGBmaWxlc2AgaXMgYW4gYXJyYXkgb2YgZXZlcnl0aGluZyBpbiB0aGUgYHN0YXRpY2AgZGlyZWN0b3J5XG5jb25zdCB0b19jYWNoZSA9IHNoZWxsLmNvbmNhdChmaWxlcyk7XG5jb25zdCBzdGF0aWNBc3NldHMgPSBuZXcgU2V0KHRvX2NhY2hlKTtcblxuc2VsZi5fX1dCX0RJU0FCTEVfREVWX0xPR1MgPSB0cnVlO1xuXG5wcmVjYWNoZUFuZFJvdXRlKHNoZWxsKTtcbnByZWNhY2hlQW5kUm91dGUoZmlsZXMpO1xuXG5yZWdpc3RlclJvdXRlKFxuLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICovXG4gIG5ldyBSZWdFeHAoJ2h0dHBzOlxcL1xcL3Byb2R1Y3RldXJzYWdyaVxcLm9wZW5kYXRhc29mdFxcLmNvbScpLFxuICBuZXcgQ2FjaGVGaXJzdCh7XG4gICAgY2FjaGVOYW1lOiBgb2RzLXJlcXVlc3RzLSR7dGltZXN0YW1wfWAsXG4gICAgcGx1Z2luczogW1xuICAgICAgbmV3IEV4cGlyYXRpb25QbHVnaW4oe1xuICAgICAgICBtYXhFbnRyaWVzOiA1MCxcbiAgICAgICAgbWF4QWdlU2Vjb25kczogMzYwMCAqIDI0LFxuICAgICAgfSksXG4gICAgXSxcbiAgfSksXG4pO1xuIl0sIm5hbWVzIjpbImFzc2VydCIsIm1lc3NhZ2VzIl0sIm1hcHBpbmdzIjoiOzs7Q0FBQTtDQUNPLE1BQU0sU0FBUyxHQUFHLGFBQWEsQ0FBQztBQUN2QztDQUNPLE1BQU0sS0FBSyxHQUFHO0NBQ3JCLENBQUMsNEJBQTRCO0NBQzdCLENBQUMsNkJBQTZCO0NBQzlCLENBQUMsNkJBQTZCO0NBQzlCLENBQUMsdUJBQXVCO0NBQ3hCLENBQUMsb0JBQW9CO0NBQ3JCLENBQUMsb0JBQW9CO0NBQ3JCLENBQUMsb0JBQW9CO0NBQ3JCLENBQUMsY0FBYztDQUNmLENBQUMsY0FB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
