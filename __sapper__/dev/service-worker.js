(function () {
	'use strict';

	// This file is generated by Sapper â€” do not edit it!
	const timestamp = 1608153684751;

	const files = [
		"/service-worker-index.html",
		"/resources/android-chrome-192x192.png",
		"/resources/android-chrome-512x512.png",
		"/resources/apple-touch-icon.png",
		"/resources/browserconfig.xml",
		"/resources/favicon-16x16.png",
		"/resources/favicon-32x32.png",
		"/resources/favicon.ico",
		"/resources/favicon.png",
		"/resources/global.css",
		"/resources/location.svg",
		"/resources/logo-192.png",
		"/resources/logo-512.png",
		"/resources/manifest.webmanifest",
		"/resources/mstile-144x144.png",
		"/resources/mstile-150x150.png",
		"/resources/mstile-310x150.png",
		"/resources/mstile-310x310.png",
		"/resources/mstile-70x70.png",
		"/resources/safari-pinned-tab.svg"
	];

	const shell = [
		
	];

	// @ts-ignore
	try {
	    self['workbox:core:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const messages = {
	    'invalid-value': ({ paramName, validValueDescription, value }) => {
	        if (!paramName || !validValueDescription) {
	            throw new Error(`Unexpected input to 'invalid-value' error.`);
	        }
	        return `The '${paramName}' parameter was given a value with an ` +
	            `unexpected value. ${validValueDescription} Received a value of ` +
	            `${JSON.stringify(value)}.`;
	    },
	    'not-an-array': ({ moduleName, className, funcName, paramName }) => {
	        if (!moduleName || !className || !funcName || !paramName) {
	            throw new Error(`Unexpected input to 'not-an-array' error.`);
	        }
	        return `The parameter '${paramName}' passed into ` +
	            `'${moduleName}.${className}.${funcName}()' must be an array.`;
	    },
	    'incorrect-type': ({ expectedType, paramName, moduleName, className, funcName }) => {
	        if (!expectedType || !paramName || !moduleName || !funcName) {
	            throw new Error(`Unexpected input to 'incorrect-type' error.`);
	        }
	        return `The parameter '${paramName}' passed into ` +
	            `'${moduleName}.${className ? (className + '.') : ''}` +
	            `${funcName}()' must be of type ${expectedType}.`;
	    },
	    'incorrect-class': ({ expectedClass, paramName, moduleName, className, funcName, isReturnValueProblem }) => {
	        if (!expectedClass || !moduleName || !funcName) {
	            throw new Error(`Unexpected input to 'incorrect-class' error.`);
	        }
	        if (isReturnValueProblem) {
	            return `The return value from ` +
	                `'${moduleName}.${className ? (className + '.') : ''}${funcName}()' ` +
	                `must be an instance of class ${expectedClass.name}.`;
	        }
	        return `The parameter '${paramName}' passed into ` +
	            `'${moduleName}.${className ? (className + '.') : ''}${funcName}()' ` +
	            `must be an instance of class ${expectedClass.name}.`;
	    },
	    'missing-a-method': ({ expectedMethod, paramName, moduleName, className, funcName }) => {
	        if (!expectedMethod || !paramName || !moduleName || !className
	            || !funcName) {
	            throw new Error(`Unexpected input to 'missing-a-method' error.`);
	        }
	        return `${moduleName}.${className}.${funcName}() expected the ` +
	            `'${paramName}' parameter to expose a '${expectedMethod}' method.`;
	    },
	    'add-to-cache-list-unexpected-type': ({ entry }) => {
	        return `An unexpected entry was passed to ` +
	            `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` +
	            `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` +
	            `strings with one or more characters, objects with a url property or ` +
	            `Request objects.`;
	    },
	    'add-to-cache-list-conflicting-entries': ({ firstEntry, secondEntry }) => {
	        if (!firstEntry || !secondEntry) {
	            throw new Error(`Unexpected input to ` +
	                `'add-to-cache-list-duplicate-entries' error.`);
	        }
	        return `Two of the entries passed to ` +
	            `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` +
	            `${firstEntry._entryId} but different revision details. Workbox is ` +
	            `unable to cache and version the asset correctly. Please remove one ` +
	            `of the entries.`;
	    },
	    'plugin-error-request-will-fetch': ({ thrownError }) => {
	        if (!thrownError) {
	            throw new Error(`Unexpected input to ` +
	                `'plugin-error-request-will-fetch', error.`);
	        }
	        return `An error was thrown by a plugins 'requestWillFetch()' method. ` +
	            `The thrown error message was: '${thrownError.message}'.`;
	    },
	    'invalid-cache-name': ({ cacheNameId, value }) => {
	        if (!cacheNameId) {
	            throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);
	        }
	        return `You must provide a name containing at least one character for ` +
	            `setCacheDetails({${cacheNameId}: '...'}). Received a value of ` +
	            `'${JSON.stringify(value)}'`;
	    },
	    'unregister-route-but-not-found-with-method': ({ method }) => {
	        if (!method) {
	            throw new Error(`Unexpected input to ` +
	                `'unregister-route-but-not-found-with-method' error.`);
	        }
	        return `The route you're trying to unregister was not  previously ` +
	            `registered for the method type '${method}'.`;
	    },
	    'unregister-route-route-not-registered': () => {
	        return `The route you're trying to unregister was not previously ` +
	            `registered.`;
	    },
	    'queue-replay-failed': ({ name }) => {
	        return `Replaying the background sync queue '${name}' failed.`;
	    },
	    'duplicate-queue-name': ({ name }) => {
	        return `The Queue name '${name}' is already being used. ` +
	            `All instances of backgroundSync.Queue must be given unique names.`;
	    },
	    'expired-test-without-max-age': ({ methodName, paramName }) => {
	        return `The '${methodName}()' method can only be used when the ` +
	            `'${paramName}' is used in the constructor.`;
	    },
	    'unsupported-route-type': ({ moduleName, className, funcName, paramName }) => {
	        return `The supplied '${paramName}' parameter was an unsupported type. ` +
	            `Please check the docs for ${moduleName}.${className}.${funcName} for ` +
	            `valid input types.`;
	    },
	    'not-array-of-class': ({ value, expectedClass, moduleName, className, funcName, paramName }) => {
	        return `The supplied '${paramName}' parameter must be an array of ` +
	            `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` +
	            `Please check the call to ${moduleName}.${className}.${funcName}() ` +
	            `to fix the issue.`;
	    },
	    'max-entries-or-age-required': ({ moduleName, className, funcName }) => {
	        return `You must define either config.maxEntries or config.maxAgeSeconds` +
	            `in ${moduleName}.${className}.${funcName}`;
	    },
	    'statuses-or-headers-required': ({ moduleName, className, funcName }) => {
	        return `You must define either config.statuses or config.headers` +
	            `in ${moduleName}.${className}.${funcName}`;
	    },
	    'invalid-string': ({ moduleName, funcName, paramName }) => {
	        if (!paramName || !moduleName || !funcName) {
	            throw new Error(`Unexpected input to 'invalid-string' error.`);
	        }
	        return `When using strings, the '${paramName}' parameter must start with ` +
	            `'http' (for cross-origin matches) or '/' (for same-origin matches). ` +
	            `Please see the docs for ${moduleName}.${funcName}() for ` +
	            `more info.`;
	    },
	    'channel-name-required': () => {
	        return `You must provide a channelName to construct a ` +
	            `BroadcastCacheUpdate instance.`;
	    },
	    'invalid-responses-are-same-args': () => {
	        return `The arguments passed into responsesAreSame() appear to be ` +
	            `invalid. Please ensure valid Responses are used.`;
	    },
	    'expire-custom-caches-only': () => {
	        return `You must provide a 'cacheName' property when using the ` +
	            `expiration plugin with a runtime caching strategy.`;
	    },
	    'unit-must-be-bytes': ({ normalizedRangeHeader }) => {
	        if (!normalizedRangeHeader) {
	            throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);
	        }
	        return `The 'unit' portion of the Range header must be set to 'bytes'. ` +
	            `The Range header provided was "${normalizedRangeHeader}"`;
	    },
	    'single-range-only': ({ normalizedRangeHeader }) => {
	        if (!normalizedRangeHeader) {
	            throw new Error(`Unexpected input to 'single-range-only' error.`);
	        }
	        return `Multiple ranges are not supported. Please use a  single start ` +
	            `value, and optional end value. The Range header provided was ` +
	            `"${normalizedRangeHeader}"`;
	    },
	    'invalid-range-values': ({ normalizedRangeHeader }) => {
	        if (!normalizedRangeHeader) {
	            throw new Error(`Unexpected input to 'invalid-range-values' error.`);
	        }
	        return `The Range header is missing both start and end values. At least ` +
	            `one of those values is needed. The Range header provided was ` +
	            `"${normalizedRangeHeader}"`;
	    },
	    'no-range-header': () => {
	        return `No Range header was found in the Request provided.`;
	    },
	    'range-not-satisfiable': ({ size, start, end }) => {
	        return `The start (${start}) and end (${end}) values in the Range are ` +
	            `not satisfiable by the cached response, which is ${size} bytes.`;
	    },
	    'attempt-to-cache-non-get-request': ({ url, method }) => {
	        return `Unable to cache '${url}' because it is a '${method}' request and ` +
	            `only 'GET' requests can be cached.`;
	    },
	    'cache-put-with-no-response': ({ url }) => {
	        return `There was an attempt to cache '${url}' but the response was not ` +
	            `defined.`;
	    },
	    'no-response': ({ url, error }) => {
	        let message = `The strategy could not generate a response for '${url}'.`;
	        if (error) {
	            message += ` The underlying error is ${error}.`;
	        }
	        return message;
	    },
	    'bad-precaching-response': ({ url, status }) => {
	        return `The precaching request for '${url}' failed` +
	            (status ? ` with an HTTP status of ${status}.` : `.`);
	    },
	    'non-precached-url': ({ url }) => {
	        return `createHandlerBoundToURL('${url}') was called, but that URL is ` +
	            `not precached. Please pass in a URL that is precached instead.`;
	    },
	    'add-to-cache-list-conflicting-integrities': ({ url }) => {
	        return `Two of the entries passed to ` +
	            `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` +
	            `${url} with different integrity values. Please remove one of them.`;
	    },
	    'missing-precache-entry': ({ cacheName, url }) => {
	        return `Unable to find a precached response in ${cacheName} for ${url}.`;
	    },
	    'cross-origin-copy-response': ({ origin }) => {
	        return `workbox-core.copyResponse() can only be used with same-origin ` +
	            `responses. It was passed a response with origin ${origin}.`;
	    },
	};

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const generatorFunction = (code, details = {}) => {
	    const message = messages[code];
	    if (!message) {
	        throw new Error(`Unable to find message for code '${code}'.`);
	    }
	    return message(details);
	};
	const messageGenerator =  generatorFunction;

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Workbox errors should be thrown with this class.
	 * This allows use to ensure the type easily in tests,
	 * helps developers identify errors from workbox
	 * easily and allows use to optimise error
	 * messages correctly.
	 *
	 * @private
	 */
	class WorkboxError extends Error {
	    /**
	     *
	     * @param {string} errorCode The error code that
	     * identifies this particular error.
	     * @param {Object=} details Any relevant arguments
	     * that will help developers identify issues should
	     * be added as a key on the context object.
	     */
	    constructor(errorCode, details) {
	        const message = messageGenerator(errorCode, details);
	        super(message);
	        this.name = errorCode;
	        this.details = details;
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/*
	 * This method throws if the supplied value is not an array.
	 * The destructed values are required to produce a meaningful error for users.
	 * The destructed and restructured object is so it's clear what is
	 * needed.
	 */
	const isArray = (value, details) => {
	    if (!Array.isArray(value)) {
	        throw new WorkboxError('not-an-array', details);
	    }
	};
	const hasMethod = (object, expectedMethod, details) => {
	    const type = typeof object[expectedMethod];
	    if (type !== 'function') {
	        details['expectedMethod'] = expectedMethod;
	        throw new WorkboxError('missing-a-method', details);
	    }
	};
	const isType = (object, expectedType, details) => {
	    if (typeof object !== expectedType) {
	        details['expectedType'] = expectedType;
	        throw new WorkboxError('incorrect-type', details);
	    }
	};
	const isInstance = (object, expectedClass, details) => {
	    if (!(object instanceof expectedClass)) {
	        details['expectedClass'] = expectedClass;
	        throw new WorkboxError('incorrect-class', details);
	    }
	};
	const isOneOf = (value, validValues, details) => {
	    if (!validValues.includes(value)) {
	        details['validValueDescription'] =
	            `Valid values are ${JSON.stringify(validValues)}.`;
	        throw new WorkboxError('invalid-value', details);
	    }
	};
	const isArrayOfClass = (value, expectedClass, details) => {
	    const error = new WorkboxError('not-array-of-class', details);
	    if (!Array.isArray(value)) {
	        throw error;
	    }
	    for (const item of value) {
	        if (!(item instanceof expectedClass)) {
	            throw error;
	        }
	    }
	};
	const finalAssertExports =  {
	    hasMethod,
	    isArray,
	    isInstance,
	    isOneOf,
	    isType,
	    isArrayOfClass,
	};

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const _cacheNameDetails = {
	    googleAnalytics: 'googleAnalytics',
	    precache: 'precache-v2',
	    prefix: 'workbox',
	    runtime: 'runtime',
	    suffix: typeof registration !== 'undefined' ? registration.scope : '',
	};
	const _createCacheName = (cacheName) => {
	    return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix]
	        .filter((value) => value && value.length > 0)
	        .join('-');
	};
	const eachCacheNameDetail = (fn) => {
	    for (const key of Object.keys(_cacheNameDetails)) {
	        fn(key);
	    }
	};
	const cacheNames = {
	    updateDetails: (details) => {
	        eachCacheNameDetail((key) => {
	            if (typeof details[key] === 'string') {
	                _cacheNameDetails[key] = details[key];
	            }
	        });
	    },
	    getGoogleAnalyticsName: (userCacheName) => {
	        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);
	    },
	    getPrecacheName: (userCacheName) => {
	        return userCacheName || _createCacheName(_cacheNameDetails.precache);
	    },
	    getPrefix: () => {
	        return _cacheNameDetails.prefix;
	    },
	    getRuntimeName: (userCacheName) => {
	        return userCacheName || _createCacheName(_cacheNameDetails.runtime);
	    },
	    getSuffix: () => {
	        return _cacheNameDetails.suffix;
	    },
	};

	/*
	  Copyright 2019 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const logger = ( (() => {
	    // Don't overwrite this value if it's already set.
	    // See https://github.com/GoogleChrome/workbox/pull/2284#issuecomment-560470923
	    if (!('__WB_DISABLE_DEV_LOGS' in self)) {
	        self.__WB_DISABLE_DEV_LOGS = false;
	    }
	    let inGroup = false;
	    const methodToColorMap = {
	        debug: `#7f8c8d`,
	        log: `#2ecc71`,
	        warn: `#f39c12`,
	        error: `#c0392b`,
	        groupCollapsed: `#3498db`,
	        groupEnd: null,
	    };
	    const print = function (method, args) {
	        if (self.__WB_DISABLE_DEV_LOGS) {
	            return;
	        }
	        if (method === 'groupCollapsed') {
	            // Safari doesn't print all console.groupCollapsed() arguments:
	            // https://bugs.webkit.org/show_bug.cgi?id=182754
	            if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
	                console[method](...args);
	                return;
	            }
	        }
	        const styles = [
	            `background: ${methodToColorMap[method]}`,
	            `border-radius: 0.5em`,
	            `color: white`,
	            `font-weight: bold`,
	            `padding: 2px 0.5em`,
	        ];
	        // When in a group, the workbox prefix is not displayed.
	        const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];
	        console[method](...logPrefix, ...args);
	        if (method === 'groupCollapsed') {
	            inGroup = true;
	        }
	        if (method === 'groupEnd') {
	            inGroup = false;
	        }
	    };
	    const api = {};
	    const loggerMethods = Object.keys(methodToColorMap);
	    for (const key of loggerMethods) {
	        const method = key;
	        api[method] = (...args) => {
	            print(method, args);
	        };
	    }
	    return api;
	})());

	/*
	  Copyright 2020 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A utility method that makes it easier to use `event.waitUntil` with
	 * async functions and return the result.
	 *
	 * @param {ExtendableEvent} event
	 * @param {Function} asyncFn
	 * @return {Function}
	 * @private
	 */
	function waitUntil(event, asyncFn) {
	    const returnPromise = asyncFn();
	    event.waitUntil(returnPromise);
	    return returnPromise;
	}

	// @ts-ignore
	try {
	    self['workbox:precaching:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	// Name of the search parameter used to store revision info.
	const REVISION_SEARCH_PARAM = '__WB_REVISION__';
	/**
	 * Converts a manifest entry into a versioned URL suitable for precaching.
	 *
	 * @param {Object|string} entry
	 * @return {string} A URL with versioning info.
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function createCacheKey(entry) {
	    if (!entry) {
	        throw new WorkboxError('add-to-cache-list-unexpected-type', { entry });
	    }
	    // If a precache manifest entry is a string, it's assumed to be a versioned
	    // URL, like '/app.abcd1234.js'. Return as-is.
	    if (typeof entry === 'string') {
	        const urlObject = new URL(entry, location.href);
	        return {
	            cacheKey: urlObject.href,
	            url: urlObject.href,
	        };
	    }
	    const { revision, url } = entry;
	    if (!url) {
	        throw new WorkboxError('add-to-cache-list-unexpected-type', { entry });
	    }
	    // If there's just a URL and no revision, then it's also assumed to be a
	    // versioned URL.
	    if (!revision) {
	        const urlObject = new URL(url, location.href);
	        return {
	            cacheKey: urlObject.href,
	            url: urlObject.href,
	        };
	    }
	    // Otherwise, construct a properly versioned URL using the custom Workbox
	    // search parameter along with the revision info.
	    const cacheKeyURL = new URL(url, location.href);
	    const originalURL = new URL(url, location.href);
	    cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);
	    return {
	        cacheKey: cacheKeyURL.href,
	        url: originalURL.href,
	    };
	}

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A plugin, designed to be used with PrecacheController, to determine the
	 * of assets that were updated (or not updated) during the install event.
	 *
	 * @private
	 */
	class PrecacheInstallReportPlugin {
	    constructor() {
	        this.updatedURLs = [];
	        this.notUpdatedURLs = [];
	        this.handlerWillStart = async ({ request, state, }) => {
	            // TODO: `state` should never be undefined...
	            if (state) {
	                state.originalRequest = request;
	            }
	        };
	        this.cachedResponseWillBeUsed = async ({ event, state, cachedResponse, }) => {
	            if (event.type === 'install') {
	                // TODO: `state` should never be undefined...
	                const url = state.originalRequest.url;
	                if (cachedResponse) {
	                    this.notUpdatedURLs.push(url);
	                }
	                else {
	                    this.updatedURLs.push(url);
	                }
	            }
	            return cachedResponse;
	        };
	    }
	}

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A plugin, designed to be used with PrecacheController, to translate URLs into
	 * the corresponding cache key, based on the current revision info.
	 *
	 * @private
	 */
	class PrecacheCacheKeyPlugin {
	    constructor({ precacheController }) {
	        this.cacheKeyWillBeUsed = async ({ request, params, }) => {
	            const cacheKey = params && params.cacheKey ||
	                this._precacheController.getCacheKeyForURL(request.url);
	            return cacheKey ? new Request(cacheKey) : request;
	        };
	        this._precacheController = precacheController;
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * @param {string} groupTitle
	 * @param {Array<string>} deletedURLs
	 *
	 * @private
	 */
	const logGroup = (groupTitle, deletedURLs) => {
	    logger.groupCollapsed(groupTitle);
	    for (const url of deletedURLs) {
	        logger.log(url);
	    }
	    logger.groupEnd();
	};
	/**
	 * @param {Array<string>} deletedURLs
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function printCleanupDetails(deletedURLs) {
	    const deletionCount = deletedURLs.length;
	    if (deletionCount > 0) {
	        logger.groupCollapsed(`During precaching cleanup, ` +
	            `${deletionCount} cached ` +
	            `request${deletionCount === 1 ? ' was' : 's were'} deleted.`);
	        logGroup('Deleted Cache Requests', deletedURLs);
	        logger.groupEnd();
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * @param {string} groupTitle
	 * @param {Array<string>} urls
	 *
	 * @private
	 */
	function _nestedGroup(groupTitle, urls) {
	    if (urls.length === 0) {
	        return;
	    }
	    logger.groupCollapsed(groupTitle);
	    for (const url of urls) {
	        logger.log(url);
	    }
	    logger.groupEnd();
	}
	/**
	 * @param {Array<string>} urlsToPrecache
	 * @param {Array<string>} urlsAlreadyPrecached
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function printInstallDetails(urlsToPrecache, urlsAlreadyPrecached) {
	    const precachedCount = urlsToPrecache.length;
	    const alreadyPrecachedCount = urlsAlreadyPrecached.length;
	    if (precachedCount || alreadyPrecachedCount) {
	        let message = `Precaching ${precachedCount} file${precachedCount === 1 ? '' : 's'}.`;
	        if (alreadyPrecachedCount > 0) {
	            message += ` ${alreadyPrecachedCount} ` +
	                `file${alreadyPrecachedCount === 1 ? ' is' : 's are'} already cached.`;
	        }
	        logger.groupCollapsed(message);
	        _nestedGroup(`View newly precached URLs.`, urlsToPrecache);
	        _nestedGroup(`View previously precached URLs.`, urlsAlreadyPrecached);
	        logger.groupEnd();
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	let supportStatus;
	/**
	 * A utility function that determines whether the current browser supports
	 * constructing a new `Response` from a `response.body` stream.
	 *
	 * @return {boolean} `true`, if the current browser can successfully
	 *     construct a `Response` from a `response.body` stream, `false` otherwise.
	 *
	 * @private
	 */
	function canConstructResponseFromBodyStream() {
	    if (supportStatus === undefined) {
	        const testResponse = new Response('');
	        if ('body' in testResponse) {
	            try {
	                new Response(testResponse.body);
	                supportStatus = true;
	            }
	            catch (error) {
	                supportStatus = false;
	            }
	        }
	        supportStatus = false;
	    }
	    return supportStatus;
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Allows developers to copy a response and modify its `headers`, `status`,
	 * or `statusText` values (the values settable via a
	 * [`ResponseInit`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#Syntax}
	 * object in the constructor).
	 * To modify these values, pass a function as the second argument. That
	 * function will be invoked with a single object with the response properties
	 * `{headers, status, statusText}`. The return value of this function will
	 * be used as the `ResponseInit` for the new `Response`. To change the values
	 * either modify the passed parameter(s) and return it, or return a totally
	 * new object.
	 *
	 * This method is intentionally limited to same-origin responses, regardless of
	 * whether CORS was used or not.
	 *
	 * @param {Response} response
	 * @param {Function} modifier
	 * @memberof module:workbox-core
	 */
	async function copyResponse(response, modifier) {
	    let origin = null;
	    // If response.url isn't set, assume it's cross-origin and keep origin null.
	    if (response.url) {
	        const responseURL = new URL(response.url);
	        origin = responseURL.origin;
	    }
	    if (origin !== self.location.origin) {
	        throw new WorkboxError('cross-origin-copy-response', { origin });
	    }
	    const clonedResponse = response.clone();
	    // Create a fresh `ResponseInit` object by cloning the headers.
	    const responseInit = {
	        headers: new Headers(clonedResponse.headers),
	        status: clonedResponse.status,
	        statusText: clonedResponse.statusText,
	    };
	    // Apply any user modifications.
	    const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;
	    // Create the new response from the body stream and `ResponseInit`
	    // modifications. Note: not all browsers support the Response.body stream,
	    // so fall back to reading the entire body into memory as a blob.
	    const body = canConstructResponseFromBodyStream() ?
	        clonedResponse.body : await clonedResponse.blob();
	    return new Response(body, modifiedResponseInit);
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const getFriendlyURL = (url) => {
	    const urlObj = new URL(String(url), location.href);
	    // See https://github.com/GoogleChrome/workbox/issues/2323
	    // We want to include everything, except for the origin if it's same-origin.
	    return urlObj.href.replace(new RegExp(`^${location.origin}`), '');
	};

	/*
	  Copyright 2020 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	function stripParams(fullURL, ignoreParams) {
	    const strippedURL = new URL(fullURL);
	    for (const param of ignoreParams) {
	        strippedURL.searchParams.delete(param);
	    }
	    return strippedURL.href;
	}
	/**
	 * Matches an item in the cache, ignoring specific URL params. This is similar
	 * to the `ignoreSearch` option, but it allows you to ignore just specific
	 * params (while continuing to match on the others).
	 *
	 * @private
	 * @param {Cache} cache
	 * @param {Request} request
	 * @param {Object} matchOptions
	 * @param {Array<string>} ignoreParams
	 * @return {Promise<Response|undefined>}
	 */
	async function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {
	    const strippedRequestURL = stripParams(request.url, ignoreParams);
	    // If the request doesn't include any ignored params, match as normal.
	    if (request.url === strippedRequestURL) {
	        return cache.match(request, matchOptions);
	    }
	    // Otherwise, match by comparing keys
	    const keysOptions = { ...matchOptions, ignoreSearch: true };
	    const cacheKeys = await cache.keys(request, keysOptions);
	    for (const cacheKey of cacheKeys) {
	        const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);
	        if (strippedRequestURL === strippedCacheKeyURL) {
	            return cache.match(cacheKey, matchOptions);
	        }
	    }
	    return;
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * The Deferred class composes Promises in a way that allows for them to be
	 * resolved or rejected from outside the constructor. In most cases promises
	 * should be used directly, but Deferreds can be necessary when the logic to
	 * resolve a promise must be separate.
	 *
	 * @private
	 */
	class Deferred {
	    /**
	     * Creates a promise and exposes its resolve and reject functions as methods.
	     */
	    constructor() {
	        this.promise = new Promise((resolve, reject) => {
	            this.resolve = resolve;
	            this.reject = reject;
	        });
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	// Callbacks to be executed whenever there's a quota error.
	const quotaErrorCallbacks = new Set();

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Runs all of the callback functions, one at a time sequentially, in the order
	 * in which they were registered.
	 *
	 * @memberof module:workbox-core
	 * @private
	 */
	async function executeQuotaErrorCallbacks() {
	    {
	        logger.log(`About to run ${quotaErrorCallbacks.size} ` +
	            `callbacks to clean up caches.`);
	    }
	    for (const callback of quotaErrorCallbacks) {
	        await callback();
	        {
	            logger.log(callback, 'is complete.');
	        }
	    }
	    {
	        logger.log('Finished running callbacks.');
	    }
	}

	/*
	  Copyright 2019 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Returns a promise that resolves and the passed number of milliseconds.
	 * This utility is an async/await-friendly version of `setTimeout`.
	 *
	 * @param {number} ms
	 * @return {Promise}
	 * @private
	 */
	function timeout(ms) {
	    return new Promise((resolve) => setTimeout(resolve, ms));
	}

	// @ts-ignore
	try {
	    self['workbox:strategies:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	function toRequest(input) {
	    return (typeof input === 'string') ? new Request(input) : input;
	}
	/**
	 * A class created every time a Strategy instance instance calls
	 * [handle()]{@link module:workbox-strategies.Strategy~handle} or
	 * [handleAll()]{@link module:workbox-strategies.Strategy~handleAll} that wraps all fetch and
	 * cache actions around plugin callbacks and keeps track of when the strategy
	 * is "done" (i.e. all added `event.waitUntil()` promises have resolved).
	 *
	 * @memberof module:workbox-strategies
	 */
	class StrategyHandler {
	    /**
	     * Creates a new instance associated with the passed strategy and event
	     * that's handling the request.
	     *
	     * The constructor also initializes the state that will be passed to each of
	     * the plugins handling this request.
	     *
	     * @param {module:workbox-strategies.Strategy} strategy
	     * @param {Object} options
	     * @param {Request|string} options.request A request to run this strategy for.
	     * @param {ExtendableEvent} options.event The event associated with the
	     *     request.
	     * @param {URL} [options.url]
	     * @param {*} [options.params]
	     *     [match callback]{@link module:workbox-routing~matchCallback},
	     *     (if applicable).
	     */
	    constructor(strategy, options) {
	        this._cacheKeys = {};
	        /**
	         * The request the strategy is performing (passed to the strategy's
	         * `handle()` or `handleAll()` method).
	         * @name request
	         * @instance
	         * @type {Request}
	         * @memberof module:workbox-strategies.StrategyHandler
	         */
	        /**
	         * The event associated with this request.
	         * @name event
	         * @instance
	         * @type {ExtendableEvent}
	         * @memberof module:workbox-strategies.StrategyHandler
	         */
	        /**
	         * A `URL` instance of `request.url` (if passed to the strategy's
	         * `handle()` or `handleAll()` method).
	         * Note: the `url` param will be present if the strategy was invoked
	         * from a workbox `Route` object.
	         * @name url
	         * @instance
	         * @type {URL|undefined}
	         * @memberof module:workbox-strategies.StrategyHandler
	         */
	        /**
	         * A `param` value (if passed to the strategy's
	         * `handle()` or `handleAll()` method).
	         * Note: the `param` param will be present if the strategy was invoked
	         * from a workbox `Route` object and the
	         * [match callback]{@link module:workbox-routing~matchCallback} returned
	         * a truthy value (it will be that value).
	         * @name params
	         * @instance
	         * @type {*|undefined}
	         * @memberof module:workbox-strategies.StrategyHandler
	         */
	        {
	            finalAssertExports.isInstance(options.event, ExtendableEvent, {
	                moduleName: 'workbox-strategies',
	                className: 'StrategyHandler',
	                funcName: 'constructor',
	                paramName: 'options.event',
	            });
	        }
	        Object.assign(this, options);
	        this.event = options.event;
	        this._strategy = strategy;
	        this._handlerDeferred = new Deferred();
	        this._extendLifetimePromises = [];
	        // Copy the plugins list (since it's mutable on the strategy),
	        // so any mutations don't affect this handler instance.
	        this._plugins = [...strategy.plugins];
	        this._pluginStateMap = new Map();
	        for (const plugin of this._plugins) {
	            this._pluginStateMap.set(plugin, {});
	        }
	        this.event.waitUntil(this._handlerDeferred.promise);
	    }
	    /**
	     * Fetches a given request (and invokes any applicable plugin callback
	     * methods) using the `fetchOptions` and `plugins` defined on the strategy
	     * object.
	     *
	     * The following plugin lifecycle methods are invoked when using this method:
	     * - `requestWillFetch()`
	     * - `fetchDidSucceed()`
	     * - `fetchDidFail()`
	     *
	     * @param {Request|string} input The URL or request to fetch.
	     * @return {Promise<Response>}
	     */
	    fetch(input) {
	        return this.waitUntil((async () => {
	            const { event } = this;
	            let request = toRequest(input);
	            if (request.mode === 'navigate' &&
	                event instanceof FetchEvent &&
	                event.preloadResponse) {
	                const possiblePreloadResponse = await event.preloadResponse;
	                if (possiblePreloadResponse) {
	                    {
	                        logger.log(`Using a preloaded navigation response for ` +
	                            `'${getFriendlyURL(request.url)}'`);
	                    }
	                    return possiblePreloadResponse;
	                }
	            }
	            // If there is a fetchDidFail plugin, we need to save a clone of the
	            // original request before it's either modified by a requestWillFetch
	            // plugin or before the original request's body is consumed via fetch().
	            const originalRequest = this.hasCallback('fetchDidFail') ?
	                request.clone() : null;
	            try {
	                for (const cb of this.iterateCallbacks('requestWillFetch')) {
	                    request = await cb({ request: request.clone(), event });
	                }
	            }
	            catch (err) {
	                throw new WorkboxError('plugin-error-request-will-fetch', {
	                    thrownError: err,
	                });
	            }
	            // The request can be altered by plugins with `requestWillFetch` making
	            // the original request (most likely from a `fetch` event) different
	            // from the Request we make. Pass both to `fetchDidFail` to aid debugging.
	            const pluginFilteredRequest = request.clone();
	            try {
	                let fetchResponse;
	                // See https://github.com/GoogleChrome/workbox/issues/1796
	                fetchResponse = await fetch(request, request.mode === 'navigate' ?
	                    undefined : this._strategy.fetchOptions);
	                if ("development" !== 'production') {
	                    logger.debug(`Network request for ` +
	                        `'${getFriendlyURL(request.url)}' returned a response with ` +
	                        `status '${fetchResponse.status}'.`);
	                }
	                for (const callback of this.iterateCallbacks('fetchDidSucceed')) {
	                    fetchResponse = await callback({
	                        event,
	                        request: pluginFilteredRequest,
	                        response: fetchResponse,
	                    });
	                }
	                return fetchResponse;
	            }
	            catch (error) {
	                {
	                    logger.error(`Network request for ` +
	                        `'${getFriendlyURL(request.url)}' threw an error.`, error);
	                }
	                // `originalRequest` will only exist if a `fetchDidFail` callback
	                // is being used (see above).
	                if (originalRequest) {
	                    await this.runCallbacks('fetchDidFail', {
	                        error,
	                        event,
	                        originalRequest: originalRequest.clone(),
	                        request: pluginFilteredRequest.clone(),
	                    });
	                }
	                throw error;
	            }
	        })());
	    }
	    /**
	     * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on
	     * the response generated by `this.fetch()`.
	     *
	     * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,
	     * so you do not have to manually call `waitUntil()` on the event.
	     *
	     * @param {Request|string} input The request or URL to fetch and cache.
	     * @return {Promise<Response>}
	     */
	    async fetchAndCachePut(input) {
	        const response = await this.fetch(input);
	        const responseClone = response.clone();
	        this.waitUntil(this.cachePut(input, responseClone));
	        return response;
	    }
	    /**
	     * Matches a request from the cache (and invokes any applicable plugin
	     * callback methods) using the `cacheName`, `matchOptions`, and `plugins`
	     * defined on the strategy object.
	     *
	     * The following plugin lifecycle methods are invoked when using this method:
	     * - cacheKeyWillByUsed()
	     * - cachedResponseWillByUsed()
	     *
	     * @param {Request|string} key The Request or URL to use as the cache key.
	     * @return {Promise<Response|undefined>} A matching response, if found.
	     */
	    cacheMatch(key) {
	        return this.waitUntil((async () => {
	            const request = toRequest(key);
	            let cachedResponse;
	            const { cacheName, matchOptions } = this._strategy;
	            const effectiveRequest = await this.getCacheKey(request, 'read');
	            const multiMatchOptions = { ...matchOptions, ...{ cacheName } };
	            cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);
	            {
	                if (cachedResponse) {
	                    logger.debug(`Found a cached response in '${cacheName}'.`);
	                }
	                else {
	                    logger.debug(`No cached response found in '${cacheName}'.`);
	                }
	            }
	            for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {
	                cachedResponse = (await callback({
	                    cacheName,
	                    matchOptions,
	                    cachedResponse,
	                    request: effectiveRequest,
	                    event: this.event,
	                })) || undefined;
	            }
	            return cachedResponse;
	        })());
	    }
	    /**
	     * Puts a request/response pair in the cache (and invokes any applicable
	     * plugin callback methods) using the `cacheName` and `plugins` defined on
	     * the strategy object.
	     *
	     * The following plugin lifecycle methods are invoked when using this method:
	     * - cacheKeyWillByUsed()
	     * - cacheWillUpdate()
	     * - cacheDidUpdate()
	     *
	     * @param {Request|string} key The request or URL to use as the cache key.
	     * @param {Promise<void>} response The response to cache.
	     */
	    async cachePut(key, response) {
	        const request = toRequest(key);
	        // Run in the next task to avoid blocking other cache reads.
	        // https://github.com/w3c/ServiceWorker/issues/1397
	        await timeout(0);
	        const effectiveRequest = await this.getCacheKey(request, 'write');
	        {
	            if (effectiveRequest.method && effectiveRequest.method !== 'GET') {
	                throw new WorkboxError('attempt-to-cache-non-get-request', {
	                    url: getFriendlyURL(effectiveRequest.url),
	                    method: effectiveRequest.method,
	                });
	            }
	        }
	        if (!response) {
	            {
	                logger.error(`Cannot cache non-existent response for ` +
	                    `'${getFriendlyURL(effectiveRequest.url)}'.`);
	            }
	            throw new WorkboxError('cache-put-with-no-response', {
	                url: getFriendlyURL(effectiveRequest.url),
	            });
	        }
	        const responseToCache = await this._ensureResponseSafeToCache(response);
	        if (!responseToCache) {
	            {
	                logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` +
	                    `will not be cached.`, responseToCache);
	            }
	            return;
	        }
	        const { cacheName, matchOptions } = this._strategy;
	        const cache = await self.caches.open(cacheName);
	        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');
	        const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams(
	        // TODO(philipwalton): the `__WB_REVISION__` param is a precaching
	        // feature. Consider into ways to only add this behavior if using
	        // precaching.
	        cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions) :
	            null;
	        {
	            logger.debug(`Updating the '${cacheName}' cache with a new Response ` +
	                `for ${getFriendlyURL(effectiveRequest.url)}.`);
	        }
	        try {
	            await cache.put(effectiveRequest, hasCacheUpdateCallback ?
	                responseToCache.clone() : responseToCache);
	        }
	        catch (error) {
	            // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError
	            if (error.name === 'QuotaExceededError') {
	                await executeQuotaErrorCallbacks();
	            }
	            throw error;
	        }
	        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {
	            await callback({
	                cacheName,
	                oldResponse,
	                newResponse: responseToCache.clone(),
	                request: effectiveRequest,
	                event: this.event,
	            });
	        }
	    }
	    /**
	     * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and
	     * executes any of those callbacks found in sequence. The final `Request`
	     * object returned by the last plugin is treated as the cache key for cache
	     * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have
	     * been registered, the passed request is returned unmodified
	     *
	     * @param {Request} request
	     * @param {string} mode
	     * @return {Promise<Request>}
	     */
	    async getCacheKey(request, mode) {
	        if (!this._cacheKeys[mode]) {
	            let effectiveRequest = request;
	            for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {
	                effectiveRequest = toRequest(await callback({
	                    mode,
	                    request: effectiveRequest,
	                    event: this.event,
	                    params: this.params,
	                }));
	            }
	            this._cacheKeys[mode] = effectiveRequest;
	        }
	        return this._cacheKeys[mode];
	    }
	    /**
	     * Returns true if the strategy has at least one plugin with the given
	     * callback.
	     *
	     * @param {string} name The name of the callback to check for.
	     * @return {boolean}
	     */
	    hasCallback(name) {
	        for (const plugin of this._strategy.plugins) {
	            if (name in plugin) {
	                return true;
	            }
	        }
	        return false;
	    }
	    /**
	     * Runs all plugin callbacks matching the given name, in order, passing the
	     * given param object (merged ith the current plugin state) as the only
	     * argument.
	     *
	     * Note: since this method runs all plugins, it's not suitable for cases
	     * where the return value of a callback needs to be applied prior to calling
	     * the next callback. See
	     * [`iterateCallbacks()`]{@link module:workbox-strategies.StrategyHandler#iterateCallbacks}
	     * below for how to handle that case.
	     *
	     * @param {string} name The name of the callback to run within each plugin.
	     * @param {Object} param The object to pass as the first (and only) param
	     *     when executing each callback. This object will be merged with the
	     *     current plugin state prior to callback execution.
	     */
	    async runCallbacks(name, param) {
	        for (const callback of this.iterateCallbacks(name)) {
	            // TODO(philipwalton): not sure why `any` is needed. It seems like
	            // this should work with `as WorkboxPluginCallbackParam[C]`.
	            await callback(param);
	        }
	    }
	    /**
	     * Accepts a callback and returns an iterable of matching plugin callbacks,
	     * where each callback is wrapped with the current handler state (i.e. when
	     * you call each callback, whatever object parameter you pass it will
	     * be merged with the plugin's current state).
	     *
	     * @param {string} name The name fo the callback to run
	     * @return {Array<Function>}
	     */
	    *iterateCallbacks(name) {
	        for (const plugin of this._strategy.plugins) {
	            if (typeof plugin[name] === 'function') {
	                const state = this._pluginStateMap.get(plugin);
	                const statefulCallback = (param) => {
	                    const statefulParam = { ...param, state };
	                    // TODO(philipwalton): not sure why `any` is needed. It seems like
	                    // this should work with `as WorkboxPluginCallbackParam[C]`.
	                    return plugin[name](statefulParam);
	                };
	                yield statefulCallback;
	            }
	        }
	    }
	    /**
	     * Adds a promise to the
	     * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}
	     * of the event event associated with the request being handled (usually a
	     * `FetchEvent`).
	     *
	     * Note: you can await
	     * [`doneWaiting()`]{@link module:workbox-strategies.StrategyHandler~doneWaiting}
	     * to know when all added promises have settled.
	     *
	     * @param {Promise} promise A promise to add to the extend lifetime promises
	     *     of the event that triggered the request.
	     */
	    waitUntil(promise) {
	        this._extendLifetimePromises.push(promise);
	        return promise;
	    }
	    /**
	     * Returns a promise that resolves once all promises passed to
	     * [`waitUntil()`]{@link module:workbox-strategies.StrategyHandler~waitUntil}
	     * have settled.
	     *
	     * Note: any work done after `doneWaiting()` settles should be manually
	     * passed to an event's `waitUntil()` method (not this handler's
	     * `waitUntil()` method), otherwise the service worker thread my be killed
	     * prior to your work completing.
	     */
	    async doneWaiting() {
	        let promise;
	        while (promise = this._extendLifetimePromises.shift()) {
	            await promise;
	        }
	    }
	    /**
	     * Stops running the strategy and immediately resolves any pending
	     * `waitUntil()` promises.
	     */
	    destroy() {
	        this._handlerDeferred.resolve();
	    }
	    /**
	     * This method will call cacheWillUpdate on the available plugins (or use
	     * status === 200) to determine if the Response is safe and valid to cache.
	     *
	     * @param {Request} options.request
	     * @param {Response} options.response
	     * @return {Promise<Response|undefined>}
	     *
	     * @private
	     */
	    async _ensureResponseSafeToCache(response) {
	        let responseToCache = response;
	        let pluginsUsed = false;
	        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {
	            responseToCache = (await callback({
	                request: this.request,
	                response: responseToCache,
	                event: this.event,
	            })) || undefined;
	            pluginsUsed = true;
	            if (!responseToCache) {
	                break;
	            }
	        }
	        if (!pluginsUsed) {
	            if (responseToCache && responseToCache.status !== 200) {
	                responseToCache = undefined;
	            }
	            {
	                if (responseToCache) {
	                    if (responseToCache.status !== 200) {
	                        if (responseToCache.status === 0) {
	                            logger.warn(`The response for '${this.request.url}' ` +
	                                `is an opaque response. The caching strategy that you're ` +
	                                `using will not cache opaque responses by default.`);
	                        }
	                        else {
	                            logger.debug(`The response for '${this.request.url}' ` +
	                                `returned a status code of '${response.status}' and won't ` +
	                                `be cached as a result.`);
	                        }
	                    }
	                }
	            }
	        }
	        return responseToCache;
	    }
	}

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * An abstract base class that all other strategy classes must extend from:
	 *
	 * @memberof module:workbox-strategies
	 */
	class Strategy {
	    /**
	     * Creates a new instance of the strategy and sets all documented option
	     * properties as public instance properties.
	     *
	     * Note: if a custom strategy class extends the base Strategy class and does
	     * not need more than these properties, it does not need to define its own
	     * constructor.
	     *
	     * @param {Object} [options]
	     * @param {string} [options.cacheName] Cache name to store and retrieve
	     * requests. Defaults to the cache names provided by
	     * [workbox-core]{@link module:workbox-core.cacheNames}.
	     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
	     * to use in conjunction with this caching strategy.
	     * @param {Object} [options.fetchOptions] Values passed along to the
	     * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}
	     * of all fetch() requests made by this strategy.
	     * @param {Object} [options.matchOptions] The
	     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
	     * for any `cache.match()` or `cache.put()` calls made by this strategy.
	     */
	    constructor(options = {}) {
	        /**
	         * Cache name to store and retrieve
	         * requests. Defaults to the cache names provided by
	         * [workbox-core]{@link module:workbox-core.cacheNames}.
	         *
	         * @type {string}
	         */
	        this.cacheName = cacheNames.getRuntimeName(options.cacheName);
	        /**
	         * The list
	         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
	         * used by this strategy.
	         *
	         * @type {Array<Object>}
	         */
	        this.plugins = options.plugins || [];
	        /**
	         * Values passed along to the
	         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}
	         * of all fetch() requests made by this strategy.
	         *
	         * @type {Object}
	         */
	        this.fetchOptions = options.fetchOptions;
	        /**
	         * The
	         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
	         * for any `cache.match()` or `cache.put()` calls made by this strategy.
	         *
	         * @type {Object}
	         */
	        this.matchOptions = options.matchOptions;
	    }
	    /**
	     * Perform a request strategy and returns a `Promise` that will resolve with
	     * a `Response`, invoking all relevant plugin callbacks.
	     *
	     * When a strategy instance is registered with a Workbox
	     * [route]{@link module:workbox-routing.Route}, this method is automatically
	     * called when the route matches.
	     *
	     * Alternatively, this method can be used in a standalone `FetchEvent`
	     * listener by passing it to `event.respondWith()`.
	     *
	     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
	     *     properties listed below.
	     * @param {Request|string} options.request A request to run this strategy for.
	     * @param {ExtendableEvent} options.event The event associated with the
	     *     request.
	     * @param {URL} [options.url]
	     * @param {*} [options.params]
	     */
	    handle(options) {
	        const [responseDone] = this.handleAll(options);
	        return responseDone;
	    }
	    /**
	     * Similar to [`handle()`]{@link module:workbox-strategies.Strategy~handle}, but
	     * instead of just returning a `Promise` that resolves to a `Response` it
	     * it will return an tuple of [response, done] promises, where the former
	     * (`response`) is equivalent to what `handle()` returns, and the latter is a
	     * Promise that will resolve once any promises that were added to
	     * `event.waitUntil()` as part of performing the strategy have completed.
	     *
	     * You can await the `done` promise to ensure any extra work performed by
	     * the strategy (usually caching responses) completes successfully.
	     *
	     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
	     *     properties listed below.
	     * @param {Request|string} options.request A request to run this strategy for.
	     * @param {ExtendableEvent} options.event The event associated with the
	     *     request.
	     * @param {URL} [options.url]
	     * @param {*} [options.params]
	     * @return {Array<Promise>} A tuple of [response, done]
	     *     promises that can be used to determine when the response resolves as
	     *     well as when the handler has completed all its work.
	     */
	    handleAll(options) {
	        // Allow for flexible options to be passed.
	        if (options instanceof FetchEvent) {
	            options = {
	                event: options,
	                request: options.request,
	            };
	        }
	        const event = options.event;
	        const request = typeof options.request === 'string' ?
	            new Request(options.request) :
	            options.request;
	        const params = 'params' in options ? options.params : undefined;
	        const handler = new StrategyHandler(this, { event, request, params });
	        const responseDone = this._getResponse(handler, request, event);
	        const handlerDone = this._awaitComplete(responseDone, handler, request, event);
	        // Return an array of promises, suitable for use with Promise.all().
	        return [responseDone, handlerDone];
	    }
	    async _getResponse(handler, request, event) {
	        await handler.runCallbacks('handlerWillStart', { event, request });
	        let response = undefined;
	        try {
	            response = await this._handle(request, handler);
	            // The "official" Strategy subclasses all throw this error automatically,
	            // but in case a third-party Strategy doesn't, ensure that we have a
	            // consistent failure when there's no response or an error response.
	            if (!response || response.type === 'error') {
	                throw new WorkboxError('no-response', { url: request.url });
	            }
	        }
	        catch (error) {
	            for (const callback of handler.iterateCallbacks('handlerDidError')) {
	                response = await callback({ error, event, request });
	                if (response) {
	                    break;
	                }
	            }
	            if (!response) {
	                throw error;
	            }
	            else {
	                logger.log(`While responding to '${getFriendlyURL(request.url)}', ` +
	                    `an ${error} error occurred. Using a fallback response provided by ` +
	                    `a handlerDidError plugin.`);
	            }
	        }
	        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {
	            response = await callback({ event, request, response });
	        }
	        return response;
	    }
	    async _awaitComplete(responseDone, handler, request, event) {
	        let response;
	        let error;
	        try {
	            response = await responseDone;
	        }
	        catch (error) {
	            // Ignore errors, as response errors should be caught via the `response`
	            // promise above. The `done` promise will only throw for errors in
	            // promises passed to `handler.waitUntil()`.
	        }
	        try {
	            await handler.runCallbacks('handlerDidRespond', {
	                event,
	                request,
	                response,
	            });
	            await handler.doneWaiting();
	        }
	        catch (waitUntilError) {
	            error = waitUntilError;
	        }
	        await handler.runCallbacks('handlerDidComplete', {
	            event,
	            request,
	            response,
	            error,
	        });
	        handler.destroy();
	        if (error) {
	            throw error;
	        }
	    }
	}
	/**
	 * Classes extending the `Strategy` based class should implement this method,
	 * and leverage the [`handler`]{@link module:workbox-strategies.StrategyHandler}
	 * arg to perform all fetching and cache logic, which will ensure all relevant
	 * cache, cache options, fetch options and plugins are used (per the current
	 * strategy instance).
	 *
	 * @name _handle
	 * @instance
	 * @abstract
	 * @function
	 * @param {Request} request
	 * @param {module:workbox-strategies.StrategyHandler} handler
	 * @return {Promise<Response>}
	 *
	 * @memberof module:workbox-strategies.Strategy
	 */

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const copyRedirectedCacheableResponsesPlugin = {
	    async cacheWillUpdate({ response }) {
	        return response.redirected ? await copyResponse(response) : response;
	    }
	};
	/**
	 * A [Strategy]{@link module:workbox-strategies.Strategy} implementation
	 * specifically designed to work with
	 * [PrecacheController]{@link module:workbox-precaching.PrecacheController}
	 * to both cache and fetch precached assets.
	 *
	 * Note: an instance of this class is created automatically when creating a
	 * `PrecacheController`; it's generally not necessary to create this yourself.
	 *
	 * @extends module:workbox-strategies.Strategy
	 * @memberof module:workbox-precaching
	 */
	class PrecacheStrategy extends Strategy {
	    /**
	     *
	     * @param {Object} [options]
	     * @param {string} [options.cacheName] Cache name to store and retrieve
	     * requests. Defaults to the cache names provided by
	     * [workbox-core]{@link module:workbox-core.cacheNames}.
	     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
	     * to use in conjunction with this caching strategy.
	     * @param {Object} [options.fetchOptions] Values passed along to the
	     * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}
	     * of all fetch() requests made by this strategy.
	     * @param {Object} [options.matchOptions] The
	     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
	     * for any `cache.match()` or `cache.put()` calls made by this strategy.
	     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
	     * get the response from the network if there's a precache miss.
	     */
	    constructor(options = {}) {
	        options.cacheName = cacheNames.getPrecacheName(options.cacheName);
	        super(options);
	        this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true;
	        // Redirected responses cannot be used to satisfy a navigation request, so
	        // any redirected response must be "copied" rather than cloned, so the new
	        // response doesn't contain the `redirected` flag. See:
	        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1
	        this.plugins.push(copyRedirectedCacheableResponsesPlugin);
	    }
	    /**
	     * @private
	     * @param {Request|string} request A request to run this strategy for.
	     * @param {module:workbox-strategies.StrategyHandler} handler The event that
	     *     triggered the request.
	     * @return {Promise<Response>}
	     */
	    async _handle(request, handler) {
	        const response = await handler.cacheMatch(request);
	        if (!response) {
	            // If this is an `install` event then populate the cache. If this is a
	            // `fetch` event (or any other event) then respond with the cached
	            // response.
	            if (handler.event && handler.event.type === 'install') {
	                return await this._handleInstall(request, handler);
	            }
	            return await this._handleFetch(request, handler);
	        }
	        return response;
	    }
	    async _handleFetch(request, handler) {
	        let response;
	        // Fall back to the network if we don't have a cached response
	        // (perhaps due to manual cache cleanup).
	        if (this._fallbackToNetwork) {
	            {
	                logger.warn(`The precached response for ` +
	                    `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` +
	                    `found. Falling back to the network instead.`);
	            }
	            response = await handler.fetch(request);
	        }
	        else {
	            // This shouldn't normally happen, but there are edge cases:
	            // https://github.com/GoogleChrome/workbox/issues/1441
	            throw new WorkboxError('missing-precache-entry', {
	                cacheName: this.cacheName,
	                url: request.url,
	            });
	        }
	        {
	            const cacheKey = handler.params && handler.params.cacheKey ||
	                await handler.getCacheKey(request, 'read');
	            // Workbox is going to handle the route.
	            // print the routing details to the console.
	            logger.groupCollapsed(`Precaching is responding to: ` +
	                getFriendlyURL(request.url));
	            logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey.url)}`);
	            logger.groupCollapsed(`View request details here.`);
	            logger.log(request);
	            logger.groupEnd();
	            logger.groupCollapsed(`View response details here.`);
	            logger.log(response);
	            logger.groupEnd();
	            logger.groupEnd();
	        }
	        return response;
	    }
	    async _handleInstall(request, handler) {
	        const response = await handler.fetchAndCachePut(request);
	        // Any time there's no response, consider it a precaching error.
	        let responseSafeToPrecache = Boolean(response);
	        // Also consider it an error if the user didn't pass their own
	        // cacheWillUpdate plugin, and the response is a 400+ (note: this means
	        // that by default opaque responses can be precached).
	        if (response && response.status >= 400 &&
	            !this._usesCustomCacheableResponseLogic()) {
	            responseSafeToPrecache = false;
	        }
	        if (!responseSafeToPrecache) {
	            // Throwing here will lead to the `install` handler failing, which
	            // we want to do if *any* of the responses aren't safe to cache.
	            throw new WorkboxError('bad-precaching-response', {
	                url: request.url,
	                status: response.status,
	            });
	        }
	        return response;
	    }
	    /**
	     * Returns true if any users plugins were added containing their own
	     * `cacheWillUpdate` callback.
	     *
	     * This method indicates whether the default cacheable response logic (i.e.
	     * <400, including opaque responses) should be used. If a custom plugin
	     * with a `cacheWillUpdate` callback is passed, then the strategy should
	     * defer to that plugin's logic.
	     *
	     * @private
	     */
	    _usesCustomCacheableResponseLogic() {
	        return this.plugins.some((plugin) => plugin.cacheWillUpdate &&
	            plugin !== copyRedirectedCacheableResponsesPlugin);
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Performs efficient precaching of assets.
	 *
	 * @memberof module:workbox-precaching
	 */
	class PrecacheController {
	    /**
	     * Create a new PrecacheController.
	     *
	     * @param {Object} [options]
	     * @param {string} [options.cacheName] The cache to use for precaching.
	     * @param {string} [options.plugins] Plugins to use when precaching as well
	     * as responding to fetch events for precached assets.
	     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
	     * get the response from the network if there's a precache miss.
	     */
	    constructor({ cacheName, plugins = [], fallbackToNetwork = true } = {}) {
	        this._urlsToCacheKeys = new Map();
	        this._urlsToCacheModes = new Map();
	        this._cacheKeysToIntegrities = new Map();
	        this._strategy = new PrecacheStrategy({
	            cacheName: cacheNames.getPrecacheName(cacheName),
	            plugins: [
	                ...plugins,
	                new PrecacheCacheKeyPlugin({ precacheController: this }),
	            ],
	            fallbackToNetwork,
	        });
	        // Bind the install and activate methods to the instance.
	        this.install = this.install.bind(this);
	        this.activate = this.activate.bind(this);
	    }
	    /**
	     * @type {module:workbox-precaching.PrecacheStrategy} The strategy created by this controller and
	     * used to cache assets and respond to fetch events.
	     */
	    get strategy() {
	        return this._strategy;
	    }
	    /**
	     * Adds items to the precache list, removing any duplicates and
	     * stores the files in the
	     * ["precache cache"]{@link module:workbox-core.cacheNames} when the service
	     * worker installs.
	     *
	     * This method can be called multiple times.
	     *
	     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.
	     */
	    precache(entries) {
	        this.addToCacheList(entries);
	        if (!this._installAndActiveListenersAdded) {
	            self.addEventListener('install', this.install);
	            self.addEventListener('activate', this.activate);
	            this._installAndActiveListenersAdded = true;
	        }
	    }
	    /**
	     * This method will add items to the precache list, removing duplicates
	     * and ensuring the information is valid.
	     *
	     * @param {Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>} entries
	     *     Array of entries to precache.
	     */
	    addToCacheList(entries) {
	        {
	            finalAssertExports.isArray(entries, {
	                moduleName: 'workbox-precaching',
	                className: 'PrecacheController',
	                funcName: 'addToCacheList',
	                paramName: 'entries',
	            });
	        }
	        const urlsToWarnAbout = [];
	        for (const entry of entries) {
	            // See https://github.com/GoogleChrome/workbox/issues/2259
	            if (typeof entry === 'string') {
	                urlsToWarnAbout.push(entry);
	            }
	            else if (entry && entry.revision === undefined) {
	                urlsToWarnAbout.push(entry.url);
	            }
	            const { cacheKey, url } = createCacheKey(entry);
	            const cacheMode = (typeof entry !== 'string' && entry.revision) ?
	                'reload' : 'default';
	            if (this._urlsToCacheKeys.has(url) &&
	                this._urlsToCacheKeys.get(url) !== cacheKey) {
	                throw new WorkboxError('add-to-cache-list-conflicting-entries', {
	                    firstEntry: this._urlsToCacheKeys.get(url),
	                    secondEntry: cacheKey,
	                });
	            }
	            if (typeof entry !== 'string' && entry.integrity) {
	                if (this._cacheKeysToIntegrities.has(cacheKey) &&
	                    this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {
	                    throw new WorkboxError('add-to-cache-list-conflicting-integrities', {
	                        url,
	                    });
	                }
	                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);
	            }
	            this._urlsToCacheKeys.set(url, cacheKey);
	            this._urlsToCacheModes.set(url, cacheMode);
	            if (urlsToWarnAbout.length > 0) {
	                const warningMessage = `Workbox is precaching URLs without revision ` +
	                    `info: ${urlsToWarnAbout.join(', ')}\nThis is generally NOT safe. ` +
	                    `Learn more at https://bit.ly/wb-precache`;
	                {
	                    logger.warn(warningMessage);
	                }
	            }
	        }
	    }
	    /**
	     * Precaches new and updated assets. Call this method from the service worker
	     * install event.
	     *
	     * Note: this method calls `event.waitUntil()` for you, so you do not need
	     * to call it yourself in your event handlers.
	     *
	     * @param {Object} options
	     * @param {Event} options.event The install event.
	     * @return {Promise<module:workbox-precaching.InstallResult>}
	     */
	    install(event) {
	        return waitUntil(event, async () => {
	            const installReportPlugin = new PrecacheInstallReportPlugin();
	            this.strategy.plugins.push(installReportPlugin);
	            // Cache entries one at a time.
	            // See https://github.com/GoogleChrome/workbox/issues/2528
	            for (const [url, cacheKey] of this._urlsToCacheKeys) {
	                const integrity = this._cacheKeysToIntegrities.get(cacheKey);
	                const cacheMode = this._urlsToCacheModes.get(url);
	                const request = new Request(url, {
	                    integrity,
	                    cache: cacheMode,
	                    credentials: 'same-origin',
	                });
	                await Promise.all(this.strategy.handleAll({
	                    params: { cacheKey },
	                    request,
	                    event,
	                }));
	            }
	            const { updatedURLs, notUpdatedURLs } = installReportPlugin;
	            {
	                printInstallDetails(updatedURLs, notUpdatedURLs);
	            }
	            return { updatedURLs, notUpdatedURLs };
	        });
	    }
	    /**
	     * Deletes assets that are no longer present in the current precache manifest.
	     * Call this method from the service worker activate event.
	     *
	     * Note: this method calls `event.waitUntil()` for you, so you do not need
	     * to call it yourself in your event handlers.
	     *
	     * @param {ExtendableEvent}
	     * @return {Promise<module:workbox-precaching.CleanupResult>}
	     */
	    activate(event) {
	        return waitUntil(event, async () => {
	            const cache = await self.caches.open(this.strategy.cacheName);
	            const currentlyCachedRequests = await cache.keys();
	            const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());
	            const deletedURLs = [];
	            for (const request of currentlyCachedRequests) {
	                if (!expectedCacheKeys.has(request.url)) {
	                    await cache.delete(request);
	                    deletedURLs.push(request.url);
	                }
	            }
	            {
	                printCleanupDetails(deletedURLs);
	            }
	            return { deletedURLs };
	        });
	    }
	    /**
	     * Returns a mapping of a precached URL to the corresponding cache key, taking
	     * into account the revision information for the URL.
	     *
	     * @return {Map<string, string>} A URL to cache key mapping.
	     */
	    getURLsToCacheKeys() {
	        return this._urlsToCacheKeys;
	    }
	    /**
	     * Returns a list of all the URLs that have been precached by the current
	     * service worker.
	     *
	     * @return {Array<string>} The precached URLs.
	     */
	    getCachedURLs() {
	        return [...this._urlsToCacheKeys.keys()];
	    }
	    /**
	     * Returns the cache key used for storing a given URL. If that URL is
	     * unversioned, like `/index.html', then the cache key will be the original
	     * URL with a search parameter appended to it.
	     *
	     * @param {string} url A URL whose cache key you want to look up.
	     * @return {string} The versioned URL that corresponds to a cache key
	     * for the original URL, or undefined if that URL isn't precached.
	     */
	    getCacheKeyForURL(url) {
	        const urlObject = new URL(url, location.href);
	        return this._urlsToCacheKeys.get(urlObject.href);
	    }
	    /**
	     * This acts as a drop-in replacement for
	     * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)
	     * with the following differences:
	     *
	     * - It knows what the name of the precache is, and only checks in that cache.
	     * - It allows you to pass in an "original" URL without versioning parameters,
	     * and it will automatically look up the correct cache key for the currently
	     * active revision of that URL.
	     *
	     * E.g., `matchPrecache('index.html')` will find the correct precached
	     * response for the currently active service worker, even if the actual cache
	     * key is `'/index.html?__WB_REVISION__=1234abcd'`.
	     *
	     * @param {string|Request} request The key (without revisioning parameters)
	     * to look up in the precache.
	     * @return {Promise<Response|undefined>}
	     */
	    async matchPrecache(request) {
	        const url = request instanceof Request ? request.url : request;
	        const cacheKey = this.getCacheKeyForURL(url);
	        if (cacheKey) {
	            const cache = await self.caches.open(this.strategy.cacheName);
	            return cache.match(cacheKey);
	        }
	        return undefined;
	    }
	    /**
	     * Returns a function that looks up `url` in the precache (taking into
	     * account revision information), and returns the corresponding `Response`.
	     *
	     * @param {string} url The precached URL which will be used to lookup the
	     * `Response`.
	     * @return {module:workbox-routing~handlerCallback}
	     */
	    createHandlerBoundToURL(url) {
	        const cacheKey = this.getCacheKeyForURL(url);
	        if (!cacheKey) {
	            throw new WorkboxError('non-precached-url', { url });
	        }
	        return (options) => {
	            options.request = new Request(url);
	            options.params = { cacheKey, ...options.params };
	            return this.strategy.handle(options);
	        };
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	let precacheController;
	/**
	 * @return {PrecacheController}
	 * @private
	 */
	const getOrCreatePrecacheController = () => {
	    if (!precacheController) {
	        precacheController = new PrecacheController();
	    }
	    return precacheController;
	};

	// @ts-ignore
	try {
	    self['workbox:routing:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * The default HTTP method, 'GET', used when there's no specific method
	 * configured for a route.
	 *
	 * @type {string}
	 *
	 * @private
	 */
	const defaultMethod = 'GET';
	/**
	 * The list of valid HTTP methods associated with requests that could be routed.
	 *
	 * @type {Array<string>}
	 *
	 * @private
	 */
	const validMethods = [
	    'DELETE',
	    'GET',
	    'HEAD',
	    'PATCH',
	    'POST',
	    'PUT',
	];

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * @param {function()|Object} handler Either a function, or an object with a
	 * 'handle' method.
	 * @return {Object} An object with a handle method.
	 *
	 * @private
	 */
	const normalizeHandler = (handler) => {
	    if (handler && typeof handler === 'object') {
	        {
	            finalAssertExports.hasMethod(handler, 'handle', {
	                moduleName: 'workbox-routing',
	                className: 'Route',
	                funcName: 'constructor',
	                paramName: 'handler',
	            });
	        }
	        return handler;
	    }
	    else {
	        {
	            finalAssertExports.isType(handler, 'function', {
	                moduleName: 'workbox-routing',
	                className: 'Route',
	                funcName: 'constructor',
	                paramName: 'handler',
	            });
	        }
	        return { handle: handler };
	    }
	};

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A `Route` consists of a pair of callback functions, "match" and "handler".
	 * The "match" callback determine if a route should be used to "handle" a
	 * request by returning a non-falsy value if it can. The "handler" callback
	 * is called when there is a match and should return a Promise that resolves
	 * to a `Response`.
	 *
	 * @memberof module:workbox-routing
	 */
	class Route {
	    /**
	     * Constructor for Route class.
	     *
	     * @param {module:workbox-routing~matchCallback} match
	     * A callback function that determines whether the route matches a given
	     * `fetch` event by returning a non-falsy value.
	     * @param {module:workbox-routing~handlerCallback} handler A callback
	     * function that returns a Promise resolving to a Response.
	     * @param {string} [method='GET'] The HTTP method to match the Route
	     * against.
	     */
	    constructor(match, handler, method = defaultMethod) {
	        {
	            finalAssertExports.isType(match, 'function', {
	                moduleName: 'workbox-routing',
	                className: 'Route',
	                funcName: 'constructor',
	                paramName: 'match',
	            });
	            if (method) {
	                finalAssertExports.isOneOf(method, validMethods, { paramName: 'method' });
	            }
	        }
	        // These values are referenced directly by Router so cannot be
	        // altered by minificaton.
	        this.handler = normalizeHandler(handler);
	        this.match = match;
	        this.method = method;
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * RegExpRoute makes it easy to create a regular expression based
	 * [Route]{@link module:workbox-routing.Route}.
	 *
	 * For same-origin requests the RegExp only needs to match part of the URL. For
	 * requests against third-party servers, you must define a RegExp that matches
	 * the start of the URL.
	 *
	 * [See the module docs for info.]{@link https://developers.google.com/web/tools/workbox/modules/workbox-routing}
	 *
	 * @memberof module:workbox-routing
	 * @extends module:workbox-routing.Route
	 */
	class RegExpRoute extends Route {
	    /**
	     * If the regular expression contains
	     * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},
	     * the captured values will be passed to the
	     * [handler's]{@link module:workbox-routing~handlerCallback} `params`
	     * argument.
	     *
	     * @param {RegExp} regExp The regular expression to match against URLs.
	     * @param {module:workbox-routing~handlerCallback} handler A callback
	     * function that returns a Promise resulting in a Response.
	     * @param {string} [method='GET'] The HTTP method to match the Route
	     * against.
	     */
	    constructor(regExp, handler, method) {
	        {
	            finalAssertExports.isInstance(regExp, RegExp, {
	                moduleName: 'workbox-routing',
	                className: 'RegExpRoute',
	                funcName: 'constructor',
	                paramName: 'pattern',
	            });
	        }
	        const match = ({ url }) => {
	            const result = regExp.exec(url.href);
	            // Return immediately if there's no match.
	            if (!result) {
	                return;
	            }
	            // Require that the match start at the first character in the URL string
	            // if it's a cross-origin request.
	            // See https://github.com/GoogleChrome/workbox/issues/281 for the context
	            // behind this behavior.
	            if ((url.origin !== location.origin) && (result.index !== 0)) {
	                {
	                    logger.debug(`The regular expression '${regExp}' only partially matched ` +
	                        `against the cross-origin URL '${url}'. RegExpRoute's will only ` +
	                        `handle cross-origin requests if they match the entire URL.`);
	                }
	                return;
	            }
	            // If the route matches, but there aren't any capture groups defined, then
	            // this will return [], which is truthy and therefore sufficient to
	            // indicate a match.
	            // If there are capture groups, then it will return their values.
	            return result.slice(1);
	        };
	        super(match, handler, method);
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * The Router can be used to process a FetchEvent through one or more
	 * [Routes]{@link module:workbox-routing.Route} responding  with a Request if
	 * a matching route exists.
	 *
	 * If no route matches a given a request, the Router will use a "default"
	 * handler if one is defined.
	 *
	 * Should the matching Route throw an error, the Router will use a "catch"
	 * handler if one is defined to gracefully deal with issues and respond with a
	 * Request.
	 *
	 * If a request matches multiple routes, the **earliest** registered route will
	 * be used to respond to the request.
	 *
	 * @memberof module:workbox-routing
	 */
	class Router {
	    /**
	     * Initializes a new Router.
	     */
	    constructor() {
	        this._routes = new Map();
	        this._defaultHandlerMap = new Map();
	    }
	    /**
	     * @return {Map<string, Array<module:workbox-routing.Route>>} routes A `Map` of HTTP
	     * method name ('GET', etc.) to an array of all the corresponding `Route`
	     * instances that are registered.
	     */
	    get routes() {
	        return this._routes;
	    }
	    /**
	     * Adds a fetch event listener to respond to events when a route matches
	     * the event's request.
	     */
	    addFetchListener() {
	        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
	        self.addEventListener('fetch', ((event) => {
	            const { request } = event;
	            const responsePromise = this.handleRequest({ request, event });
	            if (responsePromise) {
	                event.respondWith(responsePromise);
	            }
	        }));
	    }
	    /**
	     * Adds a message event listener for URLs to cache from the window.
	     * This is useful to cache resources loaded on the page prior to when the
	     * service worker started controlling it.
	     *
	     * The format of the message data sent from the window should be as follows.
	     * Where the `urlsToCache` array may consist of URL strings or an array of
	     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).
	     *
	     * ```
	     * {
	     *   type: 'CACHE_URLS',
	     *   payload: {
	     *     urlsToCache: [
	     *       './script1.js',
	     *       './script2.js',
	     *       ['./script3.js', {mode: 'no-cors'}],
	     *     ],
	     *   },
	     * }
	     * ```
	     */
	    addCacheListener() {
	        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
	        self.addEventListener('message', ((event) => {
	            if (event.data && event.data.type === 'CACHE_URLS') {
	                const { payload } = event.data;
	                {
	                    logger.debug(`Caching URLs from the window`, payload.urlsToCache);
	                }
	                const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {
	                    if (typeof entry === 'string') {
	                        entry = [entry];
	                    }
	                    const request = new Request(...entry);
	                    return this.handleRequest({ request, event });
	                    // TODO(philipwalton): TypeScript errors without this typecast for
	                    // some reason (probably a bug). The real type here should work but
	                    // doesn't: `Array<Promise<Response> | undefined>`.
	                })); // TypeScript
	                event.waitUntil(requestPromises);
	                // If a MessageChannel was used, reply to the message on success.
	                if (event.ports && event.ports[0]) {
	                    requestPromises.then(() => event.ports[0].postMessage(true));
	                }
	            }
	        }));
	    }
	    /**
	     * Apply the routing rules to a FetchEvent object to get a Response from an
	     * appropriate Route's handler.
	     *
	     * @param {Object} options
	     * @param {Request} options.request The request to handle.
	     * @param {ExtendableEvent} options.event The event that triggered the
	     *     request.
	     * @return {Promise<Response>|undefined} A promise is returned if a
	     *     registered route can handle the request. If there is no matching
	     *     route and there's no `defaultHandler`, `undefined` is returned.
	     */
	    handleRequest({ request, event }) {
	        {
	            finalAssertExports.isInstance(request, Request, {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'handleRequest',
	                paramName: 'options.request',
	            });
	        }
	        const url = new URL(request.url, location.href);
	        if (!url.protocol.startsWith('http')) {
	            {
	                logger.debug(`Workbox Router only supports URLs that start with 'http'.`);
	            }
	            return;
	        }
	        const sameOrigin = url.origin === location.origin;
	        const { params, route } = this.findMatchingRoute({
	            event,
	            request,
	            sameOrigin,
	            url,
	        });
	        let handler = route && route.handler;
	        const debugMessages = [];
	        {
	            if (handler) {
	                debugMessages.push([
	                    `Found a route to handle this request:`, route,
	                ]);
	                if (params) {
	                    debugMessages.push([
	                        `Passing the following params to the route's handler:`, params,
	                    ]);
	                }
	            }
	        }
	        // If we don't have a handler because there was no matching route, then
	        // fall back to defaultHandler if that's defined.
	        const method = request.method;
	        if (!handler && this._defaultHandlerMap.has(method)) {
	            {
	                debugMessages.push(`Failed to find a matching route. Falling ` +
	                    `back to the default handler for ${method}.`);
	            }
	            handler = this._defaultHandlerMap.get(method);
	        }
	        if (!handler) {
	            {
	                // No handler so Workbox will do nothing. If logs is set of debug
	                // i.e. verbose, we should print out this information.
	                logger.debug(`No route found for: ${getFriendlyURL(url)}`);
	            }
	            return;
	        }
	        {
	            // We have a handler, meaning Workbox is going to handle the route.
	            // print the routing details to the console.
	            logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);
	            debugMessages.forEach((msg) => {
	                if (Array.isArray(msg)) {
	                    logger.log(...msg);
	                }
	                else {
	                    logger.log(msg);
	                }
	            });
	            logger.groupEnd();
	        }
	        // Wrap in try and catch in case the handle method throws a synchronous
	        // error. It should still callback to the catch handler.
	        let responsePromise;
	        try {
	            responsePromise = handler.handle({ url, request, event, params });
	        }
	        catch (err) {
	            responsePromise = Promise.reject(err);
	        }
	        if (responsePromise instanceof Promise && this._catchHandler) {
	            responsePromise = responsePromise.catch((err) => {
	                {
	                    // Still include URL here as it will be async from the console group
	                    // and may not make sense without the URL
	                    logger.groupCollapsed(`Error thrown when responding to: ` +
	                        ` ${getFriendlyURL(url)}. Falling back to Catch Handler.`);
	                    logger.error(`Error thrown by:`, route);
	                    logger.error(err);
	                    logger.groupEnd();
	                }
	                return this._catchHandler.handle({ url, request, event });
	            });
	        }
	        return responsePromise;
	    }
	    /**
	     * Checks a request and URL (and optionally an event) against the list of
	     * registered routes, and if there's a match, returns the corresponding
	     * route along with any params generated by the match.
	     *
	     * @param {Object} options
	     * @param {URL} options.url
	     * @param {Request} options.request The request to match.
	     * @param {Event} options.event The corresponding event.
	     * @return {Object} An object with `route` and `params` properties.
	     *     They are populated if a matching route was found or `undefined`
	     *     otherwise.
	     */
	    findMatchingRoute({ url, sameOrigin, request, event }) {
	        const routes = this._routes.get(request.method) || [];
	        for (const route of routes) {
	            let params;
	            const matchResult = route.match({ url, sameOrigin, request, event });
	            if (matchResult) {
	                {
	                    // Warn developers that using an async matchCallback is almost always
	                    // not the right thing to do. 
	                    if (matchResult instanceof Promise) {
	                        logger.warn(`While routing ${getFriendlyURL(url)}, an async ` +
	                            `matchCallback function was used. Please convert the ` +
	                            `following route to use a synchronous matchCallback function:`, route);
	                    }
	                }
	                // See https://github.com/GoogleChrome/workbox/issues/2079
	                params = matchResult;
	                if (Array.isArray(matchResult) && matchResult.length === 0) {
	                    // Instead of passing an empty array in as params, use undefined.
	                    params = undefined;
	                }
	                else if ((matchResult.constructor === Object &&
	                    Object.keys(matchResult).length === 0)) {
	                    // Instead of passing an empty object in as params, use undefined.
	                    params = undefined;
	                }
	                else if (typeof matchResult === 'boolean') {
	                    // For the boolean value true (rather than just something truth-y),
	                    // don't set params.
	                    // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353
	                    params = undefined;
	                }
	                // Return early if have a match.
	                return { route, params };
	            }
	        }
	        // If no match was found above, return and empty object.
	        return {};
	    }
	    /**
	     * Define a default `handler` that's called when no routes explicitly
	     * match the incoming request.
	     *
	     * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.
	     *
	     * Without a default handler, unmatched requests will go against the
	     * network as if there were no service worker present.
	     *
	     * @param {module:workbox-routing~handlerCallback} handler A callback
	     * function that returns a Promise resulting in a Response.
	     * @param {string} [method='GET'] The HTTP method to associate with this
	     * default handler. Each method has its own default.
	     */
	    setDefaultHandler(handler, method = defaultMethod) {
	        this._defaultHandlerMap.set(method, normalizeHandler(handler));
	    }
	    /**
	     * If a Route throws an error while handling a request, this `handler`
	     * will be called and given a chance to provide a response.
	     *
	     * @param {module:workbox-routing~handlerCallback} handler A callback
	     * function that returns a Promise resulting in a Response.
	     */
	    setCatchHandler(handler) {
	        this._catchHandler = normalizeHandler(handler);
	    }
	    /**
	     * Registers a route with the router.
	     *
	     * @param {module:workbox-routing.Route} route The route to register.
	     */
	    registerRoute(route) {
	        {
	            finalAssertExports.isType(route, 'object', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route',
	            });
	            finalAssertExports.hasMethod(route, 'match', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route',
	            });
	            finalAssertExports.isType(route.handler, 'object', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route',
	            });
	            finalAssertExports.hasMethod(route.handler, 'handle', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route.handler',
	            });
	            finalAssertExports.isType(route.method, 'string', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route.method',
	            });
	        }
	        if (!this._routes.has(route.method)) {
	            this._routes.set(route.method, []);
	        }
	        // Give precedence to all of the earlier routes by adding this additional
	        // route to the end of the array.
	        this._routes.get(route.method).push(route);
	    }
	    /**
	     * Unregisters a route with the router.
	     *
	     * @param {module:workbox-routing.Route} route The route to unregister.
	     */
	    unregisterRoute(route) {
	        if (!this._routes.has(route.method)) {
	            throw new WorkboxError('unregister-route-but-not-found-with-method', {
	                method: route.method,
	            });
	        }
	        const routeIndex = this._routes.get(route.method).indexOf(route);
	        if (routeIndex > -1) {
	            this._routes.get(route.method).splice(routeIndex, 1);
	        }
	        else {
	            throw new WorkboxError('unregister-route-route-not-registered');
	        }
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	let defaultRouter;
	/**
	 * Creates a new, singleton Router instance if one does not exist. If one
	 * does already exist, that instance is returned.
	 *
	 * @private
	 * @return {Router}
	 */
	const getOrCreateDefaultRouter = () => {
	    if (!defaultRouter) {
	        defaultRouter = new Router();
	        // The helpers that use the default Router assume these listeners exist.
	        defaultRouter.addFetchListener();
	        defaultRouter.addCacheListener();
	    }
	    return defaultRouter;
	};

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Easily register a RegExp, string, or function with a caching
	 * strategy to a singleton Router instance.
	 *
	 * This method will generate a Route for you if needed and
	 * call [registerRoute()]{@link module:workbox-routing.Router#registerRoute}.
	 *
	 * @param {RegExp|string|module:workbox-routing.Route~matchCallback|module:workbox-routing.Route} capture
	 * If the capture param is a `Route`, all other arguments will be ignored.
	 * @param {module:workbox-routing~handlerCallback} [handler] A callback
	 * function that returns a Promise resulting in a Response. This parameter
	 * is required if `capture` is not a `Route` object.
	 * @param {string} [method='GET'] The HTTP method to match the Route
	 * against.
	 * @return {module:workbox-routing.Route} The generated `Route`(Useful for
	 * unregistering).
	 *
	 * @memberof module:workbox-routing
	 */
	function registerRoute(capture, handler, method) {
	    let route;
	    if (typeof capture === 'string') {
	        const captureUrl = new URL(capture, location.href);
	        {
	            if (!(capture.startsWith('/') || capture.startsWith('http'))) {
	                throw new WorkboxError('invalid-string', {
	                    moduleName: 'workbox-routing',
	                    funcName: 'registerRoute',
	                    paramName: 'capture',
	                });
	            }
	            // We want to check if Express-style wildcards are in the pathname only.
	            // TODO: Remove this log message in v4.
	            const valueToCheck = capture.startsWith('http') ?
	                captureUrl.pathname : capture;
	            // See https://github.com/pillarjs/path-to-regexp#parameters
	            const wildcards = '[*:?+]';
	            if ((new RegExp(`${wildcards}`)).exec(valueToCheck)) {
	                logger.debug(`The '$capture' parameter contains an Express-style wildcard ` +
	                    `character (${wildcards}). Strings are now always interpreted as ` +
	                    `exact matches; use a RegExp for partial or wildcard matches.`);
	            }
	        }
	        const matchCallback = ({ url }) => {
	            {
	                if ((url.pathname === captureUrl.pathname) &&
	                    (url.origin !== captureUrl.origin)) {
	                    logger.debug(`${capture} only partially matches the cross-origin URL ` +
	                        `${url}. This route will only handle cross-origin requests ` +
	                        `if they match the entire URL.`);
	                }
	            }
	            return url.href === captureUrl.href;
	        };
	        // If `capture` is a string then `handler` and `method` must be present.
	        route = new Route(matchCallback, handler, method);
	    }
	    else if (capture instanceof RegExp) {
	        // If `capture` is a `RegExp` then `handler` and `method` must be present.
	        route = new RegExpRoute(capture, handler, method);
	    }
	    else if (typeof capture === 'function') {
	        // If `capture` is a function then `handler` and `method` must be present.
	        route = new Route(capture, handler, method);
	    }
	    else if (capture instanceof Route) {
	        route = capture;
	    }
	    else {
	        throw new WorkboxError('unsupported-route-type', {
	            moduleName: 'workbox-routing',
	            funcName: 'registerRoute',
	            paramName: 'capture',
	        });
	    }
	    const defaultRouter = getOrCreateDefaultRouter();
	    defaultRouter.registerRoute(route);
	    return route;
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Removes any URL search parameters that should be ignored.
	 *
	 * @param {URL} urlObject The original URL.
	 * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against
	 * each search parameter name. Matches mean that the search parameter should be
	 * ignored.
	 * @return {URL} The URL with any ignored search parameters removed.
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching = []) {
	    // Convert the iterable into an array at the start of the loop to make sure
	    // deletion doesn't mess up iteration.
	    for (const paramName of [...urlObject.searchParams.keys()]) {
	        if (ignoreURLParametersMatching.some((regExp) => regExp.test(paramName))) {
	            urlObject.searchParams.delete(paramName);
	        }
	    }
	    return urlObject;
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Generator function that yields possible variations on the original URL to
	 * check, one at a time.
	 *
	 * @param {string} url
	 * @param {Object} options
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function* generateURLVariations(url, { ignoreURLParametersMatching = [/^utm_/, /^fbclid$/], directoryIndex = 'index.html', cleanURLs = true, urlManipulation, } = {}) {
	    const urlObject = new URL(url, location.href);
	    urlObject.hash = '';
	    yield urlObject.href;
	    const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);
	    yield urlWithoutIgnoredParams.href;
	    if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {
	        const directoryURL = new URL(urlWithoutIgnoredParams.href);
	        directoryURL.pathname += directoryIndex;
	        yield directoryURL.href;
	    }
	    if (cleanURLs) {
	        const cleanURL = new URL(urlWithoutIgnoredParams.href);
	        cleanURL.pathname += '.html';
	        yield cleanURL.href;
	    }
	    if (urlManipulation) {
	        const additionalURLs = urlManipulation({ url: urlObject });
	        for (const urlToAttempt of additionalURLs) {
	            yield urlToAttempt.href;
	        }
	    }
	}

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A subclass of [Route]{@link module:workbox-routing.Route} that takes a
	 * [PrecacheController]{@link module:workbox-precaching.PrecacheController}
	 * instance and uses it to match incoming requests and handle fetching
	 * responses from the precache.
	 *
	 * @memberof module:workbox-precaching
	 * @extends module:workbox-routing.Route
	 */
	class PrecacheRoute extends Route {
	    /**
	     * @param {PrecacheController} precacheController A `PrecacheController`
	     * instance used to both match requests and respond to fetch events.
	     * @param {Object} [options] Options to control how requests are matched
	     * against the list of precached URLs.
	     * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will
	     * check cache entries for a URLs ending with '/' to see if there is a hit when
	     * appending the `directoryIndex` value.
	     * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An
	     * array of regex's to remove search params when looking for a cache match.
	     * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will
	     * check the cache for the URL with a `.html` added to the end of the end.
	     * @param {module:workbox-precaching~urlManipulation} [options.urlManipulation]
	     * This is a function that should take a URL and return an array of
	     * alternative URLs that should be checked for precache matches.
	     */
	    constructor(precacheController, options) {
	        const match = ({ request }) => {
	            const urlsToCacheKeys = precacheController.getURLsToCacheKeys();
	            for (const possibleURL of generateURLVariations(request.url, options)) {
	                const cacheKey = urlsToCacheKeys.get(possibleURL);
	                if (cacheKey) {
	                    return { cacheKey };
	                }
	            }
	            {
	                logger.debug(`Precaching did not find a match for ` +
	                    getFriendlyURL(request.url));
	            }
	            return;
	        };
	        super(match, precacheController.strategy);
	    }
	}

	/*
	  Copyright 2019 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Add a `fetch` listener to the service worker that will
	 * respond to
	 * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}
	 * with precached assets.
	 *
	 * Requests for assets that aren't precached, the `FetchEvent` will not be
	 * responded to, allowing the event to fall through to other `fetch` event
	 * listeners.
	 *
	 * @param {Object} [options] See
	 * [PrecacheRoute options]{@link module:workbox-precaching.PrecacheRoute}.
	 *
	 * @memberof module:workbox-precaching
	 */
	function addRoute(options) {
	    const precacheController = getOrCreatePrecacheController();
	    const precacheRoute = new PrecacheRoute(precacheController, options);
	    registerRoute(precacheRoute);
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Adds items to the precache list, removing any duplicates and
	 * stores the files in the
	 * ["precache cache"]{@link module:workbox-core.cacheNames} when the service
	 * worker installs.
	 *
	 * This method can be called multiple times.
	 *
	 * Please note: This method **will not** serve any of the cached files for you.
	 * It only precaches files. To respond to a network request you call
	 * [addRoute()]{@link module:workbox-precaching.addRoute}.
	 *
	 * If you have a single array of files to precache, you can just call
	 * [precacheAndRoute()]{@link module:workbox-precaching.precacheAndRoute}.
	 *
	 * @param {Array<Object|string>} [entries=[]] Array of entries to precache.
	 *
	 * @memberof module:workbox-precaching
	 */
	function precache(entries) {
	    const precacheController = getOrCreatePrecacheController();
	    precacheController.precache(entries);
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * This method will add entries to the precache list and add a route to
	 * respond to fetch events.
	 *
	 * This is a convenience method that will call
	 * [precache()]{@link module:workbox-precaching.precache} and
	 * [addRoute()]{@link module:workbox-precaching.addRoute} in a single call.
	 *
	 * @param {Array<Object|string>} entries Array of entries to precache.
	 * @param {Object} [options] See
	 * [PrecacheRoute options]{@link module:workbox-precaching.PrecacheRoute}.
	 *
	 * @memberof module:workbox-precaching
	 */
	function precacheAndRoute(entries, options) {
	    precache(entries);
	    addRoute(options);
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const messages$1 = {
	    strategyStart: (strategyName, request) => `Using ${strategyName} to respond to '${getFriendlyURL(request.url)}'`,
	    printFinalResponse: (response) => {
	        if (response) {
	            logger.groupCollapsed(`View the final response here.`);
	            logger.log(response || '[No response returned]');
	            logger.groupEnd();
	        }
	    },
	};

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}
	 * request strategy.
	 *
	 * A cache first strategy is useful for assets that have been revisioned,
	 * such as URLs like `/styles/example.a8f5f1.css`, since they
	 * can be cached for long periods of time.
	 *
	 * If the network request fails, and there is no cache match, this will throw
	 * a `WorkboxError` exception.
	 *
	 * @extends module:workbox-strategies.Strategy
	 * @memberof module:workbox-strategies
	 */
	class CacheFirst extends Strategy {
	    /**
	     * @private
	     * @param {Request|string} request A request to run this strategy for.
	     * @param {module:workbox-strategies.StrategyHandler} handler The event that
	     *     triggered the request.
	     * @return {Promise<Response>}
	     */
	    async _handle(request, handler) {
	        const logs = [];
	        {
	            finalAssertExports.isInstance(request, Request, {
	                moduleName: 'workbox-strategies',
	                className: this.constructor.name,
	                funcName: 'makeRequest',
	                paramName: 'request',
	            });
	        }
	        let response = await handler.cacheMatch(request);
	        let error;
	        if (!response) {
	            {
	                logs.push(`No response found in the '${this.cacheName}' cache. ` +
	                    `Will respond with a network request.`);
	            }
	            try {
	                response = await handler.fetchAndCachePut(request);
	            }
	            catch (err) {
	                error = err;
	            }
	            {
	                if (response) {
	                    logs.push(`Got response from network.`);
	                }
	                else {
	                    logs.push(`Unable to get a response from the network.`);
	                }
	            }
	        }
	        else {
	            {
	                logs.push(`Found a cached response in the '${this.cacheName}' cache.`);
	            }
	        }
	        {
	            logger.groupCollapsed(messages$1.strategyStart(this.constructor.name, request));
	            for (const log of logs) {
	                logger.log(log);
	            }
	            messages$1.printFinalResponse(response);
	            logger.groupEnd();
	        }
	        if (!response) {
	            throw new WorkboxError('no-response', { url: request.url, error });
	        }
	        return response;
	    }
	}

	/*
	  Copyright 2019 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A helper function that prevents a promise from being flagged as unused.
	 *
	 * @private
	 **/
	function dontWaitFor(promise) {
	    // Effective no-op.
	    promise.then(() => { });
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A class that wraps common IndexedDB functionality in a promise-based API.
	 * It exposes all the underlying power and functionality of IndexedDB, but
	 * wraps the most commonly used features in a way that's much simpler to use.
	 *
	 * @private
	 */
	class DBWrapper {
	    /**
	     * @param {string} name
	     * @param {number} version
	     * @param {Object=} [callback]
	     * @param {!Function} [callbacks.onupgradeneeded]
	     * @param {!Function} [callbacks.onversionchange] Defaults to
	     *     DBWrapper.prototype._onversionchange when not specified.
	     * @private
	     */
	    constructor(name, version, { onupgradeneeded, onversionchange, } = {}) {
	        this._db = null;
	        this._name = name;
	        this._version = version;
	        this._onupgradeneeded = onupgradeneeded;
	        this._onversionchange = onversionchange || (() => this.close());
	    }
	    /**
	     * Returns the IDBDatabase instance (not normally needed).
	     * @return {IDBDatabase|undefined}
	     *
	     * @private
	     */
	    get db() {
	        return this._db;
	    }
	    /**
	     * Opens a connected to an IDBDatabase, invokes any onupgradedneeded
	     * callback, and added an onversionchange callback to the database.
	     *
	     * @return {IDBDatabase}
	     * @private
	     */
	    async open() {
	        if (this._db)
	            return;
	        this._db = await new Promise((resolve, reject) => {
	            // This flag is flipped to true if the timeout callback runs prior
	            // to the request failing or succeeding. Note: we use a timeout instead
	            // of an onblocked handler since there are cases where onblocked will
	            // never never run. A timeout better handles all possible scenarios:
	            // https://github.com/w3c/IndexedDB/issues/223
	            let openRequestTimedOut = false;
	            setTimeout(() => {
	                openRequestTimedOut = true;
	                reject(new Error('The open request was blocked and timed out'));
	            }, this.OPEN_TIMEOUT);
	            const openRequest = indexedDB.open(this._name, this._version);
	            openRequest.onerror = () => reject(openRequest.error);
	            openRequest.onupgradeneeded = (evt) => {
	                if (openRequestTimedOut) {
	                    openRequest.transaction.abort();
	                    openRequest.result.close();
	                }
	                else if (typeof this._onupgradeneeded === 'function') {
	                    this._onupgradeneeded(evt);
	                }
	            };
	            openRequest.onsuccess = () => {
	                const db = openRequest.result;
	                if (openRequestTimedOut) {
	                    db.close();
	                }
	                else {
	                    db.onversionchange = this._onversionchange.bind(this);
	                    resolve(db);
	                }
	            };
	        });
	        return this;
	    }
	    /**
	     * Polyfills the native `getKey()` method. Note, this is overridden at
	     * runtime if the browser supports the native method.
	     *
	     * @param {string} storeName
	     * @param {*} query
	     * @return {Array}
	     * @private
	     */
	    async getKey(storeName, query) {
	        return (await this.getAllKeys(storeName, query, 1))[0];
	    }
	    /**
	     * Polyfills the native `getAll()` method. Note, this is overridden at
	     * runtime if the browser supports the native method.
	     *
	     * @param {string} storeName
	     * @param {*} query
	     * @param {number} count
	     * @return {Array}
	     * @private
	     */
	    async getAll(storeName, query, count) {
	        return await this.getAllMatching(storeName, { query, count });
	    }
	    /**
	     * Polyfills the native `getAllKeys()` method. Note, this is overridden at
	     * runtime if the browser supports the native method.
	     *
	     * @param {string} storeName
	     * @param {*} query
	     * @param {number} count
	     * @return {Array}
	     * @private
	     */
	    async getAllKeys(storeName, query, count) {
	        const entries = await this.getAllMatching(storeName, { query, count, includeKeys: true });
	        return entries.map((entry) => entry.key);
	    }
	    /**
	     * Supports flexible lookup in an object store by specifying an index,
	     * query, direction, and count. This method returns an array of objects
	     * with the signature .
	     *
	     * @param {string} storeName
	     * @param {Object} [opts]
	     * @param {string} [opts.index] The index to use (if specified).
	     * @param {*} [opts.query]
	     * @param {IDBCursorDirection} [opts.direction]
	     * @param {number} [opts.count] The max number of results to return.
	     * @param {boolean} [opts.includeKeys] When true, the structure of the
	     *     returned objects is changed from an array of values to an array of
	     *     objects in the form {key, primaryKey, value}.
	     * @return {Array}
	     * @private
	     */
	    async getAllMatching(storeName, { index, query = null, // IE/Edge errors if query === `undefined`.
	    direction = 'next', count, includeKeys = false, } = {}) {
	        return await this.transaction([storeName], 'readonly', (txn, done) => {
	            const store = txn.objectStore(storeName);
	            const target = index ? store.index(index) : store;
	            const results = [];
	            const request = target.openCursor(query, direction);
	            request.onsuccess = () => {
	                const cursor = request.result;
	                if (cursor) {
	                    results.push(includeKeys ? cursor : cursor.value);
	                    if (count && results.length >= count) {
	                        done(results);
	                    }
	                    else {
	                        cursor.continue();
	                    }
	                }
	                else {
	                    done(results);
	                }
	            };
	        });
	    }
	    /**
	     * Accepts a list of stores, a transaction type, and a callback and
	     * performs a transaction. A promise is returned that resolves to whatever
	     * value the callback chooses. The callback holds all the transaction logic
	     * and is invoked with two arguments:
	     *   1. The IDBTransaction object
	     *   2. A `done` function, that's used to resolve the promise when
	     *      when the transaction is done, if passed a value, the promise is
	     *      resolved to that value.
	     *
	     * @param {Array<string>} storeNames An array of object store names
	     *     involved in the transaction.
	     * @param {string} type Can be `readonly` or `readwrite`.
	     * @param {!Function} callback
	     * @return {*} The result of the transaction ran by the callback.
	     * @private
	     */
	    async transaction(storeNames, type, callback) {
	        await this.open();
	        return await new Promise((resolve, reject) => {
	            const txn = this._db.transaction(storeNames, type);
	            txn.onabort = () => reject(txn.error);
	            txn.oncomplete = () => resolve();
	            callback(txn, (value) => resolve(value));
	        });
	    }
	    /**
	     * Delegates async to a native IDBObjectStore method.
	     *
	     * @param {string} method The method name.
	     * @param {string} storeName The object store name.
	     * @param {string} type Can be `readonly` or `readwrite`.
	     * @param {...*} args The list of args to pass to the native method.
	     * @return {*} The result of the transaction.
	     * @private
	     */
	    async _call(method, storeName, type, ...args) {
	        const callback = (txn, done) => {
	            const objStore = txn.objectStore(storeName);
	            // TODO(philipwalton): Fix this underlying TS2684 error.
	            // @ts-ignore
	            const request = objStore[method].apply(objStore, args);
	            request.onsuccess = () => done(request.result);
	        };
	        return await this.transaction([storeName], type, callback);
	    }
	    /**
	     * Closes the connection opened by `DBWrapper.open()`. Generally this method
	     * doesn't need to be called since:
	     *   1. It's usually better to keep a connection open since opening
	     *      a new connection is somewhat slow.
	     *   2. Connections are automatically closed when the reference is
	     *      garbage collected.
	     * The primary use case for needing to close a connection is when another
	     * reference (typically in another tab) needs to upgrade it and would be
	     * blocked by the current, open connection.
	     *
	     * @private
	     */
	    close() {
	        if (this._db) {
	            this._db.close();
	            this._db = null;
	        }
	    }
	}
	// Exposed on the prototype to let users modify the default timeout on a
	// per-instance or global basis.
	DBWrapper.prototype.OPEN_TIMEOUT = 2000;
	// Wrap native IDBObjectStore methods according to their mode.
	const methodsToWrap = {
	    readonly: ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],
	    readwrite: ['add', 'put', 'clear', 'delete'],
	};
	for (const [mode, methods] of Object.entries(methodsToWrap)) {
	    for (const method of methods) {
	        if (method in IDBObjectStore.prototype) {
	            // Don't use arrow functions here since we're outside of the class.
	            DBWrapper.prototype[method] =
	                async function (storeName, ...args) {
	                    return await this._call(method, storeName, mode, ...args);
	                };
	        }
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Deletes the database.
	 * Note: this is exported separately from the DBWrapper module because most
	 * usages of IndexedDB in workbox dont need deleting, and this way it can be
	 * reused in tests to delete databases without creating DBWrapper instances.
	 *
	 * @param {string} name The database name.
	 * @private
	 */
	const deleteDatabase = async (name) => {
	    await new Promise((resolve, reject) => {
	        const request = indexedDB.deleteDatabase(name);
	        request.onerror = () => {
	            reject(request.error);
	        };
	        request.onblocked = () => {
	            reject(new Error('Delete blocked'));
	        };
	        request.onsuccess = () => {
	            resolve();
	        };
	    });
	};

	// @ts-ignore
	try {
	    self['workbox:expiration:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const DB_NAME = 'workbox-expiration';
	const OBJECT_STORE_NAME = 'cache-entries';
	const normalizeURL = (unNormalizedUrl) => {
	    const url = new URL(unNormalizedUrl, location.href);
	    url.hash = '';
	    return url.href;
	};
	/**
	 * Returns the timestamp model.
	 *
	 * @private
	 */
	class CacheTimestampsModel {
	    /**
	     *
	     * @param {string} cacheName
	     *
	     * @private
	     */
	    constructor(cacheName) {
	        this._cacheName = cacheName;
	        this._db = new DBWrapper(DB_NAME, 1, {
	            onupgradeneeded: (event) => this._handleUpgrade(event),
	        });
	    }
	    /**
	     * Should perform an upgrade of indexedDB.
	     *
	     * @param {Event} event
	     *
	     * @private
	     */
	    _handleUpgrade(event) {
	        const db = event.target.result;
	        // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we
	        // have to use the `id` keyPath here and create our own values (a
	        // concatenation of `url + cacheName`) instead of simply using
	        // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.
	        const objStore = db.createObjectStore(OBJECT_STORE_NAME, { keyPath: 'id' });
	        // TODO(philipwalton): once we don't have to support EdgeHTML, we can
	        // create a single index with the keyPath `['cacheName', 'timestamp']`
	        // instead of doing both these indexes.
	        objStore.createIndex('cacheName', 'cacheName', { unique: false });
	        objStore.createIndex('timestamp', 'timestamp', { unique: false });
	        // Previous versions of `workbox-expiration` used `this._cacheName`
	        // as the IDBDatabase name.
	        deleteDatabase(this._cacheName);
	    }
	    /**
	     * @param {string} url
	     * @param {number} timestamp
	     *
	     * @private
	     */
	    async setTimestamp(url, timestamp) {
	        url = normalizeURL(url);
	        const entry = {
	            url,
	            timestamp,
	            cacheName: this._cacheName,
	            // Creating an ID from the URL and cache name won't be necessary once
	            // Edge switches to Chromium and all browsers we support work with
	            // array keyPaths.
	            id: this._getId(url),
	        };
	        await this._db.put(OBJECT_STORE_NAME, entry);
	    }
	    /**
	     * Returns the timestamp stored for a given URL.
	     *
	     * @param {string} url
	     * @return {number}
	     *
	     * @private
	     */
	    async getTimestamp(url) {
	        const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));
	        return entry.timestamp;
	    }
	    /**
	     * Iterates through all the entries in the object store (from newest to
	     * oldest) and removes entries once either `maxCount` is reached or the
	     * entry's timestamp is less than `minTimestamp`.
	     *
	     * @param {number} minTimestamp
	     * @param {number} maxCount
	     * @return {Array<string>}
	     *
	     * @private
	     */
	    async expireEntries(minTimestamp, maxCount) {
	        const entriesToDelete = await this._db.transaction(OBJECT_STORE_NAME, 'readwrite', (txn, done) => {
	            const store = txn.objectStore(OBJECT_STORE_NAME);
	            const request = store.index('timestamp').openCursor(null, 'prev');
	            const entriesToDelete = [];
	            let entriesNotDeletedCount = 0;
	            request.onsuccess = () => {
	                const cursor = request.result;
	                if (cursor) {
	                    const result = cursor.value;
	                    // TODO(philipwalton): once we can use a multi-key index, we
	                    // won't have to check `cacheName` here.
	                    if (result.cacheName === this._cacheName) {
	                        // Delete an entry if it's older than the max age or
	                        // if we already have the max number allowed.
	                        if ((minTimestamp && result.timestamp < minTimestamp) ||
	                            (maxCount && entriesNotDeletedCount >= maxCount)) {
	                            // TODO(philipwalton): we should be able to delete the
	                            // entry right here, but doing so causes an iteration
	                            // bug in Safari stable (fixed in TP). Instead we can
	                            // store the keys of the entries to delete, and then
	                            // delete the separate transactions.
	                            // https://github.com/GoogleChrome/workbox/issues/1978
	                            // cursor.delete();
	                            // We only need to return the URL, not the whole entry.
	                            entriesToDelete.push(cursor.value);
	                        }
	                        else {
	                            entriesNotDeletedCount++;
	                        }
	                    }
	                    cursor.continue();
	                }
	                else {
	                    done(entriesToDelete);
	                }
	            };
	        });
	        // TODO(philipwalton): once the Safari bug in the following issue is fixed,
	        // we should be able to remove this loop and do the entry deletion in the
	        // cursor loop above:
	        // https://github.com/GoogleChrome/workbox/issues/1978
	        const urlsDeleted = [];
	        for (const entry of entriesToDelete) {
	            await this._db.delete(OBJECT_STORE_NAME, entry.id);
	            urlsDeleted.push(entry.url);
	        }
	        return urlsDeleted;
	    }
	    /**
	     * Takes a URL and returns an ID that will be unique in the object store.
	     *
	     * @param {string} url
	     * @return {string}
	     *
	     * @private
	     */
	    _getId(url) {
	        // Creating an ID from the URL and cache name won't be necessary once
	        // Edge switches to Chromium and all browsers we support work with
	        // array keyPaths.
	        return this._cacheName + '|' + normalizeURL(url);
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * The `CacheExpiration` class allows you define an expiration and / or
	 * limit on the number of responses stored in a
	 * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).
	 *
	 * @memberof module:workbox-expiration
	 */
	class CacheExpiration {
	    /**
	     * To construct a new CacheExpiration instance you must provide at least
	     * one of the `config` properties.
	     *
	     * @param {string} cacheName Name of the cache to apply restrictions to.
	     * @param {Object} config
	     * @param {number} [config.maxEntries] The maximum number of entries to cache.
	     * Entries used the least will be removed as the maximum is reached.
	     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before
	     * it's treated as stale and removed.
	     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)
	     * that will be used when calling `delete()` on the cache.
	     */
	    constructor(cacheName, config = {}) {
	        this._isRunning = false;
	        this._rerunRequested = false;
	        {
	            finalAssertExports.isType(cacheName, 'string', {
	                moduleName: 'workbox-expiration',
	                className: 'CacheExpiration',
	                funcName: 'constructor',
	                paramName: 'cacheName',
	            });
	            if (!(config.maxEntries || config.maxAgeSeconds)) {
	                throw new WorkboxError('max-entries-or-age-required', {
	                    moduleName: 'workbox-expiration',
	                    className: 'CacheExpiration',
	                    funcName: 'constructor',
	                });
	            }
	            if (config.maxEntries) {
	                finalAssertExports.isType(config.maxEntries, 'number', {
	                    moduleName: 'workbox-expiration',
	                    className: 'CacheExpiration',
	                    funcName: 'constructor',
	                    paramName: 'config.maxEntries',
	                });
	            }
	            if (config.maxAgeSeconds) {
	                finalAssertExports.isType(config.maxAgeSeconds, 'number', {
	                    moduleName: 'workbox-expiration',
	                    className: 'CacheExpiration',
	                    funcName: 'constructor',
	                    paramName: 'config.maxAgeSeconds',
	                });
	            }
	        }
	        this._maxEntries = config.maxEntries;
	        this._maxAgeSeconds = config.maxAgeSeconds;
	        this._matchOptions = config.matchOptions;
	        this._cacheName = cacheName;
	        this._timestampModel = new CacheTimestampsModel(cacheName);
	    }
	    /**
	     * Expires entries for the given cache and given criteria.
	     */
	    async expireEntries() {
	        if (this._isRunning) {
	            this._rerunRequested = true;
	            return;
	        }
	        this._isRunning = true;
	        const minTimestamp = this._maxAgeSeconds ?
	            Date.now() - (this._maxAgeSeconds * 1000) : 0;
	        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);
	        // Delete URLs from the cache
	        const cache = await self.caches.open(this._cacheName);
	        for (const url of urlsExpired) {
	            await cache.delete(url, this._matchOptions);
	        }
	        {
	            if (urlsExpired.length > 0) {
	                logger.groupCollapsed(`Expired ${urlsExpired.length} ` +
	                    `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +
	                    `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +
	                    `'${this._cacheName}' cache.`);
	                logger.log(`Expired the following ${urlsExpired.length === 1 ?
                    'URL' : 'URLs'}:`);
	                urlsExpired.forEach((url) => logger.log(`    ${url}`));
	                logger.groupEnd();
	            }
	            else {
	                logger.debug(`Cache expiration ran and found no entries to remove.`);
	            }
	        }
	        this._isRunning = false;
	        if (this._rerunRequested) {
	            this._rerunRequested = false;
	            dontWaitFor(this.expireEntries());
	        }
	    }
	    /**
	     * Update the timestamp for the given URL. This ensures the when
	     * removing entries based on maximum entries, most recently used
	     * is accurate or when expiring, the timestamp is up-to-date.
	     *
	     * @param {string} url
	     */
	    async updateTimestamp(url) {
	        {
	            finalAssertExports.isType(url, 'string', {
	                moduleName: 'workbox-expiration',
	                className: 'CacheExpiration',
	                funcName: 'updateTimestamp',
	                paramName: 'url',
	            });
	        }
	        await this._timestampModel.setTimestamp(url, Date.now());
	    }
	    /**
	     * Can be used to check if a URL has expired or not before it's used.
	     *
	     * This requires a look up from IndexedDB, so can be slow.
	     *
	     * Note: This method will not remove the cached entry, call
	     * `expireEntries()` to remove indexedDB and Cache entries.
	     *
	     * @param {string} url
	     * @return {boolean}
	     */
	    async isURLExpired(url) {
	        if (!this._maxAgeSeconds) {
	            {
	                throw new WorkboxError(`expired-test-without-max-age`, {
	                    methodName: 'isURLExpired',
	                    paramName: 'maxAgeSeconds',
	                });
	            }
	        }
	        else {
	            const timestamp = await this._timestampModel.getTimestamp(url);
	            const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);
	            return (timestamp < expireOlderThan);
	        }
	    }
	    /**
	     * Removes the IndexedDB object store used to keep track of cache expiration
	     * metadata.
	     */
	    async delete() {
	        // Make sure we don't attempt another rerun if we're called in the middle of
	        // a cache expiration.
	        this._rerunRequested = false;
	        await this._timestampModel.expireEntries(Infinity); // Expires all.
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Adds a function to the set of quotaErrorCallbacks that will be executed if
	 * there's a quota error.
	 *
	 * @param {Function} callback
	 * @memberof module:workbox-core
	 */
	function registerQuotaErrorCallback(callback) {
	    {
	        finalAssertExports.isType(callback, 'function', {
	            moduleName: 'workbox-core',
	            funcName: 'register',
	            paramName: 'callback',
	        });
	    }
	    quotaErrorCallbacks.add(callback);
	    {
	        logger.log('Registered a callback to respond to quota errors.', callback);
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * This plugin can be used in a `workbox-strategy` to regularly enforce a
	 * limit on the age and / or the number of cached requests.
	 *
	 * It can only be used with `workbox-strategy` instances that have a
	 * [custom `cacheName` property set](/web/tools/workbox/guides/configure-workbox#custom_cache_names_in_strategies).
	 * In other words, it can't be used to expire entries in strategy that uses the
	 * default runtime cache name.
	 *
	 * Whenever a cached request is used or updated, this plugin will look
	 * at the associated cache and remove any old or extra requests.
	 *
	 * When using `maxAgeSeconds`, requests may be used *once* after expiring
	 * because the expiration clean up will not have occurred until *after* the
	 * cached request has been used. If the request has a "Date" header, then
	 * a light weight expiration check is performed and the request will not be
	 * used immediately.
	 *
	 * When using `maxEntries`, the entry least-recently requested will be removed
	 * from the cache first.
	 *
	 * @memberof module:workbox-expiration
	 */
	class ExpirationPlugin {
	    /**
	     * @param {Object} config
	     * @param {number} [config.maxEntries] The maximum number of entries to cache.
	     * Entries used the least will be removed as the maximum is reached.
	     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before
	     * it's treated as stale and removed.
	     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)
	     * that will be used when calling `delete()` on the cache.
	     * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to
	     * automatic deletion if the available storage quota has been exceeded.
	     */
	    constructor(config = {}) {
	        /**
	         * A "lifecycle" callback that will be triggered automatically by the
	         * `workbox-strategies` handlers when a `Response` is about to be returned
	         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to
	         * the handler. It allows the `Response` to be inspected for freshness and
	         * prevents it from being used if the `Response`'s `Date` header value is
	         * older than the configured `maxAgeSeconds`.
	         *
	         * @param {Object} options
	         * @param {string} options.cacheName Name of the cache the response is in.
	         * @param {Response} options.cachedResponse The `Response` object that's been
	         *     read from a cache and whose freshness should be checked.
	         * @return {Response} Either the `cachedResponse`, if it's
	         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.
	         *
	         * @private
	         */
	        this.cachedResponseWillBeUsed = async ({ event, request, cacheName, cachedResponse }) => {
	            if (!cachedResponse) {
	                return null;
	            }
	            const isFresh = this._isResponseDateFresh(cachedResponse);
	            // Expire entries to ensure that even if the expiration date has
	            // expired, it'll only be used once.
	            const cacheExpiration = this._getCacheExpiration(cacheName);
	            dontWaitFor(cacheExpiration.expireEntries());
	            // Update the metadata for the request URL to the current timestamp,
	            // but don't `await` it as we don't want to block the response.
	            const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);
	            if (event) {
	                try {
	                    event.waitUntil(updateTimestampDone);
	                }
	                catch (error) {
	                    {
	                        // The event may not be a fetch event; only log the URL if it is.
	                        if ('request' in event) {
	                            logger.warn(`Unable to ensure service worker stays alive when ` +
	                                `updating cache entry for ` +
	                                `'${getFriendlyURL(event.request.url)}'.`);
	                        }
	                    }
	                }
	            }
	            return isFresh ? cachedResponse : null;
	        };
	        /**
	         * A "lifecycle" callback that will be triggered automatically by the
	         * `workbox-strategies` handlers when an entry is added to a cache.
	         *
	         * @param {Object} options
	         * @param {string} options.cacheName Name of the cache that was updated.
	         * @param {string} options.request The Request for the cached entry.
	         *
	         * @private
	         */
	        this.cacheDidUpdate = async ({ cacheName, request }) => {
	            {
	                finalAssertExports.isType(cacheName, 'string', {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'cacheDidUpdate',
	                    paramName: 'cacheName',
	                });
	                finalAssertExports.isInstance(request, Request, {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'cacheDidUpdate',
	                    paramName: 'request',
	                });
	            }
	            const cacheExpiration = this._getCacheExpiration(cacheName);
	            await cacheExpiration.updateTimestamp(request.url);
	            await cacheExpiration.expireEntries();
	        };
	        {
	            if (!(config.maxEntries || config.maxAgeSeconds)) {
	                throw new WorkboxError('max-entries-or-age-required', {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'constructor',
	                });
	            }
	            if (config.maxEntries) {
	                finalAssertExports.isType(config.maxEntries, 'number', {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'constructor',
	                    paramName: 'config.maxEntries',
	                });
	            }
	            if (config.maxAgeSeconds) {
	                finalAssertExports.isType(config.maxAgeSeconds, 'number', {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'constructor',
	                    paramName: 'config.maxAgeSeconds',
	                });
	            }
	        }
	        this._config = config;
	        this._maxAgeSeconds = config.maxAgeSeconds;
	        this._cacheExpirations = new Map();
	        if (config.purgeOnQuotaError) {
	            registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());
	        }
	    }
	    /**
	     * A simple helper method to return a CacheExpiration instance for a given
	     * cache name.
	     *
	     * @param {string} cacheName
	     * @return {CacheExpiration}
	     *
	     * @private
	     */
	    _getCacheExpiration(cacheName) {
	        if (cacheName === cacheNames.getRuntimeName()) {
	            throw new WorkboxError('expire-custom-caches-only');
	        }
	        let cacheExpiration = this._cacheExpirations.get(cacheName);
	        if (!cacheExpiration) {
	            cacheExpiration = new CacheExpiration(cacheName, this._config);
	            this._cacheExpirations.set(cacheName, cacheExpiration);
	        }
	        return cacheExpiration;
	    }
	    /**
	     * @param {Response} cachedResponse
	     * @return {boolean}
	     *
	     * @private
	     */
	    _isResponseDateFresh(cachedResponse) {
	        if (!this._maxAgeSeconds) {
	            // We aren't expiring by age, so return true, it's fresh
	            return true;
	        }
	        // Check if the 'date' header will suffice a quick expiration check.
	        // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for
	        // discussion.
	        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);
	        if (dateHeaderTimestamp === null) {
	            // Unable to parse date, so assume it's fresh.
	            return true;
	        }
	        // If we have a valid headerTime, then our response is fresh iff the
	        // headerTime plus maxAgeSeconds is greater than the current time.
	        const now = Date.now();
	        return dateHeaderTimestamp >= now - (this._maxAgeSeconds * 1000);
	    }
	    /**
	     * This method will extract the data header and parse it into a useful
	     * value.
	     *
	     * @param {Response} cachedResponse
	     * @return {number|null}
	     *
	     * @private
	     */
	    _getDateHeaderTimestamp(cachedResponse) {
	        if (!cachedResponse.headers.has('date')) {
	            return null;
	        }
	        const dateHeader = cachedResponse.headers.get('date');
	        const parsedDate = new Date(dateHeader);
	        const headerTime = parsedDate.getTime();
	        // If the Date header was invalid for some reason, parsedDate.getTime()
	        // will return NaN.
	        if (isNaN(headerTime)) {
	            return null;
	        }
	        return headerTime;
	    }
	    /**
	     * This is a helper method that performs two operations:
	     *
	     * - Deletes *all* the underlying Cache instances associated with this plugin
	     * instance, by calling caches.delete() on your behalf.
	     * - Deletes the metadata from IndexedDB used to keep track of expiration
	     * details for each Cache instance.
	     *
	     * When using cache expiration, calling this method is preferable to calling
	     * `caches.delete()` directly, since this will ensure that the IndexedDB
	     * metadata is also cleanly removed and open IndexedDB instances are deleted.
	     *
	     * Note that if you're *not* using cache expiration for a given cache, calling
	     * `caches.delete()` and passing in the cache's name should be sufficient.
	     * There is no Workbox-specific method needed for cleanup in that case.
	     */
	    async deleteCacheAndMetadata() {
	        // Do this one at a time instead of all at once via `Promise.all()` to
	        // reduce the chance of inconsistency if a promise rejects.
	        for (const [cacheName, cacheExpiration] of this._cacheExpirations) {
	            await self.caches.delete(cacheName);
	            await cacheExpiration.delete();
	        }
	        // Reset this._cacheExpirations to its initial state.
	        this._cacheExpirations = new Map();
	    }
	}

	self.__WB_DISABLE_DEV_LOGS = true;

	precacheAndRoute(shell);
	precacheAndRoute(files);

	registerRoute(
	/* eslint-disable-next-line */
	  new RegExp('https:\/\/producteursagri\.opendatasoft\.com'),
	  new CacheFirst({
	    cacheName: `ods-requests-${timestamp}`,
	    plugins: [
	      new ExpirationPlugin({
	        maxEntries: 50,
	        maxAgeSeconds: 3600 * 24,
	      }),
	    ],
	  }),
	);

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VydmljZS13b3JrZXIuanMiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ub2RlX21vZHVsZXMvQHNhcHBlci9zZXJ2aWNlLXdvcmtlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvX3ZlcnNpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL21vZGVscy9tZXNzYWdlcy9tZXNzYWdlcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvbW9kZWxzL21lc3NhZ2VzL21lc3NhZ2VHZW5lcmF0b3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtY29yZS9fcHJpdmF0ZS9jYWNoZU5hbWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL3dhaXRVbnRpbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXByZWNhY2hpbmcvX3ZlcnNpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL2NyZWF0ZUNhY2hlS2V5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy91dGlscy9QcmVjYWNoZUluc3RhbGxSZXBvcnRQbHVnaW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL1ByZWNhY2hlQ2FjaGVLZXlQbHVnaW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL3ByaW50Q2xlYW51cERldGFpbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL3ByaW50SW5zdGFsbERldGFpbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL2NhbkNvbnN0cnVjdFJlc3BvbnNlRnJvbUJvZHlTdHJlYW0uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL2NvcHlSZXNwb25zZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL2NhY2hlTWF0Y2hJZ25vcmVQYXJhbXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL0RlZmVycmVkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtY29yZS9tb2RlbHMvcXVvdGFFcnJvckNhbGxiYWNrcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvX3ByaXZhdGUvZXhlY3V0ZVF1b3RhRXJyb3JDYWxsYmFja3MuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL3RpbWVvdXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1zdHJhdGVnaWVzL192ZXJzaW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtc3RyYXRlZ2llcy9TdHJhdGVneUhhbmRsZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1zdHJhdGVnaWVzL1N0cmF0ZWd5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy9QcmVjYWNoZVN0cmF0ZWd5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy9QcmVjYWNoZUNvbnRyb2xsZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL2dldE9yQ3JlYXRlUHJlY2FjaGVDb250cm9sbGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcm91dGluZy9fdmVyc2lvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXJvdXRpbmcvdXRpbHMvY29uc3RhbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcm91dGluZy91dGlscy9ub3JtYWxpemVIYW5kbGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcm91dGluZy9Sb3V0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXJvdXRpbmcvUmVnRXhwUm91dGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1yb3V0aW5nL1JvdXRlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXJvdXRpbmcvdXRpbHMvZ2V0T3JDcmVhdGVEZWZhdWx0Um91dGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcm91dGluZy9yZWdpc3RlclJvdXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy91dGlscy9yZW1vdmVJZ25vcmVkU2VhcmNoUGFyYW1zLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy91dGlscy9nZW5lcmF0ZVVSTFZhcmlhdGlvbnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL1ByZWNhY2hlUm91dGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL2FkZFJvdXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy9wcmVjYWNoZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXByZWNhY2hpbmcvcHJlY2FjaGVBbmRSb3V0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXN0cmF0ZWdpZXMvdXRpbHMvbWVzc2FnZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1zdHJhdGVnaWVzL0NhY2hlRmlyc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL2RvbnRXYWl0Rm9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtY29yZS9fcHJpdmF0ZS9EQldyYXBwZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL2RlbGV0ZURhdGFiYXNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtZXhwaXJhdGlvbi9fdmVyc2lvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWV4cGlyYXRpb24vbW9kZWxzL0NhY2hlVGltZXN0YW1wc01vZGVsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtZXhwaXJhdGlvbi9DYWNoZUV4cGlyYXRpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL3JlZ2lzdGVyUXVvdGFFcnJvckNhbGxiYWNrLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtZXhwaXJhdGlvbi9FeHBpcmF0aW9uUGx1Z2luLmpzIiwiLi4vLi4vc3JjL3NlcnZpY2Utd29ya2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgU2FwcGVyIOKAlCBkbyBub3QgZWRpdCBpdCFcbmV4cG9ydCBjb25zdCB0aW1lc3RhbXAgPSAxNjA4MTUzNjg0NzUxO1xuXG5leHBvcnQgY29uc3QgZmlsZXMgPSBbXG5cdFwiL3NlcnZpY2Utd29ya2VyLWluZGV4Lmh0bWxcIixcblx0XCIvcmVzb3VyY2VzL2FuZHJvaWQtY2hyb21lLTE5MngxOTIucG5nXCIsXG5cdFwiL3Jlc291cmNlcy9hbmRyb2lkLWNocm9tZS01MTJ4NTEyLnBuZ1wiLFxuXHRcIi9yZXNvdXJjZXMvYXBwbGUtdG91Y2gtaWNvbi5wbmdcIixcblx0XCIvcmVzb3VyY2VzL2Jyb3dzZXJjb25maWcueG1sXCIsXG5cdFwiL3Jlc291cmNlcy9mYXZpY29uLTE2eDE2LnBuZ1wiLFxuXHRcIi9yZXNvdXJjZXMvZmF2aWNvbi0zMngzMi5wbmdcIixcblx0XCIvcmVzb3VyY2VzL2Zhdmljb24uaWNvXCIsXG5cdFwiL3Jlc291cmNlcy9mYXZpY29uLnBuZ1wiLFxuXHRcIi9yZXNvdXJjZXMvZ2xvYmFsLmNzc1wiLFxuXHRcIi9yZXNvdXJjZXMvbG9jYXRpb24uc3ZnXCIsXG5cdFwiL3Jlc291cmNlcy9sb2dvLTE5Mi5wbmdcIixcblx0XCIvcmVzb3VyY2VzL2xvZ28tNTEyLnBuZ1wiLFxuXHRcIi9yZXNvdXJjZXMvbWFuaWZlc3Qud2VibWFuaWZlc3RcIixcblx0XCIvcmVzb3VyY2VzL21zdGlsZS0xNDR4MTQ0LnBuZ1wiLFxuXHRcIi9yZXNvdXJjZXMvbXN0aWxlLTE1MHgxNTAucG5nXCIsXG5cdFwiL3Jlc291cmNlcy9tc3RpbGUtMzEweDE1MC5wbmdcIixcblx0XCIvcmVzb3VyY2VzL21zdGlsZS0zMTB4MzEwLnBuZ1wiLFxuXHRcIi9yZXNvdXJjZXMvbXN0aWxlLTcweDcwLnBuZ1wiLFxuXHRcIi9yZXNvdXJjZXMvc2FmYXJpLXBpbm5lZC10YWIuc3ZnXCJcbl07XG5leHBvcnQgeyBmaWxlcyBhcyBhc3NldHMgfTsgLy8gbGVnYWN5XG5cbmV4cG9ydCBjb25zdCBzaGVsbCA9IFtcblx0XG5dO1xuXG5leHBvcnQgY29uc3Qgcm91dGVzID0gW1xuXHR7IHBhdHRlcm46IC9eXFwvJC8gfSxcblx0eyBwYXR0ZXJuOiAvXlxcL3BhcnRuZXJzXFwvPyQvIH0sXG5cdHsgcGF0dGVybjogL15cXC9hYm91dFxcLz8kLyB9LFxuXHR7IHBhdHRlcm46IC9eXFwvZmFybXNcXC8/JC8gfSxcblx0eyBwYXR0ZXJuOiAvXlxcL2Zhcm1zXFwvKFteL10rPylcXC8/JC8gfVxuXTsiLCJcInVzZSBzdHJpY3RcIjtcbi8vIEB0cy1pZ25vcmVcbnRyeSB7XG4gICAgc2VsZlsnd29ya2JveDpjb3JlOjYuMC4yJ10gJiYgXygpO1xufVxuY2F0Y2ggKGUpIHsgfVxuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi8uLi9fdmVyc2lvbi5qcyc7XG5leHBvcnQgY29uc3QgbWVzc2FnZXMgPSB7XG4gICAgJ2ludmFsaWQtdmFsdWUnOiAoeyBwYXJhbU5hbWUsIHZhbGlkVmFsdWVEZXNjcmlwdGlvbiwgdmFsdWUgfSkgPT4ge1xuICAgICAgICBpZiAoIXBhcmFtTmFtZSB8fCAhdmFsaWRWYWx1ZURlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ2ludmFsaWQtdmFsdWUnIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgVGhlICcke3BhcmFtTmFtZX0nIHBhcmFtZXRlciB3YXMgZ2l2ZW4gYSB2YWx1ZSB3aXRoIGFuIGAgK1xuICAgICAgICAgICAgYHVuZXhwZWN0ZWQgdmFsdWUuICR7dmFsaWRWYWx1ZURlc2NyaXB0aW9ufSBSZWNlaXZlZCBhIHZhbHVlIG9mIGAgK1xuICAgICAgICAgICAgYCR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfS5gO1xuICAgIH0sXG4gICAgJ25vdC1hbi1hcnJheSc6ICh7IG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUsIHBhcmFtTmFtZSB9KSA9PiB7XG4gICAgICAgIGlmICghbW9kdWxlTmFtZSB8fCAhY2xhc3NOYW1lIHx8ICFmdW5jTmFtZSB8fCAhcGFyYW1OYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ25vdC1hbi1hcnJheScgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBUaGUgcGFyYW1ldGVyICcke3BhcmFtTmFtZX0nIHBhc3NlZCBpbnRvIGAgK1xuICAgICAgICAgICAgYCcke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lfS4ke2Z1bmNOYW1lfSgpJyBtdXN0IGJlIGFuIGFycmF5LmA7XG4gICAgfSxcbiAgICAnaW5jb3JyZWN0LXR5cGUnOiAoeyBleHBlY3RlZFR5cGUsIHBhcmFtTmFtZSwgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSB9KSA9PiB7XG4gICAgICAgIGlmICghZXhwZWN0ZWRUeXBlIHx8ICFwYXJhbU5hbWUgfHwgIW1vZHVsZU5hbWUgfHwgIWZ1bmNOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ2luY29ycmVjdC10eXBlJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFRoZSBwYXJhbWV0ZXIgJyR7cGFyYW1OYW1lfScgcGFzc2VkIGludG8gYCArXG4gICAgICAgICAgICBgJyR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWUgPyAoY2xhc3NOYW1lICsgJy4nKSA6ICcnfWAgK1xuICAgICAgICAgICAgYCR7ZnVuY05hbWV9KCknIG11c3QgYmUgb2YgdHlwZSAke2V4cGVjdGVkVHlwZX0uYDtcbiAgICB9LFxuICAgICdpbmNvcnJlY3QtY2xhc3MnOiAoeyBleHBlY3RlZENsYXNzLCBwYXJhbU5hbWUsIG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUsIGlzUmV0dXJuVmFsdWVQcm9ibGVtIH0pID0+IHtcbiAgICAgICAgaWYgKCFleHBlY3RlZENsYXNzIHx8ICFtb2R1bGVOYW1lIHx8ICFmdW5jTmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0IHRvICdpbmNvcnJlY3QtY2xhc3MnIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1JldHVyblZhbHVlUHJvYmxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGBUaGUgcmV0dXJuIHZhbHVlIGZyb20gYCArXG4gICAgICAgICAgICAgICAgYCcke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lID8gKGNsYXNzTmFtZSArICcuJykgOiAnJ30ke2Z1bmNOYW1lfSgpJyBgICtcbiAgICAgICAgICAgICAgICBgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBjbGFzcyAke2V4cGVjdGVkQ2xhc3MubmFtZX0uYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFRoZSBwYXJhbWV0ZXIgJyR7cGFyYW1OYW1lfScgcGFzc2VkIGludG8gYCArXG4gICAgICAgICAgICBgJyR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWUgPyAoY2xhc3NOYW1lICsgJy4nKSA6ICcnfSR7ZnVuY05hbWV9KCknIGAgK1xuICAgICAgICAgICAgYG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgY2xhc3MgJHtleHBlY3RlZENsYXNzLm5hbWV9LmA7XG4gICAgfSxcbiAgICAnbWlzc2luZy1hLW1ldGhvZCc6ICh7IGV4cGVjdGVkTWV0aG9kLCBwYXJhbU5hbWUsIG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUgfSkgPT4ge1xuICAgICAgICBpZiAoIWV4cGVjdGVkTWV0aG9kIHx8ICFwYXJhbU5hbWUgfHwgIW1vZHVsZU5hbWUgfHwgIWNsYXNzTmFtZVxuICAgICAgICAgICAgfHwgIWZ1bmNOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ21pc3NpbmctYS1tZXRob2QnIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHttb2R1bGVOYW1lfS4ke2NsYXNzTmFtZX0uJHtmdW5jTmFtZX0oKSBleHBlY3RlZCB0aGUgYCArXG4gICAgICAgICAgICBgJyR7cGFyYW1OYW1lfScgcGFyYW1ldGVyIHRvIGV4cG9zZSBhICcke2V4cGVjdGVkTWV0aG9kfScgbWV0aG9kLmA7XG4gICAgfSxcbiAgICAnYWRkLXRvLWNhY2hlLWxpc3QtdW5leHBlY3RlZC10eXBlJzogKHsgZW50cnkgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYEFuIHVuZXhwZWN0ZWQgZW50cnkgd2FzIHBhc3NlZCB0byBgICtcbiAgICAgICAgICAgIGAnd29ya2JveC1wcmVjYWNoaW5nLlByZWNhY2hlQ29udHJvbGxlci5hZGRUb0NhY2hlTGlzdCgpJyBUaGUgZW50cnkgYCArXG4gICAgICAgICAgICBgJyR7SlNPTi5zdHJpbmdpZnkoZW50cnkpfScgaXNuJ3Qgc3VwcG9ydGVkLiBZb3UgbXVzdCBzdXBwbHkgYW4gYXJyYXkgb2YgYCArXG4gICAgICAgICAgICBgc3RyaW5ncyB3aXRoIG9uZSBvciBtb3JlIGNoYXJhY3RlcnMsIG9iamVjdHMgd2l0aCBhIHVybCBwcm9wZXJ0eSBvciBgICtcbiAgICAgICAgICAgIGBSZXF1ZXN0IG9iamVjdHMuYDtcbiAgICB9LFxuICAgICdhZGQtdG8tY2FjaGUtbGlzdC1jb25mbGljdGluZy1lbnRyaWVzJzogKHsgZmlyc3RFbnRyeSwgc2Vjb25kRW50cnkgfSkgPT4ge1xuICAgICAgICBpZiAoIWZpcnN0RW50cnkgfHwgIXNlY29uZEVudHJ5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gYCArXG4gICAgICAgICAgICAgICAgYCdhZGQtdG8tY2FjaGUtbGlzdC1kdXBsaWNhdGUtZW50cmllcycgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBUd28gb2YgdGhlIGVudHJpZXMgcGFzc2VkIHRvIGAgK1xuICAgICAgICAgICAgYCd3b3JrYm94LXByZWNhY2hpbmcuUHJlY2FjaGVDb250cm9sbGVyLmFkZFRvQ2FjaGVMaXN0KCknIGhhZCB0aGUgVVJMIGAgK1xuICAgICAgICAgICAgYCR7Zmlyc3RFbnRyeS5fZW50cnlJZH0gYnV0IGRpZmZlcmVudCByZXZpc2lvbiBkZXRhaWxzLiBXb3JrYm94IGlzIGAgK1xuICAgICAgICAgICAgYHVuYWJsZSB0byBjYWNoZSBhbmQgdmVyc2lvbiB0aGUgYXNzZXQgY29ycmVjdGx5LiBQbGVhc2UgcmVtb3ZlIG9uZSBgICtcbiAgICAgICAgICAgIGBvZiB0aGUgZW50cmllcy5gO1xuICAgIH0sXG4gICAgJ3BsdWdpbi1lcnJvci1yZXF1ZXN0LXdpbGwtZmV0Y2gnOiAoeyB0aHJvd25FcnJvciB9KSA9PiB7XG4gICAgICAgIGlmICghdGhyb3duRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byBgICtcbiAgICAgICAgICAgICAgICBgJ3BsdWdpbi1lcnJvci1yZXF1ZXN0LXdpbGwtZmV0Y2gnLCBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYEFuIGVycm9yIHdhcyB0aHJvd24gYnkgYSBwbHVnaW5zICdyZXF1ZXN0V2lsbEZldGNoKCknIG1ldGhvZC4gYCArXG4gICAgICAgICAgICBgVGhlIHRocm93biBlcnJvciBtZXNzYWdlIHdhczogJyR7dGhyb3duRXJyb3IubWVzc2FnZX0nLmA7XG4gICAgfSxcbiAgICAnaW52YWxpZC1jYWNoZS1uYW1lJzogKHsgY2FjaGVOYW1lSWQsIHZhbHVlIH0pID0+IHtcbiAgICAgICAgaWYgKCFjYWNoZU5hbWVJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhICdjYWNoZU5hbWVJZCcgZm9yIGVycm9yICdpbnZhbGlkLWNhY2hlLW5hbWUnYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBZb3UgbXVzdCBwcm92aWRlIGEgbmFtZSBjb250YWluaW5nIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgZm9yIGAgK1xuICAgICAgICAgICAgYHNldENhY2hlRGV0YWlscyh7JHtjYWNoZU5hbWVJZH06ICcuLi4nfSkuIFJlY2VpdmVkIGEgdmFsdWUgb2YgYCArXG4gICAgICAgICAgICBgJyR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSdgO1xuICAgIH0sXG4gICAgJ3VucmVnaXN0ZXItcm91dGUtYnV0LW5vdC1mb3VuZC13aXRoLW1ldGhvZCc6ICh7IG1ldGhvZCB9KSA9PiB7XG4gICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gYCArXG4gICAgICAgICAgICAgICAgYCd1bnJlZ2lzdGVyLXJvdXRlLWJ1dC1ub3QtZm91bmQtd2l0aC1tZXRob2QnIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgVGhlIHJvdXRlIHlvdSdyZSB0cnlpbmcgdG8gdW5yZWdpc3RlciB3YXMgbm90ICBwcmV2aW91c2x5IGAgK1xuICAgICAgICAgICAgYHJlZ2lzdGVyZWQgZm9yIHRoZSBtZXRob2QgdHlwZSAnJHttZXRob2R9Jy5gO1xuICAgIH0sXG4gICAgJ3VucmVnaXN0ZXItcm91dGUtcm91dGUtbm90LXJlZ2lzdGVyZWQnOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBgVGhlIHJvdXRlIHlvdSdyZSB0cnlpbmcgdG8gdW5yZWdpc3RlciB3YXMgbm90IHByZXZpb3VzbHkgYCArXG4gICAgICAgICAgICBgcmVnaXN0ZXJlZC5gO1xuICAgIH0sXG4gICAgJ3F1ZXVlLXJlcGxheS1mYWlsZWQnOiAoeyBuYW1lIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGBSZXBsYXlpbmcgdGhlIGJhY2tncm91bmQgc3luYyBxdWV1ZSAnJHtuYW1lfScgZmFpbGVkLmA7XG4gICAgfSxcbiAgICAnZHVwbGljYXRlLXF1ZXVlLW5hbWUnOiAoeyBuYW1lIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGBUaGUgUXVldWUgbmFtZSAnJHtuYW1lfScgaXMgYWxyZWFkeSBiZWluZyB1c2VkLiBgICtcbiAgICAgICAgICAgIGBBbGwgaW5zdGFuY2VzIG9mIGJhY2tncm91bmRTeW5jLlF1ZXVlIG11c3QgYmUgZ2l2ZW4gdW5pcXVlIG5hbWVzLmA7XG4gICAgfSxcbiAgICAnZXhwaXJlZC10ZXN0LXdpdGhvdXQtbWF4LWFnZSc6ICh7IG1ldGhvZE5hbWUsIHBhcmFtTmFtZSB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgVGhlICcke21ldGhvZE5hbWV9KCknIG1ldGhvZCBjYW4gb25seSBiZSB1c2VkIHdoZW4gdGhlIGAgK1xuICAgICAgICAgICAgYCcke3BhcmFtTmFtZX0nIGlzIHVzZWQgaW4gdGhlIGNvbnN0cnVjdG9yLmA7XG4gICAgfSxcbiAgICAndW5zdXBwb3J0ZWQtcm91dGUtdHlwZSc6ICh7IG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUsIHBhcmFtTmFtZSB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgVGhlIHN1cHBsaWVkICcke3BhcmFtTmFtZX0nIHBhcmFtZXRlciB3YXMgYW4gdW5zdXBwb3J0ZWQgdHlwZS4gYCArXG4gICAgICAgICAgICBgUGxlYXNlIGNoZWNrIHRoZSBkb2NzIGZvciAke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lfS4ke2Z1bmNOYW1lfSBmb3IgYCArXG4gICAgICAgICAgICBgdmFsaWQgaW5wdXQgdHlwZXMuYDtcbiAgICB9LFxuICAgICdub3QtYXJyYXktb2YtY2xhc3MnOiAoeyB2YWx1ZSwgZXhwZWN0ZWRDbGFzcywgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSwgcGFyYW1OYW1lIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGBUaGUgc3VwcGxpZWQgJyR7cGFyYW1OYW1lfScgcGFyYW1ldGVyIG11c3QgYmUgYW4gYXJyYXkgb2YgYCArXG4gICAgICAgICAgICBgJyR7ZXhwZWN0ZWRDbGFzc30nIG9iamVjdHMuIFJlY2VpdmVkICcke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0sJy4gYCArXG4gICAgICAgICAgICBgUGxlYXNlIGNoZWNrIHRoZSBjYWxsIHRvICR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWV9LiR7ZnVuY05hbWV9KCkgYCArXG4gICAgICAgICAgICBgdG8gZml4IHRoZSBpc3N1ZS5gO1xuICAgIH0sXG4gICAgJ21heC1lbnRyaWVzLW9yLWFnZS1yZXF1aXJlZCc6ICh7IG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFlvdSBtdXN0IGRlZmluZSBlaXRoZXIgY29uZmlnLm1heEVudHJpZXMgb3IgY29uZmlnLm1heEFnZVNlY29uZHNgICtcbiAgICAgICAgICAgIGBpbiAke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lfS4ke2Z1bmNOYW1lfWA7XG4gICAgfSxcbiAgICAnc3RhdHVzZXMtb3ItaGVhZGVycy1yZXF1aXJlZCc6ICh7IG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFlvdSBtdXN0IGRlZmluZSBlaXRoZXIgY29uZmlnLnN0YXR1c2VzIG9yIGNvbmZpZy5oZWFkZXJzYCArXG4gICAgICAgICAgICBgaW4gJHttb2R1bGVOYW1lfS4ke2NsYXNzTmFtZX0uJHtmdW5jTmFtZX1gO1xuICAgIH0sXG4gICAgJ2ludmFsaWQtc3RyaW5nJzogKHsgbW9kdWxlTmFtZSwgZnVuY05hbWUsIHBhcmFtTmFtZSB9KSA9PiB7XG4gICAgICAgIGlmICghcGFyYW1OYW1lIHx8ICFtb2R1bGVOYW1lIHx8ICFmdW5jTmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0IHRvICdpbnZhbGlkLXN0cmluZycgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBXaGVuIHVzaW5nIHN0cmluZ3MsIHRoZSAnJHtwYXJhbU5hbWV9JyBwYXJhbWV0ZXIgbXVzdCBzdGFydCB3aXRoIGAgK1xuICAgICAgICAgICAgYCdodHRwJyAoZm9yIGNyb3NzLW9yaWdpbiBtYXRjaGVzKSBvciAnLycgKGZvciBzYW1lLW9yaWdpbiBtYXRjaGVzKS4gYCArXG4gICAgICAgICAgICBgUGxlYXNlIHNlZSB0aGUgZG9jcyBmb3IgJHttb2R1bGVOYW1lfS4ke2Z1bmNOYW1lfSgpIGZvciBgICtcbiAgICAgICAgICAgIGBtb3JlIGluZm8uYDtcbiAgICB9LFxuICAgICdjaGFubmVsLW5hbWUtcmVxdWlyZWQnOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBgWW91IG11c3QgcHJvdmlkZSBhIGNoYW5uZWxOYW1lIHRvIGNvbnN0cnVjdCBhIGAgK1xuICAgICAgICAgICAgYEJyb2FkY2FzdENhY2hlVXBkYXRlIGluc3RhbmNlLmA7XG4gICAgfSxcbiAgICAnaW52YWxpZC1yZXNwb25zZXMtYXJlLXNhbWUtYXJncyc6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGBUaGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIHJlc3BvbnNlc0FyZVNhbWUoKSBhcHBlYXIgdG8gYmUgYCArXG4gICAgICAgICAgICBgaW52YWxpZC4gUGxlYXNlIGVuc3VyZSB2YWxpZCBSZXNwb25zZXMgYXJlIHVzZWQuYDtcbiAgICB9LFxuICAgICdleHBpcmUtY3VzdG9tLWNhY2hlcy1vbmx5JzogKCkgPT4ge1xuICAgICAgICByZXR1cm4gYFlvdSBtdXN0IHByb3ZpZGUgYSAnY2FjaGVOYW1lJyBwcm9wZXJ0eSB3aGVuIHVzaW5nIHRoZSBgICtcbiAgICAgICAgICAgIGBleHBpcmF0aW9uIHBsdWdpbiB3aXRoIGEgcnVudGltZSBjYWNoaW5nIHN0cmF0ZWd5LmA7XG4gICAgfSxcbiAgICAndW5pdC1tdXN0LWJlLWJ5dGVzJzogKHsgbm9ybWFsaXplZFJhbmdlSGVhZGVyIH0pID0+IHtcbiAgICAgICAgaWYgKCFub3JtYWxpemVkUmFuZ2VIZWFkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAndW5pdC1tdXN0LWJlLWJ5dGVzJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFRoZSAndW5pdCcgcG9ydGlvbiBvZiB0aGUgUmFuZ2UgaGVhZGVyIG11c3QgYmUgc2V0IHRvICdieXRlcycuIGAgK1xuICAgICAgICAgICAgYFRoZSBSYW5nZSBoZWFkZXIgcHJvdmlkZWQgd2FzIFwiJHtub3JtYWxpemVkUmFuZ2VIZWFkZXJ9XCJgO1xuICAgIH0sXG4gICAgJ3NpbmdsZS1yYW5nZS1vbmx5JzogKHsgbm9ybWFsaXplZFJhbmdlSGVhZGVyIH0pID0+IHtcbiAgICAgICAgaWYgKCFub3JtYWxpemVkUmFuZ2VIZWFkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAnc2luZ2xlLXJhbmdlLW9ubHknIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgTXVsdGlwbGUgcmFuZ2VzIGFyZSBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIGEgIHNpbmdsZSBzdGFydCBgICtcbiAgICAgICAgICAgIGB2YWx1ZSwgYW5kIG9wdGlvbmFsIGVuZCB2YWx1ZS4gVGhlIFJhbmdlIGhlYWRlciBwcm92aWRlZCB3YXMgYCArXG4gICAgICAgICAgICBgXCIke25vcm1hbGl6ZWRSYW5nZUhlYWRlcn1cImA7XG4gICAgfSxcbiAgICAnaW52YWxpZC1yYW5nZS12YWx1ZXMnOiAoeyBub3JtYWxpemVkUmFuZ2VIZWFkZXIgfSkgPT4ge1xuICAgICAgICBpZiAoIW5vcm1hbGl6ZWRSYW5nZUhlYWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0IHRvICdpbnZhbGlkLXJhbmdlLXZhbHVlcycgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBUaGUgUmFuZ2UgaGVhZGVyIGlzIG1pc3NpbmcgYm90aCBzdGFydCBhbmQgZW5kIHZhbHVlcy4gQXQgbGVhc3QgYCArXG4gICAgICAgICAgICBgb25lIG9mIHRob3NlIHZhbHVlcyBpcyBuZWVkZWQuIFRoZSBSYW5nZSBoZWFkZXIgcHJvdmlkZWQgd2FzIGAgK1xuICAgICAgICAgICAgYFwiJHtub3JtYWxpemVkUmFuZ2VIZWFkZXJ9XCJgO1xuICAgIH0sXG4gICAgJ25vLXJhbmdlLWhlYWRlcic6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGBObyBSYW5nZSBoZWFkZXIgd2FzIGZvdW5kIGluIHRoZSBSZXF1ZXN0IHByb3ZpZGVkLmA7XG4gICAgfSxcbiAgICAncmFuZ2Utbm90LXNhdGlzZmlhYmxlJzogKHsgc2l6ZSwgc3RhcnQsIGVuZCB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgVGhlIHN0YXJ0ICgke3N0YXJ0fSkgYW5kIGVuZCAoJHtlbmR9KSB2YWx1ZXMgaW4gdGhlIFJhbmdlIGFyZSBgICtcbiAgICAgICAgICAgIGBub3Qgc2F0aXNmaWFibGUgYnkgdGhlIGNhY2hlZCByZXNwb25zZSwgd2hpY2ggaXMgJHtzaXplfSBieXRlcy5gO1xuICAgIH0sXG4gICAgJ2F0dGVtcHQtdG8tY2FjaGUtbm9uLWdldC1yZXF1ZXN0JzogKHsgdXJsLCBtZXRob2QgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFVuYWJsZSB0byBjYWNoZSAnJHt1cmx9JyBiZWNhdXNlIGl0IGlzIGEgJyR7bWV0aG9kfScgcmVxdWVzdCBhbmQgYCArXG4gICAgICAgICAgICBgb25seSAnR0VUJyByZXF1ZXN0cyBjYW4gYmUgY2FjaGVkLmA7XG4gICAgfSxcbiAgICAnY2FjaGUtcHV0LXdpdGgtbm8tcmVzcG9uc2UnOiAoeyB1cmwgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFRoZXJlIHdhcyBhbiBhdHRlbXB0IHRvIGNhY2hlICcke3VybH0nIGJ1dCB0aGUgcmVzcG9uc2Ugd2FzIG5vdCBgICtcbiAgICAgICAgICAgIGBkZWZpbmVkLmA7XG4gICAgfSxcbiAgICAnbm8tcmVzcG9uc2UnOiAoeyB1cmwsIGVycm9yIH0pID0+IHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBgVGhlIHN0cmF0ZWd5IGNvdWxkIG5vdCBnZW5lcmF0ZSBhIHJlc3BvbnNlIGZvciAnJHt1cmx9Jy5gO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYCBUaGUgdW5kZXJseWluZyBlcnJvciBpcyAke2Vycm9yfS5gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgJ2JhZC1wcmVjYWNoaW5nLXJlc3BvbnNlJzogKHsgdXJsLCBzdGF0dXMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFRoZSBwcmVjYWNoaW5nIHJlcXVlc3QgZm9yICcke3VybH0nIGZhaWxlZGAgK1xuICAgICAgICAgICAgKHN0YXR1cyA/IGAgd2l0aCBhbiBIVFRQIHN0YXR1cyBvZiAke3N0YXR1c30uYCA6IGAuYCk7XG4gICAgfSxcbiAgICAnbm9uLXByZWNhY2hlZC11cmwnOiAoeyB1cmwgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYGNyZWF0ZUhhbmRsZXJCb3VuZFRvVVJMKCcke3VybH0nKSB3YXMgY2FsbGVkLCBidXQgdGhhdCBVUkwgaXMgYCArXG4gICAgICAgICAgICBgbm90IHByZWNhY2hlZC4gUGxlYXNlIHBhc3MgaW4gYSBVUkwgdGhhdCBpcyBwcmVjYWNoZWQgaW5zdGVhZC5gO1xuICAgIH0sXG4gICAgJ2FkZC10by1jYWNoZS1saXN0LWNvbmZsaWN0aW5nLWludGVncml0aWVzJzogKHsgdXJsIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGBUd28gb2YgdGhlIGVudHJpZXMgcGFzc2VkIHRvIGAgK1xuICAgICAgICAgICAgYCd3b3JrYm94LXByZWNhY2hpbmcuUHJlY2FjaGVDb250cm9sbGVyLmFkZFRvQ2FjaGVMaXN0KCknIGhhZCB0aGUgVVJMIGAgK1xuICAgICAgICAgICAgYCR7dXJsfSB3aXRoIGRpZmZlcmVudCBpbnRlZ3JpdHkgdmFsdWVzLiBQbGVhc2UgcmVtb3ZlIG9uZSBvZiB0aGVtLmA7XG4gICAgfSxcbiAgICAnbWlzc2luZy1wcmVjYWNoZS1lbnRyeSc6ICh7IGNhY2hlTmFtZSwgdXJsIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGBVbmFibGUgdG8gZmluZCBhIHByZWNhY2hlZCByZXNwb25zZSBpbiAke2NhY2hlTmFtZX0gZm9yICR7dXJsfS5gO1xuICAgIH0sXG4gICAgJ2Nyb3NzLW9yaWdpbi1jb3B5LXJlc3BvbnNlJzogKHsgb3JpZ2luIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGB3b3JrYm94LWNvcmUuY29weVJlc3BvbnNlKCkgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHNhbWUtb3JpZ2luIGAgK1xuICAgICAgICAgICAgYHJlc3BvbnNlcy4gSXQgd2FzIHBhc3NlZCBhIHJlc3BvbnNlIHdpdGggb3JpZ2luICR7b3JpZ2lufS5gO1xuICAgIH0sXG59O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgbWVzc2FnZXMgfSBmcm9tICcuL21lc3NhZ2VzLmpzJztcbmltcG9ydCAnLi4vLi4vX3ZlcnNpb24uanMnO1xuY29uc3QgZmFsbGJhY2sgPSAoY29kZSwgLi4uYXJncykgPT4ge1xuICAgIGxldCBtc2cgPSBjb2RlO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbXNnICs9IGAgOjogJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gO1xuICAgIH1cbiAgICByZXR1cm4gbXNnO1xufTtcbmNvbnN0IGdlbmVyYXRvckZ1bmN0aW9uID0gKGNvZGUsIGRldGFpbHMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tjb2RlXTtcbiAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBtZXNzYWdlIGZvciBjb2RlICcke2NvZGV9Jy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2UoZGV0YWlscyk7XG59O1xuZXhwb3J0IGNvbnN0IG1lc3NhZ2VHZW5lcmF0b3IgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykgP1xuICAgIGZhbGxiYWNrIDogZ2VuZXJhdG9yRnVuY3Rpb247XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBtZXNzYWdlR2VuZXJhdG9yIH0gZnJvbSAnLi4vbW9kZWxzL21lc3NhZ2VzL21lc3NhZ2VHZW5lcmF0b3IuanMnO1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIFdvcmtib3ggZXJyb3JzIHNob3VsZCBiZSB0aHJvd24gd2l0aCB0aGlzIGNsYXNzLlxuICogVGhpcyBhbGxvd3MgdXNlIHRvIGVuc3VyZSB0aGUgdHlwZSBlYXNpbHkgaW4gdGVzdHMsXG4gKiBoZWxwcyBkZXZlbG9wZXJzIGlkZW50aWZ5IGVycm9ycyBmcm9tIHdvcmtib3hcbiAqIGVhc2lseSBhbmQgYWxsb3dzIHVzZSB0byBvcHRpbWlzZSBlcnJvclxuICogbWVzc2FnZXMgY29ycmVjdGx5LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFdvcmtib3hFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlcnJvckNvZGUgVGhlIGVycm9yIGNvZGUgdGhhdFxuICAgICAqIGlkZW50aWZpZXMgdGhpcyBwYXJ0aWN1bGFyIGVycm9yLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZGV0YWlscyBBbnkgcmVsZXZhbnQgYXJndW1lbnRzXG4gICAgICogdGhhdCB3aWxsIGhlbHAgZGV2ZWxvcGVycyBpZGVudGlmeSBpc3N1ZXMgc2hvdWxkXG4gICAgICogYmUgYWRkZWQgYXMgYSBrZXkgb24gdGhlIGNvbnRleHQgb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVycm9yQ29kZSwgZGV0YWlscykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZUdlbmVyYXRvcihlcnJvckNvZGUsIGRldGFpbHMpO1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZXJyb3JDb2RlO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cbn1cbmV4cG9ydCB7IFdvcmtib3hFcnJvciB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgV29ya2JveEVycm9yIH0gZnJvbSAnLi4vX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLypcbiAqIFRoaXMgbWV0aG9kIHRocm93cyBpZiB0aGUgc3VwcGxpZWQgdmFsdWUgaXMgbm90IGFuIGFycmF5LlxuICogVGhlIGRlc3RydWN0ZWQgdmFsdWVzIGFyZSByZXF1aXJlZCB0byBwcm9kdWNlIGEgbWVhbmluZ2Z1bCBlcnJvciBmb3IgdXNlcnMuXG4gKiBUaGUgZGVzdHJ1Y3RlZCBhbmQgcmVzdHJ1Y3R1cmVkIG9iamVjdCBpcyBzbyBpdCdzIGNsZWFyIHdoYXQgaXNcbiAqIG5lZWRlZC5cbiAqL1xuY29uc3QgaXNBcnJheSA9ICh2YWx1ZSwgZGV0YWlscykgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignbm90LWFuLWFycmF5JywgZGV0YWlscyk7XG4gICAgfVxufTtcbmNvbnN0IGhhc01ldGhvZCA9IChvYmplY3QsIGV4cGVjdGVkTWV0aG9kLCBkZXRhaWxzKSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBvYmplY3RbZXhwZWN0ZWRNZXRob2RdO1xuICAgIGlmICh0eXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRldGFpbHNbJ2V4cGVjdGVkTWV0aG9kJ10gPSBleHBlY3RlZE1ldGhvZDtcbiAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignbWlzc2luZy1hLW1ldGhvZCcsIGRldGFpbHMpO1xuICAgIH1cbn07XG5jb25zdCBpc1R5cGUgPSAob2JqZWN0LCBleHBlY3RlZFR5cGUsIGRldGFpbHMpID0+IHtcbiAgICBpZiAodHlwZW9mIG9iamVjdCAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIGRldGFpbHNbJ2V4cGVjdGVkVHlwZSddID0gZXhwZWN0ZWRUeXBlO1xuICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdpbmNvcnJlY3QtdHlwZScsIGRldGFpbHMpO1xuICAgIH1cbn07XG5jb25zdCBpc0luc3RhbmNlID0gKG9iamVjdCwgZXhwZWN0ZWRDbGFzcywgZGV0YWlscykgPT4ge1xuICAgIGlmICghKG9iamVjdCBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIGRldGFpbHNbJ2V4cGVjdGVkQ2xhc3MnXSA9IGV4cGVjdGVkQ2xhc3M7XG4gICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2luY29ycmVjdC1jbGFzcycsIGRldGFpbHMpO1xuICAgIH1cbn07XG5jb25zdCBpc09uZU9mID0gKHZhbHVlLCB2YWxpZFZhbHVlcywgZGV0YWlscykgPT4ge1xuICAgIGlmICghdmFsaWRWYWx1ZXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIGRldGFpbHNbJ3ZhbGlkVmFsdWVEZXNjcmlwdGlvbiddID1cbiAgICAgICAgICAgIGBWYWxpZCB2YWx1ZXMgYXJlICR7SlNPTi5zdHJpbmdpZnkodmFsaWRWYWx1ZXMpfS5gO1xuICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdpbnZhbGlkLXZhbHVlJywgZGV0YWlscyk7XG4gICAgfVxufTtcbmNvbnN0IGlzQXJyYXlPZkNsYXNzID0gKHZhbHVlLCBleHBlY3RlZENsYXNzLCBkZXRhaWxzKSA9PiB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgV29ya2JveEVycm9yKCdub3QtYXJyYXktb2YtY2xhc3MnLCBkZXRhaWxzKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBmaW5hbEFzc2VydEV4cG9ydHMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nID8gbnVsbCA6IHtcbiAgICBoYXNNZXRob2QsXG4gICAgaXNBcnJheSxcbiAgICBpc0luc3RhbmNlLFxuICAgIGlzT25lT2YsXG4gICAgaXNUeXBlLFxuICAgIGlzQXJyYXlPZkNsYXNzLFxufTtcbmV4cG9ydCB7IGZpbmFsQXNzZXJ0RXhwb3J0cyBhcyBhc3NlcnQgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuY29uc3QgX2NhY2hlTmFtZURldGFpbHMgPSB7XG4gICAgZ29vZ2xlQW5hbHl0aWNzOiAnZ29vZ2xlQW5hbHl0aWNzJyxcbiAgICBwcmVjYWNoZTogJ3ByZWNhY2hlLXYyJyxcbiAgICBwcmVmaXg6ICd3b3JrYm94JyxcbiAgICBydW50aW1lOiAncnVudGltZScsXG4gICAgc3VmZml4OiB0eXBlb2YgcmVnaXN0cmF0aW9uICE9PSAndW5kZWZpbmVkJyA/IHJlZ2lzdHJhdGlvbi5zY29wZSA6ICcnLFxufTtcbmNvbnN0IF9jcmVhdGVDYWNoZU5hbWUgPSAoY2FjaGVOYW1lKSA9PiB7XG4gICAgcmV0dXJuIFtfY2FjaGVOYW1lRGV0YWlscy5wcmVmaXgsIGNhY2hlTmFtZSwgX2NhY2hlTmFtZURldGFpbHMuc3VmZml4XVxuICAgICAgICAuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUgJiYgdmFsdWUubGVuZ3RoID4gMClcbiAgICAgICAgLmpvaW4oJy0nKTtcbn07XG5jb25zdCBlYWNoQ2FjaGVOYW1lRGV0YWlsID0gKGZuKSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoX2NhY2hlTmFtZURldGFpbHMpKSB7XG4gICAgICAgIGZuKGtleSk7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBjYWNoZU5hbWVzID0ge1xuICAgIHVwZGF0ZURldGFpbHM6IChkZXRhaWxzKSA9PiB7XG4gICAgICAgIGVhY2hDYWNoZU5hbWVEZXRhaWwoKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXRhaWxzW2tleV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgX2NhY2hlTmFtZURldGFpbHNba2V5XSA9IGRldGFpbHNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRHb29nbGVBbmFseXRpY3NOYW1lOiAodXNlckNhY2hlTmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gdXNlckNhY2hlTmFtZSB8fCBfY3JlYXRlQ2FjaGVOYW1lKF9jYWNoZU5hbWVEZXRhaWxzLmdvb2dsZUFuYWx5dGljcyk7XG4gICAgfSxcbiAgICBnZXRQcmVjYWNoZU5hbWU6ICh1c2VyQ2FjaGVOYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiB1c2VyQ2FjaGVOYW1lIHx8IF9jcmVhdGVDYWNoZU5hbWUoX2NhY2hlTmFtZURldGFpbHMucHJlY2FjaGUpO1xuICAgIH0sXG4gICAgZ2V0UHJlZml4OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBfY2FjaGVOYW1lRGV0YWlscy5wcmVmaXg7XG4gICAgfSxcbiAgICBnZXRSdW50aW1lTmFtZTogKHVzZXJDYWNoZU5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHVzZXJDYWNoZU5hbWUgfHwgX2NyZWF0ZUNhY2hlTmFtZShfY2FjaGVOYW1lRGV0YWlscy5ydW50aW1lKTtcbiAgICB9LFxuICAgIGdldFN1ZmZpeDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gX2NhY2hlTmFtZURldGFpbHMuc3VmZml4O1xuICAgIH0sXG59O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuY29uc3QgbG9nZ2VyID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyBudWxsIDogKCgpID0+IHtcbiAgICAvLyBEb24ndCBvdmVyd3JpdGUgdGhpcyB2YWx1ZSBpZiBpdCdzIGFscmVhZHkgc2V0LlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL3dvcmtib3gvcHVsbC8yMjg0I2lzc3VlY29tbWVudC01NjA0NzA5MjNcbiAgICBpZiAoISgnX19XQl9ESVNBQkxFX0RFVl9MT0dTJyBpbiBzZWxmKSkge1xuICAgICAgICBzZWxmLl9fV0JfRElTQUJMRV9ERVZfTE9HUyA9IGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaW5Hcm91cCA9IGZhbHNlO1xuICAgIGNvbnN0IG1ldGhvZFRvQ29sb3JNYXAgPSB7XG4gICAgICAgIGRlYnVnOiBgIzdmOGM4ZGAsXG4gICAgICAgIGxvZzogYCMyZWNjNzFgLFxuICAgICAgICB3YXJuOiBgI2YzOWMxMmAsXG4gICAgICAgIGVycm9yOiBgI2MwMzkyYmAsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBgIzM0OThkYmAsXG4gICAgICAgIGdyb3VwRW5kOiBudWxsLFxuICAgIH07XG4gICAgY29uc3QgcHJpbnQgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmdzKSB7XG4gICAgICAgIGlmIChzZWxmLl9fV0JfRElTQUJMRV9ERVZfTE9HUykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgPT09ICdncm91cENvbGxhcHNlZCcpIHtcbiAgICAgICAgICAgIC8vIFNhZmFyaSBkb2Vzbid0IHByaW50IGFsbCBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKCkgYXJndW1lbnRzOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4Mjc1NFxuICAgICAgICAgICAgaWYgKC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlW21ldGhvZF0oLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IFtcbiAgICAgICAgICAgIGBiYWNrZ3JvdW5kOiAke21ldGhvZFRvQ29sb3JNYXBbbWV0aG9kXX1gLFxuICAgICAgICAgICAgYGJvcmRlci1yYWRpdXM6IDAuNWVtYCxcbiAgICAgICAgICAgIGBjb2xvcjogd2hpdGVgLFxuICAgICAgICAgICAgYGZvbnQtd2VpZ2h0OiBib2xkYCxcbiAgICAgICAgICAgIGBwYWRkaW5nOiAycHggMC41ZW1gLFxuICAgICAgICBdO1xuICAgICAgICAvLyBXaGVuIGluIGEgZ3JvdXAsIHRoZSB3b3JrYm94IHByZWZpeCBpcyBub3QgZGlzcGxheWVkLlxuICAgICAgICBjb25zdCBsb2dQcmVmaXggPSBpbkdyb3VwID8gW10gOiBbJyVjd29ya2JveCcsIHN0eWxlcy5qb2luKCc7JyldO1xuICAgICAgICBjb25zb2xlW21ldGhvZF0oLi4ubG9nUHJlZml4LCAuLi5hcmdzKTtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ2dyb3VwQ29sbGFwc2VkJykge1xuICAgICAgICAgICAgaW5Hcm91cCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ2dyb3VwRW5kJykge1xuICAgICAgICAgICAgaW5Hcm91cCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhcGkgPSB7fTtcbiAgICBjb25zdCBsb2dnZXJNZXRob2RzID0gT2JqZWN0LmtleXMobWV0aG9kVG9Db2xvck1hcCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgbG9nZ2VyTWV0aG9kcykge1xuICAgICAgICBjb25zdCBtZXRob2QgPSBrZXk7XG4gICAgICAgIGFwaVttZXRob2RdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHByaW50KG1ldGhvZCwgYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBhcGk7XG59KSgpKTtcbmV4cG9ydCB7IGxvZ2dlciB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBBIHV0aWxpdHkgbWV0aG9kIHRoYXQgbWFrZXMgaXQgZWFzaWVyIHRvIHVzZSBgZXZlbnQud2FpdFVudGlsYCB3aXRoXG4gKiBhc3luYyBmdW5jdGlvbnMgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSB7RXh0ZW5kYWJsZUV2ZW50fSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXN5bmNGblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB3YWl0VW50aWwoZXZlbnQsIGFzeW5jRm4pIHtcbiAgICBjb25zdCByZXR1cm5Qcm9taXNlID0gYXN5bmNGbigpO1xuICAgIGV2ZW50LndhaXRVbnRpbChyZXR1cm5Qcm9taXNlKTtcbiAgICByZXR1cm4gcmV0dXJuUHJvbWlzZTtcbn1cbmV4cG9ydCB7IHdhaXRVbnRpbCB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBAdHMtaWdub3JlXG50cnkge1xuICAgIHNlbGZbJ3dvcmtib3g6cHJlY2FjaGluZzo2LjAuMiddICYmIF8oKTtcbn1cbmNhdGNoIChlKSB7IH1cbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IFdvcmtib3hFcnJvciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9Xb3JrYm94RXJyb3IuanMnO1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vLyBOYW1lIG9mIHRoZSBzZWFyY2ggcGFyYW1ldGVyIHVzZWQgdG8gc3RvcmUgcmV2aXNpb24gaW5mby5cbmNvbnN0IFJFVklTSU9OX1NFQVJDSF9QQVJBTSA9ICdfX1dCX1JFVklTSU9OX18nO1xuLyoqXG4gKiBDb252ZXJ0cyBhIG1hbmlmZXN0IGVudHJ5IGludG8gYSB2ZXJzaW9uZWQgVVJMIHN1aXRhYmxlIGZvciBwcmVjYWNoaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gZW50cnlcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBVUkwgd2l0aCB2ZXJzaW9uaW5nIGluZm8uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDYWNoZUtleShlbnRyeSkge1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignYWRkLXRvLWNhY2hlLWxpc3QtdW5leHBlY3RlZC10eXBlJywgeyBlbnRyeSB9KTtcbiAgICB9XG4gICAgLy8gSWYgYSBwcmVjYWNoZSBtYW5pZmVzdCBlbnRyeSBpcyBhIHN0cmluZywgaXQncyBhc3N1bWVkIHRvIGJlIGEgdmVyc2lvbmVkXG4gICAgLy8gVVJMLCBsaWtlICcvYXBwLmFiY2QxMjM0LmpzJy4gUmV0dXJuIGFzLWlzLlxuICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwoZW50cnksIGxvY2F0aW9uLmhyZWYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FjaGVLZXk6IHVybE9iamVjdC5ocmVmLFxuICAgICAgICAgICAgdXJsOiB1cmxPYmplY3QuaHJlZixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgeyByZXZpc2lvbiwgdXJsIH0gPSBlbnRyeTtcbiAgICBpZiAoIXVybCkge1xuICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdhZGQtdG8tY2FjaGUtbGlzdC11bmV4cGVjdGVkLXR5cGUnLCB7IGVudHJ5IH0pO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIGp1c3QgYSBVUkwgYW5kIG5vIHJldmlzaW9uLCB0aGVuIGl0J3MgYWxzbyBhc3N1bWVkIHRvIGJlIGFcbiAgICAvLyB2ZXJzaW9uZWQgVVJMLlxuICAgIGlmICghcmV2aXNpb24pIHtcbiAgICAgICAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLmhyZWYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FjaGVLZXk6IHVybE9iamVjdC5ocmVmLFxuICAgICAgICAgICAgdXJsOiB1cmxPYmplY3QuaHJlZixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCBjb25zdHJ1Y3QgYSBwcm9wZXJseSB2ZXJzaW9uZWQgVVJMIHVzaW5nIHRoZSBjdXN0b20gV29ya2JveFxuICAgIC8vIHNlYXJjaCBwYXJhbWV0ZXIgYWxvbmcgd2l0aCB0aGUgcmV2aXNpb24gaW5mby5cbiAgICBjb25zdCBjYWNoZUtleVVSTCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5ocmVmKTtcbiAgICBjb25zdCBvcmlnaW5hbFVSTCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5ocmVmKTtcbiAgICBjYWNoZUtleVVSTC5zZWFyY2hQYXJhbXMuc2V0KFJFVklTSU9OX1NFQVJDSF9QQVJBTSwgcmV2aXNpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNhY2hlS2V5OiBjYWNoZUtleVVSTC5ocmVmLFxuICAgICAgICB1cmw6IG9yaWdpbmFsVVJMLmhyZWYsXG4gICAgfTtcbn1cbiIsIi8qXG4gIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBBIHBsdWdpbiwgZGVzaWduZWQgdG8gYmUgdXNlZCB3aXRoIFByZWNhY2hlQ29udHJvbGxlciwgdG8gZGV0ZXJtaW5lIHRoZVxuICogb2YgYXNzZXRzIHRoYXQgd2VyZSB1cGRhdGVkIChvciBub3QgdXBkYXRlZCkgZHVyaW5nIHRoZSBpbnN0YWxsIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFByZWNhY2hlSW5zdGFsbFJlcG9ydFBsdWdpbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlZFVSTHMgPSBbXTtcbiAgICAgICAgdGhpcy5ub3RVcGRhdGVkVVJMcyA9IFtdO1xuICAgICAgICB0aGlzLmhhbmRsZXJXaWxsU3RhcnQgPSBhc3luYyAoeyByZXF1ZXN0LCBzdGF0ZSwgfSkgPT4ge1xuICAgICAgICAgICAgLy8gVE9ETzogYHN0YXRlYCBzaG91bGQgbmV2ZXIgYmUgdW5kZWZpbmVkLi4uXG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcmlnaW5hbFJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNhY2hlZFJlc3BvbnNlV2lsbEJlVXNlZCA9IGFzeW5jICh7IGV2ZW50LCBzdGF0ZSwgY2FjaGVkUmVzcG9uc2UsIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAnaW5zdGFsbCcpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBgc3RhdGVgIHNob3VsZCBuZXZlciBiZSB1bmRlZmluZWQuLi5cbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBzdGF0ZS5vcmlnaW5hbFJlcXVlc3QudXJsO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdFVwZGF0ZWRVUkxzLnB1c2godXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlZFVSTHMucHVzaCh1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXNwb25zZTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgeyBQcmVjYWNoZUluc3RhbGxSZXBvcnRQbHVnaW4gfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBBIHBsdWdpbiwgZGVzaWduZWQgdG8gYmUgdXNlZCB3aXRoIFByZWNhY2hlQ29udHJvbGxlciwgdG8gdHJhbnNsYXRlIFVSTHMgaW50b1xuICogdGhlIGNvcnJlc3BvbmRpbmcgY2FjaGUga2V5LCBiYXNlZCBvbiB0aGUgY3VycmVudCByZXZpc2lvbiBpbmZvLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFByZWNhY2hlQ2FjaGVLZXlQbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKHsgcHJlY2FjaGVDb250cm9sbGVyIH0pIHtcbiAgICAgICAgdGhpcy5jYWNoZUtleVdpbGxCZVVzZWQgPSBhc3luYyAoeyByZXF1ZXN0LCBwYXJhbXMsIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gcGFyYW1zICYmIHBhcmFtcy5jYWNoZUtleSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZWNhY2hlQ29udHJvbGxlci5nZXRDYWNoZUtleUZvclVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVLZXkgPyBuZXcgUmVxdWVzdChjYWNoZUtleSkgOiByZXF1ZXN0O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcmVjYWNoZUNvbnRyb2xsZXIgPSBwcmVjYWNoZUNvbnRyb2xsZXI7XG4gICAgfVxufVxuZXhwb3J0IHsgUHJlY2FjaGVDYWNoZUtleVBsdWdpbiB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGdyb3VwVGl0bGVcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZGVsZXRlZFVSTHNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBsb2dHcm91cCA9IChncm91cFRpdGxlLCBkZWxldGVkVVJMcykgPT4ge1xuICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChncm91cFRpdGxlKTtcbiAgICBmb3IgKGNvbnN0IHVybCBvZiBkZWxldGVkVVJMcykge1xuICAgICAgICBsb2dnZXIubG9nKHVybCk7XG4gICAgfVxuICAgIGxvZ2dlci5ncm91cEVuZCgpO1xufTtcbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBkZWxldGVkVVJMc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRDbGVhbnVwRGV0YWlscyhkZWxldGVkVVJMcykge1xuICAgIGNvbnN0IGRlbGV0aW9uQ291bnQgPSBkZWxldGVkVVJMcy5sZW5ndGg7XG4gICAgaWYgKGRlbGV0aW9uQ291bnQgPiAwKSB7XG4gICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgRHVyaW5nIHByZWNhY2hpbmcgY2xlYW51cCwgYCArXG4gICAgICAgICAgICBgJHtkZWxldGlvbkNvdW50fSBjYWNoZWQgYCArXG4gICAgICAgICAgICBgcmVxdWVzdCR7ZGVsZXRpb25Db3VudCA9PT0gMSA/ICcgd2FzJyA6ICdzIHdlcmUnfSBkZWxldGVkLmApO1xuICAgICAgICBsb2dHcm91cCgnRGVsZXRlZCBDYWNoZSBSZXF1ZXN0cycsIGRlbGV0ZWRVUkxzKTtcbiAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgfVxufVxuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGdyb3VwVGl0bGVcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdXJsc1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9uZXN0ZWRHcm91cChncm91cFRpdGxlLCB1cmxzKSB7XG4gICAgaWYgKHVybHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGdyb3VwVGl0bGUpO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIHVybHMpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyh1cmwpO1xuICAgIH1cbiAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB1cmxzVG9QcmVjYWNoZVxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB1cmxzQWxyZWFkeVByZWNhY2hlZFxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRJbnN0YWxsRGV0YWlscyh1cmxzVG9QcmVjYWNoZSwgdXJsc0FscmVhZHlQcmVjYWNoZWQpIHtcbiAgICBjb25zdCBwcmVjYWNoZWRDb3VudCA9IHVybHNUb1ByZWNhY2hlLmxlbmd0aDtcbiAgICBjb25zdCBhbHJlYWR5UHJlY2FjaGVkQ291bnQgPSB1cmxzQWxyZWFkeVByZWNhY2hlZC5sZW5ndGg7XG4gICAgaWYgKHByZWNhY2hlZENvdW50IHx8IGFscmVhZHlQcmVjYWNoZWRDb3VudCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IGBQcmVjYWNoaW5nICR7cHJlY2FjaGVkQ291bnR9IGZpbGUke3ByZWNhY2hlZENvdW50ID09PSAxID8gJycgOiAncyd9LmA7XG4gICAgICAgIGlmIChhbHJlYWR5UHJlY2FjaGVkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IGAgJHthbHJlYWR5UHJlY2FjaGVkQ291bnR9IGAgK1xuICAgICAgICAgICAgICAgIGBmaWxlJHthbHJlYWR5UHJlY2FjaGVkQ291bnQgPT09IDEgPyAnIGlzJyA6ICdzIGFyZSd9IGFscmVhZHkgY2FjaGVkLmA7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKG1lc3NhZ2UpO1xuICAgICAgICBfbmVzdGVkR3JvdXAoYFZpZXcgbmV3bHkgcHJlY2FjaGVkIFVSTHMuYCwgdXJsc1RvUHJlY2FjaGUpO1xuICAgICAgICBfbmVzdGVkR3JvdXAoYFZpZXcgcHJldmlvdXNseSBwcmVjYWNoZWQgVVJMcy5gLCB1cmxzQWxyZWFkeVByZWNhY2hlZCk7XG4gICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgIH1cbn1cbiIsIi8qXG4gIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xubGV0IHN1cHBvcnRTdGF0dXM7XG4vKipcbiAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzXG4gKiBjb25zdHJ1Y3RpbmcgYSBuZXcgYFJlc3BvbnNlYCBmcm9tIGEgYHJlc3BvbnNlLmJvZHlgIHN0cmVhbS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAsIGlmIHRoZSBjdXJyZW50IGJyb3dzZXIgY2FuIHN1Y2Nlc3NmdWxseVxuICogICAgIGNvbnN0cnVjdCBhIGBSZXNwb25zZWAgZnJvbSBhIGByZXNwb25zZS5ib2R5YCBzdHJlYW0sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbkNvbnN0cnVjdFJlc3BvbnNlRnJvbUJvZHlTdHJlYW0oKSB7XG4gICAgaWYgKHN1cHBvcnRTdGF0dXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0ZXN0UmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoJycpO1xuICAgICAgICBpZiAoJ2JvZHknIGluIHRlc3RSZXNwb25zZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXcgUmVzcG9uc2UodGVzdFJlc3BvbnNlLmJvZHkpO1xuICAgICAgICAgICAgICAgIHN1cHBvcnRTdGF0dXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cHBvcnRTdGF0dXMgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRTdGF0dXM7XG59XG5leHBvcnQgeyBjYW5Db25zdHJ1Y3RSZXNwb25zZUZyb21Cb2R5U3RyZWFtIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBjYW5Db25zdHJ1Y3RSZXNwb25zZUZyb21Cb2R5U3RyZWFtIH0gZnJvbSAnLi9fcHJpdmF0ZS9jYW5Db25zdHJ1Y3RSZXNwb25zZUZyb21Cb2R5U3RyZWFtLmpzJztcbmltcG9ydCB7IFdvcmtib3hFcnJvciB9IGZyb20gJy4vX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEFsbG93cyBkZXZlbG9wZXJzIHRvIGNvcHkgYSByZXNwb25zZSBhbmQgbW9kaWZ5IGl0cyBgaGVhZGVyc2AsIGBzdGF0dXNgLFxuICogb3IgYHN0YXR1c1RleHRgIHZhbHVlcyAodGhlIHZhbHVlcyBzZXR0YWJsZSB2aWEgYVxuICogW2BSZXNwb25zZUluaXRgXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUmVzcG9uc2UvUmVzcG9uc2UjU3ludGF4fVxuICogb2JqZWN0IGluIHRoZSBjb25zdHJ1Y3RvcikuXG4gKiBUbyBtb2RpZnkgdGhlc2UgdmFsdWVzLCBwYXNzIGEgZnVuY3Rpb24gYXMgdGhlIHNlY29uZCBhcmd1bWVudC4gVGhhdFxuICogZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIHdpdGggYSBzaW5nbGUgb2JqZWN0IHdpdGggdGhlIHJlc3BvbnNlIHByb3BlcnRpZXNcbiAqIGB7aGVhZGVycywgc3RhdHVzLCBzdGF0dXNUZXh0fWAuIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbiB3aWxsXG4gKiBiZSB1c2VkIGFzIHRoZSBgUmVzcG9uc2VJbml0YCBmb3IgdGhlIG5ldyBgUmVzcG9uc2VgLiBUbyBjaGFuZ2UgdGhlIHZhbHVlc1xuICogZWl0aGVyIG1vZGlmeSB0aGUgcGFzc2VkIHBhcmFtZXRlcihzKSBhbmQgcmV0dXJuIGl0LCBvciByZXR1cm4gYSB0b3RhbGx5XG4gKiBuZXcgb2JqZWN0LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGludGVudGlvbmFsbHkgbGltaXRlZCB0byBzYW1lLW9yaWdpbiByZXNwb25zZXMsIHJlZ2FyZGxlc3Mgb2ZcbiAqIHdoZXRoZXIgQ09SUyB3YXMgdXNlZCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtY29yZVxuICovXG5hc3luYyBmdW5jdGlvbiBjb3B5UmVzcG9uc2UocmVzcG9uc2UsIG1vZGlmaWVyKSB7XG4gICAgbGV0IG9yaWdpbiA9IG51bGw7XG4gICAgLy8gSWYgcmVzcG9uc2UudXJsIGlzbid0IHNldCwgYXNzdW1lIGl0J3MgY3Jvc3Mtb3JpZ2luIGFuZCBrZWVwIG9yaWdpbiBudWxsLlxuICAgIGlmIChyZXNwb25zZS51cmwpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VVUkwgPSBuZXcgVVJMKHJlc3BvbnNlLnVybCk7XG4gICAgICAgIG9yaWdpbiA9IHJlc3BvbnNlVVJMLm9yaWdpbjtcbiAgICB9XG4gICAgaWYgKG9yaWdpbiAhPT0gc2VsZi5sb2NhdGlvbi5vcmlnaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignY3Jvc3Mtb3JpZ2luLWNvcHktcmVzcG9uc2UnLCB7IG9yaWdpbiB9KTtcbiAgICB9XG4gICAgY29uc3QgY2xvbmVkUmVzcG9uc2UgPSByZXNwb25zZS5jbG9uZSgpO1xuICAgIC8vIENyZWF0ZSBhIGZyZXNoIGBSZXNwb25zZUluaXRgIG9iamVjdCBieSBjbG9uaW5nIHRoZSBoZWFkZXJzLlxuICAgIGNvbnN0IHJlc3BvbnNlSW5pdCA9IHtcbiAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoY2xvbmVkUmVzcG9uc2UuaGVhZGVycyksXG4gICAgICAgIHN0YXR1czogY2xvbmVkUmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiBjbG9uZWRSZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgIH07XG4gICAgLy8gQXBwbHkgYW55IHVzZXIgbW9kaWZpY2F0aW9ucy5cbiAgICBjb25zdCBtb2RpZmllZFJlc3BvbnNlSW5pdCA9IG1vZGlmaWVyID8gbW9kaWZpZXIocmVzcG9uc2VJbml0KSA6IHJlc3BvbnNlSW5pdDtcbiAgICAvLyBDcmVhdGUgdGhlIG5ldyByZXNwb25zZSBmcm9tIHRoZSBib2R5IHN0cmVhbSBhbmQgYFJlc3BvbnNlSW5pdGBcbiAgICAvLyBtb2RpZmljYXRpb25zLiBOb3RlOiBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdGhlIFJlc3BvbnNlLmJvZHkgc3RyZWFtLFxuICAgIC8vIHNvIGZhbGwgYmFjayB0byByZWFkaW5nIHRoZSBlbnRpcmUgYm9keSBpbnRvIG1lbW9yeSBhcyBhIGJsb2IuXG4gICAgY29uc3QgYm9keSA9IGNhbkNvbnN0cnVjdFJlc3BvbnNlRnJvbUJvZHlTdHJlYW0oKSA/XG4gICAgICAgIGNsb25lZFJlc3BvbnNlLmJvZHkgOiBhd2FpdCBjbG9uZWRSZXNwb25zZS5ibG9iKCk7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShib2R5LCBtb2RpZmllZFJlc3BvbnNlSW5pdCk7XG59XG5leHBvcnQgeyBjb3B5UmVzcG9uc2UgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuY29uc3QgZ2V0RnJpZW5kbHlVUkwgPSAodXJsKSA9PiB7XG4gICAgY29uc3QgdXJsT2JqID0gbmV3IFVSTChTdHJpbmcodXJsKSwgbG9jYXRpb24uaHJlZik7XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvd29ya2JveC9pc3N1ZXMvMjMyM1xuICAgIC8vIFdlIHdhbnQgdG8gaW5jbHVkZSBldmVyeXRoaW5nLCBleGNlcHQgZm9yIHRoZSBvcmlnaW4gaWYgaXQncyBzYW1lLW9yaWdpbi5cbiAgICByZXR1cm4gdXJsT2JqLmhyZWYucmVwbGFjZShuZXcgUmVnRXhwKGBeJHtsb2NhdGlvbi5vcmlnaW59YCksICcnKTtcbn07XG5leHBvcnQgeyBnZXRGcmllbmRseVVSTCB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuZnVuY3Rpb24gc3RyaXBQYXJhbXMoZnVsbFVSTCwgaWdub3JlUGFyYW1zKSB7XG4gICAgY29uc3Qgc3RyaXBwZWRVUkwgPSBuZXcgVVJMKGZ1bGxVUkwpO1xuICAgIGZvciAoY29uc3QgcGFyYW0gb2YgaWdub3JlUGFyYW1zKSB7XG4gICAgICAgIHN0cmlwcGVkVVJMLnNlYXJjaFBhcmFtcy5kZWxldGUocGFyYW0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaXBwZWRVUkwuaHJlZjtcbn1cbi8qKlxuICogTWF0Y2hlcyBhbiBpdGVtIGluIHRoZSBjYWNoZSwgaWdub3Jpbmcgc3BlY2lmaWMgVVJMIHBhcmFtcy4gVGhpcyBpcyBzaW1pbGFyXG4gKiB0byB0aGUgYGlnbm9yZVNlYXJjaGAgb3B0aW9uLCBidXQgaXQgYWxsb3dzIHlvdSB0byBpZ25vcmUganVzdCBzcGVjaWZpY1xuICogcGFyYW1zICh3aGlsZSBjb250aW51aW5nIHRvIG1hdGNoIG9uIHRoZSBvdGhlcnMpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0NhY2hlfSBjYWNoZVxuICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gbWF0Y2hPcHRpb25zXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGlnbm9yZVBhcmFtc1xuICogQHJldHVybiB7UHJvbWlzZTxSZXNwb25zZXx1bmRlZmluZWQ+fVxuICovXG5hc3luYyBmdW5jdGlvbiBjYWNoZU1hdGNoSWdub3JlUGFyYW1zKGNhY2hlLCByZXF1ZXN0LCBpZ25vcmVQYXJhbXMsIG1hdGNoT3B0aW9ucykge1xuICAgIGNvbnN0IHN0cmlwcGVkUmVxdWVzdFVSTCA9IHN0cmlwUGFyYW1zKHJlcXVlc3QudXJsLCBpZ25vcmVQYXJhbXMpO1xuICAgIC8vIElmIHRoZSByZXF1ZXN0IGRvZXNuJ3QgaW5jbHVkZSBhbnkgaWdub3JlZCBwYXJhbXMsIG1hdGNoIGFzIG5vcm1hbC5cbiAgICBpZiAocmVxdWVzdC51cmwgPT09IHN0cmlwcGVkUmVxdWVzdFVSTCkge1xuICAgICAgICByZXR1cm4gY2FjaGUubWF0Y2gocmVxdWVzdCwgbWF0Y2hPcHRpb25zKTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCBtYXRjaCBieSBjb21wYXJpbmcga2V5c1xuICAgIGNvbnN0IGtleXNPcHRpb25zID0geyAuLi5tYXRjaE9wdGlvbnMsIGlnbm9yZVNlYXJjaDogdHJ1ZSB9O1xuICAgIGNvbnN0IGNhY2hlS2V5cyA9IGF3YWl0IGNhY2hlLmtleXMocmVxdWVzdCwga2V5c09wdGlvbnMpO1xuICAgIGZvciAoY29uc3QgY2FjaGVLZXkgb2YgY2FjaGVLZXlzKSB7XG4gICAgICAgIGNvbnN0IHN0cmlwcGVkQ2FjaGVLZXlVUkwgPSBzdHJpcFBhcmFtcyhjYWNoZUtleS51cmwsIGlnbm9yZVBhcmFtcyk7XG4gICAgICAgIGlmIChzdHJpcHBlZFJlcXVlc3RVUkwgPT09IHN0cmlwcGVkQ2FjaGVLZXlVUkwpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5tYXRjaChjYWNoZUtleSwgbWF0Y2hPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG59XG5leHBvcnQgeyBjYWNoZU1hdGNoSWdub3JlUGFyYW1zIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogVGhlIERlZmVycmVkIGNsYXNzIGNvbXBvc2VzIFByb21pc2VzIGluIGEgd2F5IHRoYXQgYWxsb3dzIGZvciB0aGVtIHRvIGJlXG4gKiByZXNvbHZlZCBvciByZWplY3RlZCBmcm9tIG91dHNpZGUgdGhlIGNvbnN0cnVjdG9yLiBJbiBtb3N0IGNhc2VzIHByb21pc2VzXG4gKiBzaG91bGQgYmUgdXNlZCBkaXJlY3RseSwgYnV0IERlZmVycmVkcyBjYW4gYmUgbmVjZXNzYXJ5IHdoZW4gdGhlIGxvZ2ljIHRvXG4gKiByZXNvbHZlIGEgcHJvbWlzZSBtdXN0IGJlIHNlcGFyYXRlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIERlZmVycmVkIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcHJvbWlzZSBhbmQgZXhwb3NlcyBpdHMgcmVzb2x2ZSBhbmQgcmVqZWN0IGZ1bmN0aW9ucyBhcyBtZXRob2RzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCB7IERlZmVycmVkIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8vIENhbGxiYWNrcyB0byBiZSBleGVjdXRlZCB3aGVuZXZlciB0aGVyZSdzIGEgcXVvdGEgZXJyb3IuXG5jb25zdCBxdW90YUVycm9yQ2FsbGJhY2tzID0gbmV3IFNldCgpO1xuZXhwb3J0IHsgcXVvdGFFcnJvckNhbGxiYWNrcyB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IHF1b3RhRXJyb3JDYWxsYmFja3MgfSBmcm9tICcuLi9tb2RlbHMvcXVvdGFFcnJvckNhbGxiYWNrcy5qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogUnVucyBhbGwgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucywgb25lIGF0IGEgdGltZSBzZXF1ZW50aWFsbHksIGluIHRoZSBvcmRlclxuICogaW4gd2hpY2ggdGhleSB3ZXJlIHJlZ2lzdGVyZWQuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LWNvcmVcbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVRdW90YUVycm9yQ2FsbGJhY2tzKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGxvZ2dlci5sb2coYEFib3V0IHRvIHJ1biAke3F1b3RhRXJyb3JDYWxsYmFja3Muc2l6ZX0gYCArXG4gICAgICAgICAgICBgY2FsbGJhY2tzIHRvIGNsZWFuIHVwIGNhY2hlcy5gKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBxdW90YUVycm9yQ2FsbGJhY2tzKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrKCk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGNhbGxiYWNrLCAnaXMgY29tcGxldGUuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnRmluaXNoZWQgcnVubmluZyBjYWxsYmFja3MuJyk7XG4gICAgfVxufVxuZXhwb3J0IHsgZXhlY3V0ZVF1b3RhRXJyb3JDYWxsYmFja3MgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhbmQgdGhlIHBhc3NlZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICogVGhpcyB1dGlsaXR5IGlzIGFuIGFzeW5jL2F3YWl0LWZyaWVuZGx5IHZlcnNpb24gb2YgYHNldFRpbWVvdXRgLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBtc1xuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aW1lb3V0KG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIEB0cy1pZ25vcmVcbnRyeSB7XG4gICAgc2VsZlsnd29ya2JveDpzdHJhdGVnaWVzOjYuMC4yJ10gJiYgXygpO1xufVxuY2F0Y2ggKGUpIHsgfVxuIiwiLypcbiAgQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBjYWNoZU1hdGNoSWdub3JlUGFyYW1zIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2NhY2hlTWF0Y2hJZ25vcmVQYXJhbXMuanMnO1xuaW1wb3J0IHsgRGVmZXJyZWQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvRGVmZXJyZWQuanMnO1xuaW1wb3J0IHsgZXhlY3V0ZVF1b3RhRXJyb3JDYWxsYmFja3MgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZXhlY3V0ZVF1b3RhRXJyb3JDYWxsYmFja3MuanMnO1xuaW1wb3J0IHsgZ2V0RnJpZW5kbHlVUkwgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwuanMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5qcyc7XG5pbXBvcnQgeyB0aW1lb3V0IH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL3RpbWVvdXQuanMnO1xuaW1wb3J0IHsgV29ya2JveEVycm9yIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuZnVuY3Rpb24gdG9SZXF1ZXN0KGlucHV0KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSA/IG5ldyBSZXF1ZXN0KGlucHV0KSA6IGlucHV0O1xufVxuLyoqXG4gKiBBIGNsYXNzIGNyZWF0ZWQgZXZlcnkgdGltZSBhIFN0cmF0ZWd5IGluc3RhbmNlIGluc3RhbmNlIGNhbGxzXG4gKiBbaGFuZGxlKClde0BsaW5rIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3l+aGFuZGxlfSBvclxuICogW2hhbmRsZUFsbCgpXXtAbGluayBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5fmhhbmRsZUFsbH0gdGhhdCB3cmFwcyBhbGwgZmV0Y2ggYW5kXG4gKiBjYWNoZSBhY3Rpb25zIGFyb3VuZCBwbHVnaW4gY2FsbGJhY2tzIGFuZCBrZWVwcyB0cmFjayBvZiB3aGVuIHRoZSBzdHJhdGVneVxuICogaXMgXCJkb25lXCIgKGkuZS4gYWxsIGFkZGVkIGBldmVudC53YWl0VW50aWwoKWAgcHJvbWlzZXMgaGF2ZSByZXNvbHZlZCkuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXNcbiAqL1xuY2xhc3MgU3RyYXRlZ3lIYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcGFzc2VkIHN0cmF0ZWd5IGFuZCBldmVudFxuICAgICAqIHRoYXQncyBoYW5kbGluZyB0aGUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBhbHNvIGluaXRpYWxpemVzIHRoZSBzdGF0ZSB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIGVhY2ggb2ZcbiAgICAgKiB0aGUgcGx1Z2lucyBoYW5kbGluZyB0aGlzIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3l9IHN0cmF0ZWd5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R8c3RyaW5nfSBvcHRpb25zLnJlcXVlc3QgQSByZXF1ZXN0IHRvIHJ1biB0aGlzIHN0cmF0ZWd5IGZvci5cbiAgICAgKiBAcGFyYW0ge0V4dGVuZGFibGVFdmVudH0gb3B0aW9ucy5ldmVudCBUaGUgZXZlbnQgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgICAqICAgICByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7VVJMfSBbb3B0aW9ucy51cmxdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5wYXJhbXNdXG4gICAgICogICAgIFttYXRjaCBjYWxsYmFja117QGxpbmsgbW9kdWxlOndvcmtib3gtcm91dGluZ35tYXRjaENhbGxiYWNrfSxcbiAgICAgKiAgICAgKGlmIGFwcGxpY2FibGUpLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0cmF0ZWd5LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlS2V5cyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlcXVlc3QgdGhlIHN0cmF0ZWd5IGlzIHBlcmZvcm1pbmcgKHBhc3NlZCB0byB0aGUgc3RyYXRlZ3knc1xuICAgICAgICAgKiBgaGFuZGxlKClgIG9yIGBoYW5kbGVBbGwoKWAgbWV0aG9kKS5cbiAgICAgICAgICogQG5hbWUgcmVxdWVzdFxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUge1JlcXVlc3R9XG4gICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5SGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBldmVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyByZXF1ZXN0LlxuICAgICAgICAgKiBAbmFtZSBldmVudFxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUge0V4dGVuZGFibGVFdmVudH1cbiAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3lIYW5kbGVyXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBgVVJMYCBpbnN0YW5jZSBvZiBgcmVxdWVzdC51cmxgIChpZiBwYXNzZWQgdG8gdGhlIHN0cmF0ZWd5J3NcbiAgICAgICAgICogYGhhbmRsZSgpYCBvciBgaGFuZGxlQWxsKClgIG1ldGhvZCkuXG4gICAgICAgICAqIE5vdGU6IHRoZSBgdXJsYCBwYXJhbSB3aWxsIGJlIHByZXNlbnQgaWYgdGhlIHN0cmF0ZWd5IHdhcyBpbnZva2VkXG4gICAgICAgICAqIGZyb20gYSB3b3JrYm94IGBSb3V0ZWAgb2JqZWN0LlxuICAgICAgICAgKiBAbmFtZSB1cmxcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHtVUkx8dW5kZWZpbmVkfVxuICAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneUhhbmRsZXJcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGBwYXJhbWAgdmFsdWUgKGlmIHBhc3NlZCB0byB0aGUgc3RyYXRlZ3knc1xuICAgICAgICAgKiBgaGFuZGxlKClgIG9yIGBoYW5kbGVBbGwoKWAgbWV0aG9kKS5cbiAgICAgICAgICogTm90ZTogdGhlIGBwYXJhbWAgcGFyYW0gd2lsbCBiZSBwcmVzZW50IGlmIHRoZSBzdHJhdGVneSB3YXMgaW52b2tlZFxuICAgICAgICAgKiBmcm9tIGEgd29ya2JveCBgUm91dGVgIG9iamVjdCBhbmQgdGhlXG4gICAgICAgICAqIFttYXRjaCBjYWxsYmFja117QGxpbmsgbW9kdWxlOndvcmtib3gtcm91dGluZ35tYXRjaENhbGxiYWNrfSByZXR1cm5lZFxuICAgICAgICAgKiBhIHRydXRoeSB2YWx1ZSAoaXQgd2lsbCBiZSB0aGF0IHZhbHVlKS5cbiAgICAgICAgICogQG5hbWUgcGFyYW1zXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7Knx1bmRlZmluZWR9XG4gICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5SGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc0luc3RhbmNlKG9wdGlvbnMuZXZlbnQsIEV4dGVuZGFibGVFdmVudCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXN0cmF0ZWdpZXMnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1N0cmF0ZWd5SGFuZGxlcicsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnb3B0aW9ucy5ldmVudCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmV2ZW50ID0gb3B0aW9ucy5ldmVudDtcbiAgICAgICAgdGhpcy5fc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICAgICAgdGhpcy5faGFuZGxlckRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMuX2V4dGVuZExpZmV0aW1lUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgLy8gQ29weSB0aGUgcGx1Z2lucyBsaXN0IChzaW5jZSBpdCdzIG11dGFibGUgb24gdGhlIHN0cmF0ZWd5KSxcbiAgICAgICAgLy8gc28gYW55IG11dGF0aW9ucyBkb24ndCBhZmZlY3QgdGhpcyBoYW5kbGVyIGluc3RhbmNlLlxuICAgICAgICB0aGlzLl9wbHVnaW5zID0gWy4uLnN0cmF0ZWd5LnBsdWdpbnNdO1xuICAgICAgICB0aGlzLl9wbHVnaW5TdGF0ZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5fcGx1Z2lucykge1xuICAgICAgICAgICAgdGhpcy5fcGx1Z2luU3RhdGVNYXAuc2V0KHBsdWdpbiwge30pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnQud2FpdFVudGlsKHRoaXMuX2hhbmRsZXJEZWZlcnJlZC5wcm9taXNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIGdpdmVuIHJlcXVlc3QgKGFuZCBpbnZva2VzIGFueSBhcHBsaWNhYmxlIHBsdWdpbiBjYWxsYmFja1xuICAgICAqIG1ldGhvZHMpIHVzaW5nIHRoZSBgZmV0Y2hPcHRpb25zYCBhbmQgYHBsdWdpbnNgIGRlZmluZWQgb24gdGhlIHN0cmF0ZWd5XG4gICAgICogb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBwbHVnaW4gbGlmZWN5Y2xlIG1ldGhvZHMgYXJlIGludm9rZWQgd2hlbiB1c2luZyB0aGlzIG1ldGhvZDpcbiAgICAgKiAtIGByZXF1ZXN0V2lsbEZldGNoKClgXG4gICAgICogLSBgZmV0Y2hEaWRTdWNjZWVkKClgXG4gICAgICogLSBgZmV0Y2hEaWRGYWlsKClgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R8c3RyaW5nfSBpbnB1dCBUaGUgVVJMIG9yIHJlcXVlc3QgdG8gZmV0Y2guXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxSZXNwb25zZT59XG4gICAgICovXG4gICAgZmV0Y2goaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2FpdFVudGlsKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGV2ZW50IH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSB0b1JlcXVlc3QoaW5wdXQpO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ25hdmlnYXRlJyAmJlxuICAgICAgICAgICAgICAgIGV2ZW50IGluc3RhbmNlb2YgRmV0Y2hFdmVudCAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LnByZWxvYWRSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlUHJlbG9hZFJlc3BvbnNlID0gYXdhaXQgZXZlbnQucHJlbG9hZFJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZVByZWxvYWRSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgVXNpbmcgYSBwcmVsb2FkZWQgbmF2aWdhdGlvbiByZXNwb25zZSBmb3IgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCcke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0nYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc3NpYmxlUHJlbG9hZFJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgZmV0Y2hEaWRGYWlsIHBsdWdpbiwgd2UgbmVlZCB0byBzYXZlIGEgY2xvbmUgb2YgdGhlXG4gICAgICAgICAgICAvLyBvcmlnaW5hbCByZXF1ZXN0IGJlZm9yZSBpdCdzIGVpdGhlciBtb2RpZmllZCBieSBhIHJlcXVlc3RXaWxsRmV0Y2hcbiAgICAgICAgICAgIC8vIHBsdWdpbiBvciBiZWZvcmUgdGhlIG9yaWdpbmFsIHJlcXVlc3QncyBib2R5IGlzIGNvbnN1bWVkIHZpYSBmZXRjaCgpLlxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxSZXF1ZXN0ID0gdGhpcy5oYXNDYWxsYmFjaygnZmV0Y2hEaWRGYWlsJykgP1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuY2xvbmUoKSA6IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2Igb2YgdGhpcy5pdGVyYXRlQ2FsbGJhY2tzKCdyZXF1ZXN0V2lsbEZldGNoJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IGF3YWl0IGNiKHsgcmVxdWVzdDogcmVxdWVzdC5jbG9uZSgpLCBldmVudCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcigncGx1Z2luLWVycm9yLXJlcXVlc3Qtd2lsbC1mZXRjaCcsIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3duRXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSByZXF1ZXN0IGNhbiBiZSBhbHRlcmVkIGJ5IHBsdWdpbnMgd2l0aCBgcmVxdWVzdFdpbGxGZXRjaGAgbWFraW5nXG4gICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwgcmVxdWVzdCAobW9zdCBsaWtlbHkgZnJvbSBhIGBmZXRjaGAgZXZlbnQpIGRpZmZlcmVudFxuICAgICAgICAgICAgLy8gZnJvbSB0aGUgUmVxdWVzdCB3ZSBtYWtlLiBQYXNzIGJvdGggdG8gYGZldGNoRGlkRmFpbGAgdG8gYWlkIGRlYnVnZ2luZy5cbiAgICAgICAgICAgIGNvbnN0IHBsdWdpbkZpbHRlcmVkUmVxdWVzdCA9IHJlcXVlc3QuY2xvbmUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGZldGNoUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvd29ya2JveC9pc3N1ZXMvMTc5NlxuICAgICAgICAgICAgICAgIGZldGNoUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0LCByZXF1ZXN0Lm1vZGUgPT09ICduYXZpZ2F0ZScgP1xuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgOiB0aGlzLl9zdHJhdGVneS5mZXRjaE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgTmV0d29yayByZXF1ZXN0IGZvciBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAnJHtnZXRGcmllbmRseVVSTChyZXF1ZXN0LnVybCl9JyByZXR1cm5lZCBhIHJlc3BvbnNlIHdpdGggYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgc3RhdHVzICcke2ZldGNoUmVzcG9uc2Uuc3RhdHVzfScuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5pdGVyYXRlQ2FsbGJhY2tzKCdmZXRjaERpZFN1Y2NlZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaFJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBwbHVnaW5GaWx0ZXJlZFJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogZmV0Y2hSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaFJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOZXR3b3JrIHJlcXVlc3QgZm9yIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCcke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0nIHRocmV3IGFuIGVycm9yLmAsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYG9yaWdpbmFsUmVxdWVzdGAgd2lsbCBvbmx5IGV4aXN0IGlmIGEgYGZldGNoRGlkRmFpbGAgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyBpcyBiZWluZyB1c2VkIChzZWUgYWJvdmUpLlxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5ydW5DYWxsYmFja3MoJ2ZldGNoRGlkRmFpbCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFJlcXVlc3Q6IG9yaWdpbmFsUmVxdWVzdC5jbG9uZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogcGx1Z2luRmlsdGVyZWRSZXF1ZXN0LmNsb25lKCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxzIGB0aGlzLmZldGNoKClgIGFuZCAoaW4gdGhlIGJhY2tncm91bmQpIHJ1bnMgYHRoaXMuY2FjaGVQdXQoKWAgb25cbiAgICAgKiB0aGUgcmVzcG9uc2UgZ2VuZXJhdGVkIGJ5IGB0aGlzLmZldGNoKClgLlxuICAgICAqXG4gICAgICogVGhlIGNhbGwgdG8gYHRoaXMuY2FjaGVQdXQoKWAgYXV0b21hdGljYWxseSBpbnZva2VzIGB0aGlzLndhaXRVbnRpbCgpYCxcbiAgICAgKiBzbyB5b3UgZG8gbm90IGhhdmUgdG8gbWFudWFsbHkgY2FsbCBgd2FpdFVudGlsKClgIG9uIHRoZSBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVxdWVzdHxzdHJpbmd9IGlucHV0IFRoZSByZXF1ZXN0IG9yIFVSTCB0byBmZXRjaCBhbmQgY2FjaGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxSZXNwb25zZT59XG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hBbmRDYWNoZVB1dChpbnB1dCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2goaW5wdXQpO1xuICAgICAgICBjb25zdCByZXNwb25zZUNsb25lID0gcmVzcG9uc2UuY2xvbmUoKTtcbiAgICAgICAgdGhpcy53YWl0VW50aWwodGhpcy5jYWNoZVB1dChpbnB1dCwgcmVzcG9uc2VDbG9uZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoZXMgYSByZXF1ZXN0IGZyb20gdGhlIGNhY2hlIChhbmQgaW52b2tlcyBhbnkgYXBwbGljYWJsZSBwbHVnaW5cbiAgICAgKiBjYWxsYmFjayBtZXRob2RzKSB1c2luZyB0aGUgYGNhY2hlTmFtZWAsIGBtYXRjaE9wdGlvbnNgLCBhbmQgYHBsdWdpbnNgXG4gICAgICogZGVmaW5lZCBvbiB0aGUgc3RyYXRlZ3kgb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBwbHVnaW4gbGlmZWN5Y2xlIG1ldGhvZHMgYXJlIGludm9rZWQgd2hlbiB1c2luZyB0aGlzIG1ldGhvZDpcbiAgICAgKiAtIGNhY2hlS2V5V2lsbEJ5VXNlZCgpXG4gICAgICogLSBjYWNoZWRSZXNwb25zZVdpbGxCeVVzZWQoKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fHN0cmluZ30ga2V5IFRoZSBSZXF1ZXN0IG9yIFVSTCB0byB1c2UgYXMgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJlc3BvbnNlfHVuZGVmaW5lZD59IEEgbWF0Y2hpbmcgcmVzcG9uc2UsIGlmIGZvdW5kLlxuICAgICAqL1xuICAgIGNhY2hlTWF0Y2goa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLndhaXRVbnRpbCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRvUmVxdWVzdChrZXkpO1xuICAgICAgICAgICAgbGV0IGNhY2hlZFJlc3BvbnNlO1xuICAgICAgICAgICAgY29uc3QgeyBjYWNoZU5hbWUsIG1hdGNoT3B0aW9ucyB9ID0gdGhpcy5fc3RyYXRlZ3k7XG4gICAgICAgICAgICBjb25zdCBlZmZlY3RpdmVSZXF1ZXN0ID0gYXdhaXQgdGhpcy5nZXRDYWNoZUtleShyZXF1ZXN0LCAncmVhZCcpO1xuICAgICAgICAgICAgY29uc3QgbXVsdGlNYXRjaE9wdGlvbnMgPSB7IC4uLm1hdGNoT3B0aW9ucywgLi4ueyBjYWNoZU5hbWUgfSB9O1xuICAgICAgICAgICAgY2FjaGVkUmVzcG9uc2UgPSBhd2FpdCBjYWNoZXMubWF0Y2goZWZmZWN0aXZlUmVxdWVzdCwgbXVsdGlNYXRjaE9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBGb3VuZCBhIGNhY2hlZCByZXNwb25zZSBpbiAnJHtjYWNoZU5hbWV9Jy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgTm8gY2FjaGVkIHJlc3BvbnNlIGZvdW5kIGluICcke2NhY2hlTmFtZX0nLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5pdGVyYXRlQ2FsbGJhY2tzKCdjYWNoZWRSZXNwb25zZVdpbGxCZVVzZWQnKSkge1xuICAgICAgICAgICAgICAgIGNhY2hlZFJlc3BvbnNlID0gKGF3YWl0IGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBlZmZlY3RpdmVSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgICAgICAgICAgICB9KSkgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3BvbnNlO1xuICAgICAgICB9KSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHV0cyBhIHJlcXVlc3QvcmVzcG9uc2UgcGFpciBpbiB0aGUgY2FjaGUgKGFuZCBpbnZva2VzIGFueSBhcHBsaWNhYmxlXG4gICAgICogcGx1Z2luIGNhbGxiYWNrIG1ldGhvZHMpIHVzaW5nIHRoZSBgY2FjaGVOYW1lYCBhbmQgYHBsdWdpbnNgIGRlZmluZWQgb25cbiAgICAgKiB0aGUgc3RyYXRlZ3kgb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBwbHVnaW4gbGlmZWN5Y2xlIG1ldGhvZHMgYXJlIGludm9rZWQgd2hlbiB1c2luZyB0aGlzIG1ldGhvZDpcbiAgICAgKiAtIGNhY2hlS2V5V2lsbEJ5VXNlZCgpXG4gICAgICogLSBjYWNoZVdpbGxVcGRhdGUoKVxuICAgICAqIC0gY2FjaGVEaWRVcGRhdGUoKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fHN0cmluZ30ga2V5IFRoZSByZXF1ZXN0IG9yIFVSTCB0byB1c2UgYXMgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcGFyYW0ge1Byb21pc2U8dm9pZD59IHJlc3BvbnNlIFRoZSByZXNwb25zZSB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBhc3luYyBjYWNoZVB1dChrZXksIHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0b1JlcXVlc3Qoa2V5KTtcbiAgICAgICAgLy8gUnVuIGluIHRoZSBuZXh0IHRhc2sgdG8gYXZvaWQgYmxvY2tpbmcgb3RoZXIgY2FjaGUgcmVhZHMuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvU2VydmljZVdvcmtlci9pc3N1ZXMvMTM5N1xuICAgICAgICBhd2FpdCB0aW1lb3V0KDApO1xuICAgICAgICBjb25zdCBlZmZlY3RpdmVSZXF1ZXN0ID0gYXdhaXQgdGhpcy5nZXRDYWNoZUtleShyZXF1ZXN0LCAnd3JpdGUnKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3RpdmVSZXF1ZXN0Lm1ldGhvZCAmJiBlZmZlY3RpdmVSZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdhdHRlbXB0LXRvLWNhY2hlLW5vbi1nZXQtcmVxdWVzdCcsIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBnZXRGcmllbmRseVVSTChlZmZlY3RpdmVSZXF1ZXN0LnVybCksXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogZWZmZWN0aXZlUmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYENhbm5vdCBjYWNoZSBub24tZXhpc3RlbnQgcmVzcG9uc2UgZm9yIGAgK1xuICAgICAgICAgICAgICAgICAgICBgJyR7Z2V0RnJpZW5kbHlVUkwoZWZmZWN0aXZlUmVxdWVzdC51cmwpfScuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdjYWNoZS1wdXQtd2l0aC1uby1yZXNwb25zZScsIHtcbiAgICAgICAgICAgICAgICB1cmw6IGdldEZyaWVuZGx5VVJMKGVmZmVjdGl2ZVJlcXVlc3QudXJsKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVG9DYWNoZSA9IGF3YWl0IHRoaXMuX2Vuc3VyZVJlc3BvbnNlU2FmZVRvQ2FjaGUocmVzcG9uc2UpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlVG9DYWNoZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFJlc3BvbnNlICcke2dldEZyaWVuZGx5VVJMKGVmZmVjdGl2ZVJlcXVlc3QudXJsKX0nIGAgK1xuICAgICAgICAgICAgICAgICAgICBgd2lsbCBub3QgYmUgY2FjaGVkLmAsIHJlc3BvbnNlVG9DYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjYWNoZU5hbWUsIG1hdGNoT3B0aW9ucyB9ID0gdGhpcy5fc3RyYXRlZ3k7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgc2VsZi5jYWNoZXMub3BlbihjYWNoZU5hbWUpO1xuICAgICAgICBjb25zdCBoYXNDYWNoZVVwZGF0ZUNhbGxiYWNrID0gdGhpcy5oYXNDYWxsYmFjaygnY2FjaGVEaWRVcGRhdGUnKTtcbiAgICAgICAgY29uc3Qgb2xkUmVzcG9uc2UgPSBoYXNDYWNoZVVwZGF0ZUNhbGxiYWNrID8gYXdhaXQgY2FjaGVNYXRjaElnbm9yZVBhcmFtcyhcbiAgICAgICAgLy8gVE9ETyhwaGlsaXB3YWx0b24pOiB0aGUgYF9fV0JfUkVWSVNJT05fX2AgcGFyYW0gaXMgYSBwcmVjYWNoaW5nXG4gICAgICAgIC8vIGZlYXR1cmUuIENvbnNpZGVyIGludG8gd2F5cyB0byBvbmx5IGFkZCB0aGlzIGJlaGF2aW9yIGlmIHVzaW5nXG4gICAgICAgIC8vIHByZWNhY2hpbmcuXG4gICAgICAgIGNhY2hlLCBlZmZlY3RpdmVSZXF1ZXN0LmNsb25lKCksIFsnX19XQl9SRVZJU0lPTl9fJ10sIG1hdGNoT3B0aW9ucykgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgVXBkYXRpbmcgdGhlICcke2NhY2hlTmFtZX0nIGNhY2hlIHdpdGggYSBuZXcgUmVzcG9uc2UgYCArXG4gICAgICAgICAgICAgICAgYGZvciAke2dldEZyaWVuZGx5VVJMKGVmZmVjdGl2ZVJlcXVlc3QudXJsKX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlLnB1dChlZmZlY3RpdmVSZXF1ZXN0LCBoYXNDYWNoZVVwZGF0ZUNhbGxiYWNrID9cbiAgICAgICAgICAgICAgICByZXNwb25zZVRvQ2FjaGUuY2xvbmUoKSA6IHJlc3BvbnNlVG9DYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RPTUV4Y2VwdGlvbiNleGNlcHRpb24tUXVvdGFFeGNlZWRlZEVycm9yXG4gICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ1F1b3RhRXhjZWVkZWRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBleGVjdXRlUXVvdGFFcnJvckNhbGxiYWNrcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiB0aGlzLml0ZXJhdGVDYWxsYmFja3MoJ2NhY2hlRGlkVXBkYXRlJykpIHtcbiAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICBjYWNoZU5hbWUsXG4gICAgICAgICAgICAgICAgb2xkUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgbmV3UmVzcG9uc2U6IHJlc3BvbnNlVG9DYWNoZS5jbG9uZSgpLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGVmZmVjdGl2ZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIGxpc3Qgb2YgcGx1Z2lucyBmb3IgdGhlIGBjYWNoZUtleVdpbGxCZVVzZWRgIGNhbGxiYWNrLCBhbmRcbiAgICAgKiBleGVjdXRlcyBhbnkgb2YgdGhvc2UgY2FsbGJhY2tzIGZvdW5kIGluIHNlcXVlbmNlLiBUaGUgZmluYWwgYFJlcXVlc3RgXG4gICAgICogb2JqZWN0IHJldHVybmVkIGJ5IHRoZSBsYXN0IHBsdWdpbiBpcyB0cmVhdGVkIGFzIHRoZSBjYWNoZSBrZXkgZm9yIGNhY2hlXG4gICAgICogcmVhZHMgYW5kL29yIHdyaXRlcy4gSWYgbm8gYGNhY2hlS2V5V2lsbEJlVXNlZGAgcGx1Z2luIGNhbGxiYWNrcyBoYXZlXG4gICAgICogYmVlbiByZWdpc3RlcmVkLCB0aGUgcGFzc2VkIHJlcXVlc3QgaXMgcmV0dXJuZWQgdW5tb2RpZmllZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJlcXVlc3Q+fVxuICAgICAqL1xuICAgIGFzeW5jIGdldENhY2hlS2V5KHJlcXVlc3QsIG1vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZUtleXNbbW9kZV0pIHtcbiAgICAgICAgICAgIGxldCBlZmZlY3RpdmVSZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5pdGVyYXRlQ2FsbGJhY2tzKCdjYWNoZUtleVdpbGxCZVVzZWQnKSkge1xuICAgICAgICAgICAgICAgIGVmZmVjdGl2ZVJlcXVlc3QgPSB0b1JlcXVlc3QoYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBlZmZlY3RpdmVSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB0aGlzLnBhcmFtcyxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUtleXNbbW9kZV0gPSBlZmZlY3RpdmVSZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZUtleXNbbW9kZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3RyYXRlZ3kgaGFzIGF0IGxlYXN0IG9uZSBwbHVnaW4gd2l0aCB0aGUgZ2l2ZW5cbiAgICAgKiBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjYWxsYmFjayB0byBjaGVjayBmb3IuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNDYWxsYmFjayhuYW1lKSB7XG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMuX3N0cmF0ZWd5LnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGlmIChuYW1lIGluIHBsdWdpbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVucyBhbGwgcGx1Z2luIGNhbGxiYWNrcyBtYXRjaGluZyB0aGUgZ2l2ZW4gbmFtZSwgaW4gb3JkZXIsIHBhc3NpbmcgdGhlXG4gICAgICogZ2l2ZW4gcGFyYW0gb2JqZWN0IChtZXJnZWQgaXRoIHRoZSBjdXJyZW50IHBsdWdpbiBzdGF0ZSkgYXMgdGhlIG9ubHlcbiAgICAgKiBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIE5vdGU6IHNpbmNlIHRoaXMgbWV0aG9kIHJ1bnMgYWxsIHBsdWdpbnMsIGl0J3Mgbm90IHN1aXRhYmxlIGZvciBjYXNlc1xuICAgICAqIHdoZXJlIHRoZSByZXR1cm4gdmFsdWUgb2YgYSBjYWxsYmFjayBuZWVkcyB0byBiZSBhcHBsaWVkIHByaW9yIHRvIGNhbGxpbmdcbiAgICAgKiB0aGUgbmV4dCBjYWxsYmFjay4gU2VlXG4gICAgICogW2BpdGVyYXRlQ2FsbGJhY2tzKClgXXtAbGluayBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5SGFuZGxlciNpdGVyYXRlQ2FsbGJhY2tzfVxuICAgICAqIGJlbG93IGZvciBob3cgdG8gaGFuZGxlIHRoYXQgY2FzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjYWxsYmFjayB0byBydW4gd2l0aGluIGVhY2ggcGx1Z2luLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbSBUaGUgb2JqZWN0IHRvIHBhc3MgYXMgdGhlIGZpcnN0IChhbmQgb25seSkgcGFyYW1cbiAgICAgKiAgICAgd2hlbiBleGVjdXRpbmcgZWFjaCBjYWxsYmFjay4gVGhpcyBvYmplY3Qgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGVcbiAgICAgKiAgICAgY3VycmVudCBwbHVnaW4gc3RhdGUgcHJpb3IgdG8gY2FsbGJhY2sgZXhlY3V0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHJ1bkNhbGxiYWNrcyhuYW1lLCBwYXJhbSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuaXRlcmF0ZUNhbGxiYWNrcyhuYW1lKSkge1xuICAgICAgICAgICAgLy8gVE9ETyhwaGlsaXB3YWx0b24pOiBub3Qgc3VyZSB3aHkgYGFueWAgaXMgbmVlZGVkLiBJdCBzZWVtcyBsaWtlXG4gICAgICAgICAgICAvLyB0aGlzIHNob3VsZCB3b3JrIHdpdGggYGFzIFdvcmtib3hQbHVnaW5DYWxsYmFja1BhcmFtW0NdYC5cbiAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrKHBhcmFtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY2NlcHRzIGEgY2FsbGJhY2sgYW5kIHJldHVybnMgYW4gaXRlcmFibGUgb2YgbWF0Y2hpbmcgcGx1Z2luIGNhbGxiYWNrcyxcbiAgICAgKiB3aGVyZSBlYWNoIGNhbGxiYWNrIGlzIHdyYXBwZWQgd2l0aCB0aGUgY3VycmVudCBoYW5kbGVyIHN0YXRlIChpLmUuIHdoZW5cbiAgICAgKiB5b3UgY2FsbCBlYWNoIGNhbGxiYWNrLCB3aGF0ZXZlciBvYmplY3QgcGFyYW1ldGVyIHlvdSBwYXNzIGl0IHdpbGxcbiAgICAgKiBiZSBtZXJnZWQgd2l0aCB0aGUgcGx1Z2luJ3MgY3VycmVudCBzdGF0ZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBmbyB0aGUgY2FsbGJhY2sgdG8gcnVuXG4gICAgICogQHJldHVybiB7QXJyYXk8RnVuY3Rpb24+fVxuICAgICAqL1xuICAgICppdGVyYXRlQ2FsbGJhY2tzKG5hbWUpIHtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5fc3RyYXRlZ3kucGx1Z2lucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwbHVnaW5bbmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3BsdWdpblN0YXRlTWFwLmdldChwbHVnaW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlZnVsQ2FsbGJhY2sgPSAocGFyYW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGVmdWxQYXJhbSA9IHsgLi4ucGFyYW0sIHN0YXRlIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8ocGhpbGlwd2FsdG9uKTogbm90IHN1cmUgd2h5IGBhbnlgIGlzIG5lZWRlZC4gSXQgc2VlbXMgbGlrZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHNob3VsZCB3b3JrIHdpdGggYGFzIFdvcmtib3hQbHVnaW5DYWxsYmFja1BhcmFtW0NdYC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbltuYW1lXShzdGF0ZWZ1bFBhcmFtKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHlpZWxkIHN0YXRlZnVsQ2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHByb21pc2UgdG8gdGhlXG4gICAgICogW2V4dGVuZCBsaWZldGltZSBwcm9taXNlc117QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2V4dGVuZGFibGVldmVudC1leHRlbmQtbGlmZXRpbWUtcHJvbWlzZXN9XG4gICAgICogb2YgdGhlIGV2ZW50IGV2ZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVxdWVzdCBiZWluZyBoYW5kbGVkICh1c3VhbGx5IGFcbiAgICAgKiBgRmV0Y2hFdmVudGApLlxuICAgICAqXG4gICAgICogTm90ZTogeW91IGNhbiBhd2FpdFxuICAgICAqIFtgZG9uZVdhaXRpbmcoKWBde0BsaW5rIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3lIYW5kbGVyfmRvbmVXYWl0aW5nfVxuICAgICAqIHRvIGtub3cgd2hlbiBhbGwgYWRkZWQgcHJvbWlzZXMgaGF2ZSBzZXR0bGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQcm9taXNlfSBwcm9taXNlIEEgcHJvbWlzZSB0byBhZGQgdG8gdGhlIGV4dGVuZCBsaWZldGltZSBwcm9taXNlc1xuICAgICAqICAgICBvZiB0aGUgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgd2FpdFVudGlsKHByb21pc2UpIHtcbiAgICAgICAgdGhpcy5fZXh0ZW5kTGlmZXRpbWVQcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIGFsbCBwcm9taXNlcyBwYXNzZWQgdG9cbiAgICAgKiBbYHdhaXRVbnRpbCgpYF17QGxpbmsgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneUhhbmRsZXJ+d2FpdFVudGlsfVxuICAgICAqIGhhdmUgc2V0dGxlZC5cbiAgICAgKlxuICAgICAqIE5vdGU6IGFueSB3b3JrIGRvbmUgYWZ0ZXIgYGRvbmVXYWl0aW5nKClgIHNldHRsZXMgc2hvdWxkIGJlIG1hbnVhbGx5XG4gICAgICogcGFzc2VkIHRvIGFuIGV2ZW50J3MgYHdhaXRVbnRpbCgpYCBtZXRob2QgKG5vdCB0aGlzIGhhbmRsZXInc1xuICAgICAqIGB3YWl0VW50aWwoKWAgbWV0aG9kKSwgb3RoZXJ3aXNlIHRoZSBzZXJ2aWNlIHdvcmtlciB0aHJlYWQgbXkgYmUga2lsbGVkXG4gICAgICogcHJpb3IgdG8geW91ciB3b3JrIGNvbXBsZXRpbmcuXG4gICAgICovXG4gICAgYXN5bmMgZG9uZVdhaXRpbmcoKSB7XG4gICAgICAgIGxldCBwcm9taXNlO1xuICAgICAgICB3aGlsZSAocHJvbWlzZSA9IHRoaXMuX2V4dGVuZExpZmV0aW1lUHJvbWlzZXMuc2hpZnQoKSkge1xuICAgICAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyBydW5uaW5nIHRoZSBzdHJhdGVneSBhbmQgaW1tZWRpYXRlbHkgcmVzb2x2ZXMgYW55IHBlbmRpbmdcbiAgICAgKiBgd2FpdFVudGlsKClgIHByb21pc2VzLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZXJEZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2FsbCBjYWNoZVdpbGxVcGRhdGUgb24gdGhlIGF2YWlsYWJsZSBwbHVnaW5zIChvciB1c2VcbiAgICAgKiBzdGF0dXMgPT09IDIwMCkgdG8gZGV0ZXJtaW5lIGlmIHRoZSBSZXNwb25zZSBpcyBzYWZlIGFuZCB2YWxpZCB0byBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVxdWVzdH0gb3B0aW9ucy5yZXF1ZXN0XG4gICAgICogQHBhcmFtIHtSZXNwb25zZX0gb3B0aW9ucy5yZXNwb25zZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8UmVzcG9uc2V8dW5kZWZpbmVkPn1cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgX2Vuc3VyZVJlc3BvbnNlU2FmZVRvQ2FjaGUocmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlVG9DYWNoZSA9IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGx1Z2luc1VzZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiB0aGlzLml0ZXJhdGVDYWxsYmFja3MoJ2NhY2hlV2lsbFVwZGF0ZScpKSB7XG4gICAgICAgICAgICByZXNwb25zZVRvQ2FjaGUgPSAoYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHRoaXMucmVxdWVzdCxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2VUb0NhY2hlLFxuICAgICAgICAgICAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgICAgICAgfSkpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHBsdWdpbnNVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VUb0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwbHVnaW5zVXNlZCkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlVG9DYWNoZSAmJiByZXNwb25zZVRvQ2FjaGUuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZVRvQ2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVRvQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlVG9DYWNoZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlVG9DYWNoZS5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgVGhlIHJlc3BvbnNlIGZvciAnJHt0aGlzLnJlcXVlc3QudXJsfScgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBpcyBhbiBvcGFxdWUgcmVzcG9uc2UuIFRoZSBjYWNoaW5nIHN0cmF0ZWd5IHRoYXQgeW91J3JlIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgdXNpbmcgd2lsbCBub3QgY2FjaGUgb3BhcXVlIHJlc3BvbnNlcyBieSBkZWZhdWx0LmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBUaGUgcmVzcG9uc2UgZm9yICcke3RoaXMucmVxdWVzdC51cmx9JyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYHJldHVybmVkIGEgc3RhdHVzIGNvZGUgb2YgJyR7cmVzcG9uc2Uuc3RhdHVzfScgYW5kIHdvbid0IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYmUgY2FjaGVkIGFzIGEgcmVzdWx0LmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZVRvQ2FjaGU7XG4gICAgfVxufVxuZXhwb3J0IHsgU3RyYXRlZ3lIYW5kbGVyIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBjYWNoZU5hbWVzIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2NhY2hlTmFtZXMuanMnO1xuaW1wb3J0IHsgV29ya2JveEVycm9yIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IGdldEZyaWVuZGx5VVJMIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2dldEZyaWVuZGx5VVJMLmpzJztcbmltcG9ydCB7IFN0cmF0ZWd5SGFuZGxlciB9IGZyb20gJy4vU3RyYXRlZ3lIYW5kbGVyLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEFuIGFic3RyYWN0IGJhc2UgY2xhc3MgdGhhdCBhbGwgb3RoZXIgc3RyYXRlZ3kgY2xhc3NlcyBtdXN0IGV4dGVuZCBmcm9tOlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzXG4gKi9cbmNsYXNzIFN0cmF0ZWd5IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBzdHJhdGVneSBhbmQgc2V0cyBhbGwgZG9jdW1lbnRlZCBvcHRpb25cbiAgICAgKiBwcm9wZXJ0aWVzIGFzIHB1YmxpYyBpbnN0YW5jZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogTm90ZTogaWYgYSBjdXN0b20gc3RyYXRlZ3kgY2xhc3MgZXh0ZW5kcyB0aGUgYmFzZSBTdHJhdGVneSBjbGFzcyBhbmQgZG9lc1xuICAgICAqIG5vdCBuZWVkIG1vcmUgdGhhbiB0aGVzZSBwcm9wZXJ0aWVzLCBpdCBkb2VzIG5vdCBuZWVkIHRvIGRlZmluZSBpdHMgb3duXG4gICAgICogY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNhY2hlTmFtZV0gQ2FjaGUgbmFtZSB0byBzdG9yZSBhbmQgcmV0cmlldmVcbiAgICAgKiByZXF1ZXN0cy4gRGVmYXVsdHMgdG8gdGhlIGNhY2hlIG5hbWVzIHByb3ZpZGVkIGJ5XG4gICAgICogW3dvcmtib3gtY29yZV17QGxpbmsgbW9kdWxlOndvcmtib3gtY29yZS5jYWNoZU5hbWVzfS5cbiAgICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IFtvcHRpb25zLnBsdWdpbnNdIFtQbHVnaW5zXXtAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdG9vbHMvd29ya2JveC9ndWlkZXMvdXNpbmctcGx1Z2luc31cbiAgICAgKiB0byB1c2UgaW4gY29uanVuY3Rpb24gd2l0aCB0aGlzIGNhY2hpbmcgc3RyYXRlZ3kuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmZldGNoT3B0aW9uc10gVmFsdWVzIHBhc3NlZCBhbG9uZyB0byB0aGVcbiAgICAgKiBbYGluaXRgXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93T3JXb3JrZXJHbG9iYWxTY29wZS9mZXRjaCNQYXJhbWV0ZXJzfVxuICAgICAqIG9mIGFsbCBmZXRjaCgpIHJlcXVlc3RzIG1hZGUgYnkgdGhpcyBzdHJhdGVneS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubWF0Y2hPcHRpb25zXSBUaGVcbiAgICAgKiBbYENhY2hlUXVlcnlPcHRpb25zYF17QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2RpY3RkZWYtY2FjaGVxdWVyeW9wdGlvbnN9XG4gICAgICogZm9yIGFueSBgY2FjaGUubWF0Y2goKWAgb3IgYGNhY2hlLnB1dCgpYCBjYWxscyBtYWRlIGJ5IHRoaXMgc3RyYXRlZ3kuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWNoZSBuYW1lIHRvIHN0b3JlIGFuZCByZXRyaWV2ZVxuICAgICAgICAgKiByZXF1ZXN0cy4gRGVmYXVsdHMgdG8gdGhlIGNhY2hlIG5hbWVzIHByb3ZpZGVkIGJ5XG4gICAgICAgICAqIFt3b3JrYm94LWNvcmVde0BsaW5rIG1vZHVsZTp3b3JrYm94LWNvcmUuY2FjaGVOYW1lc30uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhY2hlTmFtZSA9IGNhY2hlTmFtZXMuZ2V0UnVudGltZU5hbWUob3B0aW9ucy5jYWNoZU5hbWUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3RcbiAgICAgICAgICogW1BsdWdpbnNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi90b29scy93b3JrYm94L2d1aWRlcy91c2luZy1wbHVnaW5zfVxuICAgICAgICAgKiB1c2VkIGJ5IHRoaXMgc3RyYXRlZ3kuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxPYmplY3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wbHVnaW5zID0gb3B0aW9ucy5wbHVnaW5zIHx8IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWVzIHBhc3NlZCBhbG9uZyB0byB0aGVcbiAgICAgICAgICogW2Bpbml0YF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd09yV29ya2VyR2xvYmFsU2NvcGUvZmV0Y2gjUGFyYW1ldGVyc31cbiAgICAgICAgICogb2YgYWxsIGZldGNoKCkgcmVxdWVzdHMgbWFkZSBieSB0aGlzIHN0cmF0ZWd5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mZXRjaE9wdGlvbnMgPSBvcHRpb25zLmZldGNoT3B0aW9ucztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZVxuICAgICAgICAgKiBbYENhY2hlUXVlcnlPcHRpb25zYF17QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2RpY3RkZWYtY2FjaGVxdWVyeW9wdGlvbnN9XG4gICAgICAgICAqIGZvciBhbnkgYGNhY2hlLm1hdGNoKClgIG9yIGBjYWNoZS5wdXQoKWAgY2FsbHMgbWFkZSBieSB0aGlzIHN0cmF0ZWd5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXRjaE9wdGlvbnMgPSBvcHRpb25zLm1hdGNoT3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIHJlcXVlc3Qgc3RyYXRlZ3kgYW5kIHJldHVybnMgYSBgUHJvbWlzZWAgdGhhdCB3aWxsIHJlc29sdmUgd2l0aFxuICAgICAqIGEgYFJlc3BvbnNlYCwgaW52b2tpbmcgYWxsIHJlbGV2YW50IHBsdWdpbiBjYWxsYmFja3MuXG4gICAgICpcbiAgICAgKiBXaGVuIGEgc3RyYXRlZ3kgaW5zdGFuY2UgaXMgcmVnaXN0ZXJlZCB3aXRoIGEgV29ya2JveFxuICAgICAqIFtyb3V0ZV17QGxpbmsgbW9kdWxlOndvcmtib3gtcm91dGluZy5Sb3V0ZX0sIHRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHlcbiAgICAgKiBjYWxsZWQgd2hlbiB0aGUgcm91dGUgbWF0Y2hlcy5cbiAgICAgKlxuICAgICAqIEFsdGVybmF0aXZlbHksIHRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGluIGEgc3RhbmRhbG9uZSBgRmV0Y2hFdmVudGBcbiAgICAgKiBsaXN0ZW5lciBieSBwYXNzaW5nIGl0IHRvIGBldmVudC5yZXNwb25kV2l0aCgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmV0Y2hFdmVudHxPYmplY3R9IG9wdGlvbnMgQSBgRmV0Y2hFdmVudGAgb3IgYW4gb2JqZWN0IHdpdGggdGhlXG4gICAgICogICAgIHByb3BlcnRpZXMgbGlzdGVkIGJlbG93LlxuICAgICAqIEBwYXJhbSB7UmVxdWVzdHxzdHJpbmd9IG9wdGlvbnMucmVxdWVzdCBBIHJlcXVlc3QgdG8gcnVuIHRoaXMgc3RyYXRlZ3kgZm9yLlxuICAgICAqIEBwYXJhbSB7RXh0ZW5kYWJsZUV2ZW50fSBvcHRpb25zLmV2ZW50IFRoZSBldmVudCBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgICogICAgIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHtVUkx9IFtvcHRpb25zLnVybF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLnBhcmFtc11cbiAgICAgKi9cbiAgICBoYW5kbGUob3B0aW9ucykge1xuICAgICAgICBjb25zdCBbcmVzcG9uc2VEb25lXSA9IHRoaXMuaGFuZGxlQWxsKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VEb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIFtgaGFuZGxlKClgXXtAbGluayBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5fmhhbmRsZX0sIGJ1dFxuICAgICAqIGluc3RlYWQgb2YganVzdCByZXR1cm5pbmcgYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB0byBhIGBSZXNwb25zZWAgaXRcbiAgICAgKiBpdCB3aWxsIHJldHVybiBhbiB0dXBsZSBvZiBbcmVzcG9uc2UsIGRvbmVdIHByb21pc2VzLCB3aGVyZSB0aGUgZm9ybWVyXG4gICAgICogKGByZXNwb25zZWApIGlzIGVxdWl2YWxlbnQgdG8gd2hhdCBgaGFuZGxlKClgIHJldHVybnMsIGFuZCB0aGUgbGF0dGVyIGlzIGFcbiAgICAgKiBQcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9uY2UgYW55IHByb21pc2VzIHRoYXQgd2VyZSBhZGRlZCB0b1xuICAgICAqIGBldmVudC53YWl0VW50aWwoKWAgYXMgcGFydCBvZiBwZXJmb3JtaW5nIHRoZSBzdHJhdGVneSBoYXZlIGNvbXBsZXRlZC5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYXdhaXQgdGhlIGBkb25lYCBwcm9taXNlIHRvIGVuc3VyZSBhbnkgZXh0cmEgd29yayBwZXJmb3JtZWQgYnlcbiAgICAgKiB0aGUgc3RyYXRlZ3kgKHVzdWFsbHkgY2FjaGluZyByZXNwb25zZXMpIGNvbXBsZXRlcyBzdWNjZXNzZnVsbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ZldGNoRXZlbnR8T2JqZWN0fSBvcHRpb25zIEEgYEZldGNoRXZlbnRgIG9yIGFuIG9iamVjdCB3aXRoIHRoZVxuICAgICAqICAgICBwcm9wZXJ0aWVzIGxpc3RlZCBiZWxvdy5cbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R8c3RyaW5nfSBvcHRpb25zLnJlcXVlc3QgQSByZXF1ZXN0IHRvIHJ1biB0aGlzIHN0cmF0ZWd5IGZvci5cbiAgICAgKiBAcGFyYW0ge0V4dGVuZGFibGVFdmVudH0gb3B0aW9ucy5ldmVudCBUaGUgZXZlbnQgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgICAqICAgICByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7VVJMfSBbb3B0aW9ucy51cmxdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5wYXJhbXNdXG4gICAgICogQHJldHVybiB7QXJyYXk8UHJvbWlzZT59IEEgdHVwbGUgb2YgW3Jlc3BvbnNlLCBkb25lXVxuICAgICAqICAgICBwcm9taXNlcyB0aGF0IGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSB3aGVuIHRoZSByZXNwb25zZSByZXNvbHZlcyBhc1xuICAgICAqICAgICB3ZWxsIGFzIHdoZW4gdGhlIGhhbmRsZXIgaGFzIGNvbXBsZXRlZCBhbGwgaXRzIHdvcmsuXG4gICAgICovXG4gICAgaGFuZGxlQWxsKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQWxsb3cgZm9yIGZsZXhpYmxlIG9wdGlvbnMgdG8gYmUgcGFzc2VkLlxuICAgICAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEZldGNoRXZlbnQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogb3B0aW9ucy5yZXF1ZXN0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudCA9IG9wdGlvbnMuZXZlbnQ7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0eXBlb2Ygb3B0aW9ucy5yZXF1ZXN0ID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICBuZXcgUmVxdWVzdChvcHRpb25zLnJlcXVlc3QpIDpcbiAgICAgICAgICAgIG9wdGlvbnMucmVxdWVzdDtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gJ3BhcmFtcycgaW4gb3B0aW9ucyA/IG9wdGlvbnMucGFyYW1zIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gbmV3IFN0cmF0ZWd5SGFuZGxlcih0aGlzLCB7IGV2ZW50LCByZXF1ZXN0LCBwYXJhbXMgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRG9uZSA9IHRoaXMuX2dldFJlc3BvbnNlKGhhbmRsZXIsIHJlcXVlc3QsIGV2ZW50KTtcbiAgICAgICAgY29uc3QgaGFuZGxlckRvbmUgPSB0aGlzLl9hd2FpdENvbXBsZXRlKHJlc3BvbnNlRG9uZSwgaGFuZGxlciwgcmVxdWVzdCwgZXZlbnQpO1xuICAgICAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgcHJvbWlzZXMsIHN1aXRhYmxlIGZvciB1c2Ugd2l0aCBQcm9taXNlLmFsbCgpLlxuICAgICAgICByZXR1cm4gW3Jlc3BvbnNlRG9uZSwgaGFuZGxlckRvbmVdO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0UmVzcG9uc2UoaGFuZGxlciwgcmVxdWVzdCwgZXZlbnQpIHtcbiAgICAgICAgYXdhaXQgaGFuZGxlci5ydW5DYWxsYmFja3MoJ2hhbmRsZXJXaWxsU3RhcnQnLCB7IGV2ZW50LCByZXF1ZXN0IH0pO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2hhbmRsZShyZXF1ZXN0LCBoYW5kbGVyKTtcbiAgICAgICAgICAgIC8vIFRoZSBcIm9mZmljaWFsXCIgU3RyYXRlZ3kgc3ViY2xhc3NlcyBhbGwgdGhyb3cgdGhpcyBlcnJvciBhdXRvbWF0aWNhbGx5LFxuICAgICAgICAgICAgLy8gYnV0IGluIGNhc2UgYSB0aGlyZC1wYXJ0eSBTdHJhdGVneSBkb2Vzbid0LCBlbnN1cmUgdGhhdCB3ZSBoYXZlIGFcbiAgICAgICAgICAgIC8vIGNvbnNpc3RlbnQgZmFpbHVyZSB3aGVuIHRoZXJlJ3Mgbm8gcmVzcG9uc2Ugb3IgYW4gZXJyb3IgcmVzcG9uc2UuXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlIHx8IHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCduby1yZXNwb25zZScsIHsgdXJsOiByZXF1ZXN0LnVybCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgaGFuZGxlci5pdGVyYXRlQ2FsbGJhY2tzKCdoYW5kbGVyRGlkRXJyb3InKSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2soeyBlcnJvciwgZXZlbnQsIHJlcXVlc3QgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBXaGlsZSByZXNwb25kaW5nIHRvICcke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0nLCBgICtcbiAgICAgICAgICAgICAgICAgICAgYGFuICR7ZXJyb3J9IGVycm9yIG9jY3VycmVkLiBVc2luZyBhIGZhbGxiYWNrIHJlc3BvbnNlIHByb3ZpZGVkIGJ5IGAgK1xuICAgICAgICAgICAgICAgICAgICBgYSBoYW5kbGVyRGlkRXJyb3IgcGx1Z2luLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgaGFuZGxlci5pdGVyYXRlQ2FsbGJhY2tzKCdoYW5kbGVyV2lsbFJlc3BvbmQnKSkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFjayh7IGV2ZW50LCByZXF1ZXN0LCByZXNwb25zZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIF9hd2FpdENvbXBsZXRlKHJlc3BvbnNlRG9uZSwgaGFuZGxlciwgcmVxdWVzdCwgZXZlbnQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlRG9uZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMsIGFzIHJlc3BvbnNlIGVycm9ycyBzaG91bGQgYmUgY2F1Z2h0IHZpYSB0aGUgYHJlc3BvbnNlYFxuICAgICAgICAgICAgLy8gcHJvbWlzZSBhYm92ZS4gVGhlIGBkb25lYCBwcm9taXNlIHdpbGwgb25seSB0aHJvdyBmb3IgZXJyb3JzIGluXG4gICAgICAgICAgICAvLyBwcm9taXNlcyBwYXNzZWQgdG8gYGhhbmRsZXIud2FpdFVudGlsKClgLlxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVyLnJ1bkNhbGxiYWNrcygnaGFuZGxlckRpZFJlc3BvbmQnLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5kb25lV2FpdGluZygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoICh3YWl0VW50aWxFcnJvcikge1xuICAgICAgICAgICAgZXJyb3IgPSB3YWl0VW50aWxFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBoYW5kbGVyLnJ1bkNhbGxiYWNrcygnaGFuZGxlckRpZENvbXBsZXRlJywge1xuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgICAgIGhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IHsgU3RyYXRlZ3kgfTtcbi8qKlxuICogQ2xhc3NlcyBleHRlbmRpbmcgdGhlIGBTdHJhdGVneWAgYmFzZWQgY2xhc3Mgc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCxcbiAqIGFuZCBsZXZlcmFnZSB0aGUgW2BoYW5kbGVyYF17QGxpbmsgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneUhhbmRsZXJ9XG4gKiBhcmcgdG8gcGVyZm9ybSBhbGwgZmV0Y2hpbmcgYW5kIGNhY2hlIGxvZ2ljLCB3aGljaCB3aWxsIGVuc3VyZSBhbGwgcmVsZXZhbnRcbiAqIGNhY2hlLCBjYWNoZSBvcHRpb25zLCBmZXRjaCBvcHRpb25zIGFuZCBwbHVnaW5zIGFyZSB1c2VkIChwZXIgdGhlIGN1cnJlbnRcbiAqIHN0cmF0ZWd5IGluc3RhbmNlKS5cbiAqXG4gKiBAbmFtZSBfaGFuZGxlXG4gKiBAaW5zdGFuY2VcbiAqIEBhYnN0cmFjdFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneUhhbmRsZXJ9IGhhbmRsZXJcbiAqIEByZXR1cm4ge1Byb21pc2U8UmVzcG9uc2U+fVxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5XG4gKi9cbiIsIi8qXG4gIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGNvcHlSZXNwb25zZSB9IGZyb20gJ3dvcmtib3gtY29yZS9jb3B5UmVzcG9uc2UuanMnO1xuaW1wb3J0IHsgY2FjaGVOYW1lcyB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9jYWNoZU5hbWVzLmpzJztcbmltcG9ydCB7IGdldEZyaWVuZGx5VVJMIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2dldEZyaWVuZGx5VVJMLmpzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMnO1xuaW1wb3J0IHsgV29ya2JveEVycm9yIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5qcyc7XG5pbXBvcnQgeyBTdHJhdGVneSB9IGZyb20gJ3dvcmtib3gtc3RyYXRlZ2llcy9TdHJhdGVneS5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuY29uc3QgY29weVJlZGlyZWN0ZWRDYWNoZWFibGVSZXNwb25zZXNQbHVnaW4gPSB7XG4gICAgYXN5bmMgY2FjaGVXaWxsVXBkYXRlKHsgcmVzcG9uc2UgfSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UucmVkaXJlY3RlZCA/IGF3YWl0IGNvcHlSZXNwb25zZShyZXNwb25zZSkgOiByZXNwb25zZTtcbiAgICB9XG59O1xuLyoqXG4gKiBBIFtTdHJhdGVneV17QGxpbmsgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneX0gaW1wbGVtZW50YXRpb25cbiAqIHNwZWNpZmljYWxseSBkZXNpZ25lZCB0byB3b3JrIHdpdGhcbiAqIFtQcmVjYWNoZUNvbnRyb2xsZXJde0BsaW5rIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuUHJlY2FjaGVDb250cm9sbGVyfVxuICogdG8gYm90aCBjYWNoZSBhbmQgZmV0Y2ggcHJlY2FjaGVkIGFzc2V0cy5cbiAqXG4gKiBOb3RlOiBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGlzIGNyZWF0ZWQgYXV0b21hdGljYWxseSB3aGVuIGNyZWF0aW5nIGFcbiAqIGBQcmVjYWNoZUNvbnRyb2xsZXJgOyBpdCdzIGdlbmVyYWxseSBub3QgbmVjZXNzYXJ5IHRvIGNyZWF0ZSB0aGlzIHlvdXJzZWxmLlxuICpcbiAqIEBleHRlbmRzIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3lcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nXG4gKi9cbmNsYXNzIFByZWNhY2hlU3RyYXRlZ3kgZXh0ZW5kcyBTdHJhdGVneSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNhY2hlTmFtZV0gQ2FjaGUgbmFtZSB0byBzdG9yZSBhbmQgcmV0cmlldmVcbiAgICAgKiByZXF1ZXN0cy4gRGVmYXVsdHMgdG8gdGhlIGNhY2hlIG5hbWVzIHByb3ZpZGVkIGJ5XG4gICAgICogW3dvcmtib3gtY29yZV17QGxpbmsgbW9kdWxlOndvcmtib3gtY29yZS5jYWNoZU5hbWVzfS5cbiAgICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IFtvcHRpb25zLnBsdWdpbnNdIFtQbHVnaW5zXXtAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdG9vbHMvd29ya2JveC9ndWlkZXMvdXNpbmctcGx1Z2luc31cbiAgICAgKiB0byB1c2UgaW4gY29uanVuY3Rpb24gd2l0aCB0aGlzIGNhY2hpbmcgc3RyYXRlZ3kuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmZldGNoT3B0aW9uc10gVmFsdWVzIHBhc3NlZCBhbG9uZyB0byB0aGVcbiAgICAgKiBbYGluaXRgXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93T3JXb3JrZXJHbG9iYWxTY29wZS9mZXRjaCNQYXJhbWV0ZXJzfVxuICAgICAqIG9mIGFsbCBmZXRjaCgpIHJlcXVlc3RzIG1hZGUgYnkgdGhpcyBzdHJhdGVneS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubWF0Y2hPcHRpb25zXSBUaGVcbiAgICAgKiBbYENhY2hlUXVlcnlPcHRpb25zYF17QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2RpY3RkZWYtY2FjaGVxdWVyeW9wdGlvbnN9XG4gICAgICogZm9yIGFueSBgY2FjaGUubWF0Y2goKWAgb3IgYGNhY2hlLnB1dCgpYCBjYWxscyBtYWRlIGJ5IHRoaXMgc3RyYXRlZ3kuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mYWxsYmFja1RvTmV0d29yaz10cnVlXSBXaGV0aGVyIHRvIGF0dGVtcHQgdG9cbiAgICAgKiBnZXQgdGhlIHJlc3BvbnNlIGZyb20gdGhlIG5ldHdvcmsgaWYgdGhlcmUncyBhIHByZWNhY2hlIG1pc3MuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIG9wdGlvbnMuY2FjaGVOYW1lID0gY2FjaGVOYW1lcy5nZXRQcmVjYWNoZU5hbWUob3B0aW9ucy5jYWNoZU5hbWUpO1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fZmFsbGJhY2tUb05ldHdvcmsgPSBvcHRpb25zLmZhbGxiYWNrVG9OZXR3b3JrID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgICAgLy8gUmVkaXJlY3RlZCByZXNwb25zZXMgY2Fubm90IGJlIHVzZWQgdG8gc2F0aXNmeSBhIG5hdmlnYXRpb24gcmVxdWVzdCwgc29cbiAgICAgICAgLy8gYW55IHJlZGlyZWN0ZWQgcmVzcG9uc2UgbXVzdCBiZSBcImNvcGllZFwiIHJhdGhlciB0aGFuIGNsb25lZCwgc28gdGhlIG5ld1xuICAgICAgICAvLyByZXNwb25zZSBkb2Vzbid0IGNvbnRhaW4gdGhlIGByZWRpcmVjdGVkYCBmbGFnLiBTZWU6XG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTY2OTM2MyZkZXNjPTIjYzFcbiAgICAgICAgdGhpcy5wbHVnaW5zLnB1c2goY29weVJlZGlyZWN0ZWRDYWNoZWFibGVSZXNwb25zZXNQbHVnaW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UmVxdWVzdHxzdHJpbmd9IHJlcXVlc3QgQSByZXF1ZXN0IHRvIHJ1biB0aGlzIHN0cmF0ZWd5IGZvci5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3lIYW5kbGVyfSBoYW5kbGVyIFRoZSBldmVudCB0aGF0XG4gICAgICogICAgIHRyaWdnZXJlZCB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJlc3BvbnNlPn1cbiAgICAgKi9cbiAgICBhc3luYyBfaGFuZGxlKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmNhY2hlTWF0Y2gocmVxdWVzdCk7XG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYW4gYGluc3RhbGxgIGV2ZW50IHRoZW4gcG9wdWxhdGUgdGhlIGNhY2hlLiBJZiB0aGlzIGlzIGFcbiAgICAgICAgICAgIC8vIGBmZXRjaGAgZXZlbnQgKG9yIGFueSBvdGhlciBldmVudCkgdGhlbiByZXNwb25kIHdpdGggdGhlIGNhY2hlZFxuICAgICAgICAgICAgLy8gcmVzcG9uc2UuXG4gICAgICAgICAgICBpZiAoaGFuZGxlci5ldmVudCAmJiBoYW5kbGVyLmV2ZW50LnR5cGUgPT09ICdpbnN0YWxsJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9oYW5kbGVJbnN0YWxsKHJlcXVlc3QsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2hhbmRsZUZldGNoKHJlcXVlc3QsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgX2hhbmRsZUZldGNoKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIG5ldHdvcmsgaWYgd2UgZG9uJ3QgaGF2ZSBhIGNhY2hlZCByZXNwb25zZVxuICAgICAgICAvLyAocGVyaGFwcyBkdWUgdG8gbWFudWFsIGNhY2hlIGNsZWFudXApLlxuICAgICAgICBpZiAodGhpcy5fZmFsbGJhY2tUb05ldHdvcmspIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFRoZSBwcmVjYWNoZWQgcmVzcG9uc2UgZm9yIGAgK1xuICAgICAgICAgICAgICAgICAgICBgJHtnZXRGcmllbmRseVVSTChyZXF1ZXN0LnVybCl9IGluICR7dGhpcy5jYWNoZU5hbWV9IHdhcyBub3QgYCArXG4gICAgICAgICAgICAgICAgICAgIGBmb3VuZC4gRmFsbGluZyBiYWNrIHRvIHRoZSBuZXR3b3JrIGluc3RlYWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGhhbmRsZXIuZmV0Y2gocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBub3JtYWxseSBoYXBwZW4sIGJ1dCB0aGVyZSBhcmUgZWRnZSBjYXNlczpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvd29ya2JveC9pc3N1ZXMvMTQ0MVxuICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignbWlzc2luZy1wcmVjYWNoZS1lbnRyeScsIHtcbiAgICAgICAgICAgICAgICBjYWNoZU5hbWU6IHRoaXMuY2FjaGVOYW1lLFxuICAgICAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBoYW5kbGVyLnBhcmFtcyAmJiBoYW5kbGVyLnBhcmFtcy5jYWNoZUtleSB8fFxuICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuZ2V0Q2FjaGVLZXkocmVxdWVzdCwgJ3JlYWQnKTtcbiAgICAgICAgICAgIC8vIFdvcmtib3ggaXMgZ29pbmcgdG8gaGFuZGxlIHRoZSByb3V0ZS5cbiAgICAgICAgICAgIC8vIHByaW50IHRoZSByb3V0aW5nIGRldGFpbHMgdG8gdGhlIGNvbnNvbGUuXG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoYFByZWNhY2hpbmcgaXMgcmVzcG9uZGluZyB0bzogYCArXG4gICAgICAgICAgICAgICAgZ2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYFNlcnZpbmcgdGhlIHByZWNhY2hlZCB1cmw6ICR7Z2V0RnJpZW5kbHlVUkwoY2FjaGVLZXkudXJsKX1gKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgVmlldyByZXF1ZXN0IGRldGFpbHMgaGVyZS5gKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2cocmVxdWVzdCk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgVmlldyByZXNwb25zZSBkZXRhaWxzIGhlcmUuYCk7XG4gICAgICAgICAgICBsb2dnZXIubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyBfaGFuZGxlSW5zdGFsbChyZXF1ZXN0LCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlci5mZXRjaEFuZENhY2hlUHV0KHJlcXVlc3QpO1xuICAgICAgICAvLyBBbnkgdGltZSB0aGVyZSdzIG5vIHJlc3BvbnNlLCBjb25zaWRlciBpdCBhIHByZWNhY2hpbmcgZXJyb3IuXG4gICAgICAgIGxldCByZXNwb25zZVNhZmVUb1ByZWNhY2hlID0gQm9vbGVhbihyZXNwb25zZSk7XG4gICAgICAgIC8vIEFsc28gY29uc2lkZXIgaXQgYW4gZXJyb3IgaWYgdGhlIHVzZXIgZGlkbid0IHBhc3MgdGhlaXIgb3duXG4gICAgICAgIC8vIGNhY2hlV2lsbFVwZGF0ZSBwbHVnaW4sIGFuZCB0aGUgcmVzcG9uc2UgaXMgYSA0MDArIChub3RlOiB0aGlzIG1lYW5zXG4gICAgICAgIC8vIHRoYXQgYnkgZGVmYXVsdCBvcGFxdWUgcmVzcG9uc2VzIGNhbiBiZSBwcmVjYWNoZWQpLlxuICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2Uuc3RhdHVzID49IDQwMCAmJlxuICAgICAgICAgICAgIXRoaXMuX3VzZXNDdXN0b21DYWNoZWFibGVSZXNwb25zZUxvZ2ljKCkpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlU2FmZVRvUHJlY2FjaGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlU2FmZVRvUHJlY2FjaGUpIHtcbiAgICAgICAgICAgIC8vIFRocm93aW5nIGhlcmUgd2lsbCBsZWFkIHRvIHRoZSBgaW5zdGFsbGAgaGFuZGxlciBmYWlsaW5nLCB3aGljaFxuICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBkbyBpZiAqYW55KiBvZiB0aGUgcmVzcG9uc2VzIGFyZW4ndCBzYWZlIHRvIGNhY2hlLlxuICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignYmFkLXByZWNhY2hpbmctcmVzcG9uc2UnLCB7XG4gICAgICAgICAgICAgICAgdXJsOiByZXF1ZXN0LnVybCxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFueSB1c2VycyBwbHVnaW5zIHdlcmUgYWRkZWQgY29udGFpbmluZyB0aGVpciBvd25cbiAgICAgKiBgY2FjaGVXaWxsVXBkYXRlYCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGluZGljYXRlcyB3aGV0aGVyIHRoZSBkZWZhdWx0IGNhY2hlYWJsZSByZXNwb25zZSBsb2dpYyAoaS5lLlxuICAgICAqIDw0MDAsIGluY2x1ZGluZyBvcGFxdWUgcmVzcG9uc2VzKSBzaG91bGQgYmUgdXNlZC4gSWYgYSBjdXN0b20gcGx1Z2luXG4gICAgICogd2l0aCBhIGBjYWNoZVdpbGxVcGRhdGVgIGNhbGxiYWNrIGlzIHBhc3NlZCwgdGhlbiB0aGUgc3RyYXRlZ3kgc2hvdWxkXG4gICAgICogZGVmZXIgdG8gdGhhdCBwbHVnaW4ncyBsb2dpYy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VzZXNDdXN0b21DYWNoZWFibGVSZXNwb25zZUxvZ2ljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wbHVnaW5zLnNvbWUoKHBsdWdpbikgPT4gcGx1Z2luLmNhY2hlV2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgcGx1Z2luICE9PSBjb3B5UmVkaXJlY3RlZENhY2hlYWJsZVJlc3BvbnNlc1BsdWdpbik7XG4gICAgfVxufVxuZXhwb3J0IHsgUHJlY2FjaGVTdHJhdGVneSB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBjYWNoZU5hbWVzIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2NhY2hlTmFtZXMuanMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5qcyc7XG5pbXBvcnQgeyBXb3JrYm94RXJyb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCB7IHdhaXRVbnRpbCB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS93YWl0VW50aWwuanMnO1xuaW1wb3J0IHsgY3JlYXRlQ2FjaGVLZXkgfSBmcm9tICcuL3V0aWxzL2NyZWF0ZUNhY2hlS2V5LmpzJztcbmltcG9ydCB7IFByZWNhY2hlSW5zdGFsbFJlcG9ydFBsdWdpbiB9IGZyb20gJy4vdXRpbHMvUHJlY2FjaGVJbnN0YWxsUmVwb3J0UGx1Z2luLmpzJztcbmltcG9ydCB7IFByZWNhY2hlQ2FjaGVLZXlQbHVnaW4gfSBmcm9tICcuL3V0aWxzL1ByZWNhY2hlQ2FjaGVLZXlQbHVnaW4uanMnO1xuaW1wb3J0IHsgcHJpbnRDbGVhbnVwRGV0YWlscyB9IGZyb20gJy4vdXRpbHMvcHJpbnRDbGVhbnVwRGV0YWlscy5qcyc7XG5pbXBvcnQgeyBwcmludEluc3RhbGxEZXRhaWxzIH0gZnJvbSAnLi91dGlscy9wcmludEluc3RhbGxEZXRhaWxzLmpzJztcbmltcG9ydCB7IFByZWNhY2hlU3RyYXRlZ3kgfSBmcm9tICcuL1ByZWNhY2hlU3RyYXRlZ3kuanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogUGVyZm9ybXMgZWZmaWNpZW50IHByZWNhY2hpbmcgb2YgYXNzZXRzLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nXG4gKi9cbmNsYXNzIFByZWNhY2hlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFByZWNhY2hlQ29udHJvbGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2FjaGVOYW1lXSBUaGUgY2FjaGUgdG8gdXNlIGZvciBwcmVjYWNoaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wbHVnaW5zXSBQbHVnaW5zIHRvIHVzZSB3aGVuIHByZWNhY2hpbmcgYXMgd2VsbFxuICAgICAqIGFzIHJlc3BvbmRpbmcgdG8gZmV0Y2ggZXZlbnRzIGZvciBwcmVjYWNoZWQgYXNzZXRzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZmFsbGJhY2tUb05ldHdvcms9dHJ1ZV0gV2hldGhlciB0byBhdHRlbXB0IHRvXG4gICAgICogZ2V0IHRoZSByZXNwb25zZSBmcm9tIHRoZSBuZXR3b3JrIGlmIHRoZXJlJ3MgYSBwcmVjYWNoZSBtaXNzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgY2FjaGVOYW1lLCBwbHVnaW5zID0gW10sIGZhbGxiYWNrVG9OZXR3b3JrID0gdHJ1ZSB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5fdXJsc1RvQ2FjaGVLZXlzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl91cmxzVG9DYWNoZU1vZGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jYWNoZUtleXNUb0ludGVncml0aWVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zdHJhdGVneSA9IG5ldyBQcmVjYWNoZVN0cmF0ZWd5KHtcbiAgICAgICAgICAgIGNhY2hlTmFtZTogY2FjaGVOYW1lcy5nZXRQcmVjYWNoZU5hbWUoY2FjaGVOYW1lKSxcbiAgICAgICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgICAgICAuLi5wbHVnaW5zLFxuICAgICAgICAgICAgICAgIG5ldyBQcmVjYWNoZUNhY2hlS2V5UGx1Z2luKHsgcHJlY2FjaGVDb250cm9sbGVyOiB0aGlzIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGZhbGxiYWNrVG9OZXR3b3JrLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQmluZCB0aGUgaW5zdGFsbCBhbmQgYWN0aXZhdGUgbWV0aG9kcyB0byB0aGUgaW5zdGFuY2UuXG4gICAgICAgIHRoaXMuaW5zdGFsbCA9IHRoaXMuaW5zdGFsbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlID0gdGhpcy5hY3RpdmF0ZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5QcmVjYWNoZVN0cmF0ZWd5fSBUaGUgc3RyYXRlZ3kgY3JlYXRlZCBieSB0aGlzIGNvbnRyb2xsZXIgYW5kXG4gICAgICogdXNlZCB0byBjYWNoZSBhc3NldHMgYW5kIHJlc3BvbmQgdG8gZmV0Y2ggZXZlbnRzLlxuICAgICAqL1xuICAgIGdldCBzdHJhdGVneSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmF0ZWd5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGl0ZW1zIHRvIHRoZSBwcmVjYWNoZSBsaXN0LCByZW1vdmluZyBhbnkgZHVwbGljYXRlcyBhbmRcbiAgICAgKiBzdG9yZXMgdGhlIGZpbGVzIGluIHRoZVxuICAgICAqIFtcInByZWNhY2hlIGNhY2hlXCJde0BsaW5rIG1vZHVsZTp3b3JrYm94LWNvcmUuY2FjaGVOYW1lc30gd2hlbiB0aGUgc2VydmljZVxuICAgICAqIHdvcmtlciBpbnN0YWxscy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdHxzdHJpbmc+fSBbZW50cmllcz1bXV0gQXJyYXkgb2YgZW50cmllcyB0byBwcmVjYWNoZS5cbiAgICAgKi9cbiAgICBwcmVjYWNoZShlbnRyaWVzKSB7XG4gICAgICAgIHRoaXMuYWRkVG9DYWNoZUxpc3QoZW50cmllcyk7XG4gICAgICAgIGlmICghdGhpcy5faW5zdGFsbEFuZEFjdGl2ZUxpc3RlbmVyc0FkZGVkKSB7XG4gICAgICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2luc3RhbGwnLCB0aGlzLmluc3RhbGwpO1xuICAgICAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdhY3RpdmF0ZScsIHRoaXMuYWN0aXZhdGUpO1xuICAgICAgICAgICAgdGhpcy5faW5zdGFsbEFuZEFjdGl2ZUxpc3RlbmVyc0FkZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGFkZCBpdGVtcyB0byB0aGUgcHJlY2FjaGUgbGlzdCwgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICAgICAqIGFuZCBlbnN1cmluZyB0aGUgaW5mb3JtYXRpb24gaXMgdmFsaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuUHJlY2FjaGVDb250cm9sbGVyLlByZWNhY2hlRW50cnl8c3RyaW5nPn0gZW50cmllc1xuICAgICAqICAgICBBcnJheSBvZiBlbnRyaWVzIHRvIHByZWNhY2hlLlxuICAgICAqL1xuICAgIGFkZFRvQ2FjaGVMaXN0KGVudHJpZXMpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc0FycmF5KGVudHJpZXMsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1wcmVjYWNoaW5nJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdQcmVjYWNoZUNvbnRyb2xsZXInLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnYWRkVG9DYWNoZUxpc3QnLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ2VudHJpZXMnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsc1RvV2FybkFib3V0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvd29ya2JveC9pc3N1ZXMvMjI1OVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB1cmxzVG9XYXJuQWJvdXQucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbnRyeSAmJiBlbnRyeS5yZXZpc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdXJsc1RvV2FybkFib3V0LnB1c2goZW50cnkudXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgY2FjaGVLZXksIHVybCB9ID0gY3JlYXRlQ2FjaGVLZXkoZW50cnkpO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVNb2RlID0gKHR5cGVvZiBlbnRyeSAhPT0gJ3N0cmluZycgJiYgZW50cnkucmV2aXNpb24pID9cbiAgICAgICAgICAgICAgICAncmVsb2FkJyA6ICdkZWZhdWx0JztcbiAgICAgICAgICAgIGlmICh0aGlzLl91cmxzVG9DYWNoZUtleXMuaGFzKHVybCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl91cmxzVG9DYWNoZUtleXMuZ2V0KHVybCkgIT09IGNhY2hlS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignYWRkLXRvLWNhY2hlLWxpc3QtY29uZmxpY3RpbmctZW50cmllcycsIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFbnRyeTogdGhpcy5fdXJsc1RvQ2FjaGVLZXlzLmdldCh1cmwpLFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRFbnRyeTogY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSAnc3RyaW5nJyAmJiBlbnRyeS5pbnRlZ3JpdHkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FjaGVLZXlzVG9JbnRlZ3JpdGllcy5oYXMoY2FjaGVLZXkpICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlS2V5c1RvSW50ZWdyaXRpZXMuZ2V0KGNhY2hlS2V5KSAhPT0gZW50cnkuaW50ZWdyaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2FkZC10by1jYWNoZS1saXN0LWNvbmZsaWN0aW5nLWludGVncml0aWVzJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXlzVG9JbnRlZ3JpdGllcy5zZXQoY2FjaGVLZXksIGVudHJ5LmludGVncml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cmxzVG9DYWNoZUtleXMuc2V0KHVybCwgY2FjaGVLZXkpO1xuICAgICAgICAgICAgdGhpcy5fdXJsc1RvQ2FjaGVNb2Rlcy5zZXQodXJsLCBjYWNoZU1vZGUpO1xuICAgICAgICAgICAgaWYgKHVybHNUb1dhcm5BYm91dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2FybmluZ01lc3NhZ2UgPSBgV29ya2JveCBpcyBwcmVjYWNoaW5nIFVSTHMgd2l0aG91dCByZXZpc2lvbiBgICtcbiAgICAgICAgICAgICAgICAgICAgYGluZm86ICR7dXJsc1RvV2FybkFib3V0LmpvaW4oJywgJyl9XFxuVGhpcyBpcyBnZW5lcmFsbHkgTk9UIHNhZmUuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgTGVhcm4gbW9yZSBhdCBodHRwczovL2JpdC5seS93Yi1wcmVjYWNoZWA7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGNvbnNvbGUgZGlyZWN0bHkgdG8gZGlzcGxheSB0aGlzIHdhcm5pbmcgd2l0aG91dCBibG9hdGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBidW5kbGUgc2l6ZXMgYnkgcHVsbGluZyBpbiBhbGwgb2YgdGhlIGxvZ2dlciBjb2RlYmFzZSBpbiBwcm9kLlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4od2FybmluZ01lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4od2FybmluZ01lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVjYWNoZXMgbmV3IGFuZCB1cGRhdGVkIGFzc2V0cy4gQ2FsbCB0aGlzIG1ldGhvZCBmcm9tIHRoZSBzZXJ2aWNlIHdvcmtlclxuICAgICAqIGluc3RhbGwgZXZlbnQuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBjYWxscyBgZXZlbnQud2FpdFVudGlsKClgIGZvciB5b3UsIHNvIHlvdSBkbyBub3QgbmVlZFxuICAgICAqIHRvIGNhbGwgaXQgeW91cnNlbGYgaW4geW91ciBldmVudCBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtFdmVudH0gb3B0aW9ucy5ldmVudCBUaGUgaW5zdGFsbCBldmVudC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuSW5zdGFsbFJlc3VsdD59XG4gICAgICovXG4gICAgaW5zdGFsbChldmVudCkge1xuICAgICAgICByZXR1cm4gd2FpdFVudGlsKGV2ZW50LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YWxsUmVwb3J0UGx1Z2luID0gbmV3IFByZWNhY2hlSW5zdGFsbFJlcG9ydFBsdWdpbigpO1xuICAgICAgICAgICAgdGhpcy5zdHJhdGVneS5wbHVnaW5zLnB1c2goaW5zdGFsbFJlcG9ydFBsdWdpbik7XG4gICAgICAgICAgICAvLyBDYWNoZSBlbnRyaWVzIG9uZSBhdCBhIHRpbWUuXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8yNTI4XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFt1cmwsIGNhY2hlS2V5XSBvZiB0aGlzLl91cmxzVG9DYWNoZUtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlZ3JpdHkgPSB0aGlzLl9jYWNoZUtleXNUb0ludGVncml0aWVzLmdldChjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVNb2RlID0gdGhpcy5fdXJsc1RvQ2FjaGVNb2Rlcy5nZXQodXJsKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodXJsLCB7XG4gICAgICAgICAgICAgICAgICAgIGludGVncml0eSxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGNhY2hlTW9kZSxcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5zdHJhdGVneS5oYW5kbGVBbGwoe1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHsgY2FjaGVLZXkgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB1cGRhdGVkVVJMcywgbm90VXBkYXRlZFVSTHMgfSA9IGluc3RhbGxSZXBvcnRQbHVnaW47XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHByaW50SW5zdGFsbERldGFpbHModXBkYXRlZFVSTHMsIG5vdFVwZGF0ZWRVUkxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHVwZGF0ZWRVUkxzLCBub3RVcGRhdGVkVVJMcyB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhc3NldHMgdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQgaW4gdGhlIGN1cnJlbnQgcHJlY2FjaGUgbWFuaWZlc3QuXG4gICAgICogQ2FsbCB0aGlzIG1ldGhvZCBmcm9tIHRoZSBzZXJ2aWNlIHdvcmtlciBhY3RpdmF0ZSBldmVudC5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGNhbGxzIGBldmVudC53YWl0VW50aWwoKWAgZm9yIHlvdSwgc28geW91IGRvIG5vdCBuZWVkXG4gICAgICogdG8gY2FsbCBpdCB5b3Vyc2VsZiBpbiB5b3VyIGV2ZW50IGhhbmRsZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFeHRlbmRhYmxlRXZlbnR9XG4gICAgICogQHJldHVybiB7UHJvbWlzZTxtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nLkNsZWFudXBSZXN1bHQ+fVxuICAgICAqL1xuICAgIGFjdGl2YXRlKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB3YWl0VW50aWwoZXZlbnQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgc2VsZi5jYWNoZXMub3Blbih0aGlzLnN0cmF0ZWd5LmNhY2hlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50bHlDYWNoZWRSZXF1ZXN0cyA9IGF3YWl0IGNhY2hlLmtleXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkQ2FjaGVLZXlzID0gbmV3IFNldCh0aGlzLl91cmxzVG9DYWNoZUtleXMudmFsdWVzKCkpO1xuICAgICAgICAgICAgY29uc3QgZGVsZXRlZFVSTHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiBjdXJyZW50bHlDYWNoZWRSZXF1ZXN0cykge1xuICAgICAgICAgICAgICAgIGlmICghZXhwZWN0ZWRDYWNoZUtleXMuaGFzKHJlcXVlc3QudXJsKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWNoZS5kZWxldGUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRVUkxzLnB1c2gocmVxdWVzdC51cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRDbGVhbnVwRGV0YWlscyhkZWxldGVkVVJMcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkZWxldGVkVVJMcyB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG1hcHBpbmcgb2YgYSBwcmVjYWNoZWQgVVJMIHRvIHRoZSBjb3JyZXNwb25kaW5nIGNhY2hlIGtleSwgdGFraW5nXG4gICAgICogaW50byBhY2NvdW50IHRoZSByZXZpc2lvbiBpbmZvcm1hdGlvbiBmb3IgdGhlIFVSTC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge01hcDxzdHJpbmcsIHN0cmluZz59IEEgVVJMIHRvIGNhY2hlIGtleSBtYXBwaW5nLlxuICAgICAqL1xuICAgIGdldFVSTHNUb0NhY2hlS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VybHNUb0NhY2hlS2V5cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHRoZSBVUkxzIHRoYXQgaGF2ZSBiZWVuIHByZWNhY2hlZCBieSB0aGUgY3VycmVudFxuICAgICAqIHNlcnZpY2Ugd29ya2VyLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gVGhlIHByZWNhY2hlZCBVUkxzLlxuICAgICAqL1xuICAgIGdldENhY2hlZFVSTHMoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5fdXJsc1RvQ2FjaGVLZXlzLmtleXMoKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNhY2hlIGtleSB1c2VkIGZvciBzdG9yaW5nIGEgZ2l2ZW4gVVJMLiBJZiB0aGF0IFVSTCBpc1xuICAgICAqIHVudmVyc2lvbmVkLCBsaWtlIGAvaW5kZXguaHRtbCcsIHRoZW4gdGhlIGNhY2hlIGtleSB3aWxsIGJlIHRoZSBvcmlnaW5hbFxuICAgICAqIFVSTCB3aXRoIGEgc2VhcmNoIHBhcmFtZXRlciBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgQSBVUkwgd2hvc2UgY2FjaGUga2V5IHlvdSB3YW50IHRvIGxvb2sgdXAuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmVyc2lvbmVkIFVSTCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgY2FjaGUga2V5XG4gICAgICogZm9yIHRoZSBvcmlnaW5hbCBVUkwsIG9yIHVuZGVmaW5lZCBpZiB0aGF0IFVSTCBpc24ndCBwcmVjYWNoZWQuXG4gICAgICovXG4gICAgZ2V0Q2FjaGVLZXlGb3JVUkwodXJsKSB7XG4gICAgICAgIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VybHNUb0NhY2hlS2V5cy5nZXQodXJsT2JqZWN0LmhyZWYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGFjdHMgYXMgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvclxuICAgICAqIFtgY2FjaGUubWF0Y2goKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYWNoZS9tYXRjaClcbiAgICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgZGlmZmVyZW5jZXM6XG4gICAgICpcbiAgICAgKiAtIEl0IGtub3dzIHdoYXQgdGhlIG5hbWUgb2YgdGhlIHByZWNhY2hlIGlzLCBhbmQgb25seSBjaGVja3MgaW4gdGhhdCBjYWNoZS5cbiAgICAgKiAtIEl0IGFsbG93cyB5b3UgdG8gcGFzcyBpbiBhbiBcIm9yaWdpbmFsXCIgVVJMIHdpdGhvdXQgdmVyc2lvbmluZyBwYXJhbWV0ZXJzLFxuICAgICAqIGFuZCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgbG9vayB1cCB0aGUgY29ycmVjdCBjYWNoZSBrZXkgZm9yIHRoZSBjdXJyZW50bHlcbiAgICAgKiBhY3RpdmUgcmV2aXNpb24gb2YgdGhhdCBVUkwuXG4gICAgICpcbiAgICAgKiBFLmcuLCBgbWF0Y2hQcmVjYWNoZSgnaW5kZXguaHRtbCcpYCB3aWxsIGZpbmQgdGhlIGNvcnJlY3QgcHJlY2FjaGVkXG4gICAgICogcmVzcG9uc2UgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIHNlcnZpY2Ugd29ya2VyLCBldmVuIGlmIHRoZSBhY3R1YWwgY2FjaGVcbiAgICAgKiBrZXkgaXMgYCcvaW5kZXguaHRtbD9fX1dCX1JFVklTSU9OX189MTIzNGFiY2QnYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfFJlcXVlc3R9IHJlcXVlc3QgVGhlIGtleSAod2l0aG91dCByZXZpc2lvbmluZyBwYXJhbWV0ZXJzKVxuICAgICAqIHRvIGxvb2sgdXAgaW4gdGhlIHByZWNhY2hlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8UmVzcG9uc2V8dW5kZWZpbmVkPn1cbiAgICAgKi9cbiAgICBhc3luYyBtYXRjaFByZWNhY2hlKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgdXJsID0gcmVxdWVzdCBpbnN0YW5jZW9mIFJlcXVlc3QgPyByZXF1ZXN0LnVybCA6IHJlcXVlc3Q7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5nZXRDYWNoZUtleUZvclVSTCh1cmwpO1xuICAgICAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgc2VsZi5jYWNoZXMub3Blbih0aGlzLnN0cmF0ZWd5LmNhY2hlTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUubWF0Y2goY2FjaGVLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGxvb2tzIHVwIGB1cmxgIGluIHRoZSBwcmVjYWNoZSAodGFraW5nIGludG9cbiAgICAgKiBhY2NvdW50IHJldmlzaW9uIGluZm9ybWF0aW9uKSwgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgYFJlc3BvbnNlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIHByZWNhY2hlZCBVUkwgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGxvb2t1cCB0aGVcbiAgICAgKiBgUmVzcG9uc2VgLlxuICAgICAqIEByZXR1cm4ge21vZHVsZTp3b3JrYm94LXJvdXRpbmd+aGFuZGxlckNhbGxiYWNrfVxuICAgICAqL1xuICAgIGNyZWF0ZUhhbmRsZXJCb3VuZFRvVVJMKHVybCkge1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuZ2V0Q2FjaGVLZXlGb3JVUkwodXJsKTtcbiAgICAgICAgaWYgKCFjYWNoZUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignbm9uLXByZWNhY2hlZC11cmwnLCB7IHVybCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIG9wdGlvbnMucmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCk7XG4gICAgICAgICAgICBvcHRpb25zLnBhcmFtcyA9IHsgY2FjaGVLZXksIC4uLm9wdGlvbnMucGFyYW1zIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJhdGVneS5oYW5kbGUob3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IHsgUHJlY2FjaGVDb250cm9sbGVyIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBQcmVjYWNoZUNvbnRyb2xsZXIgfSBmcm9tICcuLi9QcmVjYWNoZUNvbnRyb2xsZXIuanMnO1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG5sZXQgcHJlY2FjaGVDb250cm9sbGVyO1xuLyoqXG4gKiBAcmV0dXJuIHtQcmVjYWNoZUNvbnRyb2xsZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgZ2V0T3JDcmVhdGVQcmVjYWNoZUNvbnRyb2xsZXIgPSAoKSA9PiB7XG4gICAgaWYgKCFwcmVjYWNoZUNvbnRyb2xsZXIpIHtcbiAgICAgICAgcHJlY2FjaGVDb250cm9sbGVyID0gbmV3IFByZWNhY2hlQ29udHJvbGxlcigpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlY2FjaGVDb250cm9sbGVyO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gQHRzLWlnbm9yZVxudHJ5IHtcbiAgICBzZWxmWyd3b3JrYm94OnJvdXRpbmc6Ni4wLjInXSAmJiBfKCk7XG59XG5jYXRjaCAoZSkgeyB9XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogVGhlIGRlZmF1bHQgSFRUUCBtZXRob2QsICdHRVQnLCB1c2VkIHdoZW4gdGhlcmUncyBubyBzcGVjaWZpYyBtZXRob2RcbiAqIGNvbmZpZ3VyZWQgZm9yIGEgcm91dGUuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdE1ldGhvZCA9ICdHRVQnO1xuLyoqXG4gKiBUaGUgbGlzdCBvZiB2YWxpZCBIVFRQIG1ldGhvZHMgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3RzIHRoYXQgY291bGQgYmUgcm91dGVkLlxuICpcbiAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCB2YWxpZE1ldGhvZHMgPSBbXG4gICAgJ0RFTEVURScsXG4gICAgJ0dFVCcsXG4gICAgJ0hFQUQnLFxuICAgICdQQVRDSCcsXG4gICAgJ1BPU1QnLFxuICAgICdQVVQnLFxuXTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9hc3NlcnQuanMnO1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKXxPYmplY3R9IGhhbmRsZXIgRWl0aGVyIGEgZnVuY3Rpb24sIG9yIGFuIG9iamVjdCB3aXRoIGFcbiAqICdoYW5kbGUnIG1ldGhvZC5cbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggYSBoYW5kbGUgbWV0aG9kLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVIYW5kbGVyID0gKGhhbmRsZXIpID0+IHtcbiAgICBpZiAoaGFuZGxlciAmJiB0eXBlb2YgaGFuZGxlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydC5oYXNNZXRob2QoaGFuZGxlciwgJ2hhbmRsZScsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdSb3V0ZScsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnaGFuZGxlcicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBhc3NlcnQuaXNUeXBlKGhhbmRsZXIsICdmdW5jdGlvbicsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdSb3V0ZScsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnaGFuZGxlcicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBoYW5kbGU6IGhhbmRsZXIgfTtcbiAgICB9XG59O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBkZWZhdWx0TWV0aG9kLCB2YWxpZE1ldGhvZHMgfSBmcm9tICcuL3V0aWxzL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBub3JtYWxpemVIYW5kbGVyIH0gZnJvbSAnLi91dGlscy9ub3JtYWxpemVIYW5kbGVyLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEEgYFJvdXRlYCBjb25zaXN0cyBvZiBhIHBhaXIgb2YgY2FsbGJhY2sgZnVuY3Rpb25zLCBcIm1hdGNoXCIgYW5kIFwiaGFuZGxlclwiLlxuICogVGhlIFwibWF0Y2hcIiBjYWxsYmFjayBkZXRlcm1pbmUgaWYgYSByb3V0ZSBzaG91bGQgYmUgdXNlZCB0byBcImhhbmRsZVwiIGFcbiAqIHJlcXVlc3QgYnkgcmV0dXJuaW5nIGEgbm9uLWZhbHN5IHZhbHVlIGlmIGl0IGNhbi4gVGhlIFwiaGFuZGxlclwiIGNhbGxiYWNrXG4gKiBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBhIG1hdGNoIGFuZCBzaG91bGQgcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzXG4gKiB0byBhIGBSZXNwb25zZWAuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXJvdXRpbmdcbiAqL1xuY2xhc3MgUm91dGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBSb3V0ZSBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtcm91dGluZ35tYXRjaENhbGxiYWNrfSBtYXRjaFxuICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHJvdXRlIG1hdGNoZXMgYSBnaXZlblxuICAgICAqIGBmZXRjaGAgZXZlbnQgYnkgcmV0dXJuaW5nIGEgbm9uLWZhbHN5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtcm91dGluZ35oYW5kbGVyQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFja1xuICAgICAqIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIFByb21pc2UgcmVzb2x2aW5nIHRvIGEgUmVzcG9uc2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttZXRob2Q9J0dFVCddIFRoZSBIVFRQIG1ldGhvZCB0byBtYXRjaCB0aGUgUm91dGVcbiAgICAgKiBhZ2FpbnN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1hdGNoLCBoYW5kbGVyLCBtZXRob2QgPSBkZWZhdWx0TWV0aG9kKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBhc3NlcnQuaXNUeXBlKG1hdGNoLCAnZnVuY3Rpb24nLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUm91dGUnLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnY29uc3RydWN0b3InLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ21hdGNoJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGFzc2VydC5pc09uZU9mKG1ldGhvZCwgdmFsaWRNZXRob2RzLCB7IHBhcmFtTmFtZTogJ21ldGhvZCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlc2UgdmFsdWVzIGFyZSByZWZlcmVuY2VkIGRpcmVjdGx5IGJ5IFJvdXRlciBzbyBjYW5ub3QgYmVcbiAgICAgICAgLy8gYWx0ZXJlZCBieSBtaW5pZmljYXRvbi5cbiAgICAgICAgdGhpcy5oYW5kbGVyID0gbm9ybWFsaXplSGFuZGxlcihoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5tYXRjaCA9IG1hdGNoO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB9XG59XG5leHBvcnQgeyBSb3V0ZSB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IFJvdXRlIH0gZnJvbSAnLi9Sb3V0ZS5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBSZWdFeHBSb3V0ZSBtYWtlcyBpdCBlYXN5IHRvIGNyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBiYXNlZFxuICogW1JvdXRlXXtAbGluayBtb2R1bGU6d29ya2JveC1yb3V0aW5nLlJvdXRlfS5cbiAqXG4gKiBGb3Igc2FtZS1vcmlnaW4gcmVxdWVzdHMgdGhlIFJlZ0V4cCBvbmx5IG5lZWRzIHRvIG1hdGNoIHBhcnQgb2YgdGhlIFVSTC4gRm9yXG4gKiByZXF1ZXN0cyBhZ2FpbnN0IHRoaXJkLXBhcnR5IHNlcnZlcnMsIHlvdSBtdXN0IGRlZmluZSBhIFJlZ0V4cCB0aGF0IG1hdGNoZXNcbiAqIHRoZSBzdGFydCBvZiB0aGUgVVJMLlxuICpcbiAqIFtTZWUgdGhlIG1vZHVsZSBkb2NzIGZvciBpbmZvLl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3Rvb2xzL3dvcmtib3gvbW9kdWxlcy93b3JrYm94LXJvdXRpbmd9XG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXJvdXRpbmdcbiAqIEBleHRlbmRzIG1vZHVsZTp3b3JrYm94LXJvdXRpbmcuUm91dGVcbiAqL1xuY2xhc3MgUmVnRXhwUm91dGUgZXh0ZW5kcyBSb3V0ZSB7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBjb250YWluc1xuICAgICAqIFtjYXB0dXJlIGdyb3Vwc117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwI2dyb3VwaW5nLWJhY2stcmVmZXJlbmNlc30sXG4gICAgICogdGhlIGNhcHR1cmVkIHZhbHVlcyB3aWxsIGJlIHBhc3NlZCB0byB0aGVcbiAgICAgKiBbaGFuZGxlcidzXXtAbGluayBtb2R1bGU6d29ya2JveC1yb3V0aW5nfmhhbmRsZXJDYWxsYmFja30gYHBhcmFtc2BcbiAgICAgKiBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSByZWdFeHAgVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBhZ2FpbnN0IFVSTHMuXG4gICAgICogQHBhcmFtIHttb2R1bGU6d29ya2JveC1yb3V0aW5nfmhhbmRsZXJDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrXG4gICAgICogZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZSByZXN1bHRpbmcgaW4gYSBSZXNwb25zZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21ldGhvZD0nR0VUJ10gVGhlIEhUVFAgbWV0aG9kIHRvIG1hdGNoIHRoZSBSb3V0ZVxuICAgICAqIGFnYWluc3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVnRXhwLCBoYW5kbGVyLCBtZXRob2QpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc0luc3RhbmNlKHJlZ0V4cCwgUmVnRXhwLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUmVnRXhwUm91dGUnLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnY29uc3RydWN0b3InLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ3BhdHRlcm4nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0Y2ggPSAoeyB1cmwgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVnRXhwLmV4ZWModXJsLmhyZWYpO1xuICAgICAgICAgICAgLy8gUmV0dXJuIGltbWVkaWF0ZWx5IGlmIHRoZXJlJ3Mgbm8gbWF0Y2guXG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlcXVpcmUgdGhhdCB0aGUgbWF0Y2ggc3RhcnQgYXQgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgVVJMIHN0cmluZ1xuICAgICAgICAgICAgLy8gaWYgaXQncyBhIGNyb3NzLW9yaWdpbiByZXF1ZXN0LlxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvd29ya2JveC9pc3N1ZXMvMjgxIGZvciB0aGUgY29udGV4dFxuICAgICAgICAgICAgLy8gYmVoaW5kIHRoaXMgYmVoYXZpb3IuXG4gICAgICAgICAgICBpZiAoKHVybC5vcmlnaW4gIT09IGxvY2F0aW9uLm9yaWdpbikgJiYgKHJlc3VsdC5pbmRleCAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFRoZSByZWd1bGFyIGV4cHJlc3Npb24gJyR7cmVnRXhwfScgb25seSBwYXJ0aWFsbHkgbWF0Y2hlZCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBhZ2FpbnN0IHRoZSBjcm9zcy1vcmlnaW4gVVJMICcke3VybH0nLiBSZWdFeHBSb3V0ZSdzIHdpbGwgb25seSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBoYW5kbGUgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzIGlmIHRoZXkgbWF0Y2ggdGhlIGVudGlyZSBVUkwuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSByb3V0ZSBtYXRjaGVzLCBidXQgdGhlcmUgYXJlbid0IGFueSBjYXB0dXJlIGdyb3VwcyBkZWZpbmVkLCB0aGVuXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgcmV0dXJuIFtdLCB3aGljaCBpcyB0cnV0aHkgYW5kIHRoZXJlZm9yZSBzdWZmaWNpZW50IHRvXG4gICAgICAgICAgICAvLyBpbmRpY2F0ZSBhIG1hdGNoLlxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGNhcHR1cmUgZ3JvdXBzLCB0aGVuIGl0IHdpbGwgcmV0dXJuIHRoZWlyIHZhbHVlcy5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuc2xpY2UoMSk7XG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKG1hdGNoLCBoYW5kbGVyLCBtZXRob2QpO1xuICAgIH1cbn1cbmV4cG9ydCB7IFJlZ0V4cFJvdXRlIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzJztcbmltcG9ydCB7IGdldEZyaWVuZGx5VVJMIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2dldEZyaWVuZGx5VVJMLmpzJztcbmltcG9ydCB7IGRlZmF1bHRNZXRob2QgfSBmcm9tICcuL3V0aWxzL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IG5vcm1hbGl6ZUhhbmRsZXIgfSBmcm9tICcuL3V0aWxzL25vcm1hbGl6ZUhhbmRsZXIuanMnO1xuaW1wb3J0IHsgV29ya2JveEVycm9yIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBUaGUgUm91dGVyIGNhbiBiZSB1c2VkIHRvIHByb2Nlc3MgYSBGZXRjaEV2ZW50IHRocm91Z2ggb25lIG9yIG1vcmVcbiAqIFtSb3V0ZXNde0BsaW5rIG1vZHVsZTp3b3JrYm94LXJvdXRpbmcuUm91dGV9IHJlc3BvbmRpbmcgIHdpdGggYSBSZXF1ZXN0IGlmXG4gKiBhIG1hdGNoaW5nIHJvdXRlIGV4aXN0cy5cbiAqXG4gKiBJZiBubyByb3V0ZSBtYXRjaGVzIGEgZ2l2ZW4gYSByZXF1ZXN0LCB0aGUgUm91dGVyIHdpbGwgdXNlIGEgXCJkZWZhdWx0XCJcbiAqIGhhbmRsZXIgaWYgb25lIGlzIGRlZmluZWQuXG4gKlxuICogU2hvdWxkIHRoZSBtYXRjaGluZyBSb3V0ZSB0aHJvdyBhbiBlcnJvciwgdGhlIFJvdXRlciB3aWxsIHVzZSBhIFwiY2F0Y2hcIlxuICogaGFuZGxlciBpZiBvbmUgaXMgZGVmaW5lZCB0byBncmFjZWZ1bGx5IGRlYWwgd2l0aCBpc3N1ZXMgYW5kIHJlc3BvbmQgd2l0aCBhXG4gKiBSZXF1ZXN0LlxuICpcbiAqIElmIGEgcmVxdWVzdCBtYXRjaGVzIG11bHRpcGxlIHJvdXRlcywgdGhlICoqZWFybGllc3QqKiByZWdpc3RlcmVkIHJvdXRlIHdpbGxcbiAqIGJlIHVzZWQgdG8gcmVzcG9uZCB0byB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtcm91dGluZ1xuICovXG5jbGFzcyBSb3V0ZXIge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IFJvdXRlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fcm91dGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9kZWZhdWx0SGFuZGxlck1hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7TWFwPHN0cmluZywgQXJyYXk8bW9kdWxlOndvcmtib3gtcm91dGluZy5Sb3V0ZT4+fSByb3V0ZXMgQSBgTWFwYCBvZiBIVFRQXG4gICAgICogbWV0aG9kIG5hbWUgKCdHRVQnLCBldGMuKSB0byBhbiBhcnJheSBvZiBhbGwgdGhlIGNvcnJlc3BvbmRpbmcgYFJvdXRlYFxuICAgICAqIGluc3RhbmNlcyB0aGF0IGFyZSByZWdpc3RlcmVkLlxuICAgICAqL1xuICAgIGdldCByb3V0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3V0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBmZXRjaCBldmVudCBsaXN0ZW5lciB0byByZXNwb25kIHRvIGV2ZW50cyB3aGVuIGEgcm91dGUgbWF0Y2hlc1xuICAgICAqIHRoZSBldmVudCdzIHJlcXVlc3QuXG4gICAgICovXG4gICAgYWRkRmV0Y2hMaXN0ZW5lcigpIHtcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjgzNTcjaXNzdWVjb21tZW50LTQzNjQ4NDcwNVxuICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2ZldGNoJywgKChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyByZXF1ZXN0IH0gPSBldmVudDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IHRoaXMuaGFuZGxlUmVxdWVzdCh7IHJlcXVlc3QsIGV2ZW50IH0pO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnJlc3BvbmRXaXRoKHJlc3BvbnNlUHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG1lc3NhZ2UgZXZlbnQgbGlzdGVuZXIgZm9yIFVSTHMgdG8gY2FjaGUgZnJvbSB0aGUgd2luZG93LlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIHRvIGNhY2hlIHJlc291cmNlcyBsb2FkZWQgb24gdGhlIHBhZ2UgcHJpb3IgdG8gd2hlbiB0aGVcbiAgICAgKiBzZXJ2aWNlIHdvcmtlciBzdGFydGVkIGNvbnRyb2xsaW5nIGl0LlxuICAgICAqXG4gICAgICogVGhlIGZvcm1hdCBvZiB0aGUgbWVzc2FnZSBkYXRhIHNlbnQgZnJvbSB0aGUgd2luZG93IHNob3VsZCBiZSBhcyBmb2xsb3dzLlxuICAgICAqIFdoZXJlIHRoZSBgdXJsc1RvQ2FjaGVgIGFycmF5IG1heSBjb25zaXN0IG9mIFVSTCBzdHJpbmdzIG9yIGFuIGFycmF5IG9mXG4gICAgICogVVJMIHN0cmluZyArIGByZXF1ZXN0SW5pdGAgb2JqZWN0ICh0aGUgc2FtZSBhcyB5b3UnZCBwYXNzIHRvIGBmZXRjaCgpYCkuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB7XG4gICAgICogICB0eXBlOiAnQ0FDSEVfVVJMUycsXG4gICAgICogICBwYXlsb2FkOiB7XG4gICAgICogICAgIHVybHNUb0NhY2hlOiBbXG4gICAgICogICAgICAgJy4vc2NyaXB0MS5qcycsXG4gICAgICogICAgICAgJy4vc2NyaXB0Mi5qcycsXG4gICAgICogICAgICAgWycuL3NjcmlwdDMuanMnLCB7bW9kZTogJ25vLWNvcnMnfV0sXG4gICAgICogICAgIF0sXG4gICAgICogICB9LFxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhZGRDYWNoZUxpc3RlbmVyKCkge1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yODM1NyNpc3N1ZWNvbW1lbnQtNDM2NDg0NzA1XG4gICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsICgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhICYmIGV2ZW50LmRhdGEudHlwZSA9PT0gJ0NBQ0hFX1VSTFMnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXlsb2FkIH0gPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgQ2FjaGluZyBVUkxzIGZyb20gdGhlIHdpbmRvd2AsIHBheWxvYWQudXJsc1RvQ2FjaGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0UHJvbWlzZXMgPSBQcm9taXNlLmFsbChwYXlsb2FkLnVybHNUb0NhY2hlLm1hcCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5ID0gW2VudHJ5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoLi4uZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXF1ZXN0KHsgcmVxdWVzdCwgZXZlbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8ocGhpbGlwd2FsdG9uKTogVHlwZVNjcmlwdCBlcnJvcnMgd2l0aG91dCB0aGlzIHR5cGVjYXN0IGZvclxuICAgICAgICAgICAgICAgICAgICAvLyBzb21lIHJlYXNvbiAocHJvYmFibHkgYSBidWcpLiBUaGUgcmVhbCB0eXBlIGhlcmUgc2hvdWxkIHdvcmsgYnV0XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3Q6IGBBcnJheTxQcm9taXNlPFJlc3BvbnNlPiB8IHVuZGVmaW5lZD5gLlxuICAgICAgICAgICAgICAgIH0pKTsgLy8gVHlwZVNjcmlwdFxuICAgICAgICAgICAgICAgIGV2ZW50LndhaXRVbnRpbChyZXF1ZXN0UHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgIC8vIElmIGEgTWVzc2FnZUNoYW5uZWwgd2FzIHVzZWQsIHJlcGx5IHRvIHRoZSBtZXNzYWdlIG9uIHN1Y2Nlc3MuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnBvcnRzICYmIGV2ZW50LnBvcnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RQcm9taXNlcy50aGVuKCgpID0+IGV2ZW50LnBvcnRzWzBdLnBvc3RNZXNzYWdlKHRydWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIHJvdXRpbmcgcnVsZXMgdG8gYSBGZXRjaEV2ZW50IG9iamVjdCB0byBnZXQgYSBSZXNwb25zZSBmcm9tIGFuXG4gICAgICogYXBwcm9wcmlhdGUgUm91dGUncyBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R9IG9wdGlvbnMucmVxdWVzdCBUaGUgcmVxdWVzdCB0byBoYW5kbGUuXG4gICAgICogQHBhcmFtIHtFeHRlbmRhYmxlRXZlbnR9IG9wdGlvbnMuZXZlbnQgVGhlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZVxuICAgICAqICAgICByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8UmVzcG9uc2U+fHVuZGVmaW5lZH0gQSBwcm9taXNlIGlzIHJldHVybmVkIGlmIGFcbiAgICAgKiAgICAgcmVnaXN0ZXJlZCByb3V0ZSBjYW4gaGFuZGxlIHRoZSByZXF1ZXN0LiBJZiB0aGVyZSBpcyBubyBtYXRjaGluZ1xuICAgICAqICAgICByb3V0ZSBhbmQgdGhlcmUncyBubyBgZGVmYXVsdEhhbmRsZXJgLCBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBoYW5kbGVSZXF1ZXN0KHsgcmVxdWVzdCwgZXZlbnQgfSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgYXNzZXJ0LmlzSW5zdGFuY2UocmVxdWVzdCwgUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXJvdXRpbmcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1JvdXRlcicsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdoYW5kbGVSZXF1ZXN0JyxcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdvcHRpb25zLnJlcXVlc3QnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCwgbG9jYXRpb24uaHJlZik7XG4gICAgICAgIGlmICghdXJsLnByb3RvY29sLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFdvcmtib3ggUm91dGVyIG9ubHkgc3VwcG9ydHMgVVJMcyB0aGF0IHN0YXJ0IHdpdGggJ2h0dHAnLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNhbWVPcmlnaW4gPSB1cmwub3JpZ2luID09PSBsb2NhdGlvbi5vcmlnaW47XG4gICAgICAgIGNvbnN0IHsgcGFyYW1zLCByb3V0ZSB9ID0gdGhpcy5maW5kTWF0Y2hpbmdSb3V0ZSh7XG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBzYW1lT3JpZ2luLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGhhbmRsZXIgPSByb3V0ZSAmJiByb3V0ZS5oYW5kbGVyO1xuICAgICAgICBjb25zdCBkZWJ1Z01lc3NhZ2VzID0gW107XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGRlYnVnTWVzc2FnZXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIGBGb3VuZCBhIHJvdXRlIHRvIGhhbmRsZSB0aGlzIHJlcXVlc3Q6YCwgcm91dGUsXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z01lc3NhZ2VzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgYFBhc3NpbmcgdGhlIGZvbGxvd2luZyBwYXJhbXMgdG8gdGhlIHJvdXRlJ3MgaGFuZGxlcjpgLCBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgaGFuZGxlciBiZWNhdXNlIHRoZXJlIHdhcyBubyBtYXRjaGluZyByb3V0ZSwgdGhlblxuICAgICAgICAvLyBmYWxsIGJhY2sgdG8gZGVmYXVsdEhhbmRsZXIgaWYgdGhhdCdzIGRlZmluZWQuXG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgICAgICBpZiAoIWhhbmRsZXIgJiYgdGhpcy5fZGVmYXVsdEhhbmRsZXJNYXAuaGFzKG1ldGhvZCkpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZGVidWdNZXNzYWdlcy5wdXNoKGBGYWlsZWQgdG8gZmluZCBhIG1hdGNoaW5nIHJvdXRlLiBGYWxsaW5nIGAgK1xuICAgICAgICAgICAgICAgICAgICBgYmFjayB0byB0aGUgZGVmYXVsdCBoYW5kbGVyIGZvciAke21ldGhvZH0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVyID0gdGhpcy5fZGVmYXVsdEhhbmRsZXJNYXAuZ2V0KG1ldGhvZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIE5vIGhhbmRsZXIgc28gV29ya2JveCB3aWxsIGRvIG5vdGhpbmcuIElmIGxvZ3MgaXMgc2V0IG9mIGRlYnVnXG4gICAgICAgICAgICAgICAgLy8gaS5lLiB2ZXJib3NlLCB3ZSBzaG91bGQgcHJpbnQgb3V0IHRoaXMgaW5mb3JtYXRpb24uXG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBObyByb3V0ZSBmb3VuZCBmb3I6ICR7Z2V0RnJpZW5kbHlVUkwodXJsKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIGhhbmRsZXIsIG1lYW5pbmcgV29ya2JveCBpcyBnb2luZyB0byBoYW5kbGUgdGhlIHJvdXRlLlxuICAgICAgICAgICAgLy8gcHJpbnQgdGhlIHJvdXRpbmcgZGV0YWlscyB0byB0aGUgY29uc29sZS5cbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgUm91dGVyIGlzIHJlc3BvbmRpbmcgdG86ICR7Z2V0RnJpZW5kbHlVUkwodXJsKX1gKTtcbiAgICAgICAgICAgIGRlYnVnTWVzc2FnZXMuZm9yRWFjaCgobXNnKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobXNnKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKC4uLm1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXcmFwIGluIHRyeSBhbmQgY2F0Y2ggaW4gY2FzZSB0aGUgaGFuZGxlIG1ldGhvZCB0aHJvd3MgYSBzeW5jaHJvbm91c1xuICAgICAgICAvLyBlcnJvci4gSXQgc2hvdWxkIHN0aWxsIGNhbGxiYWNrIHRvIHRoZSBjYXRjaCBoYW5kbGVyLlxuICAgICAgICBsZXQgcmVzcG9uc2VQcm9taXNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlID0gaGFuZGxlci5oYW5kbGUoeyB1cmwsIHJlcXVlc3QsIGV2ZW50LCBwYXJhbXMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlID0gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2VQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSAmJiB0aGlzLl9jYXRjaEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZSA9IHJlc3BvbnNlUHJvbWlzZS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RpbGwgaW5jbHVkZSBVUkwgaGVyZSBhcyBpdCB3aWxsIGJlIGFzeW5jIGZyb20gdGhlIGNvbnNvbGUgZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIG1heSBub3QgbWFrZSBzZW5zZSB3aXRob3V0IHRoZSBVUkxcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBFcnJvciB0aHJvd24gd2hlbiByZXNwb25kaW5nIHRvOiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAgJHtnZXRGcmllbmRseVVSTCh1cmwpfS4gRmFsbGluZyBiYWNrIHRvIENhdGNoIEhhbmRsZXIuYCk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRXJyb3IgdGhyb3duIGJ5OmAsIHJvdXRlKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2F0Y2hIYW5kbGVyLmhhbmRsZSh7IHVybCwgcmVxdWVzdCwgZXZlbnQgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2VQcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgYSByZXF1ZXN0IGFuZCBVUkwgKGFuZCBvcHRpb25hbGx5IGFuIGV2ZW50KSBhZ2FpbnN0IHRoZSBsaXN0IG9mXG4gICAgICogcmVnaXN0ZXJlZCByb3V0ZXMsIGFuZCBpZiB0aGVyZSdzIGEgbWF0Y2gsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiByb3V0ZSBhbG9uZyB3aXRoIGFueSBwYXJhbXMgZ2VuZXJhdGVkIGJ5IHRoZSBtYXRjaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtVUkx9IG9wdGlvbnMudXJsXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fSBvcHRpb25zLnJlcXVlc3QgVGhlIHJlcXVlc3QgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtFdmVudH0gb3B0aW9ucy5ldmVudCBUaGUgY29ycmVzcG9uZGluZyBldmVudC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGByb3V0ZWAgYW5kIGBwYXJhbXNgIHByb3BlcnRpZXMuXG4gICAgICogICAgIFRoZXkgYXJlIHBvcHVsYXRlZCBpZiBhIG1hdGNoaW5nIHJvdXRlIHdhcyBmb3VuZCBvciBgdW5kZWZpbmVkYFxuICAgICAqICAgICBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZmluZE1hdGNoaW5nUm91dGUoeyB1cmwsIHNhbWVPcmlnaW4sIHJlcXVlc3QsIGV2ZW50IH0pIHtcbiAgICAgICAgY29uc3Qgcm91dGVzID0gdGhpcy5fcm91dGVzLmdldChyZXF1ZXN0Lm1ldGhvZCkgfHwgW107XG4gICAgICAgIGZvciAoY29uc3Qgcm91dGUgb2Ygcm91dGVzKSB7XG4gICAgICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hSZXN1bHQgPSByb3V0ZS5tYXRjaCh7IHVybCwgc2FtZU9yaWdpbiwgcmVxdWVzdCwgZXZlbnQgfSk7XG4gICAgICAgICAgICBpZiAobWF0Y2hSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXYXJuIGRldmVsb3BlcnMgdGhhdCB1c2luZyBhbiBhc3luYyBtYXRjaENhbGxiYWNrIGlzIGFsbW9zdCBhbHdheXNcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IHRoZSByaWdodCB0aGluZyB0byBkby4gXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBXaGlsZSByb3V0aW5nICR7Z2V0RnJpZW5kbHlVUkwodXJsKX0sIGFuIGFzeW5jIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBtYXRjaENhbGxiYWNrIGZ1bmN0aW9uIHdhcyB1c2VkLiBQbGVhc2UgY29udmVydCB0aGUgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGZvbGxvd2luZyByb3V0ZSB0byB1c2UgYSBzeW5jaHJvbm91cyBtYXRjaENhbGxiYWNrIGZ1bmN0aW9uOmAsIHJvdXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8yMDc5XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gbWF0Y2hSZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWF0Y2hSZXN1bHQpICYmIG1hdGNoUmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIHBhc3NpbmcgYW4gZW1wdHkgYXJyYXkgaW4gYXMgcGFyYW1zLCB1c2UgdW5kZWZpbmVkLlxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChtYXRjaFJlc3VsdC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG1hdGNoUmVzdWx0KS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgcGFzc2luZyBhbiBlbXB0eSBvYmplY3QgaW4gYXMgcGFyYW1zLCB1c2UgdW5kZWZpbmVkLlxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtYXRjaFJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciB0aGUgYm9vbGVhbiB2YWx1ZSB0cnVlIChyYXRoZXIgdGhhbiBqdXN0IHNvbWV0aGluZyB0cnV0aC15KSxcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc2V0IHBhcmFtcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvd29ya2JveC9wdWxsLzIxMzQjaXNzdWVjb21tZW50LTUxMzkyNDM1M1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJldHVybiBlYXJseSBpZiBoYXZlIGEgbWF0Y2guXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcm91dGUsIHBhcmFtcyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIG1hdGNoIHdhcyBmb3VuZCBhYm92ZSwgcmV0dXJuIGFuZCBlbXB0eSBvYmplY3QuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lIGEgZGVmYXVsdCBgaGFuZGxlcmAgdGhhdCdzIGNhbGxlZCB3aGVuIG5vIHJvdXRlcyBleHBsaWNpdGx5XG4gICAgICogbWF0Y2ggdGhlIGluY29taW5nIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBFYWNoIEhUVFAgbWV0aG9kICgnR0VUJywgJ1BPU1QnLCBldGMuKSBnZXRzIGl0cyBvd24gZGVmYXVsdCBoYW5kbGVyLlxuICAgICAqXG4gICAgICogV2l0aG91dCBhIGRlZmF1bHQgaGFuZGxlciwgdW5tYXRjaGVkIHJlcXVlc3RzIHdpbGwgZ28gYWdhaW5zdCB0aGVcbiAgICAgKiBuZXR3b3JrIGFzIGlmIHRoZXJlIHdlcmUgbm8gc2VydmljZSB3b3JrZXIgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtcm91dGluZ35oYW5kbGVyQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFja1xuICAgICAqIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIFByb21pc2UgcmVzdWx0aW5nIGluIGEgUmVzcG9uc2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttZXRob2Q9J0dFVCddIFRoZSBIVFRQIG1ldGhvZCB0byBhc3NvY2lhdGUgd2l0aCB0aGlzXG4gICAgICogZGVmYXVsdCBoYW5kbGVyLiBFYWNoIG1ldGhvZCBoYXMgaXRzIG93biBkZWZhdWx0LlxuICAgICAqL1xuICAgIHNldERlZmF1bHRIYW5kbGVyKGhhbmRsZXIsIG1ldGhvZCA9IGRlZmF1bHRNZXRob2QpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEhhbmRsZXJNYXAuc2V0KG1ldGhvZCwgbm9ybWFsaXplSGFuZGxlcihoYW5kbGVyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGEgUm91dGUgdGhyb3dzIGFuIGVycm9yIHdoaWxlIGhhbmRsaW5nIGEgcmVxdWVzdCwgdGhpcyBgaGFuZGxlcmBcbiAgICAgKiB3aWxsIGJlIGNhbGxlZCBhbmQgZ2l2ZW4gYSBjaGFuY2UgdG8gcHJvdmlkZSBhIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6d29ya2JveC1yb3V0aW5nfmhhbmRsZXJDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrXG4gICAgICogZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZSByZXN1bHRpbmcgaW4gYSBSZXNwb25zZS5cbiAgICAgKi9cbiAgICBzZXRDYXRjaEhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9jYXRjaEhhbmRsZXIgPSBub3JtYWxpemVIYW5kbGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSByb3V0ZSB3aXRoIHRoZSByb3V0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp3b3JrYm94LXJvdXRpbmcuUm91dGV9IHJvdXRlIFRoZSByb3V0ZSB0byByZWdpc3Rlci5cbiAgICAgKi9cbiAgICByZWdpc3RlclJvdXRlKHJvdXRlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBhc3NlcnQuaXNUeXBlKHJvdXRlLCAnb2JqZWN0Jywge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXJvdXRpbmcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1JvdXRlcicsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdyZWdpc3RlclJvdXRlJyxcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdyb3V0ZScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFzc2VydC5oYXNNZXRob2Qocm91dGUsICdtYXRjaCcsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdSb3V0ZXInLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAncmVnaXN0ZXJSb3V0ZScsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAncm91dGUnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3NlcnQuaXNUeXBlKHJvdXRlLmhhbmRsZXIsICdvYmplY3QnLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUm91dGVyJyxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ3JlZ2lzdGVyUm91dGUnLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ3JvdXRlJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXNzZXJ0Lmhhc01ldGhvZChyb3V0ZS5oYW5kbGVyLCAnaGFuZGxlJywge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXJvdXRpbmcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1JvdXRlcicsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdyZWdpc3RlclJvdXRlJyxcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdyb3V0ZS5oYW5kbGVyJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXNzZXJ0LmlzVHlwZShyb3V0ZS5tZXRob2QsICdzdHJpbmcnLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUm91dGVyJyxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ3JlZ2lzdGVyUm91dGUnLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ3JvdXRlLm1ldGhvZCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3JvdXRlcy5oYXMocm91dGUubWV0aG9kKSkge1xuICAgICAgICAgICAgdGhpcy5fcm91dGVzLnNldChyb3V0ZS5tZXRob2QsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHaXZlIHByZWNlZGVuY2UgdG8gYWxsIG9mIHRoZSBlYXJsaWVyIHJvdXRlcyBieSBhZGRpbmcgdGhpcyBhZGRpdGlvbmFsXG4gICAgICAgIC8vIHJvdXRlIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAgICB0aGlzLl9yb3V0ZXMuZ2V0KHJvdXRlLm1ldGhvZCkucHVzaChyb3V0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXJzIGEgcm91dGUgd2l0aCB0aGUgcm91dGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6d29ya2JveC1yb3V0aW5nLlJvdXRlfSByb3V0ZSBUaGUgcm91dGUgdG8gdW5yZWdpc3Rlci5cbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyUm91dGUocm91dGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb3V0ZXMuaGFzKHJvdXRlLm1ldGhvZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ3VucmVnaXN0ZXItcm91dGUtYnV0LW5vdC1mb3VuZC13aXRoLW1ldGhvZCcsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHJvdXRlLm1ldGhvZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlSW5kZXggPSB0aGlzLl9yb3V0ZXMuZ2V0KHJvdXRlLm1ldGhvZCkuaW5kZXhPZihyb3V0ZSk7XG4gICAgICAgIGlmIChyb3V0ZUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3JvdXRlcy5nZXQocm91dGUubWV0aG9kKS5zcGxpY2Uocm91dGVJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCd1bnJlZ2lzdGVyLXJvdXRlLXJvdXRlLW5vdC1yZWdpc3RlcmVkJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgeyBSb3V0ZXIgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IFJvdXRlciB9IGZyb20gJy4uL1JvdXRlci5qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbmxldCBkZWZhdWx0Um91dGVyO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBzaW5nbGV0b24gUm91dGVyIGluc3RhbmNlIGlmIG9uZSBkb2VzIG5vdCBleGlzdC4gSWYgb25lXG4gKiBkb2VzIGFscmVhZHkgZXhpc3QsIHRoYXQgaW5zdGFuY2UgaXMgcmV0dXJuZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge1JvdXRlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldE9yQ3JlYXRlRGVmYXVsdFJvdXRlciA9ICgpID0+IHtcbiAgICBpZiAoIWRlZmF1bHRSb3V0ZXIpIHtcbiAgICAgICAgZGVmYXVsdFJvdXRlciA9IG5ldyBSb3V0ZXIoKTtcbiAgICAgICAgLy8gVGhlIGhlbHBlcnMgdGhhdCB1c2UgdGhlIGRlZmF1bHQgUm91dGVyIGFzc3VtZSB0aGVzZSBsaXN0ZW5lcnMgZXhpc3QuXG4gICAgICAgIGRlZmF1bHRSb3V0ZXIuYWRkRmV0Y2hMaXN0ZW5lcigpO1xuICAgICAgICBkZWZhdWx0Um91dGVyLmFkZENhY2hlTGlzdGVuZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRSb3V0ZXI7XG59O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5qcyc7XG5pbXBvcnQgeyBXb3JrYm94RXJyb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCB7IFJvdXRlIH0gZnJvbSAnLi9Sb3V0ZS5qcyc7XG5pbXBvcnQgeyBSZWdFeHBSb3V0ZSB9IGZyb20gJy4vUmVnRXhwUm91dGUuanMnO1xuaW1wb3J0IHsgZ2V0T3JDcmVhdGVEZWZhdWx0Um91dGVyIH0gZnJvbSAnLi91dGlscy9nZXRPckNyZWF0ZURlZmF1bHRSb3V0ZXIuanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogRWFzaWx5IHJlZ2lzdGVyIGEgUmVnRXhwLCBzdHJpbmcsIG9yIGZ1bmN0aW9uIHdpdGggYSBjYWNoaW5nXG4gKiBzdHJhdGVneSB0byBhIHNpbmdsZXRvbiBSb3V0ZXIgaW5zdGFuY2UuXG4gKlxuICogVGhpcyBtZXRob2Qgd2lsbCBnZW5lcmF0ZSBhIFJvdXRlIGZvciB5b3UgaWYgbmVlZGVkIGFuZFxuICogY2FsbCBbcmVnaXN0ZXJSb3V0ZSgpXXtAbGluayBtb2R1bGU6d29ya2JveC1yb3V0aW5nLlJvdXRlciNyZWdpc3RlclJvdXRlfS5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd8bW9kdWxlOndvcmtib3gtcm91dGluZy5Sb3V0ZX5tYXRjaENhbGxiYWNrfG1vZHVsZTp3b3JrYm94LXJvdXRpbmcuUm91dGV9IGNhcHR1cmVcbiAqIElmIHRoZSBjYXB0dXJlIHBhcmFtIGlzIGEgYFJvdXRlYCwgYWxsIG90aGVyIGFyZ3VtZW50cyB3aWxsIGJlIGlnbm9yZWQuXG4gKiBAcGFyYW0ge21vZHVsZTp3b3JrYm94LXJvdXRpbmd+aGFuZGxlckNhbGxiYWNrfSBbaGFuZGxlcl0gQSBjYWxsYmFja1xuICogZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZSByZXN1bHRpbmcgaW4gYSBSZXNwb25zZS4gVGhpcyBwYXJhbWV0ZXJcbiAqIGlzIHJlcXVpcmVkIGlmIGBjYXB0dXJlYCBpcyBub3QgYSBgUm91dGVgIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0aG9kPSdHRVQnXSBUaGUgSFRUUCBtZXRob2QgdG8gbWF0Y2ggdGhlIFJvdXRlXG4gKiBhZ2FpbnN0LlxuICogQHJldHVybiB7bW9kdWxlOndvcmtib3gtcm91dGluZy5Sb3V0ZX0gVGhlIGdlbmVyYXRlZCBgUm91dGVgKFVzZWZ1bCBmb3JcbiAqIHVucmVnaXN0ZXJpbmcpLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1yb3V0aW5nXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyUm91dGUoY2FwdHVyZSwgaGFuZGxlciwgbWV0aG9kKSB7XG4gICAgbGV0IHJvdXRlO1xuICAgIGlmICh0eXBlb2YgY2FwdHVyZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgY2FwdHVyZVVybCA9IG5ldyBVUkwoY2FwdHVyZSwgbG9jYXRpb24uaHJlZik7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoIShjYXB0dXJlLnN0YXJ0c1dpdGgoJy8nKSB8fCBjYXB0dXJlLnN0YXJ0c1dpdGgoJ2h0dHAnKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdpbnZhbGlkLXN0cmluZycsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAncmVnaXN0ZXJSb3V0ZScsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ2NhcHR1cmUnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBjaGVjayBpZiBFeHByZXNzLXN0eWxlIHdpbGRjYXJkcyBhcmUgaW4gdGhlIHBhdGhuYW1lIG9ubHkuXG4gICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBsb2cgbWVzc2FnZSBpbiB2NC5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlVG9DaGVjayA9IGNhcHR1cmUuc3RhcnRzV2l0aCgnaHR0cCcpID9cbiAgICAgICAgICAgICAgICBjYXB0dXJlVXJsLnBhdGhuYW1lIDogY2FwdHVyZTtcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGlsbGFyanMvcGF0aC10by1yZWdleHAjcGFyYW1ldGVyc1xuICAgICAgICAgICAgY29uc3Qgd2lsZGNhcmRzID0gJ1sqOj8rXSc7XG4gICAgICAgICAgICBpZiAoKG5ldyBSZWdFeHAoYCR7d2lsZGNhcmRzfWApKS5leGVjKHZhbHVlVG9DaGVjaykpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFRoZSAnJGNhcHR1cmUnIHBhcmFtZXRlciBjb250YWlucyBhbiBFeHByZXNzLXN0eWxlIHdpbGRjYXJkIGAgK1xuICAgICAgICAgICAgICAgICAgICBgY2hhcmFjdGVyICgke3dpbGRjYXJkc30pLiBTdHJpbmdzIGFyZSBub3cgYWx3YXlzIGludGVycHJldGVkIGFzIGAgK1xuICAgICAgICAgICAgICAgICAgICBgZXhhY3QgbWF0Y2hlczsgdXNlIGEgUmVnRXhwIGZvciBwYXJ0aWFsIG9yIHdpbGRjYXJkIG1hdGNoZXMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0Y2hDYWxsYmFjayA9ICh7IHVybCB9KSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICgodXJsLnBhdGhuYW1lID09PSBjYXB0dXJlVXJsLnBhdGhuYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICAodXJsLm9yaWdpbiAhPT0gY2FwdHVyZVVybC5vcmlnaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgJHtjYXB0dXJlfSBvbmx5IHBhcnRpYWxseSBtYXRjaGVzIHRoZSBjcm9zcy1vcmlnaW4gVVJMIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCR7dXJsfS4gVGhpcyByb3V0ZSB3aWxsIG9ubHkgaGFuZGxlIGNyb3NzLW9yaWdpbiByZXF1ZXN0cyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpZiB0aGV5IG1hdGNoIHRoZSBlbnRpcmUgVVJMLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1cmwuaHJlZiA9PT0gY2FwdHVyZVVybC5ocmVmO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJZiBgY2FwdHVyZWAgaXMgYSBzdHJpbmcgdGhlbiBgaGFuZGxlcmAgYW5kIGBtZXRob2RgIG11c3QgYmUgcHJlc2VudC5cbiAgICAgICAgcm91dGUgPSBuZXcgUm91dGUobWF0Y2hDYWxsYmFjaywgaGFuZGxlciwgbWV0aG9kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2FwdHVyZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAvLyBJZiBgY2FwdHVyZWAgaXMgYSBgUmVnRXhwYCB0aGVuIGBoYW5kbGVyYCBhbmQgYG1ldGhvZGAgbXVzdCBiZSBwcmVzZW50LlxuICAgICAgICByb3V0ZSA9IG5ldyBSZWdFeHBSb3V0ZShjYXB0dXJlLCBoYW5kbGVyLCBtZXRob2QpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgY2FwdHVyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBJZiBgY2FwdHVyZWAgaXMgYSBmdW5jdGlvbiB0aGVuIGBoYW5kbGVyYCBhbmQgYG1ldGhvZGAgbXVzdCBiZSBwcmVzZW50LlxuICAgICAgICByb3V0ZSA9IG5ldyBSb3V0ZShjYXB0dXJlLCBoYW5kbGVyLCBtZXRob2QpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjYXB0dXJlIGluc3RhbmNlb2YgUm91dGUpIHtcbiAgICAgICAgcm91dGUgPSBjYXB0dXJlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcigndW5zdXBwb3J0ZWQtcm91dGUtdHlwZScsIHtcbiAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXJvdXRpbmcnLFxuICAgICAgICAgICAgZnVuY05hbWU6ICdyZWdpc3RlclJvdXRlJyxcbiAgICAgICAgICAgIHBhcmFtTmFtZTogJ2NhcHR1cmUnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFJvdXRlciA9IGdldE9yQ3JlYXRlRGVmYXVsdFJvdXRlcigpO1xuICAgIGRlZmF1bHRSb3V0ZXIucmVnaXN0ZXJSb3V0ZShyb3V0ZSk7XG4gICAgcmV0dXJuIHJvdXRlO1xufVxuZXhwb3J0IHsgcmVnaXN0ZXJSb3V0ZSB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIFJlbW92ZXMgYW55IFVSTCBzZWFyY2ggcGFyYW1ldGVycyB0aGF0IHNob3VsZCBiZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7VVJMfSB1cmxPYmplY3QgVGhlIG9yaWdpbmFsIFVSTC5cbiAqIEBwYXJhbSB7QXJyYXk8UmVnRXhwPn0gaWdub3JlVVJMUGFyYW1ldGVyc01hdGNoaW5nIFJlZ0V4cHMgdG8gdGVzdCBhZ2FpbnN0XG4gKiBlYWNoIHNlYXJjaCBwYXJhbWV0ZXIgbmFtZS4gTWF0Y2hlcyBtZWFuIHRoYXQgdGhlIHNlYXJjaCBwYXJhbWV0ZXIgc2hvdWxkIGJlXG4gKiBpZ25vcmVkLlxuICogQHJldHVybiB7VVJMfSBUaGUgVVJMIHdpdGggYW55IGlnbm9yZWQgc2VhcmNoIHBhcmFtZXRlcnMgcmVtb3ZlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUlnbm9yZWRTZWFyY2hQYXJhbXModXJsT2JqZWN0LCBpZ25vcmVVUkxQYXJhbWV0ZXJzTWF0Y2hpbmcgPSBbXSkge1xuICAgIC8vIENvbnZlcnQgdGhlIGl0ZXJhYmxlIGludG8gYW4gYXJyYXkgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsb29wIHRvIG1ha2Ugc3VyZVxuICAgIC8vIGRlbGV0aW9uIGRvZXNuJ3QgbWVzcyB1cCBpdGVyYXRpb24uXG4gICAgZm9yIChjb25zdCBwYXJhbU5hbWUgb2YgWy4uLnVybE9iamVjdC5zZWFyY2hQYXJhbXMua2V5cygpXSkge1xuICAgICAgICBpZiAoaWdub3JlVVJMUGFyYW1ldGVyc01hdGNoaW5nLnNvbWUoKHJlZ0V4cCkgPT4gcmVnRXhwLnRlc3QocGFyYW1OYW1lKSkpIHtcbiAgICAgICAgICAgIHVybE9iamVjdC5zZWFyY2hQYXJhbXMuZGVsZXRlKHBhcmFtTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVybE9iamVjdDtcbn1cbiIsIi8qXG4gIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IHJlbW92ZUlnbm9yZWRTZWFyY2hQYXJhbXMgfSBmcm9tICcuL3JlbW92ZUlnbm9yZWRTZWFyY2hQYXJhbXMuanMnO1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEdlbmVyYXRvciBmdW5jdGlvbiB0aGF0IHlpZWxkcyBwb3NzaWJsZSB2YXJpYXRpb25zIG9uIHRoZSBvcmlnaW5hbCBVUkwgdG9cbiAqIGNoZWNrLCBvbmUgYXQgYSB0aW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiogZ2VuZXJhdGVVUkxWYXJpYXRpb25zKHVybCwgeyBpZ25vcmVVUkxQYXJhbWV0ZXJzTWF0Y2hpbmcgPSBbL151dG1fLywgL15mYmNsaWQkL10sIGRpcmVjdG9yeUluZGV4ID0gJ2luZGV4Lmh0bWwnLCBjbGVhblVSTHMgPSB0cnVlLCB1cmxNYW5pcHVsYXRpb24sIH0gPSB7fSkge1xuICAgIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5ocmVmKTtcbiAgICB1cmxPYmplY3QuaGFzaCA9ICcnO1xuICAgIHlpZWxkIHVybE9iamVjdC5ocmVmO1xuICAgIGNvbnN0IHVybFdpdGhvdXRJZ25vcmVkUGFyYW1zID0gcmVtb3ZlSWdub3JlZFNlYXJjaFBhcmFtcyh1cmxPYmplY3QsIGlnbm9yZVVSTFBhcmFtZXRlcnNNYXRjaGluZyk7XG4gICAgeWllbGQgdXJsV2l0aG91dElnbm9yZWRQYXJhbXMuaHJlZjtcbiAgICBpZiAoZGlyZWN0b3J5SW5kZXggJiYgdXJsV2l0aG91dElnbm9yZWRQYXJhbXMucGF0aG5hbWUuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICBjb25zdCBkaXJlY3RvcnlVUkwgPSBuZXcgVVJMKHVybFdpdGhvdXRJZ25vcmVkUGFyYW1zLmhyZWYpO1xuICAgICAgICBkaXJlY3RvcnlVUkwucGF0aG5hbWUgKz0gZGlyZWN0b3J5SW5kZXg7XG4gICAgICAgIHlpZWxkIGRpcmVjdG9yeVVSTC5ocmVmO1xuICAgIH1cbiAgICBpZiAoY2xlYW5VUkxzKSB7XG4gICAgICAgIGNvbnN0IGNsZWFuVVJMID0gbmV3IFVSTCh1cmxXaXRob3V0SWdub3JlZFBhcmFtcy5ocmVmKTtcbiAgICAgICAgY2xlYW5VUkwucGF0aG5hbWUgKz0gJy5odG1sJztcbiAgICAgICAgeWllbGQgY2xlYW5VUkwuaHJlZjtcbiAgICB9XG4gICAgaWYgKHVybE1hbmlwdWxhdGlvbikge1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsVVJMcyA9IHVybE1hbmlwdWxhdGlvbih7IHVybDogdXJsT2JqZWN0IH0pO1xuICAgICAgICBmb3IgKGNvbnN0IHVybFRvQXR0ZW1wdCBvZiBhZGRpdGlvbmFsVVJMcykge1xuICAgICAgICAgICAgeWllbGQgdXJsVG9BdHRlbXB0LmhyZWY7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IGdldEZyaWVuZGx5VVJMIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2dldEZyaWVuZGx5VVJMLmpzJztcbmltcG9ydCB7IFJvdXRlIH0gZnJvbSAnd29ya2JveC1yb3V0aW5nL1JvdXRlLmpzJztcbmltcG9ydCB7IGdlbmVyYXRlVVJMVmFyaWF0aW9ucyB9IGZyb20gJy4vdXRpbHMvZ2VuZXJhdGVVUkxWYXJpYXRpb25zLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEEgc3ViY2xhc3Mgb2YgW1JvdXRlXXtAbGluayBtb2R1bGU6d29ya2JveC1yb3V0aW5nLlJvdXRlfSB0aGF0IHRha2VzIGFcbiAqIFtQcmVjYWNoZUNvbnRyb2xsZXJde0BsaW5rIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuUHJlY2FjaGVDb250cm9sbGVyfVxuICogaW5zdGFuY2UgYW5kIHVzZXMgaXQgdG8gbWF0Y2ggaW5jb21pbmcgcmVxdWVzdHMgYW5kIGhhbmRsZSBmZXRjaGluZ1xuICogcmVzcG9uc2VzIGZyb20gdGhlIHByZWNhY2hlLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nXG4gKiBAZXh0ZW5kcyBtb2R1bGU6d29ya2JveC1yb3V0aW5nLlJvdXRlXG4gKi9cbmNsYXNzIFByZWNhY2hlUm91dGUgZXh0ZW5kcyBSb3V0ZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQcmVjYWNoZUNvbnRyb2xsZXJ9IHByZWNhY2hlQ29udHJvbGxlciBBIGBQcmVjYWNoZUNvbnRyb2xsZXJgXG4gICAgICogaW5zdGFuY2UgdXNlZCB0byBib3RoIG1hdGNoIHJlcXVlc3RzIGFuZCByZXNwb25kIHRvIGZldGNoIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgdG8gY29udHJvbCBob3cgcmVxdWVzdHMgYXJlIG1hdGNoZWRcbiAgICAgKiBhZ2FpbnN0IHRoZSBsaXN0IG9mIHByZWNhY2hlZCBVUkxzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kaXJlY3RvcnlJbmRleD1pbmRleC5odG1sXSBUaGUgYGRpcmVjdG9yeUluZGV4YCB3aWxsXG4gICAgICogY2hlY2sgY2FjaGUgZW50cmllcyBmb3IgYSBVUkxzIGVuZGluZyB3aXRoICcvJyB0byBzZWUgaWYgdGhlcmUgaXMgYSBoaXQgd2hlblxuICAgICAqIGFwcGVuZGluZyB0aGUgYGRpcmVjdG9yeUluZGV4YCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5PFJlZ0V4cD59IFtvcHRpb25zLmlnbm9yZVVSTFBhcmFtZXRlcnNNYXRjaGluZz1bL151dG1fLywgL15mYmNsaWQkL11dIEFuXG4gICAgICogYXJyYXkgb2YgcmVnZXgncyB0byByZW1vdmUgc2VhcmNoIHBhcmFtcyB3aGVuIGxvb2tpbmcgZm9yIGEgY2FjaGUgbWF0Y2guXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jbGVhblVSTHM9dHJ1ZV0gVGhlIGBjbGVhblVSTHNgIG9wdGlvbiB3aWxsXG4gICAgICogY2hlY2sgdGhlIGNhY2hlIGZvciB0aGUgVVJMIHdpdGggYSBgLmh0bWxgIGFkZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGVuZC5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp3b3JrYm94LXByZWNhY2hpbmd+dXJsTWFuaXB1bGF0aW9ufSBbb3B0aW9ucy51cmxNYW5pcHVsYXRpb25dXG4gICAgICogVGhpcyBpcyBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIHRha2UgYSBVUkwgYW5kIHJldHVybiBhbiBhcnJheSBvZlxuICAgICAqIGFsdGVybmF0aXZlIFVSTHMgdGhhdCBzaG91bGQgYmUgY2hlY2tlZCBmb3IgcHJlY2FjaGUgbWF0Y2hlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwcmVjYWNoZUNvbnRyb2xsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSAoeyByZXF1ZXN0IH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVybHNUb0NhY2hlS2V5cyA9IHByZWNhY2hlQ29udHJvbGxlci5nZXRVUkxzVG9DYWNoZUtleXMoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcG9zc2libGVVUkwgb2YgZ2VuZXJhdGVVUkxWYXJpYXRpb25zKHJlcXVlc3QudXJsLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gdXJsc1RvQ2FjaGVLZXlzLmdldChwb3NzaWJsZVVSTCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGNhY2hlS2V5IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFByZWNhY2hpbmcgZGlkIG5vdCBmaW5kIGEgbWF0Y2ggZm9yIGAgK1xuICAgICAgICAgICAgICAgICAgICBnZXRGcmllbmRseVVSTChyZXF1ZXN0LnVybCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICBzdXBlcihtYXRjaCwgcHJlY2FjaGVDb250cm9sbGVyLnN0cmF0ZWd5KTtcbiAgICB9XG59XG5leHBvcnQgeyBQcmVjYWNoZVJvdXRlIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgcmVnaXN0ZXJSb3V0ZSB9IGZyb20gJ3dvcmtib3gtcm91dGluZy9yZWdpc3RlclJvdXRlLmpzJztcbmltcG9ydCB7IGdldE9yQ3JlYXRlUHJlY2FjaGVDb250cm9sbGVyIH0gZnJvbSAnLi91dGlscy9nZXRPckNyZWF0ZVByZWNhY2hlQ29udHJvbGxlci5qcyc7XG5pbXBvcnQgeyBQcmVjYWNoZVJvdXRlIH0gZnJvbSAnLi9QcmVjYWNoZVJvdXRlLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEFkZCBhIGBmZXRjaGAgbGlzdGVuZXIgdG8gdGhlIHNlcnZpY2Ugd29ya2VyIHRoYXQgd2lsbFxuICogcmVzcG9uZCB0b1xuICogW25ldHdvcmsgcmVxdWVzdHNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2aWNlX1dvcmtlcl9BUEkvVXNpbmdfU2VydmljZV9Xb3JrZXJzI0N1c3RvbV9yZXNwb25zZXNfdG9fcmVxdWVzdHN9XG4gKiB3aXRoIHByZWNhY2hlZCBhc3NldHMuXG4gKlxuICogUmVxdWVzdHMgZm9yIGFzc2V0cyB0aGF0IGFyZW4ndCBwcmVjYWNoZWQsIHRoZSBgRmV0Y2hFdmVudGAgd2lsbCBub3QgYmVcbiAqIHJlc3BvbmRlZCB0bywgYWxsb3dpbmcgdGhlIGV2ZW50IHRvIGZhbGwgdGhyb3VnaCB0byBvdGhlciBgZmV0Y2hgIGV2ZW50XG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBTZWVcbiAqIFtQcmVjYWNoZVJvdXRlIG9wdGlvbnNde0BsaW5rIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuUHJlY2FjaGVSb3V0ZX0uXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmdcbiAqL1xuZnVuY3Rpb24gYWRkUm91dGUob3B0aW9ucykge1xuICAgIGNvbnN0IHByZWNhY2hlQ29udHJvbGxlciA9IGdldE9yQ3JlYXRlUHJlY2FjaGVDb250cm9sbGVyKCk7XG4gICAgY29uc3QgcHJlY2FjaGVSb3V0ZSA9IG5ldyBQcmVjYWNoZVJvdXRlKHByZWNhY2hlQ29udHJvbGxlciwgb3B0aW9ucyk7XG4gICAgcmVnaXN0ZXJSb3V0ZShwcmVjYWNoZVJvdXRlKTtcbn1cbmV4cG9ydCB7IGFkZFJvdXRlIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBnZXRPckNyZWF0ZVByZWNhY2hlQ29udHJvbGxlciB9IGZyb20gJy4vdXRpbHMvZ2V0T3JDcmVhdGVQcmVjYWNoZUNvbnRyb2xsZXIuanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogQWRkcyBpdGVtcyB0byB0aGUgcHJlY2FjaGUgbGlzdCwgcmVtb3ZpbmcgYW55IGR1cGxpY2F0ZXMgYW5kXG4gKiBzdG9yZXMgdGhlIGZpbGVzIGluIHRoZVxuICogW1wicHJlY2FjaGUgY2FjaGVcIl17QGxpbmsgbW9kdWxlOndvcmtib3gtY29yZS5jYWNoZU5hbWVzfSB3aGVuIHRoZSBzZXJ2aWNlXG4gKiB3b3JrZXIgaW5zdGFsbHMuXG4gKlxuICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQbGVhc2Ugbm90ZTogVGhpcyBtZXRob2QgKip3aWxsIG5vdCoqIHNlcnZlIGFueSBvZiB0aGUgY2FjaGVkIGZpbGVzIGZvciB5b3UuXG4gKiBJdCBvbmx5IHByZWNhY2hlcyBmaWxlcy4gVG8gcmVzcG9uZCB0byBhIG5ldHdvcmsgcmVxdWVzdCB5b3UgY2FsbFxuICogW2FkZFJvdXRlKClde0BsaW5rIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuYWRkUm91dGV9LlxuICpcbiAqIElmIHlvdSBoYXZlIGEgc2luZ2xlIGFycmF5IG9mIGZpbGVzIHRvIHByZWNhY2hlLCB5b3UgY2FuIGp1c3QgY2FsbFxuICogW3ByZWNhY2hlQW5kUm91dGUoKV17QGxpbmsgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5wcmVjYWNoZUFuZFJvdXRlfS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdHxzdHJpbmc+fSBbZW50cmllcz1bXV0gQXJyYXkgb2YgZW50cmllcyB0byBwcmVjYWNoZS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZ1xuICovXG5mdW5jdGlvbiBwcmVjYWNoZShlbnRyaWVzKSB7XG4gICAgY29uc3QgcHJlY2FjaGVDb250cm9sbGVyID0gZ2V0T3JDcmVhdGVQcmVjYWNoZUNvbnRyb2xsZXIoKTtcbiAgICBwcmVjYWNoZUNvbnRyb2xsZXIucHJlY2FjaGUoZW50cmllcyk7XG59XG5leHBvcnQgeyBwcmVjYWNoZSB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgYWRkUm91dGUgfSBmcm9tICcuL2FkZFJvdXRlLmpzJztcbmltcG9ydCB7IHByZWNhY2hlIH0gZnJvbSAnLi9wcmVjYWNoZS5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBUaGlzIG1ldGhvZCB3aWxsIGFkZCBlbnRyaWVzIHRvIHRoZSBwcmVjYWNoZSBsaXN0IGFuZCBhZGQgYSByb3V0ZSB0b1xuICogcmVzcG9uZCB0byBmZXRjaCBldmVudHMuXG4gKlxuICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCB0aGF0IHdpbGwgY2FsbFxuICogW3ByZWNhY2hlKClde0BsaW5rIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcucHJlY2FjaGV9IGFuZFxuICogW2FkZFJvdXRlKClde0BsaW5rIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuYWRkUm91dGV9IGluIGEgc2luZ2xlIGNhbGwuXG4gKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3R8c3RyaW5nPn0gZW50cmllcyBBcnJheSBvZiBlbnRyaWVzIHRvIHByZWNhY2hlLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBTZWVcbiAqIFtQcmVjYWNoZVJvdXRlIG9wdGlvbnNde0BsaW5rIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuUHJlY2FjaGVSb3V0ZX0uXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmdcbiAqL1xuZnVuY3Rpb24gcHJlY2FjaGVBbmRSb3V0ZShlbnRyaWVzLCBvcHRpb25zKSB7XG4gICAgcHJlY2FjaGUoZW50cmllcyk7XG4gICAgYWRkUm91dGUob3B0aW9ucyk7XG59XG5leHBvcnQgeyBwcmVjYWNoZUFuZFJvdXRlIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IGdldEZyaWVuZGx5VVJMIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2dldEZyaWVuZGx5VVJMLmpzJztcbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuZXhwb3J0IGNvbnN0IG1lc3NhZ2VzID0ge1xuICAgIHN0cmF0ZWd5U3RhcnQ6IChzdHJhdGVneU5hbWUsIHJlcXVlc3QpID0+IGBVc2luZyAke3N0cmF0ZWd5TmFtZX0gdG8gcmVzcG9uZCB0byAnJHtnZXRGcmllbmRseVVSTChyZXF1ZXN0LnVybCl9J2AsXG4gICAgcHJpbnRGaW5hbFJlc3BvbnNlOiAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoYFZpZXcgdGhlIGZpbmFsIHJlc3BvbnNlIGhlcmUuYCk7XG4gICAgICAgICAgICBsb2dnZXIubG9nKHJlc3BvbnNlIHx8ICdbTm8gcmVzcG9uc2UgcmV0dXJuZWRdJyk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IFdvcmtib3hFcnJvciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9Xb3JrYm94RXJyb3IuanMnO1xuaW1wb3J0IHsgU3RyYXRlZ3kgfSBmcm9tICcuL1N0cmF0ZWd5LmpzJztcbmltcG9ydCB7IG1lc3NhZ2VzIH0gZnJvbSAnLi91dGlscy9tZXNzYWdlcy5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBhIFtjYWNoZS1maXJzdF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL2Z1bmRhbWVudGFscy9pbnN0YW50LWFuZC1vZmZsaW5lL29mZmxpbmUtY29va2Jvb2svI2NhY2hlLWZhbGxpbmctYmFjay10by1uZXR3b3JrfVxuICogcmVxdWVzdCBzdHJhdGVneS5cbiAqXG4gKiBBIGNhY2hlIGZpcnN0IHN0cmF0ZWd5IGlzIHVzZWZ1bCBmb3IgYXNzZXRzIHRoYXQgaGF2ZSBiZWVuIHJldmlzaW9uZWQsXG4gKiBzdWNoIGFzIFVSTHMgbGlrZSBgL3N0eWxlcy9leGFtcGxlLmE4ZjVmMS5jc3NgLCBzaW5jZSB0aGV5XG4gKiBjYW4gYmUgY2FjaGVkIGZvciBsb25nIHBlcmlvZHMgb2YgdGltZS5cbiAqXG4gKiBJZiB0aGUgbmV0d29yayByZXF1ZXN0IGZhaWxzLCBhbmQgdGhlcmUgaXMgbm8gY2FjaGUgbWF0Y2gsIHRoaXMgd2lsbCB0aHJvd1xuICogYSBgV29ya2JveEVycm9yYCBleGNlcHRpb24uXG4gKlxuICogQGV4dGVuZHMgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneVxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXNcbiAqL1xuY2xhc3MgQ2FjaGVGaXJzdCBleHRlbmRzIFN0cmF0ZWd5IHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UmVxdWVzdHxzdHJpbmd9IHJlcXVlc3QgQSByZXF1ZXN0IHRvIHJ1biB0aGlzIHN0cmF0ZWd5IGZvci5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3lIYW5kbGVyfSBoYW5kbGVyIFRoZSBldmVudCB0aGF0XG4gICAgICogICAgIHRyaWdnZXJlZCB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJlc3BvbnNlPn1cbiAgICAgKi9cbiAgICBhc3luYyBfaGFuZGxlKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgbG9ncyA9IFtdO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgYXNzZXJ0LmlzSW5zdGFuY2UocmVxdWVzdCwgUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXN0cmF0ZWdpZXMnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnbWFrZVJlcXVlc3QnLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ3JlcXVlc3QnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlci5jYWNoZU1hdGNoKHJlcXVlc3QpO1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbG9ncy5wdXNoKGBObyByZXNwb25zZSBmb3VuZCBpbiB0aGUgJyR7dGhpcy5jYWNoZU5hbWV9JyBjYWNoZS4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBXaWxsIHJlc3BvbmQgd2l0aCBhIG5ldHdvcmsgcmVxdWVzdC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmZldGNoQW5kQ2FjaGVQdXQocmVxdWVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dzLnB1c2goYEdvdCByZXNwb25zZSBmcm9tIG5ldHdvcmsuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dzLnB1c2goYFVuYWJsZSB0byBnZXQgYSByZXNwb25zZSBmcm9tIHRoZSBuZXR3b3JrLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbG9ncy5wdXNoKGBGb3VuZCBhIGNhY2hlZCByZXNwb25zZSBpbiB0aGUgJyR7dGhpcy5jYWNoZU5hbWV9JyBjYWNoZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKG1lc3NhZ2VzLnN0cmF0ZWd5U3RhcnQodGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCByZXF1ZXN0KSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxvZyBvZiBsb2dzKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhsb2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZXMucHJpbnRGaW5hbFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ25vLXJlc3BvbnNlJywgeyB1cmw6IHJlcXVlc3QudXJsLCBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuZXhwb3J0IHsgQ2FjaGVGaXJzdCB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IHByZXZlbnRzIGEgcHJvbWlzZSBmcm9tIGJlaW5nIGZsYWdnZWQgYXMgdW51c2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZG9udFdhaXRGb3IocHJvbWlzZSkge1xuICAgIC8vIEVmZmVjdGl2ZSBuby1vcC5cbiAgICBwcm9taXNlLnRoZW4oKCkgPT4geyB9KTtcbn1cbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQgd3JhcHMgY29tbW9uIEluZGV4ZWREQiBmdW5jdGlvbmFsaXR5IGluIGEgcHJvbWlzZS1iYXNlZCBBUEkuXG4gKiBJdCBleHBvc2VzIGFsbCB0aGUgdW5kZXJseWluZyBwb3dlciBhbmQgZnVuY3Rpb25hbGl0eSBvZiBJbmRleGVkREIsIGJ1dFxuICogd3JhcHMgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBmZWF0dXJlcyBpbiBhIHdheSB0aGF0J3MgbXVjaCBzaW1wbGVyIHRvIHVzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgREJXcmFwcGVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBbY2FsbGJhY2tdXG4gICAgICogQHBhcmFtIHshRnVuY3Rpb259IFtjYWxsYmFja3Mub251cGdyYWRlbmVlZGVkXVxuICAgICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBbY2FsbGJhY2tzLm9udmVyc2lvbmNoYW5nZV0gRGVmYXVsdHMgdG9cbiAgICAgKiAgICAgREJXcmFwcGVyLnByb3RvdHlwZS5fb252ZXJzaW9uY2hhbmdlIHdoZW4gbm90IHNwZWNpZmllZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHZlcnNpb24sIHsgb251cGdyYWRlbmVlZGVkLCBvbnZlcnNpb25jaGFuZ2UsIH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9kYiA9IG51bGw7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fb251cGdyYWRlbmVlZGVkID0gb251cGdyYWRlbmVlZGVkO1xuICAgICAgICB0aGlzLl9vbnZlcnNpb25jaGFuZ2UgPSBvbnZlcnNpb25jaGFuZ2UgfHwgKCgpID0+IHRoaXMuY2xvc2UoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElEQkRhdGFiYXNlIGluc3RhbmNlIChub3Qgbm9ybWFsbHkgbmVlZGVkKS5cbiAgICAgKiBAcmV0dXJuIHtJREJEYXRhYmFzZXx1bmRlZmluZWR9XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldCBkYigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyBhIGNvbm5lY3RlZCB0byBhbiBJREJEYXRhYmFzZSwgaW52b2tlcyBhbnkgb251cGdyYWRlZG5lZWRlZFxuICAgICAqIGNhbGxiYWNrLCBhbmQgYWRkZWQgYW4gb252ZXJzaW9uY2hhbmdlIGNhbGxiYWNrIHRvIHRoZSBkYXRhYmFzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lEQkRhdGFiYXNlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgb3BlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9kYiA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIFRoaXMgZmxhZyBpcyBmbGlwcGVkIHRvIHRydWUgaWYgdGhlIHRpbWVvdXQgY2FsbGJhY2sgcnVucyBwcmlvclxuICAgICAgICAgICAgLy8gdG8gdGhlIHJlcXVlc3QgZmFpbGluZyBvciBzdWNjZWVkaW5nLiBOb3RlOiB3ZSB1c2UgYSB0aW1lb3V0IGluc3RlYWRcbiAgICAgICAgICAgIC8vIG9mIGFuIG9uYmxvY2tlZCBoYW5kbGVyIHNpbmNlIHRoZXJlIGFyZSBjYXNlcyB3aGVyZSBvbmJsb2NrZWQgd2lsbFxuICAgICAgICAgICAgLy8gbmV2ZXIgbmV2ZXIgcnVuLiBBIHRpbWVvdXQgYmV0dGVyIGhhbmRsZXMgYWxsIHBvc3NpYmxlIHNjZW5hcmlvczpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvSW5kZXhlZERCL2lzc3Vlcy8yMjNcbiAgICAgICAgICAgIGxldCBvcGVuUmVxdWVzdFRpbWVkT3V0ID0gZmFsc2U7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBvcGVuUmVxdWVzdFRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGUgb3BlbiByZXF1ZXN0IHdhcyBibG9ja2VkIGFuZCB0aW1lZCBvdXQnKSk7XG4gICAgICAgICAgICB9LCB0aGlzLk9QRU5fVElNRU9VVCk7XG4gICAgICAgICAgICBjb25zdCBvcGVuUmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMuX25hbWUsIHRoaXMuX3ZlcnNpb24pO1xuICAgICAgICAgICAgb3BlblJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChvcGVuUmVxdWVzdC5lcnJvcik7XG4gICAgICAgICAgICBvcGVuUmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9wZW5SZXF1ZXN0VGltZWRPdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlblJlcXVlc3QudHJhbnNhY3Rpb24uYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgb3BlblJlcXVlc3QucmVzdWx0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9vbnVwZ3JhZGVuZWVkZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb251cGdyYWRlbmVlZGVkKGV2dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9wZW5SZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYiA9IG9wZW5SZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAob3BlblJlcXVlc3RUaW1lZE91dCkge1xuICAgICAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGIub252ZXJzaW9uY2hhbmdlID0gdGhpcy5fb252ZXJzaW9uY2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9seWZpbGxzIHRoZSBuYXRpdmUgYGdldEtleSgpYCBtZXRob2QuIE5vdGUsIHRoaXMgaXMgb3ZlcnJpZGRlbiBhdFxuICAgICAqIHJ1bnRpbWUgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIG5hdGl2ZSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVOYW1lXG4gICAgICogQHBhcmFtIHsqfSBxdWVyeVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0S2V5KHN0b3JlTmFtZSwgcXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldEFsbEtleXMoc3RvcmVOYW1lLCBxdWVyeSwgMSkpWzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb2x5ZmlsbHMgdGhlIG5hdGl2ZSBgZ2V0QWxsKClgIG1ldGhvZC4gTm90ZSwgdGhpcyBpcyBvdmVycmlkZGVuIGF0XG4gICAgICogcnVudGltZSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgbmF0aXZlIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZU5hbWVcbiAgICAgKiBAcGFyYW0geyp9IHF1ZXJ5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBbGwoc3RvcmVOYW1lLCBxdWVyeSwgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QWxsTWF0Y2hpbmcoc3RvcmVOYW1lLCB7IHF1ZXJ5LCBjb3VudCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9seWZpbGxzIHRoZSBuYXRpdmUgYGdldEFsbEtleXMoKWAgbWV0aG9kLiBOb3RlLCB0aGlzIGlzIG92ZXJyaWRkZW4gYXRcbiAgICAgKiBydW50aW1lIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBuYXRpdmUgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0b3JlTmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gcXVlcnlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIGdldEFsbEtleXMoc3RvcmVOYW1lLCBxdWVyeSwgY291bnQpIHtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IGF3YWl0IHRoaXMuZ2V0QWxsTWF0Y2hpbmcoc3RvcmVOYW1lLCB7IHF1ZXJ5LCBjb3VudCwgaW5jbHVkZUtleXM6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBlbnRyaWVzLm1hcCgoZW50cnkpID0+IGVudHJ5LmtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIGZsZXhpYmxlIGxvb2t1cCBpbiBhbiBvYmplY3Qgc3RvcmUgYnkgc3BlY2lmeWluZyBhbiBpbmRleCxcbiAgICAgKiBxdWVyeSwgZGlyZWN0aW9uLCBhbmQgY291bnQuIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gYXJyYXkgb2Ygb2JqZWN0c1xuICAgICAqIHdpdGggdGhlIHNpZ25hdHVyZSAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVOYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pbmRleF0gVGhlIGluZGV4IHRvIHVzZSAoaWYgc3BlY2lmaWVkKS5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRzLnF1ZXJ5XVxuICAgICAqIEBwYXJhbSB7SURCQ3Vyc29yRGlyZWN0aW9ufSBbb3B0cy5kaXJlY3Rpb25dXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmNvdW50XSBUaGUgbWF4IG51bWJlciBvZiByZXN1bHRzIHRvIHJldHVybi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVLZXlzXSBXaGVuIHRydWUsIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlXG4gICAgICogICAgIHJldHVybmVkIG9iamVjdHMgaXMgY2hhbmdlZCBmcm9tIGFuIGFycmF5IG9mIHZhbHVlcyB0byBhbiBhcnJheSBvZlxuICAgICAqICAgICBvYmplY3RzIGluIHRoZSBmb3JtIHtrZXksIHByaW1hcnlLZXksIHZhbHVlfS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIGdldEFsbE1hdGNoaW5nKHN0b3JlTmFtZSwgeyBpbmRleCwgcXVlcnkgPSBudWxsLCAvLyBJRS9FZGdlIGVycm9ycyBpZiBxdWVyeSA9PT0gYHVuZGVmaW5lZGAuXG4gICAgZGlyZWN0aW9uID0gJ25leHQnLCBjb3VudCwgaW5jbHVkZUtleXMgPSBmYWxzZSwgfSA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zYWN0aW9uKFtzdG9yZU5hbWVdLCAncmVhZG9ubHknLCAodHhuLCBkb25lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZSA9IHR4bi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gaW5kZXggPyBzdG9yZS5pbmRleChpbmRleCkgOiBzdG9yZTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0YXJnZXQub3BlbkN1cnNvcihxdWVyeSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IHJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGluY2x1ZGVLZXlzID8gY3Vyc29yIDogY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ICYmIHJlc3VsdHMubGVuZ3RoID49IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2VwdHMgYSBsaXN0IG9mIHN0b3JlcywgYSB0cmFuc2FjdGlvbiB0eXBlLCBhbmQgYSBjYWxsYmFjayBhbmRcbiAgICAgKiBwZXJmb3JtcyBhIHRyYW5zYWN0aW9uLiBBIHByb21pc2UgaXMgcmV0dXJuZWQgdGhhdCByZXNvbHZlcyB0byB3aGF0ZXZlclxuICAgICAqIHZhbHVlIHRoZSBjYWxsYmFjayBjaG9vc2VzLiBUaGUgY2FsbGJhY2sgaG9sZHMgYWxsIHRoZSB0cmFuc2FjdGlvbiBsb2dpY1xuICAgICAqIGFuZCBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czpcbiAgICAgKiAgIDEuIFRoZSBJREJUcmFuc2FjdGlvbiBvYmplY3RcbiAgICAgKiAgIDIuIEEgYGRvbmVgIGZ1bmN0aW9uLCB0aGF0J3MgdXNlZCB0byByZXNvbHZlIHRoZSBwcm9taXNlIHdoZW5cbiAgICAgKiAgICAgIHdoZW4gdGhlIHRyYW5zYWN0aW9uIGlzIGRvbmUsIGlmIHBhc3NlZCBhIHZhbHVlLCB0aGUgcHJvbWlzZSBpc1xuICAgICAqICAgICAgcmVzb2x2ZWQgdG8gdGhhdCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gc3RvcmVOYW1lcyBBbiBhcnJheSBvZiBvYmplY3Qgc3RvcmUgbmFtZXNcbiAgICAgKiAgICAgaW52b2x2ZWQgaW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIENhbiBiZSBgcmVhZG9ubHlgIG9yIGByZWFkd3JpdGVgLlxuICAgICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4geyp9IFRoZSByZXN1bHQgb2YgdGhlIHRyYW5zYWN0aW9uIHJhbiBieSB0aGUgY2FsbGJhY2suXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyB0cmFuc2FjdGlvbihzdG9yZU5hbWVzLCB0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICBhd2FpdCB0aGlzLm9wZW4oKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHR4biA9IHRoaXMuX2RiLnRyYW5zYWN0aW9uKHN0b3JlTmFtZXMsIHR5cGUpO1xuICAgICAgICAgICAgdHhuLm9uYWJvcnQgPSAoKSA9PiByZWplY3QodHhuLmVycm9yKTtcbiAgICAgICAgICAgIHR4bi5vbmNvbXBsZXRlID0gKCkgPT4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgY2FsbGJhY2sodHhuLCAodmFsdWUpID0+IHJlc29sdmUodmFsdWUpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGVnYXRlcyBhc3luYyB0byBhIG5hdGl2ZSBJREJPYmplY3RTdG9yZSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIFRoZSBtZXRob2QgbmFtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVOYW1lIFRoZSBvYmplY3Qgc3RvcmUgbmFtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBDYW4gYmUgYHJlYWRvbmx5YCBvciBgcmVhZHdyaXRlYC5cbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgVGhlIGxpc3Qgb2YgYXJncyB0byBwYXNzIHRvIHRoZSBuYXRpdmUgbWV0aG9kLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSByZXN1bHQgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobWV0aG9kLCBzdG9yZU5hbWUsIHR5cGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAodHhuLCBkb25lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvYmpTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICAgICAgLy8gVE9ETyhwaGlsaXB3YWx0b24pOiBGaXggdGhpcyB1bmRlcmx5aW5nIFRTMjY4NCBlcnJvci5cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBvYmpTdG9yZVttZXRob2RdLmFwcGx5KG9ialN0b3JlLCBhcmdzKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gZG9uZShyZXF1ZXN0LnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zYWN0aW9uKFtzdG9yZU5hbWVdLCB0eXBlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgY29ubmVjdGlvbiBvcGVuZWQgYnkgYERCV3JhcHBlci5vcGVuKClgLiBHZW5lcmFsbHkgdGhpcyBtZXRob2RcbiAgICAgKiBkb2Vzbid0IG5lZWQgdG8gYmUgY2FsbGVkIHNpbmNlOlxuICAgICAqICAgMS4gSXQncyB1c3VhbGx5IGJldHRlciB0byBrZWVwIGEgY29ubmVjdGlvbiBvcGVuIHNpbmNlIG9wZW5pbmdcbiAgICAgKiAgICAgIGEgbmV3IGNvbm5lY3Rpb24gaXMgc29tZXdoYXQgc2xvdy5cbiAgICAgKiAgIDIuIENvbm5lY3Rpb25zIGFyZSBhdXRvbWF0aWNhbGx5IGNsb3NlZCB3aGVuIHRoZSByZWZlcmVuY2UgaXNcbiAgICAgKiAgICAgIGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgICAqIFRoZSBwcmltYXJ5IHVzZSBjYXNlIGZvciBuZWVkaW5nIHRvIGNsb3NlIGEgY29ubmVjdGlvbiBpcyB3aGVuIGFub3RoZXJcbiAgICAgKiByZWZlcmVuY2UgKHR5cGljYWxseSBpbiBhbm90aGVyIHRhYikgbmVlZHMgdG8gdXBncmFkZSBpdCBhbmQgd291bGQgYmVcbiAgICAgKiBibG9ja2VkIGJ5IHRoZSBjdXJyZW50LCBvcGVuIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fZGIpIHtcbiAgICAgICAgICAgIHRoaXMuX2RiLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9kYiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBFeHBvc2VkIG9uIHRoZSBwcm90b3R5cGUgdG8gbGV0IHVzZXJzIG1vZGlmeSB0aGUgZGVmYXVsdCB0aW1lb3V0IG9uIGFcbi8vIHBlci1pbnN0YW5jZSBvciBnbG9iYWwgYmFzaXMuXG5EQldyYXBwZXIucHJvdG90eXBlLk9QRU5fVElNRU9VVCA9IDIwMDA7XG4vLyBXcmFwIG5hdGl2ZSBJREJPYmplY3RTdG9yZSBtZXRob2RzIGFjY29yZGluZyB0byB0aGVpciBtb2RlLlxuY29uc3QgbWV0aG9kc1RvV3JhcCA9IHtcbiAgICByZWFkb25seTogWydnZXQnLCAnY291bnQnLCAnZ2V0S2V5JywgJ2dldEFsbCcsICdnZXRBbGxLZXlzJ10sXG4gICAgcmVhZHdyaXRlOiBbJ2FkZCcsICdwdXQnLCAnY2xlYXInLCAnZGVsZXRlJ10sXG59O1xuZm9yIChjb25zdCBbbW9kZSwgbWV0aG9kc10gb2YgT2JqZWN0LmVudHJpZXMobWV0aG9kc1RvV3JhcCkpIHtcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XG4gICAgICAgIGlmIChtZXRob2QgaW4gSURCT2JqZWN0U3RvcmUucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAvLyBEb24ndCB1c2UgYXJyb3cgZnVuY3Rpb25zIGhlcmUgc2luY2Ugd2UncmUgb3V0c2lkZSBvZiB0aGUgY2xhc3MuXG4gICAgICAgICAgICBEQldyYXBwZXIucHJvdG90eXBlW21ldGhvZF0gPVxuICAgICAgICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIChzdG9yZU5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2NhbGwobWV0aG9kLCBzdG9yZU5hbWUsIG1vZGUsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogRGVsZXRlcyB0aGUgZGF0YWJhc2UuXG4gKiBOb3RlOiB0aGlzIGlzIGV4cG9ydGVkIHNlcGFyYXRlbHkgZnJvbSB0aGUgREJXcmFwcGVyIG1vZHVsZSBiZWNhdXNlIG1vc3RcbiAqIHVzYWdlcyBvZiBJbmRleGVkREIgaW4gd29ya2JveCBkb250IG5lZWQgZGVsZXRpbmcsIGFuZCB0aGlzIHdheSBpdCBjYW4gYmVcbiAqIHJldXNlZCBpbiB0ZXN0cyB0byBkZWxldGUgZGF0YWJhc2VzIHdpdGhvdXQgY3JlYXRpbmcgREJXcmFwcGVyIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgZGF0YWJhc2UgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBkZWxldGVEYXRhYmFzZSA9IGFzeW5jIChuYW1lKSA9PiB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKG5hbWUpO1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Qub25ibG9ja2VkID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRGVsZXRlIGJsb2NrZWQnKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gQHRzLWlnbm9yZVxudHJ5IHtcbiAgICBzZWxmWyd3b3JrYm94OmV4cGlyYXRpb246Ni4wLjInXSAmJiBfKCk7XG59XG5jYXRjaCAoZSkgeyB9XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBEQldyYXBwZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvREJXcmFwcGVyLmpzJztcbmltcG9ydCB7IGRlbGV0ZURhdGFiYXNlIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2RlbGV0ZURhdGFiYXNlLmpzJztcbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuY29uc3QgREJfTkFNRSA9ICd3b3JrYm94LWV4cGlyYXRpb24nO1xuY29uc3QgT0JKRUNUX1NUT1JFX05BTUUgPSAnY2FjaGUtZW50cmllcyc7XG5jb25zdCBub3JtYWxpemVVUkwgPSAodW5Ob3JtYWxpemVkVXJsKSA9PiB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh1bk5vcm1hbGl6ZWRVcmwsIGxvY2F0aW9uLmhyZWYpO1xuICAgIHVybC5oYXNoID0gJyc7XG4gICAgcmV0dXJuIHVybC5ocmVmO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgdGltZXN0YW1wIG1vZGVsLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENhY2hlVGltZXN0YW1wc01vZGVsIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2FjaGVOYW1lKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlTmFtZSA9IGNhY2hlTmFtZTtcbiAgICAgICAgdGhpcy5fZGIgPSBuZXcgREJXcmFwcGVyKERCX05BTUUsIDEsIHtcbiAgICAgICAgICAgIG9udXBncmFkZW5lZWRlZDogKGV2ZW50KSA9PiB0aGlzLl9oYW5kbGVVcGdyYWRlKGV2ZW50KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3VsZCBwZXJmb3JtIGFuIHVwZ3JhZGUgb2YgaW5kZXhlZERCLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hhbmRsZVVwZ3JhZGUoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZGIgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAvLyBUT0RPKHBoaWxpcHdhbHRvbik6IEVkZ2VIVE1MIGRvZXNuJ3Qgc3VwcG9ydCBhcnJheXMgYXMgYSBrZXlQYXRoLCBzbyB3ZVxuICAgICAgICAvLyBoYXZlIHRvIHVzZSB0aGUgYGlkYCBrZXlQYXRoIGhlcmUgYW5kIGNyZWF0ZSBvdXIgb3duIHZhbHVlcyAoYVxuICAgICAgICAvLyBjb25jYXRlbmF0aW9uIG9mIGB1cmwgKyBjYWNoZU5hbWVgKSBpbnN0ZWFkIG9mIHNpbXBseSB1c2luZ1xuICAgICAgICAvLyBga2V5UGF0aDogWyd1cmwnLCAnY2FjaGVOYW1lJ11gLCB3aGljaCBpcyBzdXBwb3J0ZWQgaW4gb3RoZXIgYnJvd3NlcnMuXG4gICAgICAgIGNvbnN0IG9ialN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX05BTUUsIHsga2V5UGF0aDogJ2lkJyB9KTtcbiAgICAgICAgLy8gVE9ETyhwaGlsaXB3YWx0b24pOiBvbmNlIHdlIGRvbid0IGhhdmUgdG8gc3VwcG9ydCBFZGdlSFRNTCwgd2UgY2FuXG4gICAgICAgIC8vIGNyZWF0ZSBhIHNpbmdsZSBpbmRleCB3aXRoIHRoZSBrZXlQYXRoIGBbJ2NhY2hlTmFtZScsICd0aW1lc3RhbXAnXWBcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBkb2luZyBib3RoIHRoZXNlIGluZGV4ZXMuXG4gICAgICAgIG9ialN0b3JlLmNyZWF0ZUluZGV4KCdjYWNoZU5hbWUnLCAnY2FjaGVOYW1lJywgeyB1bmlxdWU6IGZhbHNlIH0pO1xuICAgICAgICBvYmpTdG9yZS5jcmVhdGVJbmRleCgndGltZXN0YW1wJywgJ3RpbWVzdGFtcCcsIHsgdW5pcXVlOiBmYWxzZSB9KTtcbiAgICAgICAgLy8gUHJldmlvdXMgdmVyc2lvbnMgb2YgYHdvcmtib3gtZXhwaXJhdGlvbmAgdXNlZCBgdGhpcy5fY2FjaGVOYW1lYFxuICAgICAgICAvLyBhcyB0aGUgSURCRGF0YWJhc2UgbmFtZS5cbiAgICAgICAgZGVsZXRlRGF0YWJhc2UodGhpcy5fY2FjaGVOYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXBcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgc2V0VGltZXN0YW1wKHVybCwgdGltZXN0YW1wKSB7XG4gICAgICAgIHVybCA9IG5vcm1hbGl6ZVVSTCh1cmwpO1xuICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIGNhY2hlTmFtZTogdGhpcy5fY2FjaGVOYW1lLFxuICAgICAgICAgICAgLy8gQ3JlYXRpbmcgYW4gSUQgZnJvbSB0aGUgVVJMIGFuZCBjYWNoZSBuYW1lIHdvbid0IGJlIG5lY2Vzc2FyeSBvbmNlXG4gICAgICAgICAgICAvLyBFZGdlIHN3aXRjaGVzIHRvIENocm9taXVtIGFuZCBhbGwgYnJvd3NlcnMgd2Ugc3VwcG9ydCB3b3JrIHdpdGhcbiAgICAgICAgICAgIC8vIGFycmF5IGtleVBhdGhzLlxuICAgICAgICAgICAgaWQ6IHRoaXMuX2dldElkKHVybCksXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRoaXMuX2RiLnB1dChPQkpFQ1RfU1RPUkVfTkFNRSwgZW50cnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0aW1lc3RhbXAgc3RvcmVkIGZvciBhIGdpdmVuIFVSTC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIGdldFRpbWVzdGFtcCh1cmwpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCB0aGlzLl9kYi5nZXQoT0JKRUNUX1NUT1JFX05BTUUsIHRoaXMuX2dldElkKHVybCkpO1xuICAgICAgICByZXR1cm4gZW50cnkudGltZXN0YW1wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyB0aHJvdWdoIGFsbCB0aGUgZW50cmllcyBpbiB0aGUgb2JqZWN0IHN0b3JlIChmcm9tIG5ld2VzdCB0b1xuICAgICAqIG9sZGVzdCkgYW5kIHJlbW92ZXMgZW50cmllcyBvbmNlIGVpdGhlciBgbWF4Q291bnRgIGlzIHJlYWNoZWQgb3IgdGhlXG4gICAgICogZW50cnkncyB0aW1lc3RhbXAgaXMgbGVzcyB0aGFuIGBtaW5UaW1lc3RhbXBgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblRpbWVzdGFtcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhDb3VudFxuICAgICAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIGV4cGlyZUVudHJpZXMobWluVGltZXN0YW1wLCBtYXhDb3VudCkge1xuICAgICAgICBjb25zdCBlbnRyaWVzVG9EZWxldGUgPSBhd2FpdCB0aGlzLl9kYi50cmFuc2FjdGlvbihPQkpFQ1RfU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScsICh0eG4sIGRvbmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHhuLm9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9OQU1FKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5pbmRleCgndGltZXN0YW1wJykub3BlbkN1cnNvcihudWxsLCAncHJldicpO1xuICAgICAgICAgICAgY29uc3QgZW50cmllc1RvRGVsZXRlID0gW107XG4gICAgICAgICAgICBsZXQgZW50cmllc05vdERlbGV0ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSByZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhwaGlsaXB3YWx0b24pOiBvbmNlIHdlIGNhbiB1c2UgYSBtdWx0aS1rZXkgaW5kZXgsIHdlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdvbid0IGhhdmUgdG8gY2hlY2sgYGNhY2hlTmFtZWAgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5jYWNoZU5hbWUgPT09IHRoaXMuX2NhY2hlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIGFuIGVudHJ5IGlmIGl0J3Mgb2xkZXIgdGhhbiB0aGUgbWF4IGFnZSBvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIHRoZSBtYXggbnVtYmVyIGFsbG93ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG1pblRpbWVzdGFtcCAmJiByZXN1bHQudGltZXN0YW1wIDwgbWluVGltZXN0YW1wKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXhDb3VudCAmJiBlbnRyaWVzTm90RGVsZXRlZENvdW50ID49IG1heENvdW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8ocGhpbGlwd2FsdG9uKTogd2Ugc2hvdWxkIGJlIGFibGUgdG8gZGVsZXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVudHJ5IHJpZ2h0IGhlcmUsIGJ1dCBkb2luZyBzbyBjYXVzZXMgYW4gaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnVnIGluIFNhZmFyaSBzdGFibGUgKGZpeGVkIGluIFRQKS4gSW5zdGVhZCB3ZSBjYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUga2V5cyBvZiB0aGUgZW50cmllcyB0byBkZWxldGUsIGFuZCB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSBzZXBhcmF0ZSB0cmFuc2FjdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8xOTc4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3Vyc29yLmRlbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byByZXR1cm4gdGhlIFVSTCwgbm90IHRoZSB3aG9sZSBlbnRyeS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzVG9EZWxldGUucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllc05vdERlbGV0ZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZShlbnRyaWVzVG9EZWxldGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUT0RPKHBoaWxpcHdhbHRvbik6IG9uY2UgdGhlIFNhZmFyaSBidWcgaW4gdGhlIGZvbGxvd2luZyBpc3N1ZSBpcyBmaXhlZCxcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlIHRoaXMgbG9vcCBhbmQgZG8gdGhlIGVudHJ5IGRlbGV0aW9uIGluIHRoZVxuICAgICAgICAvLyBjdXJzb3IgbG9vcCBhYm92ZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8xOTc4XG4gICAgICAgIGNvbnN0IHVybHNEZWxldGVkID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllc1RvRGVsZXRlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9kYi5kZWxldGUoT0JKRUNUX1NUT1JFX05BTUUsIGVudHJ5LmlkKTtcbiAgICAgICAgICAgIHVybHNEZWxldGVkLnB1c2goZW50cnkudXJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsc0RlbGV0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgVVJMIGFuZCByZXR1cm5zIGFuIElEIHRoYXQgd2lsbCBiZSB1bmlxdWUgaW4gdGhlIG9iamVjdCBzdG9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRJZCh1cmwpIHtcbiAgICAgICAgLy8gQ3JlYXRpbmcgYW4gSUQgZnJvbSB0aGUgVVJMIGFuZCBjYWNoZSBuYW1lIHdvbid0IGJlIG5lY2Vzc2FyeSBvbmNlXG4gICAgICAgIC8vIEVkZ2Ugc3dpdGNoZXMgdG8gQ2hyb21pdW0gYW5kIGFsbCBicm93c2VycyB3ZSBzdXBwb3J0IHdvcmsgd2l0aFxuICAgICAgICAvLyBhcnJheSBrZXlQYXRocy5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlTmFtZSArICd8JyArIG5vcm1hbGl6ZVVSTCh1cmwpO1xuICAgIH1cbn1cbmV4cG9ydCB7IENhY2hlVGltZXN0YW1wc01vZGVsIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzJztcbmltcG9ydCB7IGRvbnRXYWl0Rm9yIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2RvbnRXYWl0Rm9yLmpzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMnO1xuaW1wb3J0IHsgV29ya2JveEVycm9yIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5qcyc7XG5pbXBvcnQgeyBDYWNoZVRpbWVzdGFtcHNNb2RlbCB9IGZyb20gJy4vbW9kZWxzL0NhY2hlVGltZXN0YW1wc01vZGVsLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIFRoZSBgQ2FjaGVFeHBpcmF0aW9uYCBjbGFzcyBhbGxvd3MgeW91IGRlZmluZSBhbiBleHBpcmF0aW9uIGFuZCAvIG9yXG4gKiBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIHJlc3BvbnNlcyBzdG9yZWQgaW4gYVxuICogW2BDYWNoZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYWNoZSkuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LWV4cGlyYXRpb25cbiAqL1xuY2xhc3MgQ2FjaGVFeHBpcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUbyBjb25zdHJ1Y3QgYSBuZXcgQ2FjaGVFeHBpcmF0aW9uIGluc3RhbmNlIHlvdSBtdXN0IHByb3ZpZGUgYXQgbGVhc3RcbiAgICAgKiBvbmUgb2YgdGhlIGBjb25maWdgIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIE5hbWUgb2YgdGhlIGNhY2hlIHRvIGFwcGx5IHJlc3RyaWN0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubWF4RW50cmllc10gVGhlIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgdG8gY2FjaGUuXG4gICAgICogRW50cmllcyB1c2VkIHRoZSBsZWFzdCB3aWxsIGJlIHJlbW92ZWQgYXMgdGhlIG1heGltdW0gaXMgcmVhY2hlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5tYXhBZ2VTZWNvbmRzXSBUaGUgbWF4aW11bSBhZ2Ugb2YgYW4gZW50cnkgYmVmb3JlXG4gICAgICogaXQncyB0cmVhdGVkIGFzIHN0YWxlIGFuZCByZW1vdmVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm1hdGNoT3B0aW9uc10gVGhlIFtgQ2FjaGVRdWVyeU9wdGlvbnNgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FjaGUvZGVsZXRlI1BhcmFtZXRlcnMpXG4gICAgICogdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiBjYWxsaW5nIGBkZWxldGUoKWAgb24gdGhlIGNhY2hlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNhY2hlTmFtZSwgY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JlcnVuUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBhc3NlcnQuaXNUeXBlKGNhY2hlTmFtZSwgJ3N0cmluZycsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1leHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdDYWNoZUV4cGlyYXRpb24nLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnY29uc3RydWN0b3InLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ2NhY2hlTmFtZScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghKGNvbmZpZy5tYXhFbnRyaWVzIHx8IGNvbmZpZy5tYXhBZ2VTZWNvbmRzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ21heC1lbnRyaWVzLW9yLWFnZS1yZXF1aXJlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtZXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ0NhY2hlRXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnY29uc3RydWN0b3InLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZy5tYXhFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmlzVHlwZShjb25maWcubWF4RW50cmllcywgJ251bWJlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtZXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ0NhY2hlRXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnY29uc3RydWN0b3InLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdjb25maWcubWF4RW50cmllcycsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLm1heEFnZVNlY29uZHMpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuaXNUeXBlKGNvbmZpZy5tYXhBZ2VTZWNvbmRzLCAnbnVtYmVyJywge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1leHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnQ2FjaGVFeHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ2NvbmZpZy5tYXhBZ2VTZWNvbmRzJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXhFbnRyaWVzID0gY29uZmlnLm1heEVudHJpZXM7XG4gICAgICAgIHRoaXMuX21heEFnZVNlY29uZHMgPSBjb25maWcubWF4QWdlU2Vjb25kcztcbiAgICAgICAgdGhpcy5fbWF0Y2hPcHRpb25zID0gY29uZmlnLm1hdGNoT3B0aW9ucztcbiAgICAgICAgdGhpcy5fY2FjaGVOYW1lID0gY2FjaGVOYW1lO1xuICAgICAgICB0aGlzLl90aW1lc3RhbXBNb2RlbCA9IG5ldyBDYWNoZVRpbWVzdGFtcHNNb2RlbChjYWNoZU5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBpcmVzIGVudHJpZXMgZm9yIHRoZSBnaXZlbiBjYWNoZSBhbmQgZ2l2ZW4gY3JpdGVyaWEuXG4gICAgICovXG4gICAgYXN5bmMgZXhwaXJlRW50cmllcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xuICAgICAgICAgICAgdGhpcy5fcmVydW5SZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IG1pblRpbWVzdGFtcCA9IHRoaXMuX21heEFnZVNlY29uZHMgP1xuICAgICAgICAgICAgRGF0ZS5ub3coKSAtICh0aGlzLl9tYXhBZ2VTZWNvbmRzICogMTAwMCkgOiAwO1xuICAgICAgICBjb25zdCB1cmxzRXhwaXJlZCA9IGF3YWl0IHRoaXMuX3RpbWVzdGFtcE1vZGVsLmV4cGlyZUVudHJpZXMobWluVGltZXN0YW1wLCB0aGlzLl9tYXhFbnRyaWVzKTtcbiAgICAgICAgLy8gRGVsZXRlIFVSTHMgZnJvbSB0aGUgY2FjaGVcbiAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBzZWxmLmNhY2hlcy5vcGVuKHRoaXMuX2NhY2hlTmFtZSk7XG4gICAgICAgIGZvciAoY29uc3QgdXJsIG9mIHVybHNFeHBpcmVkKSB7XG4gICAgICAgICAgICBhd2FpdCBjYWNoZS5kZWxldGUodXJsLCB0aGlzLl9tYXRjaE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodXJsc0V4cGlyZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgRXhwaXJlZCAke3VybHNFeHBpcmVkLmxlbmd0aH0gYCArXG4gICAgICAgICAgICAgICAgICAgIGAke3VybHNFeHBpcmVkLmxlbmd0aCA9PT0gMSA/ICdlbnRyeScgOiAnZW50cmllcyd9IGFuZCByZW1vdmVkIGAgK1xuICAgICAgICAgICAgICAgICAgICBgJHt1cmxzRXhwaXJlZC5sZW5ndGggPT09IDEgPyAnaXQnIDogJ3RoZW0nfSBmcm9tIHRoZSBgICtcbiAgICAgICAgICAgICAgICAgICAgYCcke3RoaXMuX2NhY2hlTmFtZX0nIGNhY2hlLmApO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYEV4cGlyZWQgdGhlIGZvbGxvd2luZyAke3VybHNFeHBpcmVkLmxlbmd0aCA9PT0gMSA/XG4gICAgICAgICAgICAgICAgICAgICdVUkwnIDogJ1VSTHMnfTpgKTtcbiAgICAgICAgICAgICAgICB1cmxzRXhwaXJlZC5mb3JFYWNoKCh1cmwpID0+IGxvZ2dlci5sb2coYCAgICAke3VybH1gKSk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYENhY2hlIGV4cGlyYXRpb24gcmFuIGFuZCBmb3VuZCBubyBlbnRyaWVzIHRvIHJlbW92ZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX3JlcnVuUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXJ1blJlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZG9udFdhaXRGb3IodGhpcy5leHBpcmVFbnRyaWVzKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgdGltZXN0YW1wIGZvciB0aGUgZ2l2ZW4gVVJMLiBUaGlzIGVuc3VyZXMgdGhlIHdoZW5cbiAgICAgKiByZW1vdmluZyBlbnRyaWVzIGJhc2VkIG9uIG1heGltdW0gZW50cmllcywgbW9zdCByZWNlbnRseSB1c2VkXG4gICAgICogaXMgYWNjdXJhdGUgb3Igd2hlbiBleHBpcmluZywgdGhlIHRpbWVzdGFtcCBpcyB1cC10by1kYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVRpbWVzdGFtcCh1cmwpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc1R5cGUodXJsLCAnc3RyaW5nJywge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LWV4cGlyYXRpb24nLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ0NhY2hlRXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICd1cGRhdGVUaW1lc3RhbXAnLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ3VybCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl90aW1lc3RhbXBNb2RlbC5zZXRUaW1lc3RhbXAodXJsLCBEYXRlLm5vdygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuIGJlIHVzZWQgdG8gY2hlY2sgaWYgYSBVUkwgaGFzIGV4cGlyZWQgb3Igbm90IGJlZm9yZSBpdCdzIHVzZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIHJlcXVpcmVzIGEgbG9vayB1cCBmcm9tIEluZGV4ZWREQiwgc28gY2FuIGJlIHNsb3cuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCB3aWxsIG5vdCByZW1vdmUgdGhlIGNhY2hlZCBlbnRyeSwgY2FsbFxuICAgICAqIGBleHBpcmVFbnRyaWVzKClgIHRvIHJlbW92ZSBpbmRleGVkREIgYW5kIENhY2hlIGVudHJpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBhc3luYyBpc1VSTEV4cGlyZWQodXJsKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWF4QWdlU2Vjb25kcykge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKGBleHBpcmVkLXRlc3Qtd2l0aG91dC1tYXgtYWdlYCwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2ROYW1lOiAnaXNVUkxFeHBpcmVkJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnbWF4QWdlU2Vjb25kcycsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBhd2FpdCB0aGlzLl90aW1lc3RhbXBNb2RlbC5nZXRUaW1lc3RhbXAodXJsKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGlyZU9sZGVyVGhhbiA9IERhdGUubm93KCkgLSAodGhpcy5fbWF4QWdlU2Vjb25kcyAqIDEwMDApO1xuICAgICAgICAgICAgcmV0dXJuICh0aW1lc3RhbXAgPCBleHBpcmVPbGRlclRoYW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIEluZGV4ZWREQiBvYmplY3Qgc3RvcmUgdXNlZCB0byBrZWVwIHRyYWNrIG9mIGNhY2hlIGV4cGlyYXRpb25cbiAgICAgKiBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUoKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBhdHRlbXB0IGFub3RoZXIgcmVydW4gaWYgd2UncmUgY2FsbGVkIGluIHRoZSBtaWRkbGUgb2ZcbiAgICAgICAgLy8gYSBjYWNoZSBleHBpcmF0aW9uLlxuICAgICAgICB0aGlzLl9yZXJ1blJlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICBhd2FpdCB0aGlzLl90aW1lc3RhbXBNb2RlbC5leHBpcmVFbnRyaWVzKEluZmluaXR5KTsgLy8gRXhwaXJlcyBhbGwuXG4gICAgfVxufVxuZXhwb3J0IHsgQ2FjaGVFeHBpcmF0aW9uIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL19wcml2YXRlL2xvZ2dlci5qcyc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuL19wcml2YXRlL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBxdW90YUVycm9yQ2FsbGJhY2tzIH0gZnJvbSAnLi9tb2RlbHMvcXVvdGFFcnJvckNhbGxiYWNrcy5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBBZGRzIGEgZnVuY3Rpb24gdG8gdGhlIHNldCBvZiBxdW90YUVycm9yQ2FsbGJhY2tzIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBpZlxuICogdGhlcmUncyBhIHF1b3RhIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtY29yZVxuICovXG5mdW5jdGlvbiByZWdpc3RlclF1b3RhRXJyb3JDYWxsYmFjayhjYWxsYmFjaykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydC5pc1R5cGUoY2FsbGJhY2ssICdmdW5jdGlvbicsIHtcbiAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LWNvcmUnLFxuICAgICAgICAgICAgZnVuY05hbWU6ICdyZWdpc3RlcicsXG4gICAgICAgICAgICBwYXJhbU5hbWU6ICdjYWxsYmFjaycsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBxdW90YUVycm9yQ2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnUmVnaXN0ZXJlZCBhIGNhbGxiYWNrIHRvIHJlc3BvbmQgdG8gcXVvdGEgZXJyb3JzLicsIGNhbGxiYWNrKTtcbiAgICB9XG59XG5leHBvcnQgeyByZWdpc3RlclF1b3RhRXJyb3JDYWxsYmFjayB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBjYWNoZU5hbWVzIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2NhY2hlTmFtZXMuanMnO1xuaW1wb3J0IHsgZG9udFdhaXRGb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZG9udFdhaXRGb3IuanMnO1xuaW1wb3J0IHsgZ2V0RnJpZW5kbHlVUkwgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwuanMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5qcyc7XG5pbXBvcnQgeyByZWdpc3RlclF1b3RhRXJyb3JDYWxsYmFjayB9IGZyb20gJ3dvcmtib3gtY29yZS9yZWdpc3RlclF1b3RhRXJyb3JDYWxsYmFjay5qcyc7XG5pbXBvcnQgeyBXb3JrYm94RXJyb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCB7IENhY2hlRXhwaXJhdGlvbiB9IGZyb20gJy4vQ2FjaGVFeHBpcmF0aW9uLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIFRoaXMgcGx1Z2luIGNhbiBiZSB1c2VkIGluIGEgYHdvcmtib3gtc3RyYXRlZ3lgIHRvIHJlZ3VsYXJseSBlbmZvcmNlIGFcbiAqIGxpbWl0IG9uIHRoZSBhZ2UgYW5kIC8gb3IgdGhlIG51bWJlciBvZiBjYWNoZWQgcmVxdWVzdHMuXG4gKlxuICogSXQgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIGB3b3JrYm94LXN0cmF0ZWd5YCBpbnN0YW5jZXMgdGhhdCBoYXZlIGFcbiAqIFtjdXN0b20gYGNhY2hlTmFtZWAgcHJvcGVydHkgc2V0XSgvd2ViL3Rvb2xzL3dvcmtib3gvZ3VpZGVzL2NvbmZpZ3VyZS13b3JrYm94I2N1c3RvbV9jYWNoZV9uYW1lc19pbl9zdHJhdGVnaWVzKS5cbiAqIEluIG90aGVyIHdvcmRzLCBpdCBjYW4ndCBiZSB1c2VkIHRvIGV4cGlyZSBlbnRyaWVzIGluIHN0cmF0ZWd5IHRoYXQgdXNlcyB0aGVcbiAqIGRlZmF1bHQgcnVudGltZSBjYWNoZSBuYW1lLlxuICpcbiAqIFdoZW5ldmVyIGEgY2FjaGVkIHJlcXVlc3QgaXMgdXNlZCBvciB1cGRhdGVkLCB0aGlzIHBsdWdpbiB3aWxsIGxvb2tcbiAqIGF0IHRoZSBhc3NvY2lhdGVkIGNhY2hlIGFuZCByZW1vdmUgYW55IG9sZCBvciBleHRyYSByZXF1ZXN0cy5cbiAqXG4gKiBXaGVuIHVzaW5nIGBtYXhBZ2VTZWNvbmRzYCwgcmVxdWVzdHMgbWF5IGJlIHVzZWQgKm9uY2UqIGFmdGVyIGV4cGlyaW5nXG4gKiBiZWNhdXNlIHRoZSBleHBpcmF0aW9uIGNsZWFuIHVwIHdpbGwgbm90IGhhdmUgb2NjdXJyZWQgdW50aWwgKmFmdGVyKiB0aGVcbiAqIGNhY2hlZCByZXF1ZXN0IGhhcyBiZWVuIHVzZWQuIElmIHRoZSByZXF1ZXN0IGhhcyBhIFwiRGF0ZVwiIGhlYWRlciwgdGhlblxuICogYSBsaWdodCB3ZWlnaHQgZXhwaXJhdGlvbiBjaGVjayBpcyBwZXJmb3JtZWQgYW5kIHRoZSByZXF1ZXN0IHdpbGwgbm90IGJlXG4gKiB1c2VkIGltbWVkaWF0ZWx5LlxuICpcbiAqIFdoZW4gdXNpbmcgYG1heEVudHJpZXNgLCB0aGUgZW50cnkgbGVhc3QtcmVjZW50bHkgcmVxdWVzdGVkIHdpbGwgYmUgcmVtb3ZlZFxuICogZnJvbSB0aGUgY2FjaGUgZmlyc3QuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LWV4cGlyYXRpb25cbiAqL1xuY2xhc3MgRXhwaXJhdGlvblBsdWdpbiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLm1heEVudHJpZXNdIFRoZSBtYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzIHRvIGNhY2hlLlxuICAgICAqIEVudHJpZXMgdXNlZCB0aGUgbGVhc3Qgd2lsbCBiZSByZW1vdmVkIGFzIHRoZSBtYXhpbXVtIGlzIHJlYWNoZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubWF4QWdlU2Vjb25kc10gVGhlIG1heGltdW0gYWdlIG9mIGFuIGVudHJ5IGJlZm9yZVxuICAgICAqIGl0J3MgdHJlYXRlZCBhcyBzdGFsZSBhbmQgcmVtb3ZlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5tYXRjaE9wdGlvbnNdIFRoZSBbYENhY2hlUXVlcnlPcHRpb25zYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhY2hlL2RlbGV0ZSNQYXJhbWV0ZXJzKVxuICAgICAqIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gY2FsbGluZyBgZGVsZXRlKClgIG9uIHRoZSBjYWNoZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb25maWcucHVyZ2VPblF1b3RhRXJyb3JdIFdoZXRoZXIgdG8gb3B0IHRoaXMgY2FjaGUgaW4gdG9cbiAgICAgKiBhdXRvbWF0aWMgZGVsZXRpb24gaWYgdGhlIGF2YWlsYWJsZSBzdG9yYWdlIHF1b3RhIGhhcyBiZWVuIGV4Y2VlZGVkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIFwibGlmZWN5Y2xlXCIgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIHRyaWdnZXJlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZVxuICAgICAgICAgKiBgd29ya2JveC1zdHJhdGVnaWVzYCBoYW5kbGVycyB3aGVuIGEgYFJlc3BvbnNlYCBpcyBhYm91dCB0byBiZSByZXR1cm5lZFxuICAgICAgICAgKiBmcm9tIGEgW0NhY2hlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FjaGUpIHRvXG4gICAgICAgICAqIHRoZSBoYW5kbGVyLiBJdCBhbGxvd3MgdGhlIGBSZXNwb25zZWAgdG8gYmUgaW5zcGVjdGVkIGZvciBmcmVzaG5lc3MgYW5kXG4gICAgICAgICAqIHByZXZlbnRzIGl0IGZyb20gYmVpbmcgdXNlZCBpZiB0aGUgYFJlc3BvbnNlYCdzIGBEYXRlYCBoZWFkZXIgdmFsdWUgaXNcbiAgICAgICAgICogb2xkZXIgdGhhbiB0aGUgY29uZmlndXJlZCBgbWF4QWdlU2Vjb25kc2AuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNhY2hlTmFtZSBOYW1lIG9mIHRoZSBjYWNoZSB0aGUgcmVzcG9uc2UgaXMgaW4uXG4gICAgICAgICAqIEBwYXJhbSB7UmVzcG9uc2V9IG9wdGlvbnMuY2FjaGVkUmVzcG9uc2UgVGhlIGBSZXNwb25zZWAgb2JqZWN0IHRoYXQncyBiZWVuXG4gICAgICAgICAqICAgICByZWFkIGZyb20gYSBjYWNoZSBhbmQgd2hvc2UgZnJlc2huZXNzIHNob3VsZCBiZSBjaGVja2VkLlxuICAgICAgICAgKiBAcmV0dXJuIHtSZXNwb25zZX0gRWl0aGVyIHRoZSBgY2FjaGVkUmVzcG9uc2VgLCBpZiBpdCdzXG4gICAgICAgICAqICAgICBmcmVzaCwgb3IgYG51bGxgIGlmIHRoZSBgUmVzcG9uc2VgIGlzIG9sZGVyIHRoYW4gYG1heEFnZVNlY29uZHNgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWNoZWRSZXNwb25zZVdpbGxCZVVzZWQgPSBhc3luYyAoeyBldmVudCwgcmVxdWVzdCwgY2FjaGVOYW1lLCBjYWNoZWRSZXNwb25zZSB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlZFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc0ZyZXNoID0gdGhpcy5faXNSZXNwb25zZURhdGVGcmVzaChjYWNoZWRSZXNwb25zZSk7XG4gICAgICAgICAgICAvLyBFeHBpcmUgZW50cmllcyB0byBlbnN1cmUgdGhhdCBldmVuIGlmIHRoZSBleHBpcmF0aW9uIGRhdGUgaGFzXG4gICAgICAgICAgICAvLyBleHBpcmVkLCBpdCdsbCBvbmx5IGJlIHVzZWQgb25jZS5cbiAgICAgICAgICAgIGNvbnN0IGNhY2hlRXhwaXJhdGlvbiA9IHRoaXMuX2dldENhY2hlRXhwaXJhdGlvbihjYWNoZU5hbWUpO1xuICAgICAgICAgICAgZG9udFdhaXRGb3IoY2FjaGVFeHBpcmF0aW9uLmV4cGlyZUVudHJpZXMoKSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG1ldGFkYXRhIGZvciB0aGUgcmVxdWVzdCBVUkwgdG8gdGhlIGN1cnJlbnQgdGltZXN0YW1wLFxuICAgICAgICAgICAgLy8gYnV0IGRvbid0IGBhd2FpdGAgaXQgYXMgd2UgZG9uJ3Qgd2FudCB0byBibG9jayB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVUaW1lc3RhbXBEb25lID0gY2FjaGVFeHBpcmF0aW9uLnVwZGF0ZVRpbWVzdGFtcChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC53YWl0VW50aWwodXBkYXRlVGltZXN0YW1wRG9uZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGV2ZW50IG1heSBub3QgYmUgYSBmZXRjaCBldmVudDsgb25seSBsb2cgdGhlIFVSTCBpZiBpdCBpcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgncmVxdWVzdCcgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgVW5hYmxlIHRvIGVuc3VyZSBzZXJ2aWNlIHdvcmtlciBzdGF5cyBhbGl2ZSB3aGVuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgdXBkYXRpbmcgY2FjaGUgZW50cnkgZm9yIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJyR7Z2V0RnJpZW5kbHlVUkwoZXZlbnQucmVxdWVzdC51cmwpfScuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNGcmVzaCA/IGNhY2hlZFJlc3BvbnNlIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgXCJsaWZlY3ljbGVcIiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgdHJpZ2dlcmVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlXG4gICAgICAgICAqIGB3b3JrYm94LXN0cmF0ZWdpZXNgIGhhbmRsZXJzIHdoZW4gYW4gZW50cnkgaXMgYWRkZWQgdG8gYSBjYWNoZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2FjaGVOYW1lIE5hbWUgb2YgdGhlIGNhY2hlIHRoYXQgd2FzIHVwZGF0ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJlcXVlc3QgVGhlIFJlcXVlc3QgZm9yIHRoZSBjYWNoZWQgZW50cnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhY2hlRGlkVXBkYXRlID0gYXN5bmMgKHsgY2FjaGVOYW1lLCByZXF1ZXN0IH0pID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmlzVHlwZShjYWNoZU5hbWUsICdzdHJpbmcnLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LWV4cGlyYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdQbHVnaW4nLFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ2NhY2hlRGlkVXBkYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnY2FjaGVOYW1lJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhc3NlcnQuaXNJbnN0YW5jZShyZXF1ZXN0LCBSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LWV4cGlyYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdQbHVnaW4nLFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ2NhY2hlRGlkVXBkYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAncmVxdWVzdCcsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYWNoZUV4cGlyYXRpb24gPSB0aGlzLl9nZXRDYWNoZUV4cGlyYXRpb24oY2FjaGVOYW1lKTtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlRXhwaXJhdGlvbi51cGRhdGVUaW1lc3RhbXAocmVxdWVzdC51cmwpO1xuICAgICAgICAgICAgYXdhaXQgY2FjaGVFeHBpcmF0aW9uLmV4cGlyZUVudHJpZXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGlmICghKGNvbmZpZy5tYXhFbnRyaWVzIHx8IGNvbmZpZy5tYXhBZ2VTZWNvbmRzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ21heC1lbnRyaWVzLW9yLWFnZS1yZXF1aXJlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtZXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1BsdWdpbicsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnY29uc3RydWN0b3InLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZy5tYXhFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmlzVHlwZShjb25maWcubWF4RW50cmllcywgJ251bWJlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtZXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1BsdWdpbicsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnY29uc3RydWN0b3InLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdjb25maWcubWF4RW50cmllcycsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLm1heEFnZVNlY29uZHMpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuaXNUeXBlKGNvbmZpZy5tYXhBZ2VTZWNvbmRzLCAnbnVtYmVyJywge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1leHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUGx1Z2luJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ2NvbmZpZy5tYXhBZ2VTZWNvbmRzJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuX21heEFnZVNlY29uZHMgPSBjb25maWcubWF4QWdlU2Vjb25kcztcbiAgICAgICAgdGhpcy5fY2FjaGVFeHBpcmF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wdXJnZU9uUXVvdGFFcnJvcikge1xuICAgICAgICAgICAgcmVnaXN0ZXJRdW90YUVycm9yQ2FsbGJhY2soKCkgPT4gdGhpcy5kZWxldGVDYWNoZUFuZE1ldGFkYXRhKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIGhlbHBlciBtZXRob2QgdG8gcmV0dXJuIGEgQ2FjaGVFeHBpcmF0aW9uIGluc3RhbmNlIGZvciBhIGdpdmVuXG4gICAgICogY2FjaGUgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWVcbiAgICAgKiBAcmV0dXJuIHtDYWNoZUV4cGlyYXRpb259XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDYWNoZUV4cGlyYXRpb24oY2FjaGVOYW1lKSB7XG4gICAgICAgIGlmIChjYWNoZU5hbWUgPT09IGNhY2hlTmFtZXMuZ2V0UnVudGltZU5hbWUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignZXhwaXJlLWN1c3RvbS1jYWNoZXMtb25seScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjYWNoZUV4cGlyYXRpb24gPSB0aGlzLl9jYWNoZUV4cGlyYXRpb25zLmdldChjYWNoZU5hbWUpO1xuICAgICAgICBpZiAoIWNhY2hlRXhwaXJhdGlvbikge1xuICAgICAgICAgICAgY2FjaGVFeHBpcmF0aW9uID0gbmV3IENhY2hlRXhwaXJhdGlvbihjYWNoZU5hbWUsIHRoaXMuX2NvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUV4cGlyYXRpb25zLnNldChjYWNoZU5hbWUsIGNhY2hlRXhwaXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlRXhwaXJhdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtSZXNwb25zZX0gY2FjaGVkUmVzcG9uc2VcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNSZXNwb25zZURhdGVGcmVzaChjYWNoZWRSZXNwb25zZSkge1xuICAgICAgICBpZiAoIXRoaXMuX21heEFnZVNlY29uZHMpIHtcbiAgICAgICAgICAgIC8vIFdlIGFyZW4ndCBleHBpcmluZyBieSBhZ2UsIHNvIHJldHVybiB0cnVlLCBpdCdzIGZyZXNoXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgJ2RhdGUnIGhlYWRlciB3aWxsIHN1ZmZpY2UgYSBxdWljayBleHBpcmF0aW9uIGNoZWNrLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvc3ctdG9vbGJveC9pc3N1ZXMvMTY0IGZvclxuICAgICAgICAvLyBkaXNjdXNzaW9uLlxuICAgICAgICBjb25zdCBkYXRlSGVhZGVyVGltZXN0YW1wID0gdGhpcy5fZ2V0RGF0ZUhlYWRlclRpbWVzdGFtcChjYWNoZWRSZXNwb25zZSk7XG4gICAgICAgIGlmIChkYXRlSGVhZGVyVGltZXN0YW1wID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBVbmFibGUgdG8gcGFyc2UgZGF0ZSwgc28gYXNzdW1lIGl0J3MgZnJlc2guXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgdmFsaWQgaGVhZGVyVGltZSwgdGhlbiBvdXIgcmVzcG9uc2UgaXMgZnJlc2ggaWZmIHRoZVxuICAgICAgICAvLyBoZWFkZXJUaW1lIHBsdXMgbWF4QWdlU2Vjb25kcyBpcyBncmVhdGVyIHRoYW4gdGhlIGN1cnJlbnQgdGltZS5cbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIGRhdGVIZWFkZXJUaW1lc3RhbXAgPj0gbm93IC0gKHRoaXMuX21heEFnZVNlY29uZHMgKiAxMDAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBleHRyYWN0IHRoZSBkYXRhIGhlYWRlciBhbmQgcGFyc2UgaXQgaW50byBhIHVzZWZ1bFxuICAgICAqIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZXNwb25zZX0gY2FjaGVkUmVzcG9uc2VcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ8bnVsbH1cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldERhdGVIZWFkZXJUaW1lc3RhbXAoY2FjaGVkUmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKCFjYWNoZWRSZXNwb25zZS5oZWFkZXJzLmhhcygnZGF0ZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRlSGVhZGVyID0gY2FjaGVkUmVzcG9uc2UuaGVhZGVycy5nZXQoJ2RhdGUnKTtcbiAgICAgICAgY29uc3QgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKGRhdGVIZWFkZXIpO1xuICAgICAgICBjb25zdCBoZWFkZXJUaW1lID0gcGFyc2VkRGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgIC8vIElmIHRoZSBEYXRlIGhlYWRlciB3YXMgaW52YWxpZCBmb3Igc29tZSByZWFzb24sIHBhcnNlZERhdGUuZ2V0VGltZSgpXG4gICAgICAgIC8vIHdpbGwgcmV0dXJuIE5hTi5cbiAgICAgICAgaWYgKGlzTmFOKGhlYWRlclRpbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVyVGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIGhlbHBlciBtZXRob2QgdGhhdCBwZXJmb3JtcyB0d28gb3BlcmF0aW9uczpcbiAgICAgKlxuICAgICAqIC0gRGVsZXRlcyAqYWxsKiB0aGUgdW5kZXJseWluZyBDYWNoZSBpbnN0YW5jZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcGx1Z2luXG4gICAgICogaW5zdGFuY2UsIGJ5IGNhbGxpbmcgY2FjaGVzLmRlbGV0ZSgpIG9uIHlvdXIgYmVoYWxmLlxuICAgICAqIC0gRGVsZXRlcyB0aGUgbWV0YWRhdGEgZnJvbSBJbmRleGVkREIgdXNlZCB0byBrZWVwIHRyYWNrIG9mIGV4cGlyYXRpb25cbiAgICAgKiBkZXRhaWxzIGZvciBlYWNoIENhY2hlIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogV2hlbiB1c2luZyBjYWNoZSBleHBpcmF0aW9uLCBjYWxsaW5nIHRoaXMgbWV0aG9kIGlzIHByZWZlcmFibGUgdG8gY2FsbGluZ1xuICAgICAqIGBjYWNoZXMuZGVsZXRlKClgIGRpcmVjdGx5LCBzaW5jZSB0aGlzIHdpbGwgZW5zdXJlIHRoYXQgdGhlIEluZGV4ZWREQlxuICAgICAqIG1ldGFkYXRhIGlzIGFsc28gY2xlYW5seSByZW1vdmVkIGFuZCBvcGVuIEluZGV4ZWREQiBpbnN0YW5jZXMgYXJlIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgaWYgeW91J3JlICpub3QqIHVzaW5nIGNhY2hlIGV4cGlyYXRpb24gZm9yIGEgZ2l2ZW4gY2FjaGUsIGNhbGxpbmdcbiAgICAgKiBgY2FjaGVzLmRlbGV0ZSgpYCBhbmQgcGFzc2luZyBpbiB0aGUgY2FjaGUncyBuYW1lIHNob3VsZCBiZSBzdWZmaWNpZW50LlxuICAgICAqIFRoZXJlIGlzIG5vIFdvcmtib3gtc3BlY2lmaWMgbWV0aG9kIG5lZWRlZCBmb3IgY2xlYW51cCBpbiB0aGF0IGNhc2UuXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlQ2FjaGVBbmRNZXRhZGF0YSgpIHtcbiAgICAgICAgLy8gRG8gdGhpcyBvbmUgYXQgYSB0aW1lIGluc3RlYWQgb2YgYWxsIGF0IG9uY2UgdmlhIGBQcm9taXNlLmFsbCgpYCB0b1xuICAgICAgICAvLyByZWR1Y2UgdGhlIGNoYW5jZSBvZiBpbmNvbnNpc3RlbmN5IGlmIGEgcHJvbWlzZSByZWplY3RzLlxuICAgICAgICBmb3IgKGNvbnN0IFtjYWNoZU5hbWUsIGNhY2hlRXhwaXJhdGlvbl0gb2YgdGhpcy5fY2FjaGVFeHBpcmF0aW9ucykge1xuICAgICAgICAgICAgYXdhaXQgc2VsZi5jYWNoZXMuZGVsZXRlKGNhY2hlTmFtZSk7XG4gICAgICAgICAgICBhd2FpdCBjYWNoZUV4cGlyYXRpb24uZGVsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgdGhpcy5fY2FjaGVFeHBpcmF0aW9ucyB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cbiAgICAgICAgdGhpcy5fY2FjaGVFeHBpcmF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB9XG59XG5leHBvcnQgeyBFeHBpcmF0aW9uUGx1Z2luIH07XG4iLCJpbXBvcnQgeyB0aW1lc3RhbXAsIGZpbGVzLCBzaGVsbCB9IGZyb20gJ0BzYXBwZXIvc2VydmljZS13b3JrZXInO1xuaW1wb3J0IHsgcHJlY2FjaGVBbmRSb3V0ZSB9IGZyb20gJ3dvcmtib3gtcHJlY2FjaGluZyc7XG5pbXBvcnQgeyBDYWNoZUZpcnN0IH0gZnJvbSAnd29ya2JveC1zdHJhdGVnaWVzJztcbmltcG9ydCB7IHJlZ2lzdGVyUm91dGUgfSBmcm9tICd3b3JrYm94LXJvdXRpbmcnO1xuaW1wb3J0IHsgRXhwaXJhdGlvblBsdWdpbiB9IGZyb20gJ3dvcmtib3gtZXhwaXJhdGlvbic7XG5cbmNvbnN0IEFTU0VUUyA9IGBjYWNoZSR7dGltZXN0YW1wfWA7XG5cbi8vIGBzaGVsbGAgaXMgYW4gYXJyYXkgb2YgYWxsIHRoZSBmaWxlcyBnZW5lcmF0ZWQgYnkgdGhlIGJ1bmRsZXIsXG4vLyBgZmlsZXNgIGlzIGFuIGFycmF5IG9mIGV2ZXJ5dGhpbmcgaW4gdGhlIGBzdGF0aWNgIGRpcmVjdG9yeVxuY29uc3QgdG9fY2FjaGUgPSBzaGVsbC5jb25jYXQoZmlsZXMpO1xuY29uc3Qgc3RhdGljQXNzZXRzID0gbmV3IFNldCh0b19jYWNoZSk7XG5cbnNlbGYuX19XQl9ESVNBQkxFX0RFVl9MT0dTID0gdHJ1ZTtcblxucHJlY2FjaGVBbmRSb3V0ZShzaGVsbCk7XG5wcmVjYWNoZUFuZFJvdXRlKGZpbGVzKTtcblxucmVnaXN0ZXJSb3V0ZShcbi8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAqL1xuICBuZXcgUmVnRXhwKCdodHRwczpcXC9cXC9wcm9kdWN0ZXVyc2FncmlcXC5vcGVuZGF0YXNvZnRcXC5jb20nKSxcbiAgbmV3IENhY2hlRmlyc3Qoe1xuICAgIGNhY2hlTmFtZTogYG9kcy1yZXF1ZXN0cy0ke3RpbWVzdGFtcH1gLFxuICAgIHBsdWdpbnM6IFtcbiAgICAgIG5ldyBFeHBpcmF0aW9uUGx1Z2luKHtcbiAgICAgICAgbWF4RW50cmllczogNTAsXG4gICAgICAgIG1heEFnZVNlY29uZHM6IDM2MDAgKiAyNCxcbiAgICAgIH0pLFxuICAgIF0sXG4gIH0pLFxuKTtcbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJtZXNzYWdlcyJdLCJtYXBwaW5ncyI6Ijs7O0NBQUE7Q0FDTyxNQUFNLFNBQVMsR0FBRyxhQUFhLENBQUM7QUFDdkM7Q0FDTyxNQUFNLEtBQUssR0FBRztDQUNyQixDQUFDLDRCQUE0QjtDQUM3QixDQUFDLHVDQUF1QztDQUN4QyxDQUFDLHVDQUF1QztDQUN4QyxDQUFDLGlDQUFpQztDQUNsQyxDQUFDLDhCQUE4QjtDQUMvQixDQUFDLDhCQUE4QjtDQUMvQixDQUFDLDhCQUE4QjtDQUMvQixDQUFDLHdCQUF3QjtDQUN6QixDQUFDLHdCQUF3QjtDQUN6QixDQUFDLHVCQUF1QjtDQUN4QixDQUFDLHlCQUF5QjtDQUMxQixDQUFDLHlCQUF5QjtDQUMxQixDQUFDLHlCQUF5QjtDQUMxQixDQUFDLGlDQUFpQztDQUNsQyxDQUFDLCtCQUErQjtDQUNoQyxDQUFDLCtCQUErQjtDQUNoQyxDQUFDLCtCQUErQjtDQUNoQyxDQUFDLCtCQUErQjtDQUNoQyxDQUFDLDZCQUE2QjtDQUM5QixDQUFDLGtDQUFrQztDQUNuQyxDQUFDLENBQUM7QUFFRjtDQUNPLE1BQU0sS0FBSyxHQUFHO0NBQ3JCO0NBQ0EsQ0FBQzs7Q0M1QkQ7Q0FDQSxJQUFJO0NBQ0osSUFBSSxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztDQUN0QyxDQUFDO0NBQ0QsT0FBTyxDQUFDLEVBQUU7O0NDTFY7Q0FDQTtBQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FFTyxNQUFNLFFBQVEsR0FBRztDQUN4QixJQUFJLGVBQWUsRUFBRSxDQUFDLEVBQUUsU0FBUyxFQUFFLHFCQUFxQixFQUFFLEtBQUssRUFBRSxLQUFLO0NBQ3RFLFFBQVEsSUFBSSxDQUFDLFNBQVMsSUFBSSxDQUFDLHFCQUFxQixFQUFFO0NBQ2xELFlBQVksTUFBTSxJQUFJLEtBQUssQ0FBQyxDQUFDLDBDQUEwQyxDQUFDLENBQUMsQ0FBQztDQUMxRSxTQUFTO0NBQ1QsUUFBUSxPQUFPLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxzQ0FBc0MsQ0FBQztDQUN4RSxZQUFZLENBQUMsa0JBQWtCLEVBQUUscUJBQXFCLENBQUMscUJBQXFCLENBQUM7Q0FDN0UsWUFBWSxDQUFDLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUN4QyxLQUFLO0NBQ0wsSUFBSSxjQUFjLEVBQUUsQ0FBQyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxLQUFLO0NBQ3hFLFFBQVEsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLFNBQVMsSUFBSSxDQUFDLFFBQVEsSUFBSSxDQUFDLFNBQVMsRUFBRTtDQUNsRSxZQUFZLE1BQU0sSUFBSSxLQUFLLENBQUMsQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDLENBQUM7Q0FDekUsU0FBUztDQUNULFFBQVEsT0FBTyxDQUFDLGVBQWUsRUFBRSxTQUFTLENBQUMsY0FBYyxDQUFDO0NBQzFELFlBQVksQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0NBQzNFLEtBQUs7Q0FDTCxJQUFJLGdCQUFnQixFQUFFLENBQUMsRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLEtBQUs7Q0FDeEYsUUFBUSxJQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsU0FBUyxJQUFJLENBQUMsVUFBVSxJQUFJLENBQUMsUUFBUSxFQUFFO0NBQ3JFLFlBQVksTUFBTSxJQUFJLEtBQUssQ0FBQyxDQUFDLDJDQUEyQyxDQUFDLENBQUMsQ0FBQztDQUMzRSxTQUFTO0NBQ1QsUUFBUSxPQUFPLENBQUMsZUFBZSxFQUFFLFNBQVMsQ0FBQyxjQUFjLENBQUM7Q0FDMUQsWUFBWSxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQyxFQUFFLFNBQVMsSUFBSSxTQUFTLEdBQUcsR0FBRyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0NBQ2xFLFlBQVksQ0FBQyxFQUFFLFFBQVEsQ0FBQyxvQkFBb0IsRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDOUQsS0FBSztDQUNMLElBQUksaUJBQWlCLEVBQUUsQ0FBQyxFQUFFLGFBQWEsRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsb0JBQW9CLEVBQUUsS0FBSztDQUNoSCxRQUFRLElBQUksQ0FBQyxhQUFhLElBQUksQ0FBQyxVQUFVLElBQUksQ0FBQyxRQUFRLEVBQUU7Q0FDeEQsWUFBWSxNQUFNLElBQUksS0FBSyxDQUFDLENBQUMsNENBQTRDLENBQUMsQ0FBQyxDQUFDO0NBQzVFLFNBQVM7Q0FDVCxRQUFRLElBQUksb0JBQW9CLEVBQUU7Q0FDbEMsWUFBWSxPQUFPLENBQUMsc0JBQXNCLENBQUM7Q0FDM0MsZ0JBQWdCLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLEVBQUUsU0FBUyxJQUFJLFNBQVMsR0FBRyxHQUFHLElBQUksRUFBRSxDQUFDLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQztDQUNyRixnQkFBZ0IsQ0FBQyw2QkFBNkIsRUFBRSxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQ3RFLFNBQVM7Q0FDVCxRQUFRLE9BQU8sQ0FBQyxlQUFlLEVBQUUsU0FBUyxDQUFDLGNBQWMsQ0FBQztDQUMxRCxZQUFZLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLEVBQUUsU0FBUyxJQUFJLFNBQVMsR0FBRyxHQUFHLElBQUksRUFBRSxDQUFDLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQztDQUNqRixZQUFZLENBQUMsNkJBQTZCLEVBQUUsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUNsRSxLQUFLO0NBQ0wsSUFBSSxrQkFBa0IsRUFBRSxDQUFDLEVBQUUsY0FBYyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxLQUFLO0NBQzVGLFFBQVEsSUFBSSxDQUFDLGNBQWMsSUFBSSxDQUFDLFNBQVMsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLFNBQVM7Q0FDdEUsZUFBZSxDQUFDLFFBQVEsRUFBRTtDQUMxQixZQUFZLE1BQU0sSUFBSSxLQUFLLENBQUMsQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDLENBQUM7Q0FDN0UsU0FBUztDQUNULFFBQVEsT0FBTyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQztDQUN2RSxZQUFZLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyx5QkFBeUIsRUFBRSxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUM7Q0FDL0UsS0FBSztDQUNMLElBQUksbUNBQW1DLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLO0NBQ3hELFFBQVEsT0FBTyxDQUFDLGtDQUFrQyxDQUFDO0NBQ25ELFlBQVksQ0FBQyxtRUFBbUUsQ0FBQztDQUNqRixZQUFZLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsK0NBQStDLENBQUM7Q0FDdEYsWUFBWSxDQUFDLG9FQUFvRSxDQUFDO0NBQ2xGLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0NBQy9CLEtBQUs7Q0FDTCxJQUFJLHVDQUF1QyxFQUFFLENBQUMsRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLEtBQUs7Q0FDOUUsUUFBUSxJQUFJLENBQUMsVUFBVSxJQUFJLENBQUMsV0FBVyxFQUFFO0NBQ3pDLFlBQVksTUFBTSxJQUFJLEtBQUssQ0FBQyxDQUFDLG9CQUFvQixDQUFDO0NBQ2xELGdCQUFnQixDQUFDLDRDQUE0QyxDQUFDLENBQUMsQ0FBQztDQUNoRSxTQUFTO0NBQ1QsUUFBUSxPQUFPLENBQUMsNkJBQTZCLENBQUM7Q0FDOUMsWUFBWSxDQUFDLHFFQUFxRSxDQUFDO0NBQ25GLFlBQVksQ0FBQyxFQUFFLFVBQVUsQ0FBQyxRQUFRLENBQUMsNENBQTRDLENBQUM7Q0FDaEYsWUFBWSxDQUFDLG1FQUFtRSxDQUFDO0NBQ2pGLFlBQVksQ0FBQyxlQUFlLENBQUMsQ0FBQztDQUM5QixLQUFLO0NBQ0wsSUFBSSxpQ0FBaUMsRUFBRSxDQUFDLEVBQUUsV0FBVyxFQUFFLEtBQUs7Q0FDNUQsUUFBUSxJQUFJLENBQUMsV0FBVyxFQUFFO0NBQzFCLFlBQVksTUFBTSxJQUFJLEtBQUssQ0FBQyxDQUFDLG9CQUFvQixDQUFDO0NBQ2xELGdCQUFnQixDQUFDLHlDQUF5QyxDQUFDLENBQUMsQ0FBQztDQUM3RCxTQUFTO0NBQ1QsUUFBUSxPQUFPLENBQUMsOERBQThELENBQUM7Q0FDL0UsWUFBWSxDQUFDLCtCQUErQixFQUFFLFdBQVcsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUM7Q0FDdEUsS0FBSztDQUNMLElBQUksb0JBQW9CLEVBQUUsQ0FBQyxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsS0FBSztDQUN0RCxRQUFRLElBQUksQ0FBQyxXQUFXLEVBQUU7Q0FDMUIsWUFBWSxNQUFNLElBQUksS0FBSyxDQUFDLENBQUMsdURBQXVELENBQUMsQ0FBQyxDQUFDO0NBQ3ZGLFNBQVM7Q0FDVCxRQUFRLE9BQU8sQ0FBQyw4REFBOEQsQ0FBQztDQUMvRSxZQUFZLENBQUMsaUJBQWlCLEVBQUUsV0FBVyxDQUFDLCtCQUErQixDQUFDO0NBQzVFLFlBQVksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUN6QyxLQUFLO0NBQ0wsSUFBSSw0Q0FBNEMsRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLEtBQUs7Q0FDbEUsUUFBUSxJQUFJLENBQUMsTUFBTSxFQUFFO0NBQ3JCLFlBQVksTUFBTSxJQUFJLEtBQUssQ0FBQyxDQUFDLG9CQUFvQixDQUFDO0NBQ2xELGdCQUFnQixDQUFDLG1EQUFtRCxDQUFDLENBQUMsQ0FBQztDQUN2RSxTQUFTO0NBQ1QsUUFBUSxPQUFPLENBQUMsMERBQTBELENBQUM7Q0FDM0UsWUFBWSxDQUFDLGdDQUFnQyxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztDQUMxRCxLQUFLO0NBQ0wsSUFBSSx1Q0FBdUMsRUFBRSxNQUFNO0NBQ25ELFFBQVEsT0FBTyxDQUFDLHlEQUF5RCxDQUFDO0NBQzFFLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztDQUMxQixLQUFLO0NBQ0wsSUFBSSxxQkFBcUIsRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLEtBQUs7Q0FDekMsUUFBUSxPQUFPLENBQUMscUNBQXFDLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0NBQ3ZFLEtBQUs7Q0FDTCxJQUFJLHNCQUFzQixFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsS0FBSztDQUMxQyxRQUFRLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLENBQUMseUJBQXlCLENBQUM7Q0FDakUsWUFBWSxDQUFDLGlFQUFpRSxDQUFDLENBQUM7Q0FDaEYsS0FBSztDQUNMLElBQUksOEJBQThCLEVBQUUsQ0FBQyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsS0FBSztDQUNuRSxRQUFRLE9BQU8sQ0FBQyxLQUFLLEVBQUUsVUFBVSxDQUFDLHFDQUFxQyxDQUFDO0NBQ3hFLFlBQVksQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLDZCQUE2QixDQUFDLENBQUM7Q0FDekQsS0FBSztDQUNMLElBQUksd0JBQXdCLEVBQUUsQ0FBQyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxLQUFLO0NBQ2xGLFFBQVEsT0FBTyxDQUFDLGNBQWMsRUFBRSxTQUFTLENBQUMscUNBQXFDLENBQUM7Q0FDaEYsWUFBWSxDQUFDLDBCQUEwQixFQUFFLFVBQVUsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsS0FBSyxDQUFDO0NBQ25GLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0NBQ2pDLEtBQUs7Q0FDTCxJQUFJLG9CQUFvQixFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsYUFBYSxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxLQUFLO0NBQ3BHLFFBQVEsT0FBTyxDQUFDLGNBQWMsRUFBRSxTQUFTLENBQUMsZ0NBQWdDLENBQUM7Q0FDM0UsWUFBWSxDQUFDLENBQUMsRUFBRSxhQUFhLENBQUMscUJBQXFCLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUM7Q0FDaEYsWUFBWSxDQUFDLHlCQUF5QixFQUFFLFVBQVUsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsR0FBRyxDQUFDO0NBQ2hGLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0NBQ2hDLEtBQUs7Q0FDTCxJQUFJLDZCQUE2QixFQUFFLENBQUMsRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxLQUFLO0NBQzVFLFFBQVEsT0FBTyxDQUFDLGdFQUFnRSxDQUFDO0NBQ2pGLFlBQVksQ0FBQyxHQUFHLEVBQUUsVUFBVSxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7Q0FDeEQsS0FBSztDQUNMLElBQUksOEJBQThCLEVBQUUsQ0FBQyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLEtBQUs7Q0FDN0UsUUFBUSxPQUFPLENBQUMsd0RBQXdELENBQUM7Q0FDekUsWUFBWSxDQUFDLEdBQUcsRUFBRSxVQUFVLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztDQUN4RCxLQUFLO0NBQ0wsSUFBSSxnQkFBZ0IsRUFBRSxDQUFDLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsS0FBSztDQUMvRCxRQUFRLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxVQUFVLElBQUksQ0FBQyxRQUFRLEVBQUU7Q0FDcEQsWUFBWSxNQUFNLElBQUksS0FBSyxDQUFDLENBQUMsMkNBQTJDLENBQUMsQ0FBQyxDQUFDO0NBQzNFLFNBQVM7Q0FDVCxRQUFRLE9BQU8sQ0FBQyx5QkFBeUIsRUFBRSxTQUFTLENBQUMsNEJBQTRCLENBQUM7Q0FDbEYsWUFBWSxDQUFDLG9FQUFvRSxDQUFDO0NBQ2xGLFlBQVksQ0FBQyx3QkFBd0IsRUFBRSxVQUFVLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxPQUFPLENBQUM7Q0FDdEUsWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0NBQ3pCLEtBQUs7Q0FDTCxJQUFJLHVCQUF1QixFQUFFLE1BQU07Q0FDbkMsUUFBUSxPQUFPLENBQUMsOENBQThDLENBQUM7Q0FDL0QsWUFBWSxDQUFDLDhCQUE4QixDQUFDLENBQUM7Q0FDN0MsS0FBSztDQUNMLElBQUksaUNBQWlDLEVBQUUsTUFBTTtDQUM3QyxRQUFRLE9BQU8sQ0FBQywwREFBMEQsQ0FBQztDQUMzRSxZQUFZLENBQUMsZ0RBQWdELENBQUMsQ0FBQztDQUMvRCxLQUFLO0NBQ0wsSUFBSSwyQkFBMkIsRUFBRSxNQUFNO0NBQ3ZDLFFBQVEsT0FBTyxDQUFDLHVEQUF1RCxDQUFDO0NBQ3hFLFlBQVksQ0FBQyxrREFBa0QsQ0FBQyxDQUFDO0NBQ2pFLEtBQUs7Q0FDTCxJQUFJLG9CQUFvQixFQUFFLENBQUMsRUFBRSxxQkFBcUIsRUFBRSxLQUFLO0NBQ3pELFFBQVEsSUFBSSxDQUFDLHFCQUFxQixFQUFFO0NBQ3BDLFlBQVksTUFBTSxJQUFJLEtBQUssQ0FBQyxDQUFDLCtDQUErQyxDQUFDLENBQUMsQ0FBQztDQUMvRSxTQUFTO0NBQ1QsUUFBUSxPQUFPLENBQUMsK0RBQStELENBQUM7Q0FDaEYsWUFBWSxDQUFDLCtCQUErQixFQUFFLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQ3ZFLEtBQUs7Q0FDTCxJQUFJLG1CQUFtQixFQUFFLENBQUMsRUFBRSxxQkFBcUIsRUFBRSxLQUFLO0NBQ3hELFFBQVEsSUFBSSxDQUFDLHFCQUFxQixFQUFFO0NBQ3BDLFlBQVksTUFBTSxJQUFJLEtBQUssQ0FBQyxDQUFDLDhDQUE4QyxDQUFDLENBQUMsQ0FBQztDQUM5RSxTQUFTO0NBQ1QsUUFBUSxPQUFPLENBQUMsOERBQThELENBQUM7Q0FDL0UsWUFBWSxDQUFDLDZEQUE2RCxDQUFDO0NBQzNFLFlBQVksQ0FBQyxDQUFDLEVBQUUscUJBQXFCLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDekMsS0FBSztDQUNMLElBQUksc0JBQXNCLEVBQUUsQ0FBQyxFQUFFLHFCQUFxQixFQUFFLEtBQUs7Q0FDM0QsUUFBUSxJQUFJLENBQUMscUJBQXFCLEVBQUU7Q0FDcEMsWUFBWSxNQUFNLElBQUksS0FBSyxDQUFDLENBQUMsaURBQWlELENBQUMsQ0FBQyxDQUFDO0NBQ2pGLFNBQVM7Q0FDVCxRQUFRLE9BQU8sQ0FBQyxnRUFBZ0UsQ0FBQztDQUNqRixZQUFZLENBQUMsNkRBQTZELENBQUM7Q0FDM0UsWUFBWSxDQUFDLENBQUMsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUN6QyxLQUFLO0NBQ0wsSUFBSSxpQkFBaUIsRUFBRSxNQUFNO0NBQzdCLFFBQVEsT0FBTyxDQUFDLGtEQUFrRCxDQUFDLENBQUM7Q0FDcEUsS0FBSztDQUNMLElBQUksdUJBQXVCLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLEtBQUs7Q0FDdkQsUUFBUSxPQUFPLENBQUMsV0FBVyxFQUFFLEtBQUssQ0FBQyxXQUFXLEVBQUUsR0FBRyxDQUFDLDBCQUEwQixDQUFDO0NBQy9FLFlBQVksQ0FBQyxpREFBaUQsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDOUUsS0FBSztDQUNMLElBQUksa0NBQWtDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSztDQUM3RCxRQUFRLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRSxHQUFHLENBQUMsbUJBQW1CLEVBQUUsTUFBTSxDQUFDLGNBQWMsQ0FBQztDQUNsRixZQUFZLENBQUMsa0NBQWtDLENBQUMsQ0FBQztDQUNqRCxLQUFLO0NBQ0wsSUFBSSw0QkFBNEIsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLEtBQUs7Q0FDL0MsUUFBUSxPQUFPLENBQUMsK0JBQStCLEVBQUUsR0FBRyxDQUFDLDJCQUEyQixDQUFDO0NBQ2pGLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztDQUN2QixLQUFLO0NBQ0wsSUFBSSxhQUFhLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsS0FBSztDQUN2QyxRQUFRLElBQUksT0FBTyxHQUFHLENBQUMsZ0RBQWdELEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0NBQ2pGLFFBQVEsSUFBSSxLQUFLLEVBQUU7Q0FDbkIsWUFBWSxPQUFPLElBQUksQ0FBQyx5QkFBeUIsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDNUQsU0FBUztDQUNULFFBQVEsT0FBTyxPQUFPLENBQUM7Q0FDdkIsS0FBSztDQUNMLElBQUkseUJBQXlCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSztDQUNwRCxRQUFRLE9BQU8sQ0FBQyw0QkFBNEIsRUFBRSxHQUFHLENBQUMsUUFBUSxDQUFDO0NBQzNELGFBQWEsTUFBTSxHQUFHLENBQUMsd0JBQXdCLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUNsRSxLQUFLO0NBQ0wsSUFBSSxtQkFBbUIsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLEtBQUs7Q0FDdEMsUUFBUSxPQUFPLENBQUMseUJBQXlCLEVBQUUsR0FBRyxDQUFDLCtCQUErQixDQUFDO0NBQy9FLFlBQVksQ0FBQyw4REFBOEQsQ0FBQyxDQUFDO0NBQzdFLEtBQUs7Q0FDTCxJQUFJLDJDQUEyQyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsS0FBSztDQUM5RCxRQUFRLE9BQU8sQ0FBQyw2QkFBNkIsQ0FBQztDQUM5QyxZQUFZLENBQUMscUVBQXFFLENBQUM7Q0FDbkYsWUFBWSxDQUFDLEVBQUUsR0FBRyxDQUFDLDREQUE0RCxDQUFDLENBQUM7Q0FDakYsS0FBSztDQUNMLElBQUksd0JBQXdCLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsS0FBSztDQUN0RCxRQUFRLE9BQU8sQ0FBQyx1Q0FBdUMsRUFBRSxTQUFTLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUNqRixLQUFLO0NBQ0wsSUFBSSw0QkFBNEIsRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLEtBQUs7Q0FDbEQsUUFBUSxPQUFPLENBQUMsOERBQThELENBQUM7Q0FDL0UsWUFBWSxDQUFDLGdEQUFnRCxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUN6RSxLQUFLO0NBQ0wsQ0FBQzs7Q0N2TkQ7Q0FDQTtBQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FVQSxNQUFNLGlCQUFpQixHQUFHLENBQUMsSUFBSSxFQUFFLE9BQU8sR0FBRyxFQUFFLEtBQUs7Q0FDbEQsSUFBSSxNQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDbkMsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO0NBQ2xCLFFBQVEsTUFBTSxJQUFJLEtBQUssQ0FBQyxDQUFDLGlDQUFpQyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0NBQ3RFLEtBQUs7Q0FDTCxJQUFJLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0NBQzVCLENBQUMsQ0FBQztDQUNLLE1BQU0sZ0JBQWdCLEdBQ2YsQ0FBQyxpQkFBaUI7O0NDeEJoQztDQUNBO0FBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUdBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLE1BQU0sWUFBWSxTQUFTLEtBQUssQ0FBQztDQUNqQztDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxXQUFXLENBQUMsU0FBUyxFQUFFLE9BQU8sRUFBRTtDQUNwQyxRQUFRLE1BQU0sT0FBTyxHQUFHLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztDQUM3RCxRQUFRLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztDQUN2QixRQUFRLElBQUksQ0FBQyxJQUFJLEdBQUcsU0FBUyxDQUFDO0NBQzlCLFFBQVEsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7Q0FDL0IsS0FBSztDQUNMOztDQ2pDQTtDQUNBO0FBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUdBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLE1BQU0sT0FBTyxHQUFHLENBQUMsS0FBSyxFQUFFLE9BQU8sS0FBSztDQUNwQyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO0NBQy9CLFFBQVEsTUFBTSxJQUFJLFlBQVksQ0FBQyxjQUFjLEVBQUUsT0FBTyxDQUFDLENBQUM7Q0FDeEQsS0FBSztDQUNMLENBQUMsQ0FBQztDQUNGLE1BQU0sU0FBUyxHQUFHLENBQUMsTUFBTSxFQUFFLGNBQWMsRUFBRSxPQUFPLEtBQUs7Q0FDdkQsSUFBSSxNQUFNLElBQUksR0FBRyxPQUFPLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztDQUMvQyxJQUFJLElBQUksSUFBSSxLQUFLLFVBQVUsRUFBRTtDQUM3QixRQUFRLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLGNBQWMsQ0FBQztDQUNuRCxRQUFRLE1BQU0sSUFBSSxZQUFZLENBQUMsa0JBQWtCLEVBQUUsT0FBTyxDQUFDLENBQUM7Q0FDNUQsS0FBSztDQUNMLENBQUMsQ0FBQztDQUNGLE1BQU0sTUFBTSxHQUFHLENBQUMsTUFBTSxFQUFFLFlBQVksRUFBRSxPQUFPLEtBQUs7Q0FDbEQsSUFBSSxJQUFJLE9BQU8sTUFBTSxLQUFLLFlBQVksRUFBRTtDQUN4QyxRQUFRLE9BQU8sQ0FBQyxjQUFjLENBQUMsR0FBRyxZQUFZLENBQUM7Q0FDL0MsUUFBUSxNQUFNLElBQUksWUFBWSxDQUFDLGdCQUFnQixFQUFFLE9BQU8sQ0FBQyxDQUFDO0NBQzFELEtBQUs7Q0FDTCxDQUFDLENBQUM7Q0FDRixNQUFNLFVBQVUsR0FBRyxDQUFDLE1BQU0sRUFBRSxhQUFhLEVBQUUsT0FBTyxLQUFLO0NBQ3ZELElBQUksSUFBSSxFQUFFLE1BQU0sWUFBWSxhQUFhLENBQUMsRUFBRTtDQUM1QyxRQUFRLE9BQU8sQ0FBQyxlQUFlLENBQUMsR0FBRyxhQUFhLENBQUM7Q0FDakQsUUFBUSxNQUFNLElBQUksWUFBWSxDQUFDLGlCQUFpQixFQUFFLE9BQU8sQ0FBQyxDQUFDO0NBQzNELEtBQUs7Q0FDTCxDQUFDLENBQUM7Q0FDRixNQUFNLE9BQU8sR0FBRyxDQUFDLEtBQUssRUFBRSxXQUFXLEVBQUUsT0FBTyxLQUFLO0NBQ2pELElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUU7Q0FDdEMsUUFBUSxPQUFPLENBQUMsdUJBQXVCLENBQUM7Q0FDeEMsWUFBWSxDQUFDLGlCQUFpQixFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDL0QsUUFBUSxNQUFNLElBQUksWUFBWSxDQUFDLGVBQWUsRUFBRSxPQUFPLENBQUMsQ0FBQztDQUN6RCxLQUFLO0NBQ0wsQ0FBQyxDQUFDO0NBQ0YsTUFBTSxjQUFjLEdBQUcsQ0FBQyxLQUFLLEVBQUUsYUFBYSxFQUFFLE9BQU8sS0FBSztDQUMxRCxJQUFJLE1BQU0sS0FBSyxHQUFHLElBQUksWUFBWSxDQUFDLG9CQUFvQixFQUFFLE9BQU8sQ0FBQyxDQUFDO0NBQ2xFLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7Q0FDL0IsUUFBUSxNQUFNLEtBQUssQ0FBQztDQUNwQixLQUFLO0NBQ0wsSUFBSSxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRTtDQUM5QixRQUFRLElBQUksRUFBRSxJQUFJLFlBQVksYUFBYSxDQUFDLEVBQUU7Q0FDOUMsWUFBWSxNQUFNLEtBQUssQ0FBQztDQUN4QixTQUFTO0NBQ1QsS0FBSztDQUNMLENBQUMsQ0FBQztDQUNGLE1BQU0sa0JBQWtCLEdBQWlELENBQUM7Q0FDMUUsSUFBSSxTQUFTO0NBQ2IsSUFBSSxPQUFPO0NBQ1gsSUFBSSxVQUFVO0NBQ2QsSUFBSSxPQUFPO0NBQ1gsSUFBSSxNQUFNO0NBQ1YsSUFBSSxjQUFjO0NBQ2xCLENBQUM7O0NDaEVEO0NBQ0E7QUFDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBRUEsTUFBTSxpQkFBaUIsR0FBRztDQUMxQixJQUFJLGVBQWUsRUFBRSxpQkFBaUI7Q0FDdEMsSUFBSSxRQUFRLEVBQUUsYUFBYTtDQUMzQixJQUFJLE1BQU0sRUFBRSxTQUFTO0NBQ3JCLElBQUksT0FBTyxFQUFFLFNBQVM7Q0FDdEIsSUFBSSxNQUFNLEVBQUUsT0FBTyxZQUFZLEtBQUssV0FBVyxHQUFHLFlBQVksQ0FBQyxLQUFLLEdBQUcsRUFBRTtDQUN6RSxDQUFDLENBQUM7Q0FDRixNQUFNLGdCQUFnQixHQUFHLENBQUMsU0FBUyxLQUFLO0NBQ3hDLElBQUksT0FBTyxDQUFDLGlCQUFpQixDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsaUJBQWlCLENBQUMsTUFBTSxDQUFDO0NBQzFFLFNBQVMsTUFBTSxDQUFDLENBQUMsS0FBSyxLQUFLLEtBQUssSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztDQUNyRCxTQUFTLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztDQUNuQixDQUFDLENBQUM7Q0FDRixNQUFNLG1CQUFtQixHQUFHLENBQUMsRUFBRSxLQUFLO0NBQ3BDLElBQUksS0FBSyxNQUFNLEdBQUcsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEVBQUU7Q0FDdEQsUUFBUSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7Q0FDaEIsS0FBSztDQUNMLENBQUMsQ0FBQztDQUNLLE1BQU0sVUFBVSxHQUFHO0NBQzFCLElBQUksYUFBYSxFQUFFLENBQUMsT0FBTyxLQUFLO0NBQ2hDLFFBQVEsbUJBQW1CLENBQUMsQ0FBQyxHQUFHLEtBQUs7Q0FDckMsWUFBWSxJQUFJLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLFFBQVEsRUFBRTtDQUNsRCxnQkFBZ0IsaUJBQWlCLENBQUMsR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQ3RELGFBQWE7Q0FDYixTQUFTLENBQUMsQ0FBQztDQUNYLEtBQUs7Q0FDTCxJQUFJLHNCQUFzQixFQUFFLENBQUMsYUFBYSxLQUFLO0NBQy9DLFFBQVEsT0FBTyxhQUFhLElBQUksZ0JBQWdCLENBQUMsaUJBQWlCLENBQUMsZUFBZSxDQUFDLENBQUM7Q0FDcEYsS0FBSztDQUNMLElBQUksZUFBZSxFQUFFLENBQUMsYUFBYSxLQUFLO0NBQ3hDLFFBQVEsT0FBTyxhQUFhLElBQUksZ0JBQWdCLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLENBQUM7Q0FDN0UsS0FBSztDQUNMLElBQUksU0FBUyxFQUFFLE1BQU07Q0FDckIsUUFBUSxPQUFPLGlCQUFpQixDQUFDLE1BQU0sQ0FBQztDQUN4QyxLQUFLO0NBQ0wsSUFBSSxjQUFjLEVBQUUsQ0FBQyxhQUFhLEtBQUs7Q0FDdkMsUUFBUSxPQUFPLGFBQWEsSUFBSSxnQkFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztDQUM1RSxLQUFLO0NBQ0wsSUFBSSxTQUFTLEVBQUUsTUFBTTtDQUNyQixRQUFRLE9BQU8saUJBQWlCLENBQUMsTUFBTSxDQUFDO0NBQ3hDLEtBQUs7Q0FDTCxDQUFDOztDQ2hERDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FFQSxNQUFNLE1BQU0sSUFBa0QsQ0FBQyxDQUFDLE1BQU07Q0FDdEU7Q0FDQTtDQUNBLElBQUksSUFBSSxFQUFFLHVCQUF1QixJQUFJLElBQUksQ0FBQyxFQUFFO0NBQzVDLFFBQVEsSUFBSSxDQUFDLHFCQUFxQixHQUFHLEtBQUssQ0FBQztDQUMzQyxLQUFLO0NBQ0wsSUFBSSxJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUM7Q0FDeEIsSUFBSSxNQUFNLGdCQUFnQixHQUFHO0NBQzdCLFFBQVEsS0FBSyxFQUFFLENBQUMsT0FBTyxDQUFDO0NBQ3hCLFFBQVEsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDO0NBQ3RCLFFBQVEsSUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDO0NBQ3ZCLFFBQVEsS0FBSyxFQUFFLENBQUMsT0FBTyxDQUFDO0NBQ3hCLFFBQVEsY0FBYyxFQUFFLENBQUMsT0FBTyxDQUFDO0NBQ2pDLFFBQVEsUUFBUSxFQUFFLElBQUk7Q0FDdEIsS0FBSyxDQUFDO0NBQ04sSUFBSSxNQUFNLEtBQUssR0FBRyxVQUFVLE1BQU0sRUFBRSxJQUFJLEVBQUU7Q0FDMUMsUUFBUSxJQUFJLElBQUksQ0FBQyxxQkFBcUIsRUFBRTtDQUN4QyxZQUFZLE9BQU87Q0FDbkIsU0FBUztDQUNULFFBQVEsSUFBSSxNQUFNLEtBQUssZ0JBQWdCLEVBQUU7Q0FDekM7Q0FDQTtDQUNBLFlBQVksSUFBSSxnQ0FBZ0MsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxFQUFFO0NBQzVFLGdCQUFnQixPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztDQUN6QyxnQkFBZ0IsT0FBTztDQUN2QixhQUFhO0NBQ2IsU0FBUztDQUNULFFBQVEsTUFBTSxNQUFNLEdBQUc7Q0FDdkIsWUFBWSxDQUFDLFlBQVksRUFBRSxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0NBQ3JELFlBQVksQ0FBQyxvQkFBb0IsQ0FBQztDQUNsQyxZQUFZLENBQUMsWUFBWSxDQUFDO0NBQzFCLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQztDQUMvQixZQUFZLENBQUMsa0JBQWtCLENBQUM7Q0FDaEMsU0FBUyxDQUFDO0NBQ1Y7Q0FDQSxRQUFRLE1BQU0sU0FBUyxHQUFHLE9BQU8sR0FBRyxFQUFFLEdBQUcsQ0FBQyxXQUFXLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0NBQ3pFLFFBQVEsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsU0FBUyxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUM7Q0FDL0MsUUFBUSxJQUFJLE1BQU0sS0FBSyxnQkFBZ0IsRUFBRTtDQUN6QyxZQUFZLE9BQU8sR0FBRyxJQUFJLENBQUM7Q0FDM0IsU0FBUztDQUNULFFBQVEsSUFBSSxNQUFNLEtBQUssVUFBVSxFQUFFO0NBQ25DLFlBQVksT0FBTyxHQUFHLEtBQUssQ0FBQztDQUM1QixTQUFTO0NBQ1QsS0FBSyxDQUFDO0NBQ04sSUFBSSxNQUFNLEdBQUcsR0FBRyxFQUFFLENBQUM7Q0FDbkIsSUFBSSxNQUFNLGFBQWEsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7Q0FDeEQsSUFBSSxLQUFLLE1BQU0sR0FBRyxJQUFJLGFBQWEsRUFBRTtDQUNyQyxRQUFRLE1BQU0sTUFBTSxHQUFHLEdBQUcsQ0FBQztDQUMzQixRQUFRLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxLQUFLO0NBQ25DLFlBQVksS0FBSyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztDQUNoQyxTQUFTLENBQUM7Q0FDVixLQUFLO0NBQ0wsSUFBSSxPQUFPLEdBQUcsQ0FBQztDQUNmLENBQUMsR0FBRyxDQUFDOztDQzVETDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FFQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxTQUFTLFNBQVMsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFO0NBQ25DLElBQUksTUFBTSxhQUFhLEdBQUcsT0FBTyxFQUFFLENBQUM7Q0FDcEMsSUFBSSxLQUFLLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0NBQ25DLElBQUksT0FBTyxhQUFhLENBQUM7Q0FDekI7O0NDbkJBO0NBQ0EsSUFBSTtDQUNKLElBQUksSUFBSSxDQUFDLDBCQUEwQixDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7Q0FDNUMsQ0FBQztDQUNELE9BQU8sQ0FBQyxFQUFFOztDQ0xWO0NBQ0E7QUFDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBR0E7Q0FDQSxNQUFNLHFCQUFxQixHQUFHLGlCQUFpQixDQUFDO0NBQ2hEO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNPLFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtDQUN0QyxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7Q0FDaEIsUUFBUSxNQUFNLElBQUksWUFBWSxDQUFDLG1DQUFtQyxFQUFFLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztDQUMvRSxLQUFLO0NBQ0w7Q0FDQTtDQUNBLElBQUksSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7Q0FDbkMsUUFBUSxNQUFNLFNBQVMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ3hELFFBQVEsT0FBTztDQUNmLFlBQVksUUFBUSxFQUFFLFNBQVMsQ0FBQyxJQUFJO0NBQ3BDLFlBQVksR0FBRyxFQUFFLFNBQVMsQ0FBQyxJQUFJO0NBQy9CLFNBQVMsQ0FBQztDQUNWLEtBQUs7Q0FDTCxJQUFJLE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLEdBQUcsS0FBSyxDQUFDO0NBQ3BDLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRTtDQUNkLFFBQVEsTUFBTSxJQUFJLFlBQVksQ0FBQyxtQ0FBbUMsRUFBRSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7Q0FDL0UsS0FBSztDQUNMO0NBQ0E7Q0FDQSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7Q0FDbkIsUUFBUSxNQUFNLFNBQVMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ3RELFFBQVEsT0FBTztDQUNmLFlBQVksUUFBUSxFQUFFLFNBQVMsQ0FBQyxJQUFJO0NBQ3BDLFlBQVksR0FBRyxFQUFFLFNBQVMsQ0FBQyxJQUFJO0NBQy9CLFNBQVMsQ0FBQztDQUNWLEtBQUs7Q0FDTDtDQUNBO0NBQ0EsSUFBSSxNQUFNLFdBQVcsR0FBRyxJQUFJLEdBQUcsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ3BELElBQUksTUFBTSxXQUFXLEdBQUcsSUFBSSxHQUFHLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNwRCxJQUFJLFdBQVcsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLHFCQUFxQixFQUFFLFFBQVEsQ0FBQyxDQUFDO0NBQ2xFLElBQUksT0FBTztDQUNYLFFBQVEsUUFBUSxFQUFFLFdBQVcsQ0FBQyxJQUFJO0NBQ2xDLFFBQVEsR0FBRyxFQUFFLFdBQVcsQ0FBQyxJQUFJO0NBQzdCLEtBQUssQ0FBQztDQUNOOztDQ3ZEQTtDQUNBO0FBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUVBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLE1BQU0sMkJBQTJCLENBQUM7Q0FDbEMsSUFBSSxXQUFXLEdBQUc7Q0FDbEIsUUFBUSxJQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQztDQUM5QixRQUFRLElBQUksQ0FBQyxjQUFjLEdBQUcsRUFBRSxDQUFDO0NBQ2pDLFFBQVEsSUFBSSxDQUFDLGdCQUFnQixHQUFHLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxHQUFHLEtBQUs7Q0FDL0Q7Q0FDQSxZQUFZLElBQUksS0FBSyxFQUFFO0NBQ3ZCLGdCQUFnQixLQUFLLENBQUMsZUFBZSxHQUFHLE9BQU8sQ0FBQztDQUNoRCxhQUFhO0NBQ2IsU0FBUyxDQUFDO0NBQ1YsUUFBUSxJQUFJLENBQUMsd0JBQXdCLEdBQUcsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsY0FBYyxHQUFHLEtBQUs7Q0FDckYsWUFBWSxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFO0NBQzFDO0NBQ0EsZ0JBQWdCLE1BQU0sR0FBRyxHQUFHLEtBQUssQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDO0NBQ3RELGdCQUFnQixJQUFJLGNBQWMsRUFBRTtDQUNwQyxvQkFBb0IsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7Q0FDbEQsaUJBQWlCO0NBQ2pCLHFCQUFxQjtDQUNyQixvQkFBb0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7Q0FDL0MsaUJBQWlCO0NBQ2pCLGFBQWE7Q0FDYixZQUFZLE9BQU8sY0FBYyxDQUFDO0NBQ2xDLFNBQVMsQ0FBQztDQUNWLEtBQUs7Q0FDTDs7Q0N0Q0E7Q0FDQTtBQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FFQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxNQUFNLHNCQUFzQixDQUFDO0NBQzdCLElBQUksV0FBVyxDQUFDLEVBQUUsa0JBQWtCLEVBQUUsRUFBRTtDQUN4QyxRQUFRLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sR0FBRyxLQUFLO0NBQ2xFLFlBQVksTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLE1BQU0sQ0FBQyxRQUFRO0NBQ3RELGdCQUFnQixJQUFJLENBQUMsbUJBQW1CLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQ3hFLFlBQVksT0FBTyxRQUFRLEdBQUcsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsT0FBTyxDQUFDO0NBQzlELFNBQVMsQ0FBQztDQUNWLFFBQVEsSUFBSSxDQUFDLG1CQUFtQixHQUFHLGtCQUFrQixDQUFDO0NBQ3RELEtBQUs7Q0FDTDs7Q0N2QkE7Q0FDQTtBQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FHQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxNQUFNLFFBQVEsR0FBRyxDQUFDLFVBQVUsRUFBRSxXQUFXLEtBQUs7Q0FDOUMsSUFBSSxNQUFNLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0NBQ3RDLElBQUksS0FBSyxNQUFNLEdBQUcsSUFBSSxXQUFXLEVBQUU7Q0FDbkMsUUFBUSxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQ3hCLEtBQUs7Q0FDTCxJQUFJLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztDQUN0QixDQUFDLENBQUM7Q0FDRjtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDTyxTQUFTLG1CQUFtQixDQUFDLFdBQVcsRUFBRTtDQUNqRCxJQUFJLE1BQU0sYUFBYSxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUM7Q0FDN0MsSUFBSSxJQUFJLGFBQWEsR0FBRyxDQUFDLEVBQUU7Q0FDM0IsUUFBUSxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsMkJBQTJCLENBQUM7Q0FDM0QsWUFBWSxDQUFDLEVBQUUsYUFBYSxDQUFDLFFBQVEsQ0FBQztDQUN0QyxZQUFZLENBQUMsT0FBTyxFQUFFLGFBQWEsS0FBSyxDQUFDLEdBQUcsTUFBTSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0NBQzFFLFFBQVEsUUFBUSxDQUFDLHdCQUF3QixFQUFFLFdBQVcsQ0FBQyxDQUFDO0NBQ3hELFFBQVEsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO0NBQzFCLEtBQUs7Q0FDTDs7Q0NyQ0E7Q0FDQTtBQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FHQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxTQUFTLFlBQVksQ0FBQyxVQUFVLEVBQUUsSUFBSSxFQUFFO0NBQ3hDLElBQUksSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtDQUMzQixRQUFRLE9BQU87Q0FDZixLQUFLO0NBQ0wsSUFBSSxNQUFNLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0NBQ3RDLElBQUksS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLEVBQUU7Q0FDNUIsUUFBUSxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQ3hCLEtBQUs7Q0FDTCxJQUFJLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztDQUN0QixDQUFDO0NBQ0Q7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDTyxTQUFTLG1CQUFtQixDQUFDLGNBQWMsRUFBRSxvQkFBb0IsRUFBRTtDQUMxRSxJQUFJLE1BQU0sY0FBYyxHQUFHLGNBQWMsQ0FBQyxNQUFNLENBQUM7Q0FDakQsSUFBSSxNQUFNLHFCQUFxQixHQUFHLG9CQUFvQixDQUFDLE1BQU0sQ0FBQztDQUM5RCxJQUFJLElBQUksY0FBYyxJQUFJLHFCQUFxQixFQUFFO0NBQ2pELFFBQVEsSUFBSSxPQUFPLEdBQUcsQ0FBQyxXQUFXLEVBQUUsY0FBYyxDQUFDLEtBQUssRUFBRSxjQUFjLEtBQUssQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDN0YsUUFBUSxJQUFJLHFCQUFxQixHQUFHLENBQUMsRUFBRTtDQUN2QyxZQUFZLE9BQU8sSUFBSSxDQUFDLENBQUMsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDLENBQUM7Q0FDbkQsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLHFCQUFxQixLQUFLLENBQUMsR0FBRyxLQUFLLEdBQUcsT0FBTyxDQUFDLGdCQUFnQixDQUFDLENBQUM7Q0FDdkYsU0FBUztDQUNULFFBQVEsTUFBTSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQztDQUN2QyxRQUFRLFlBQVksQ0FBQyxDQUFDLDBCQUEwQixDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUM7Q0FDbkUsUUFBUSxZQUFZLENBQUMsQ0FBQywrQkFBK0IsQ0FBQyxFQUFFLG9CQUFvQixDQUFDLENBQUM7Q0FDOUUsUUFBUSxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUM7Q0FDMUIsS0FBSztDQUNMOztDQzlDQTtDQUNBO0FBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUVBLElBQUksYUFBYSxDQUFDO0NBQ2xCO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLFNBQVMsa0NBQWtDLEdBQUc7Q0FDOUMsSUFBSSxJQUFJLGFBQWEsS0FBSyxTQUFTLEVBQUU7Q0FDckMsUUFBUSxNQUFNLFlBQVksR0FBRyxJQUFJLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztDQUM5QyxRQUFRLElBQUksTUFBTSxJQUFJLFlBQVksRUFBRTtDQUNwQyxZQUFZLElBQUk7Q0FDaEIsZ0JBQWdCLElBQUksUUFBUSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNoRCxnQkFBZ0IsYUFBYSxHQUFHLElBQUksQ0FBQztDQUNyQyxhQUFhO0NBQ2IsWUFBWSxPQUFPLEtBQUssRUFBRTtDQUMxQixnQkFBZ0IsYUFBYSxHQUFHLEtBQUssQ0FBQztDQUN0QyxhQUFhO0NBQ2IsU0FBUztDQUNULFFBQVEsYUFBYSxHQUFHLEtBQUssQ0FBQztDQUM5QixLQUFLO0NBQ0wsSUFBSSxPQUFPLGFBQWEsQ0FBQztDQUN6Qjs7Q0NqQ0E7Q0FDQTtBQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FJQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLGVBQWUsWUFBWSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUU7Q0FDaEQsSUFBSSxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUM7Q0FDdEI7Q0FDQSxJQUFJLElBQUksUUFBUSxDQUFDLEdBQUcsRUFBRTtDQUN0QixRQUFRLE1BQU0sV0FBVyxHQUFHLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztDQUNsRCxRQUFRLE1BQU0sR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDO0NBQ3BDLEtBQUs7Q0FDTCxJQUFJLElBQUksTUFBTSxLQUFLLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFO0NBQ3pDLFFBQVEsTUFBTSxJQUFJLFlBQVksQ0FBQyw0QkFBNEIsRUFBRSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7Q0FDekUsS0FBSztDQUNMLElBQUksTUFBTSxjQUFjLEdBQUcsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDO0NBQzVDO0NBQ0EsSUFBSSxNQUFNLFlBQVksR0FBRztDQUN6QixRQUFRLE9BQU8sRUFBRSxJQUFJLE9BQU8sQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDO0NBQ3BELFFBQVEsTUFBTSxFQUFFLGNBQWMsQ0FBQyxNQUFNO0NBQ3JDLFFBQVEsVUFBVSxFQUFFLGNBQWMsQ0FBQyxVQUFVO0NBQzdDLEtBQUssQ0FBQztDQUNOO0NBQ0EsSUFBSSxNQUFNLG9CQUFvQixHQUFHLFFBQVEsR0FBRyxRQUFRLENBQUMsWUFBWSxDQUFDLEdBQUcsWUFBWSxDQUFDO0NBQ2xGO0NBQ0E7Q0FDQTtDQUNBLElBQUksTUFBTSxJQUFJLEdBQUcsa0NBQWtDLEVBQUU7Q0FDckQsUUFBUSxjQUFjLENBQUMsSUFBSSxHQUFHLE1BQU0sY0FBYyxDQUFDLElBQUksRUFBRSxDQUFDO0NBQzFELElBQUksT0FBTyxJQUFJLFFBQVEsQ0FBQyxJQUFJLEVBQUUsb0JBQW9CLENBQUMsQ0FBQztDQUNwRDs7Q0N0REE7Q0FDQTtBQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FFQSxNQUFNLGNBQWMsR0FBRyxDQUFDLEdBQUcsS0FBSztDQUNoQyxJQUFJLE1BQU0sTUFBTSxHQUFHLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDdkQ7Q0FDQTtDQUNBLElBQUksT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0NBQ3RFLENBQUM7O0NDYkQ7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBRUEsU0FBUyxXQUFXLENBQUMsT0FBTyxFQUFFLFlBQVksRUFBRTtDQUM1QyxJQUFJLE1BQU0sV0FBVyxHQUFHLElBQUksR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0NBQ3pDLElBQUksS0FBSyxNQUFNLEtBQUssSUFBSSxZQUFZLEVBQUU7Q0FDdEMsUUFBUSxXQUFXLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztDQUMvQyxLQUFLO0NBQ0wsSUFBSSxPQUFPLFdBQVcsQ0FBQyxJQUFJLENBQUM7Q0FDNUIsQ0FBQztDQUNEO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLGVBQWUsc0JBQXNCLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFO0NBQ2xGLElBQUksTUFBTSxrQkFBa0IsR0FBRyxXQUFXLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxZQUFZLENBQUMsQ0FBQztDQUN0RTtDQUNBLElBQUksSUFBSSxPQUFPLENBQUMsR0FBRyxLQUFLLGtCQUFrQixFQUFFO0NBQzVDLFFBQVEsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQztDQUNsRCxLQUFLO0NBQ0w7Q0FDQSxJQUFJLE1BQU0sV0FBVyxHQUFHLEVBQUUsR0FBRyxZQUFZLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxDQUFDO0NBQ2hFLElBQUksTUFBTSxTQUFTLEdBQUcsTUFBTSxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxXQUFXLENBQUMsQ0FBQztDQUM3RCxJQUFJLEtBQUssTUFBTSxRQUFRLElBQUksU0FBUyxFQUFFO0NBQ3RDLFFBQVEsTUFBTSxtQkFBbUIsR0FBRyxXQUFXLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxZQUFZLENBQUMsQ0FBQztDQUM1RSxRQUFRLElBQUksa0JBQWtCLEtBQUssbUJBQW1CLEVBQUU7Q0FDeEQsWUFBWSxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLFlBQVksQ0FBQyxDQUFDO0NBQ3ZELFNBQVM7Q0FDVCxLQUFLO0NBQ0wsSUFBSSxPQUFPO0NBQ1g7O0NDMUNBO0NBQ0E7QUFDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBRUE7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLE1BQU0sUUFBUSxDQUFDO0NBQ2Y7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxXQUFXLEdBQUc7Q0FDbEIsUUFBUSxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLE1BQU0sS0FBSztDQUN4RCxZQUFZLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO0NBQ25DLFlBQVksSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7Q0FDakMsU0FBUyxDQUFDLENBQUM7Q0FDWCxLQUFLO0NBQ0w7O0NDMUJBO0NBQ0E7QUFDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBRUE7Q0FDQSxNQUFNLG1CQUFtQixHQUFHLElBQUksR0FBRyxFQUFFOztDQ1RyQztDQUNBO0FBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUlBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsZUFBZSwwQkFBMEIsR0FBRztDQUM1QyxJQUErQztDQUMvQyxRQUFRLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxhQUFhLEVBQUUsbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztDQUM5RCxZQUFZLENBQUMsNkJBQTZCLENBQUMsQ0FBQyxDQUFDO0NBQzdDLEtBQUs7Q0FDTCxJQUFJLEtBQUssTUFBTSxRQUFRLElBQUksbUJBQW1CLEVBQUU7Q0FDaEQsUUFBUSxNQUFNLFFBQVEsRUFBRSxDQUFDO0NBQ3pCLFFBQW1EO0NBQ25ELFlBQVksTUFBTSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsY0FBYyxDQUFDLENBQUM7Q0FDakQsU0FBUztDQUNULEtBQUs7Q0FDTCxJQUErQztDQUMvQyxRQUFRLE1BQU0sQ0FBQyxHQUFHLENBQUMsNkJBQTZCLENBQUMsQ0FBQztDQUNsRCxLQUFLO0NBQ0w7O0NDL0JBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUVBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDTyxTQUFTLE9BQU8sQ0FBQyxFQUFFLEVBQUU7Q0FDNUIsSUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxLQUFLLFVBQVUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztDQUM3RDs7Q0NoQkE7Q0FDQSxJQUFJO0NBQ0osSUFBSSxJQUFJLENBQUMsMEJBQTBCLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztDQUM1QyxDQUFDO0NBQ0QsT0FBTyxDQUFDLEVBQUU7O0NDTFY7Q0FDQTtBQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FVQSxTQUFTLFNBQVMsQ0FBQyxLQUFLLEVBQUU7Q0FDMUIsSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQztDQUNwRSxDQUFDO0NBQ0Q7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsTUFBTSxlQUFlLENBQUM7Q0FDdEI7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksV0FBVyxDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUU7Q0FDbkMsUUFBUSxJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztDQUM3QjtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLFFBQW1EO0NBQ25ELFlBQVlBLGtCQUFNLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsZUFBZSxFQUFFO0NBQzlELGdCQUFnQixVQUFVLEVBQUUsb0JBQW9CO0NBQ2hELGdCQUFnQixTQUFTLEVBQUUsaUJBQWlCO0NBQzVDLGdCQUFnQixRQUFRLEVBQUUsYUFBYTtDQUN2QyxnQkFBZ0IsU0FBUyxFQUFFLGVBQWU7Q0FDMUMsYUFBYSxDQUFDLENBQUM7Q0FDZixTQUFTO0NBQ1QsUUFBUSxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztDQUNyQyxRQUFRLElBQUksQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztDQUNuQyxRQUFRLElBQUksQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDO0NBQ2xDLFFBQVEsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksUUFBUSxFQUFFLENBQUM7Q0FDL0MsUUFBUSxJQUFJLENBQUMsdUJBQXVCLEdBQUcsRUFBRSxDQUFDO0NBQzFDO0NBQ0E7Q0FDQSxRQUFRLElBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztDQUM5QyxRQUFRLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztDQUN6QyxRQUFRLEtBQUssTUFBTSxNQUFNLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtDQUM1QyxZQUFZLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQztDQUNqRCxTQUFTO0NBQ1QsUUFBUSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDNUQsS0FBSztDQUNMO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxLQUFLLENBQUMsS0FBSyxFQUFFO0NBQ2pCLFFBQVEsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsWUFBWTtDQUMzQyxZQUFZLE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxJQUFJLENBQUM7Q0FDbkMsWUFBWSxJQUFJLE9BQU8sR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7Q0FDM0MsWUFBWSxJQUFJLE9BQU8sQ0FBQyxJQUFJLEtBQUssVUFBVTtDQUMzQyxnQkFBZ0IsS0FBSyxZQUFZLFVBQVU7Q0FDM0MsZ0JBQWdCLEtBQUssQ0FBQyxlQUFlLEVBQUU7Q0FDdkMsZ0JBQWdCLE1BQU0sdUJBQXVCLEdBQUcsTUFBTSxLQUFLLENBQUMsZUFBZSxDQUFDO0NBQzVFLGdCQUFnQixJQUFJLHVCQUF1QixFQUFFO0NBQzdDLG9CQUErRDtDQUMvRCx3QkFBd0IsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLDBDQUEwQyxDQUFDO0NBQy9FLDRCQUE0QixDQUFDLENBQUMsRUFBRSxjQUFjLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDaEUscUJBQXFCO0NBQ3JCLG9CQUFvQixPQUFPLHVCQUF1QixDQUFDO0NBQ25ELGlCQUFpQjtDQUNqQixhQUFhO0NBQ2I7Q0FDQTtDQUNBO0NBQ0EsWUFBWSxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQztDQUNwRSxnQkFBZ0IsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLElBQUksQ0FBQztDQUN2QyxZQUFZLElBQUk7Q0FDaEIsZ0JBQWdCLEtBQUssTUFBTSxFQUFFLElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLGtCQUFrQixDQUFDLEVBQUU7Q0FDNUUsb0JBQW9CLE9BQU8sR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztDQUM1RSxpQkFBaUI7Q0FDakIsYUFBYTtDQUNiLFlBQVksT0FBTyxHQUFHLEVBQUU7Q0FDeEIsZ0JBQWdCLE1BQU0sSUFBSSxZQUFZLENBQUMsaUNBQWlDLEVBQUU7Q0FDMUUsb0JBQW9CLFdBQVcsRUFBRSxHQUFHO0NBQ3BDLGlCQUFpQixDQUFDLENBQUM7Q0FDbkIsYUFBYTtDQUNiO0NBQ0E7Q0FDQTtDQUNBLFlBQVksTUFBTSxxQkFBcUIsR0FBRyxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7Q0FDMUQsWUFBWSxJQUFJO0NBQ2hCLGdCQUFnQixJQUFJLGFBQWEsQ0FBQztDQUNsQztDQUNBLGdCQUFnQixhQUFhLEdBQUcsTUFBTSxLQUFLLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxJQUFJLEtBQUssVUFBVTtDQUNoRixvQkFBb0IsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLENBQUM7Q0FDN0QsZ0JBQWdCLElBQUksYUFBb0IsS0FBSyxZQUFZLEVBQUU7Q0FDM0Qsb0JBQW9CLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQztDQUN2RCx3QkFBd0IsQ0FBQyxDQUFDLEVBQUUsY0FBYyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQywyQkFBMkIsQ0FBQztDQUNwRix3QkFBd0IsQ0FBQyxRQUFRLEVBQUUsYUFBYSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0NBQzdELGlCQUFpQjtDQUNqQixnQkFBZ0IsS0FBSyxNQUFNLFFBQVEsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsaUJBQWlCLENBQUMsRUFBRTtDQUNqRixvQkFBb0IsYUFBYSxHQUFHLE1BQU0sUUFBUSxDQUFDO0NBQ25ELHdCQUF3QixLQUFLO0NBQzdCLHdCQUF3QixPQUFPLEVBQUUscUJBQXFCO0NBQ3RELHdCQUF3QixRQUFRLEVBQUUsYUFBYTtDQUMvQyxxQkFBcUIsQ0FBQyxDQUFDO0NBQ3ZCLGlCQUFpQjtDQUNqQixnQkFBZ0IsT0FBTyxhQUFhLENBQUM7Q0FDckMsYUFBYTtDQUNiLFlBQVksT0FBTyxLQUFLLEVBQUU7Q0FDMUIsZ0JBQTJEO0NBQzNELG9CQUFvQixNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsb0JBQW9CLENBQUM7Q0FDdkQsd0JBQXdCLENBQUMsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsaUJBQWlCLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztDQUNuRixpQkFBaUI7Q0FDakI7Q0FDQTtDQUNBLGdCQUFnQixJQUFJLGVBQWUsRUFBRTtDQUNyQyxvQkFBb0IsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsRUFBRTtDQUM1RCx3QkFBd0IsS0FBSztDQUM3Qix3QkFBd0IsS0FBSztDQUM3Qix3QkFBd0IsZUFBZSxFQUFFLGVBQWUsQ0FBQyxLQUFLLEVBQUU7Q0FDaEUsd0JBQXdCLE9BQU8sRUFBRSxxQkFBcUIsQ0FBQyxLQUFLLEVBQUU7Q0FDOUQscUJBQXFCLENBQUMsQ0FBQztDQUN2QixpQkFBaUI7Q0FDakIsZ0JBQWdCLE1BQU0sS0FBSyxDQUFDO0NBQzVCLGFBQWE7Q0FDYixTQUFTLEdBQUcsQ0FBQyxDQUFDO0NBQ2QsS0FBSztDQUNMO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxNQUFNLGdCQUFnQixDQUFDLEtBQUssRUFBRTtDQUNsQyxRQUFRLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztDQUNqRCxRQUFRLE1BQU0sYUFBYSxHQUFHLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztDQUMvQyxRQUFRLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsYUFBYSxDQUFDLENBQUMsQ0FBQztDQUM1RCxRQUFRLE9BQU8sUUFBUSxDQUFDO0NBQ3hCLEtBQUs7Q0FDTDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLFVBQVUsQ0FBQyxHQUFHLEVBQUU7Q0FDcEIsUUFBUSxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxZQUFZO0NBQzNDLFlBQVksTUFBTSxPQUFPLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQzNDLFlBQVksSUFBSSxjQUFjLENBQUM7Q0FDL0IsWUFBWSxNQUFNLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7Q0FDL0QsWUFBWSxNQUFNLGdCQUFnQixHQUFHLE1BQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUM7Q0FDN0UsWUFBWSxNQUFNLGlCQUFpQixHQUFHLEVBQUUsR0FBRyxZQUFZLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxFQUFFLENBQUM7Q0FDNUUsWUFBWSxjQUFjLEdBQUcsTUFBTSxNQUFNLENBQUMsS0FBSyxDQUFDLGdCQUFnQixFQUFFLGlCQUFpQixDQUFDLENBQUM7Q0FDckYsWUFBdUQ7Q0FDdkQsZ0JBQWdCLElBQUksY0FBYyxFQUFFO0NBQ3BDLG9CQUFvQixNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsNEJBQTRCLEVBQUUsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Q0FDL0UsaUJBQWlCO0NBQ2pCLHFCQUFxQjtDQUNyQixvQkFBb0IsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLDZCQUE2QixFQUFFLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0NBQ2hGLGlCQUFpQjtDQUNqQixhQUFhO0NBQ2IsWUFBWSxLQUFLLE1BQU0sUUFBUSxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQywwQkFBMEIsQ0FBQyxFQUFFO0NBQ3RGLGdCQUFnQixjQUFjLEdBQUcsQ0FBQyxNQUFNLFFBQVEsQ0FBQztDQUNqRCxvQkFBb0IsU0FBUztDQUM3QixvQkFBb0IsWUFBWTtDQUNoQyxvQkFBb0IsY0FBYztDQUNsQyxvQkFBb0IsT0FBTyxFQUFFLGdCQUFnQjtDQUM3QyxvQkFBb0IsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLO0NBQ3JDLGlCQUFpQixDQUFDLEtBQUssU0FBUyxDQUFDO0NBQ2pDLGFBQWE7Q0FDYixZQUFZLE9BQU8sY0FBYyxDQUFDO0NBQ2xDLFNBQVMsR0FBRyxDQUFDLENBQUM7Q0FDZCxLQUFLO0NBQ0w7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLE1BQU0sUUFBUSxDQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUU7Q0FDbEMsUUFBUSxNQUFNLE9BQU8sR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7Q0FDdkM7Q0FDQTtDQUNBLFFBQVEsTUFBTSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDekIsUUFBUSxNQUFNLGdCQUFnQixHQUFHLE1BQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7Q0FDMUUsUUFBbUQ7Q0FDbkQsWUFBWSxJQUFJLGdCQUFnQixDQUFDLE1BQU0sSUFBSSxnQkFBZ0IsQ0FBQyxNQUFNLEtBQUssS0FBSyxFQUFFO0NBQzlFLGdCQUFnQixNQUFNLElBQUksWUFBWSxDQUFDLGtDQUFrQyxFQUFFO0NBQzNFLG9CQUFvQixHQUFHLEVBQUUsY0FBYyxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQztDQUM3RCxvQkFBb0IsTUFBTSxFQUFFLGdCQUFnQixDQUFDLE1BQU07Q0FDbkQsaUJBQWlCLENBQUMsQ0FBQztDQUNuQixhQUFhO0NBQ2IsU0FBUztDQUNULFFBQVEsSUFBSSxDQUFDLFFBQVEsRUFBRTtDQUN2QixZQUF1RDtDQUN2RCxnQkFBZ0IsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLHVDQUF1QyxDQUFDO0NBQ3RFLG9CQUFvQixDQUFDLENBQUMsRUFBRSxjQUFjLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztDQUNsRSxhQUFhO0NBQ2IsWUFBWSxNQUFNLElBQUksWUFBWSxDQUFDLDRCQUE0QixFQUFFO0NBQ2pFLGdCQUFnQixHQUFHLEVBQUUsY0FBYyxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQztDQUN6RCxhQUFhLENBQUMsQ0FBQztDQUNmLFNBQVM7Q0FDVCxRQUFRLE1BQU0sZUFBZSxHQUFHLE1BQU0sSUFBSSxDQUFDLDBCQUEwQixDQUFDLFFBQVEsQ0FBQyxDQUFDO0NBQ2hGLFFBQVEsSUFBSSxDQUFDLGVBQWUsRUFBRTtDQUM5QixZQUF1RDtDQUN2RCxnQkFBZ0IsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLFVBQVUsRUFBRSxjQUFjLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDO0NBQ2xGLG9CQUFvQixDQUFDLG1CQUFtQixDQUFDLEVBQUUsZUFBZSxDQUFDLENBQUM7Q0FDNUQsYUFBYTtDQUNiLFlBQVksT0FBTztDQUNuQixTQUFTO0NBQ1QsUUFBUSxNQUFNLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7Q0FDM0QsUUFBUSxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0NBQ3hELFFBQVEsTUFBTSxzQkFBc0IsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLGdCQUFnQixDQUFDLENBQUM7Q0FDMUUsUUFBUSxNQUFNLFdBQVcsR0FBRyxzQkFBc0IsR0FBRyxNQUFNLHNCQUFzQjtDQUNqRjtDQUNBO0NBQ0E7Q0FDQSxRQUFRLEtBQUssRUFBRSxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsWUFBWSxDQUFDO0NBQzNFLFlBQVksSUFBSSxDQUFDO0NBQ2pCLFFBQW1EO0NBQ25ELFlBQVksTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRSxTQUFTLENBQUMsNEJBQTRCLENBQUM7Q0FDakYsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQ2hFLFNBQVM7Q0FDVCxRQUFRLElBQUk7Q0FDWixZQUFZLE1BQU0sS0FBSyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsRUFBRSxzQkFBc0I7Q0FDcEUsZ0JBQWdCLGVBQWUsQ0FBQyxLQUFLLEVBQUUsR0FBRyxlQUFlLENBQUMsQ0FBQztDQUMzRCxTQUFTO0NBQ1QsUUFBUSxPQUFPLEtBQUssRUFBRTtDQUN0QjtDQUNBLFlBQVksSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLG9CQUFvQixFQUFFO0NBQ3JELGdCQUFnQixNQUFNLDBCQUEwQixFQUFFLENBQUM7Q0FDbkQsYUFBYTtDQUNiLFlBQVksTUFBTSxLQUFLLENBQUM7Q0FDeEIsU0FBUztDQUNULFFBQVEsS0FBSyxNQUFNLFFBQVEsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtDQUN4RSxZQUFZLE1BQU0sUUFBUSxDQUFDO0NBQzNCLGdCQUFnQixTQUFTO0NBQ3pCLGdCQUFnQixXQUFXO0NBQzNCLGdCQUFnQixXQUFXLEVBQUUsZUFBZSxDQUFDLEtBQUssRUFBRTtDQUNwRCxnQkFBZ0IsT0FBTyxFQUFFLGdCQUFnQjtDQUN6QyxnQkFBZ0IsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLO0NBQ2pDLGFBQWEsQ0FBQyxDQUFDO0NBQ2YsU0FBUztDQUNULEtBQUs7Q0FDTDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxNQUFNLFdBQVcsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFO0NBQ3JDLFFBQVEsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUU7Q0FDcEMsWUFBWSxJQUFJLGdCQUFnQixHQUFHLE9BQU8sQ0FBQztDQUMzQyxZQUFZLEtBQUssTUFBTSxRQUFRLElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLG9CQUFvQixDQUFDLEVBQUU7Q0FDaEYsZ0JBQWdCLGdCQUFnQixHQUFHLFNBQVMsQ0FBQyxNQUFNLFFBQVEsQ0FBQztDQUM1RCxvQkFBb0IsSUFBSTtDQUN4QixvQkFBb0IsT0FBTyxFQUFFLGdCQUFnQjtDQUM3QyxvQkFBb0IsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLO0NBQ3JDLG9CQUFvQixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07Q0FDdkMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO0NBQ3BCLGFBQWE7Q0FDYixZQUFZLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsZ0JBQWdCLENBQUM7Q0FDckQsU0FBUztDQUNULFFBQVEsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ3JDLEtBQUs7Q0FDTDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksV0FBVyxDQUFDLElBQUksRUFBRTtDQUN0QixRQUFRLEtBQUssTUFBTSxNQUFNLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUU7Q0FDckQsWUFBWSxJQUFJLElBQUksSUFBSSxNQUFNLEVBQUU7Q0FDaEMsZ0JBQWdCLE9BQU8sSUFBSSxDQUFDO0NBQzVCLGFBQWE7Q0FDYixTQUFTO0NBQ1QsUUFBUSxPQUFPLEtBQUssQ0FBQztDQUNyQixLQUFLO0NBQ0w7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLE1BQU0sWUFBWSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUU7Q0FDcEMsUUFBUSxLQUFLLE1BQU0sUUFBUSxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsRUFBRTtDQUM1RDtDQUNBO0NBQ0EsWUFBWSxNQUFNLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztDQUNsQyxTQUFTO0NBQ1QsS0FBSztDQUNMO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUU7Q0FDNUIsUUFBUSxLQUFLLE1BQU0sTUFBTSxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFO0NBQ3JELFlBQVksSUFBSSxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxVQUFVLEVBQUU7Q0FDcEQsZ0JBQWdCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0NBQy9ELGdCQUFnQixNQUFNLGdCQUFnQixHQUFHLENBQUMsS0FBSyxLQUFLO0NBQ3BELG9CQUFvQixNQUFNLGFBQWEsR0FBRyxFQUFFLEdBQUcsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDO0NBQzlEO0NBQ0E7Q0FDQSxvQkFBb0IsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUM7Q0FDdkQsaUJBQWlCLENBQUM7Q0FDbEIsZ0JBQWdCLE1BQU0sZ0JBQWdCLENBQUM7Q0FDdkMsYUFBYTtDQUNiLFNBQVM7Q0FDVCxLQUFLO0NBQ0w7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLFNBQVMsQ0FBQyxPQUFPLEVBQUU7Q0FDdkIsUUFBUSxJQUFJLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0NBQ25ELFFBQVEsT0FBTyxPQUFPLENBQUM7Q0FDdkIsS0FBSztDQUNMO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxNQUFNLFdBQVcsR0FBRztDQUN4QixRQUFRLElBQUksT0FBTyxDQUFDO0NBQ3BCLFFBQVEsT0FBTyxPQUFPLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixDQUFDLEtBQUssRUFBRSxFQUFFO0NBQy9ELFlBQVksTUFBTSxPQUFPLENBQUM7Q0FDMUIsU0FBUztDQUNULEtBQUs7Q0FDTDtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksT0FBTyxHQUFHO0NBQ2QsUUFBUSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLENBQUM7Q0FDeEMsS0FBSztDQUNMO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxNQUFNLDBCQUEwQixDQUFDLFFBQVEsRUFBRTtDQUMvQyxRQUFRLElBQUksZUFBZSxHQUFHLFFBQVEsQ0FBQztDQUN2QyxRQUFRLElBQUksV0FBVyxHQUFHLEtBQUssQ0FBQztDQUNoQyxRQUFRLEtBQUssTUFBTSxRQUFRLElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLGlCQUFpQixDQUFDLEVBQUU7Q0FDekUsWUFBWSxlQUFlLEdBQUcsQ0FBQyxNQUFNLFFBQVEsQ0FBQztDQUM5QyxnQkFBZ0IsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPO0NBQ3JDLGdCQUFnQixRQUFRLEVBQUUsZUFBZTtDQUN6QyxnQkFBZ0IsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLO0NBQ2pDLGFBQWEsQ0FBQyxLQUFLLFNBQVMsQ0FBQztDQUM3QixZQUFZLFdBQVcsR0FBRyxJQUFJLENBQUM7Q0FDL0IsWUFBWSxJQUFJLENBQUMsZUFBZSxFQUFFO0NBQ2xDLGdCQUFnQixNQUFNO0NBQ3RCLGFBQWE7Q0FDYixTQUFTO0NBQ1QsUUFBUSxJQUFJLENBQUMsV0FBVyxFQUFFO0NBQzFCLFlBQVksSUFBSSxlQUFlLElBQUksZUFBZSxDQUFDLE1BQU0sS0FBSyxHQUFHLEVBQUU7Q0FDbkUsZ0JBQWdCLGVBQWUsR0FBRyxTQUFTLENBQUM7Q0FDNUMsYUFBYTtDQUNiLFlBQXVEO0NBQ3ZELGdCQUFnQixJQUFJLGVBQWUsRUFBRTtDQUNyQyxvQkFBb0IsSUFBSSxlQUFlLENBQUMsTUFBTSxLQUFLLEdBQUcsRUFBRTtDQUN4RCx3QkFBd0IsSUFBSSxlQUFlLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtDQUMxRCw0QkFBNEIsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLGtCQUFrQixFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztDQUNqRixnQ0FBZ0MsQ0FBQyx3REFBd0QsQ0FBQztDQUMxRixnQ0FBZ0MsQ0FBQyxpREFBaUQsQ0FBQyxDQUFDLENBQUM7Q0FDckYseUJBQXlCO0NBQ3pCLDZCQUE2QjtDQUM3Qiw0QkFBNEIsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLGtCQUFrQixFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztDQUNsRixnQ0FBZ0MsQ0FBQywyQkFBMkIsRUFBRSxRQUFRLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQztDQUMzRixnQ0FBZ0MsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUM7Q0FDMUQseUJBQXlCO0NBQ3pCLHFCQUFxQjtDQUNyQixpQkFBaUI7Q0FDakIsYUFBYTtDQUNiLFNBQVM7Q0FDVCxRQUFRLE9BQU8sZUFBZSxDQUFDO0NBQy9CLEtBQUs7Q0FDTDs7Q0NyZkE7Q0FDQTtBQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FPQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsTUFBTSxRQUFRLENBQUM7Q0FDZjtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLFdBQVcsQ0FBQyxPQUFPLEdBQUcsRUFBRSxFQUFFO0NBQzlCO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsUUFBUSxJQUFJLENBQUMsU0FBUyxHQUFHLFVBQVUsQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0NBQ3RFO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsUUFBUSxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDO0NBQzdDO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsUUFBUSxJQUFJLENBQUMsWUFBWSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUM7Q0FDakQ7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxRQUFRLElBQUksQ0FBQyxZQUFZLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQztDQUNqRCxLQUFLO0NBQ0w7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUU7Q0FDcEIsUUFBUSxNQUFNLENBQUMsWUFBWSxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztDQUN2RCxRQUFRLE9BQU8sWUFBWSxDQUFDO0NBQzVCLEtBQUs7Q0FDTDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksU0FBUyxDQUFDLE9BQU8sRUFBRTtDQUN2QjtDQUNBLFFBQVEsSUFBSSxPQUFPLFlBQVksVUFBVSxFQUFFO0NBQzNDLFlBQVksT0FBTyxHQUFHO0NBQ3RCLGdCQUFnQixLQUFLLEVBQUUsT0FBTztDQUM5QixnQkFBZ0IsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPO0NBQ3hDLGFBQWEsQ0FBQztDQUNkLFNBQVM7Q0FDVCxRQUFRLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7Q0FDcEMsUUFBUSxNQUFNLE9BQU8sR0FBRyxPQUFPLE9BQU8sQ0FBQyxPQUFPLEtBQUssUUFBUTtDQUMzRCxZQUFZLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUM7Q0FDeEMsWUFBWSxPQUFPLENBQUMsT0FBTyxDQUFDO0NBQzVCLFFBQVEsTUFBTSxNQUFNLEdBQUcsUUFBUSxJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQztDQUN4RSxRQUFRLE1BQU0sT0FBTyxHQUFHLElBQUksZUFBZSxDQUFDLElBQUksRUFBRSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztDQUM5RSxRQUFRLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztDQUN4RSxRQUFRLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7Q0FDdkY7Q0FDQSxRQUFRLE9BQU8sQ0FBQyxZQUFZLEVBQUUsV0FBVyxDQUFDLENBQUM7Q0FDM0MsS0FBSztDQUNMLElBQUksTUFBTSxZQUFZLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUU7Q0FDaEQsUUFBUSxNQUFNLE9BQU8sQ0FBQyxZQUFZLENBQUMsa0JBQWtCLEVBQUUsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztDQUMzRSxRQUFRLElBQUksUUFBUSxHQUFHLFNBQVMsQ0FBQztDQUNqQyxRQUFRLElBQUk7Q0FDWixZQUFZLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0NBQzVEO0NBQ0E7Q0FDQTtDQUNBLFlBQVksSUFBSSxDQUFDLFFBQVEsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLE9BQU8sRUFBRTtDQUN4RCxnQkFBZ0IsTUFBTSxJQUFJLFlBQVksQ0FBQyxhQUFhLEVBQUUsRUFBRSxHQUFHLEVBQUUsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7Q0FDNUUsYUFBYTtDQUNiLFNBQVM7Q0FDVCxRQUFRLE9BQU8sS0FBSyxFQUFFO0NBQ3RCLFlBQVksS0FBSyxNQUFNLFFBQVEsSUFBSSxPQUFPLENBQUMsZ0JBQWdCLENBQUMsaUJBQWlCLENBQUMsRUFBRTtDQUNoRixnQkFBZ0IsUUFBUSxHQUFHLE1BQU0sUUFBUSxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO0NBQ3JFLGdCQUFnQixJQUFJLFFBQVEsRUFBRTtDQUM5QixvQkFBb0IsTUFBTTtDQUMxQixpQkFBaUI7Q0FDakIsYUFBYTtDQUNiLFlBQVksSUFBSSxDQUFDLFFBQVEsRUFBRTtDQUMzQixnQkFBZ0IsTUFBTSxLQUFLLENBQUM7Q0FDNUIsYUFBYTtDQUNiLGlCQUE0RDtDQUM1RCxnQkFBZ0IsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLHFCQUFxQixFQUFFLGNBQWMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDO0NBQ25GLG9CQUFvQixDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsdURBQXVELENBQUM7Q0FDeEYsb0JBQW9CLENBQUMseUJBQXlCLENBQUMsQ0FBQyxDQUFDO0NBQ2pELGFBQWE7Q0FDYixTQUFTO0NBQ1QsUUFBUSxLQUFLLE1BQU0sUUFBUSxJQUFJLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFO0NBQy9FLFlBQVksUUFBUSxHQUFHLE1BQU0sUUFBUSxDQUFDLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO0NBQ3BFLFNBQVM7Q0FDVCxRQUFRLE9BQU8sUUFBUSxDQUFDO0NBQ3hCLEtBQUs7Q0FDTCxJQUFJLE1BQU0sY0FBYyxDQUFDLFlBQVksRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRTtDQUNoRSxRQUFRLElBQUksUUFBUSxDQUFDO0NBQ3JCLFFBQVEsSUFBSSxLQUFLLENBQUM7Q0FDbEIsUUFBUSxJQUFJO0NBQ1osWUFBWSxRQUFRLEdBQUcsTUFBTSxZQUFZLENBQUM7Q0FDMUMsU0FBUztDQUNULFFBQVEsT0FBTyxLQUFLLEVBQUU7Q0FDdEI7Q0FDQTtDQUNBO0NBQ0EsU0FBUztDQUNULFFBQVEsSUFBSTtDQUNaLFlBQVksTUFBTSxPQUFPLENBQUMsWUFBWSxDQUFDLG1CQUFtQixFQUFFO0NBQzVELGdCQUFnQixLQUFLO0NBQ3JCLGdCQUFnQixPQUFPO0NBQ3ZCLGdCQUFnQixRQUFRO0NBQ3hCLGFBQWEsQ0FBQyxDQUFDO0NBQ2YsWUFBWSxNQUFNLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQztDQUN4QyxTQUFTO0NBQ1QsUUFBUSxPQUFPLGNBQWMsRUFBRTtDQUMvQixZQUFZLEtBQUssR0FBRyxjQUFjLENBQUM7Q0FDbkMsU0FBUztDQUNULFFBQVEsTUFBTSxPQUFPLENBQUMsWUFBWSxDQUFDLG9CQUFvQixFQUFFO0NBQ3pELFlBQVksS0FBSztDQUNqQixZQUFZLE9BQU87Q0FDbkIsWUFBWSxRQUFRO0NBQ3BCLFlBQVksS0FBSztDQUNqQixTQUFTLENBQUMsQ0FBQztDQUNYLFFBQVEsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO0NBQzFCLFFBQVEsSUFBSSxLQUFLLEVBQUU7Q0FDbkIsWUFBWSxNQUFNLEtBQUssQ0FBQztDQUN4QixTQUFTO0NBQ1QsS0FBSztDQUNMLENBQUM7Q0FFRDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBOztDQzlOQTtDQUNBO0FBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQVFBLE1BQU0sc0NBQXNDLEdBQUc7Q0FDL0MsSUFBSSxNQUFNLGVBQWUsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFO0NBQ3hDLFFBQVEsT0FBTyxRQUFRLENBQUMsVUFBVSxHQUFHLE1BQU0sWUFBWSxDQUFDLFFBQVEsQ0FBQyxHQUFHLFFBQVEsQ0FBQztDQUM3RSxLQUFLO0NBQ0wsQ0FBQyxDQUFDO0NBQ0Y7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsTUFBTSxnQkFBZ0IsU0FBUyxRQUFRLENBQUM7Q0FDeEM7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksV0FBVyxDQUFDLE9BQU8sR0FBRyxFQUFFLEVBQUU7Q0FDOUIsUUFBUSxPQUFPLENBQUMsU0FBUyxHQUFHLFVBQVUsQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0NBQzFFLFFBQVEsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0NBQ3ZCLFFBQVEsSUFBSSxDQUFDLGtCQUFrQixHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsS0FBSyxLQUFLLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQztDQUNyRjtDQUNBO0NBQ0E7Q0FDQTtDQUNBLFFBQVEsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsc0NBQXNDLENBQUMsQ0FBQztDQUNsRSxLQUFLO0NBQ0w7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLE1BQU0sT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUU7Q0FDcEMsUUFBUSxNQUFNLFFBQVEsR0FBRyxNQUFNLE9BQU8sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDM0QsUUFBUSxJQUFJLENBQUMsUUFBUSxFQUFFO0NBQ3ZCO0NBQ0E7Q0FDQTtDQUNBLFlBQVksSUFBSSxPQUFPLENBQUMsS0FBSyxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLFNBQVMsRUFBRTtDQUNuRSxnQkFBZ0IsT0FBTyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0NBQ25FLGFBQWE7Q0FDYixZQUFZLE9BQU8sTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztDQUM3RCxTQUFTO0NBQ1QsUUFBUSxPQUFPLFFBQVEsQ0FBQztDQUN4QixLQUFLO0NBQ0wsSUFBSSxNQUFNLFlBQVksQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFO0NBQ3pDLFFBQVEsSUFBSSxRQUFRLENBQUM7Q0FDckI7Q0FDQTtDQUNBLFFBQVEsSUFBSSxJQUFJLENBQUMsa0JBQWtCLEVBQUU7Q0FDckMsWUFBdUQ7Q0FDdkQsZ0JBQWdCLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQywyQkFBMkIsQ0FBQztDQUN6RCxvQkFBb0IsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDO0NBQ2xGLG9CQUFvQixDQUFDLDJDQUEyQyxDQUFDLENBQUMsQ0FBQztDQUNuRSxhQUFhO0NBQ2IsWUFBWSxRQUFRLEdBQUcsTUFBTSxPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0NBQ3BELFNBQVM7Q0FDVCxhQUFhO0NBQ2I7Q0FDQTtDQUNBLFlBQVksTUFBTSxJQUFJLFlBQVksQ0FBQyx3QkFBd0IsRUFBRTtDQUM3RCxnQkFBZ0IsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTO0NBQ3pDLGdCQUFnQixHQUFHLEVBQUUsT0FBTyxDQUFDLEdBQUc7Q0FDaEMsYUFBYSxDQUFDLENBQUM7Q0FDZixTQUFTO0NBQ1QsUUFBbUQ7Q0FDbkQsWUFBWSxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsTUFBTSxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsUUFBUTtDQUN0RSxnQkFBZ0IsTUFBTSxPQUFPLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQztDQUMzRDtDQUNBO0NBQ0EsWUFBWSxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsNkJBQTZCLENBQUM7Q0FDakUsZ0JBQWdCLGNBQWMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztDQUM3QyxZQUFZLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQywyQkFBMkIsRUFBRSxjQUFjLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQ3JGLFlBQVksTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLDBCQUEwQixDQUFDLENBQUMsQ0FBQztDQUNoRSxZQUFZLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDaEMsWUFBWSxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUM7Q0FDOUIsWUFBWSxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsMkJBQTJCLENBQUMsQ0FBQyxDQUFDO0NBQ2pFLFlBQVksTUFBTSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztDQUNqQyxZQUFZLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztDQUM5QixZQUFZLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztDQUM5QixTQUFTO0NBQ1QsUUFBUSxPQUFPLFFBQVEsQ0FBQztDQUN4QixLQUFLO0NBQ0wsSUFBSSxNQUFNLGNBQWMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFO0NBQzNDLFFBQVEsTUFBTSxRQUFRLEdBQUcsTUFBTSxPQUFPLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDakU7Q0FDQSxRQUFRLElBQUksc0JBQXNCLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0NBQ3ZEO0NBQ0E7Q0FDQTtDQUNBLFFBQVEsSUFBSSxRQUFRLElBQUksUUFBUSxDQUFDLE1BQU0sSUFBSSxHQUFHO0NBQzlDLFlBQVksQ0FBQyxJQUFJLENBQUMsaUNBQWlDLEVBQUUsRUFBRTtDQUN2RCxZQUFZLHNCQUFzQixHQUFHLEtBQUssQ0FBQztDQUMzQyxTQUFTO0NBQ1QsUUFBUSxJQUFJLENBQUMsc0JBQXNCLEVBQUU7Q0FDckM7Q0FDQTtDQUNBLFlBQVksTUFBTSxJQUFJLFlBQVksQ0FBQyx5QkFBeUIsRUFBRTtDQUM5RCxnQkFBZ0IsR0FBRyxFQUFFLE9BQU8sQ0FBQyxHQUFHO0NBQ2hDLGdCQUFnQixNQUFNLEVBQUUsUUFBUSxDQUFDLE1BQU07Q0FDdkMsYUFBYSxDQUFDLENBQUM7Q0FDZixTQUFTO0NBQ1QsUUFBUSxPQUFPLFFBQVEsQ0FBQztDQUN4QixLQUFLO0NBQ0w7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksaUNBQWlDLEdBQUc7Q0FDeEMsUUFBUSxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxLQUFLLE1BQU0sQ0FBQyxlQUFlO0NBQ25FLFlBQVksTUFBTSxLQUFLLHNDQUFzQyxDQUFDLENBQUM7Q0FDL0QsS0FBSztDQUNMOztDQ3pKQTtDQUNBO0FBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQWFBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxNQUFNLGtCQUFrQixDQUFDO0NBQ3pCO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxXQUFXLENBQUMsRUFBRSxTQUFTLEVBQUUsT0FBTyxHQUFHLEVBQUUsRUFBRSxpQkFBaUIsR0FBRyxJQUFJLEVBQUUsR0FBRyxFQUFFLEVBQUU7Q0FDNUUsUUFBUSxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztDQUMxQyxRQUFRLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO0NBQzNDLFFBQVEsSUFBSSxDQUFDLHVCQUF1QixHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7Q0FDakQsUUFBUSxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksZ0JBQWdCLENBQUM7Q0FDOUMsWUFBWSxTQUFTLEVBQUUsVUFBVSxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUM7Q0FDNUQsWUFBWSxPQUFPLEVBQUU7Q0FDckIsZ0JBQWdCLEdBQUcsT0FBTztDQUMxQixnQkFBZ0IsSUFBSSxzQkFBc0IsQ0FBQyxFQUFFLGtCQUFrQixFQUFFLElBQUksRUFBRSxDQUFDO0NBQ3hFLGFBQWE7Q0FDYixZQUFZLGlCQUFpQjtDQUM3QixTQUFTLENBQUMsQ0FBQztDQUNYO0NBQ0EsUUFBUSxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQy9DLFFBQVEsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNqRCxLQUFLO0NBQ0w7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLElBQUksUUFBUSxHQUFHO0NBQ25CLFFBQVEsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO0NBQzlCLEtBQUs7Q0FDTDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksUUFBUSxDQUFDLE9BQU8sRUFBRTtDQUN0QixRQUFRLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDckMsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDLCtCQUErQixFQUFFO0NBQ25ELFlBQVksSUFBSSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDM0QsWUFBWSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztDQUM3RCxZQUFZLElBQUksQ0FBQywrQkFBK0IsR0FBRyxJQUFJLENBQUM7Q0FDeEQsU0FBUztDQUNULEtBQUs7Q0FDTDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksY0FBYyxDQUFDLE9BQU8sRUFBRTtDQUM1QixRQUFtRDtDQUNuRCxZQUFZQSxrQkFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUU7Q0FDcEMsZ0JBQWdCLFVBQVUsRUFBRSxvQkFBb0I7Q0FDaEQsZ0JBQWdCLFNBQVMsRUFBRSxvQkFBb0I7Q0FDL0MsZ0JBQWdCLFFBQVEsRUFBRSxnQkFBZ0I7Q0FDMUMsZ0JBQWdCLFNBQVMsRUFBRSxTQUFTO0NBQ3BDLGFBQWEsQ0FBQyxDQUFDO0NBQ2YsU0FBUztDQUNULFFBQVEsTUFBTSxlQUFlLEdBQUcsRUFBRSxDQUFDO0NBQ25DLFFBQVEsS0FBSyxNQUFNLEtBQUssSUFBSSxPQUFPLEVBQUU7Q0FDckM7Q0FDQSxZQUFZLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO0NBQzNDLGdCQUFnQixlQUFlLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0NBQzVDLGFBQWE7Q0FDYixpQkFBaUIsSUFBSSxLQUFLLElBQUksS0FBSyxDQUFDLFFBQVEsS0FBSyxTQUFTLEVBQUU7Q0FDNUQsZ0JBQWdCLGVBQWUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQ2hELGFBQWE7Q0FDYixZQUFZLE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO0NBQzVELFlBQVksTUFBTSxTQUFTLEdBQUcsQ0FBQyxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksS0FBSyxDQUFDLFFBQVE7Q0FDMUUsZ0JBQWdCLFFBQVEsR0FBRyxTQUFTLENBQUM7Q0FDckMsWUFBWSxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO0NBQzlDLGdCQUFnQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLFFBQVEsRUFBRTtDQUM3RCxnQkFBZ0IsTUFBTSxJQUFJLFlBQVksQ0FBQyx1Q0FBdUMsRUFBRTtDQUNoRixvQkFBb0IsVUFBVSxFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO0NBQzlELG9CQUFvQixXQUFXLEVBQUUsUUFBUTtDQUN6QyxpQkFBaUIsQ0FBQyxDQUFDO0NBQ25CLGFBQWE7Q0FDYixZQUFZLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLEtBQUssQ0FBQyxTQUFTLEVBQUU7Q0FDOUQsZ0JBQWdCLElBQUksSUFBSSxDQUFDLHVCQUF1QixDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUM7Q0FDOUQsb0JBQW9CLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEtBQUssS0FBSyxDQUFDLFNBQVMsRUFBRTtDQUNwRixvQkFBb0IsTUFBTSxJQUFJLFlBQVksQ0FBQywyQ0FBMkMsRUFBRTtDQUN4Rix3QkFBd0IsR0FBRztDQUMzQixxQkFBcUIsQ0FBQyxDQUFDO0NBQ3ZCLGlCQUFpQjtDQUNqQixnQkFBZ0IsSUFBSSxDQUFDLHVCQUF1QixDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0NBQzVFLGFBQWE7Q0FDYixZQUFZLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0NBQ3JELFlBQVksSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsU0FBUyxDQUFDLENBQUM7Q0FDdkQsWUFBWSxJQUFJLGVBQWUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO0NBQzVDLGdCQUFnQixNQUFNLGNBQWMsR0FBRyxDQUFDLDRDQUE0QyxDQUFDO0NBQ3JGLG9CQUFvQixDQUFDLE1BQU0sRUFBRSxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLDhCQUE4QixDQUFDO0NBQ3ZGLG9CQUFvQixDQUFDLHdDQUF3QyxDQUFDLENBQUM7Q0FDL0QsZ0JBS3FCO0NBQ3JCLG9CQUFvQixNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0NBQ2hELGlCQUFpQjtDQUNqQixhQUFhO0NBQ2IsU0FBUztDQUNULEtBQUs7Q0FDTDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFO0NBQ25CLFFBQVEsT0FBTyxTQUFTLENBQUMsS0FBSyxFQUFFLFlBQVk7Q0FDNUMsWUFBWSxNQUFNLG1CQUFtQixHQUFHLElBQUksMkJBQTJCLEVBQUUsQ0FBQztDQUMxRSxZQUFZLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0NBQzVEO0NBQ0E7Q0FDQSxZQUFZLEtBQUssTUFBTSxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7Q0FDakUsZ0JBQWdCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7Q0FDN0UsZ0JBQWdCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7Q0FDbEUsZ0JBQWdCLE1BQU0sT0FBTyxHQUFHLElBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtDQUNqRCxvQkFBb0IsU0FBUztDQUM3QixvQkFBb0IsS0FBSyxFQUFFLFNBQVM7Q0FDcEMsb0JBQW9CLFdBQVcsRUFBRSxhQUFhO0NBQzlDLGlCQUFpQixDQUFDLENBQUM7Q0FDbkIsZ0JBQWdCLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQztDQUMxRCxvQkFBb0IsTUFBTSxFQUFFLEVBQUUsUUFBUSxFQUFFO0NBQ3hDLG9CQUFvQixPQUFPO0NBQzNCLG9CQUFvQixLQUFLO0NBQ3pCLGlCQUFpQixDQUFDLENBQUMsQ0FBQztDQUNwQixhQUFhO0NBQ2IsWUFBWSxNQUFNLEVBQUUsV0FBVyxFQUFFLGNBQWMsRUFBRSxHQUFHLG1CQUFtQixDQUFDO0NBQ3hFLFlBQXVEO0NBQ3ZELGdCQUFnQixtQkFBbUIsQ0FBQyxXQUFXLEVBQUUsY0FBYyxDQUFDLENBQUM7Q0FDakUsYUFBYTtDQUNiLFlBQVksT0FBTyxFQUFFLFdBQVcsRUFBRSxjQUFjLEVBQUUsQ0FBQztDQUNuRCxTQUFTLENBQUMsQ0FBQztDQUNYLEtBQUs7Q0FDTDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksUUFBUSxDQUFDLEtBQUssRUFBRTtDQUNwQixRQUFRLE9BQU8sU0FBUyxDQUFDLEtBQUssRUFBRSxZQUFZO0NBQzVDLFlBQVksTUFBTSxLQUFLLEdBQUcsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0NBQzFFLFlBQVksTUFBTSx1QkFBdUIsR0FBRyxNQUFNLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQztDQUMvRCxZQUFZLE1BQU0saUJBQWlCLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7Q0FDOUUsWUFBWSxNQUFNLFdBQVcsR0FBRyxFQUFFLENBQUM7Q0FDbkMsWUFBWSxLQUFLLE1BQU0sT0FBTyxJQUFJLHVCQUF1QixFQUFFO0NBQzNELGdCQUFnQixJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtDQUN6RCxvQkFBb0IsTUFBTSxLQUFLLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0NBQ2hELG9CQUFvQixXQUFXLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztDQUNsRCxpQkFBaUI7Q0FDakIsYUFBYTtDQUNiLFlBQXVEO0NBQ3ZELGdCQUFnQixtQkFBbUIsQ0FBQyxXQUFXLENBQUMsQ0FBQztDQUNqRCxhQUFhO0NBQ2IsWUFBWSxPQUFPLEVBQUUsV0FBVyxFQUFFLENBQUM7Q0FDbkMsU0FBUyxDQUFDLENBQUM7Q0FDWCxLQUFLO0NBQ0w7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxrQkFBa0IsR0FBRztDQUN6QixRQUFRLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDO0NBQ3JDLEtBQUs7Q0FDTDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLGFBQWEsR0FBRztDQUNwQixRQUFRLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0NBQ2pELEtBQUs7Q0FDTDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLGlCQUFpQixDQUFDLEdBQUcsRUFBRTtDQUMzQixRQUFRLE1BQU0sU0FBUyxHQUFHLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDdEQsUUFBUSxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ3pELEtBQUs7Q0FDTDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLE1BQU0sYUFBYSxDQUFDLE9BQU8sRUFBRTtDQUNqQyxRQUFRLE1BQU0sR0FBRyxHQUFHLE9BQU8sWUFBWSxPQUFPLEdBQUcsT0FBTyxDQUFDLEdBQUcsR0FBRyxPQUFPLENBQUM7Q0FDdkUsUUFBUSxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUM7Q0FDckQsUUFBUSxJQUFJLFFBQVEsRUFBRTtDQUN0QixZQUFZLE1BQU0sS0FBSyxHQUFHLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQztDQUMxRSxZQUFZLE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztDQUN6QyxTQUFTO0NBQ1QsUUFBUSxPQUFPLFNBQVMsQ0FBQztDQUN6QixLQUFLO0NBQ0w7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksdUJBQXVCLENBQUMsR0FBRyxFQUFFO0NBQ2pDLFFBQVEsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQ3JELFFBQVEsSUFBSSxDQUFDLFFBQVEsRUFBRTtDQUN2QixZQUFZLE1BQU0sSUFBSSxZQUFZLENBQUMsbUJBQW1CLEVBQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0NBQ2pFLFNBQVM7Q0FDVCxRQUFRLE9BQU8sQ0FBQyxPQUFPLEtBQUs7Q0FDNUIsWUFBWSxPQUFPLENBQUMsT0FBTyxHQUFHLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQy9DLFlBQVksT0FBTyxDQUFDLE1BQU0sR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQztDQUM3RCxZQUFZLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDakQsU0FBUyxDQUFDO0NBQ1YsS0FBSztDQUNMOztDQ3hSQTtDQUNBO0FBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUdBLElBQUksa0JBQWtCLENBQUM7Q0FDdkI7Q0FDQTtDQUNBO0NBQ0E7Q0FDTyxNQUFNLDZCQUE2QixHQUFHLE1BQU07Q0FDbkQsSUFBSSxJQUFJLENBQUMsa0JBQWtCLEVBQUU7Q0FDN0IsUUFBUSxrQkFBa0IsR0FBRyxJQUFJLGtCQUFrQixFQUFFLENBQUM7Q0FDdEQsS0FBSztDQUNMLElBQUksT0FBTyxrQkFBa0IsQ0FBQztDQUM5QixDQUFDOztDQ2xCRDtDQUNBLElBQUk7Q0FDSixJQUFJLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO0NBQ3pDLENBQUM7Q0FDRCxPQUFPLENBQUMsRUFBRTs7Q0NMVjtDQUNBO0FBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUVBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDTyxNQUFNLGFBQWEsR0FBRyxLQUFLLENBQUM7Q0FDbkM7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDTyxNQUFNLFlBQVksR0FBRztDQUM1QixJQUFJLFFBQVE7Q0FDWixJQUFJLEtBQUs7Q0FDVCxJQUFJLE1BQU07Q0FDVixJQUFJLE9BQU87Q0FDWCxJQUFJLE1BQU07Q0FDVixJQUFJLEtBQUs7Q0FDVCxDQUFDOztDQy9CRDtDQUNBO0FBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUdBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ08sTUFBTSxnQkFBZ0IsR0FBRyxDQUFDLE9BQU8sS0FBSztDQUM3QyxJQUFJLElBQUksT0FBTyxJQUFJLE9BQU8sT0FBTyxLQUFLLFFBQVEsRUFBRTtDQUNoRCxRQUFtRDtDQUNuRCxZQUFZQSxrQkFBTSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsUUFBUSxFQUFFO0NBQ2hELGdCQUFnQixVQUFVLEVBQUUsaUJBQWlCO0NBQzdDLGdCQUFnQixTQUFTLEVBQUUsT0FBTztDQUNsQyxnQkFBZ0IsUUFBUSxFQUFFLGFBQWE7Q0FDdkMsZ0JBQWdCLFNBQVMsRUFBRSxTQUFTO0NBQ3BDLGFBQWEsQ0FBQyxDQUFDO0NBQ2YsU0FBUztDQUNULFFBQVEsT0FBTyxPQUFPLENBQUM7Q0FDdkIsS0FBSztDQUNMLFNBQVM7Q0FDVCxRQUFtRDtDQUNuRCxZQUFZQSxrQkFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsVUFBVSxFQUFFO0NBQy9DLGdCQUFnQixVQUFVLEVBQUUsaUJBQWlCO0NBQzdDLGdCQUFnQixTQUFTLEVBQUUsT0FBTztDQUNsQyxnQkFBZ0IsUUFBUSxFQUFFLGFBQWE7Q0FDdkMsZ0JBQWdCLFNBQVMsRUFBRSxTQUFTO0NBQ3BDLGFBQWEsQ0FBQyxDQUFDO0NBQ2YsU0FBUztDQUNULFFBQVEsT0FBTyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsQ0FBQztDQUNuQyxLQUFLO0NBQ0wsQ0FBQzs7Q0N2Q0Q7Q0FDQTtBQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FLQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxNQUFNLEtBQUssQ0FBQztDQUNaO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLFdBQVcsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLE1BQU0sR0FBRyxhQUFhLEVBQUU7Q0FDeEQsUUFBbUQ7Q0FDbkQsWUFBWUEsa0JBQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLFVBQVUsRUFBRTtDQUM3QyxnQkFBZ0IsVUFBVSxFQUFFLGlCQUFpQjtDQUM3QyxnQkFBZ0IsU0FBUyxFQUFFLE9BQU87Q0FDbEMsZ0JBQWdCLFFBQVEsRUFBRSxhQUFhO0NBQ3ZDLGdCQUFnQixTQUFTLEVBQUUsT0FBTztDQUNsQyxhQUFhLENBQUMsQ0FBQztDQUNmLFlBQVksSUFBSSxNQUFNLEVBQUU7Q0FDeEIsZ0JBQWdCQSxrQkFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsWUFBWSxFQUFFLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUM7Q0FDOUUsYUFBYTtDQUNiLFNBQVM7Q0FDVDtDQUNBO0NBQ0EsUUFBUSxJQUFJLENBQUMsT0FBTyxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0NBQ2pELFFBQVEsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7Q0FDM0IsUUFBUSxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztDQUM3QixLQUFLO0NBQ0w7O0NDbERBO0NBQ0E7QUFDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBS0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxNQUFNLFdBQVcsU0FBUyxLQUFLLENBQUM7Q0FDaEM7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLFdBQVcsQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRTtDQUN6QyxRQUFtRDtDQUNuRCxZQUFZQSxrQkFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFO0NBQzlDLGdCQUFnQixVQUFVLEVBQUUsaUJBQWlCO0NBQzdDLGdCQUFnQixTQUFTLEVBQUUsYUFBYTtDQUN4QyxnQkFBZ0IsUUFBUSxFQUFFLGFBQWE7Q0FDdkMsZ0JBQWdCLFNBQVMsRUFBRSxTQUFTO0NBQ3BDLGFBQWEsQ0FBQyxDQUFDO0NBQ2YsU0FBUztDQUNULFFBQVEsTUFBTSxLQUFLLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxLQUFLO0NBQ25DLFlBQVksTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDakQ7Q0FDQSxZQUFZLElBQUksQ0FBQyxNQUFNLEVBQUU7Q0FDekIsZ0JBQWdCLE9BQU87Q0FDdkIsYUFBYTtDQUNiO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsWUFBWSxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsTUFBTSxNQUFNLE1BQU0sQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLEVBQUU7Q0FDMUUsZ0JBQTJEO0NBQzNELG9CQUFvQixNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsd0JBQXdCLEVBQUUsTUFBTSxDQUFDLHlCQUF5QixDQUFDO0NBQzdGLHdCQUF3QixDQUFDLDhCQUE4QixFQUFFLEdBQUcsQ0FBQywyQkFBMkIsQ0FBQztDQUN6Rix3QkFBd0IsQ0FBQywwREFBMEQsQ0FBQyxDQUFDLENBQUM7Q0FDdEYsaUJBQWlCO0NBQ2pCLGdCQUFnQixPQUFPO0NBQ3ZCLGFBQWE7Q0FDYjtDQUNBO0NBQ0E7Q0FDQTtDQUNBLFlBQVksT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQ25DLFNBQVMsQ0FBQztDQUNWLFFBQVEsS0FBSyxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUM7Q0FDdEMsS0FBSztDQUNMOztDQ3pFQTtDQUNBO0FBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQVFBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxNQUFNLE1BQU0sQ0FBQztDQUNiO0NBQ0E7Q0FDQTtDQUNBLElBQUksV0FBVyxHQUFHO0NBQ2xCLFFBQVEsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO0NBQ2pDLFFBQVEsSUFBSSxDQUFDLGtCQUFrQixHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7Q0FDNUMsS0FBSztDQUNMO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLElBQUksTUFBTSxHQUFHO0NBQ2pCLFFBQVEsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO0NBQzVCLEtBQUs7Q0FDTDtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksZ0JBQWdCLEdBQUc7Q0FDdkI7Q0FDQSxRQUFRLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxLQUFLLEtBQUs7Q0FDbkQsWUFBWSxNQUFNLEVBQUUsT0FBTyxFQUFFLEdBQUcsS0FBSyxDQUFDO0NBQ3RDLFlBQVksTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO0NBQzNFLFlBQVksSUFBSSxlQUFlLEVBQUU7Q0FDakMsZ0JBQWdCLEtBQUssQ0FBQyxXQUFXLENBQUMsZUFBZSxDQUFDLENBQUM7Q0FDbkQsYUFBYTtDQUNiLFNBQVMsRUFBRSxDQUFDO0NBQ1osS0FBSztDQUNMO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxnQkFBZ0IsR0FBRztDQUN2QjtDQUNBLFFBQVEsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsR0FBRyxDQUFDLEtBQUssS0FBSztDQUNyRCxZQUFZLElBQUksS0FBSyxDQUFDLElBQUksSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxZQUFZLEVBQUU7Q0FDaEUsZ0JBQWdCLE1BQU0sRUFBRSxPQUFPLEVBQUUsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDO0NBQy9DLGdCQUEyRDtDQUMzRCxvQkFBb0IsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLDRCQUE0QixDQUFDLEVBQUUsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0NBQ3RGLGlCQUFpQjtDQUNqQixnQkFBZ0IsTUFBTSxlQUFlLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssS0FBSztDQUN2RixvQkFBb0IsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7Q0FDbkQsd0JBQXdCLEtBQUssR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0NBQ3hDLHFCQUFxQjtDQUNyQixvQkFBb0IsTUFBTSxPQUFPLEdBQUcsSUFBSSxPQUFPLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQztDQUMxRCxvQkFBb0IsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7Q0FDbEU7Q0FDQTtDQUNBO0NBQ0EsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO0NBQ3BCLGdCQUFnQixLQUFLLENBQUMsU0FBUyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0NBQ2pEO0NBQ0EsZ0JBQWdCLElBQUksS0FBSyxDQUFDLEtBQUssSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFO0NBQ25ELG9CQUFvQixlQUFlLENBQUMsSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztDQUNqRixpQkFBaUI7Q0FDakIsYUFBYTtDQUNiLFNBQVMsRUFBRSxDQUFDO0NBQ1osS0FBSztDQUNMO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksYUFBYSxDQUFDLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxFQUFFO0NBQ3RDLFFBQW1EO0NBQ25ELFlBQVlBLGtCQUFNLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUU7Q0FDaEQsZ0JBQWdCLFVBQVUsRUFBRSxpQkFBaUI7Q0FDN0MsZ0JBQWdCLFNBQVMsRUFBRSxRQUFRO0NBQ25DLGdCQUFnQixRQUFRLEVBQUUsZUFBZTtDQUN6QyxnQkFBZ0IsU0FBUyxFQUFFLGlCQUFpQjtDQUM1QyxhQUFhLENBQUMsQ0FBQztDQUNmLFNBQVM7Q0FDVCxRQUFRLE1BQU0sR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ3hELFFBQVEsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFO0NBQzlDLFlBQXVEO0NBQ3ZELGdCQUFnQixNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMseURBQXlELENBQUMsQ0FBQyxDQUFDO0NBQzFGLGFBQWE7Q0FDYixZQUFZLE9BQU87Q0FDbkIsU0FBUztDQUNULFFBQVEsTUFBTSxVQUFVLEdBQUcsR0FBRyxDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsTUFBTSxDQUFDO0NBQzFELFFBQVEsTUFBTSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUM7Q0FDekQsWUFBWSxLQUFLO0NBQ2pCLFlBQVksT0FBTztDQUNuQixZQUFZLFVBQVU7Q0FDdEIsWUFBWSxHQUFHO0NBQ2YsU0FBUyxDQUFDLENBQUM7Q0FDWCxRQUFRLElBQUksT0FBTyxHQUFHLEtBQUssSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDO0NBQzdDLFFBQVEsTUFBTSxhQUFhLEdBQUcsRUFBRSxDQUFDO0NBQ2pDLFFBQW1EO0NBQ25ELFlBQVksSUFBSSxPQUFPLEVBQUU7Q0FDekIsZ0JBQWdCLGFBQWEsQ0FBQyxJQUFJLENBQUM7Q0FDbkMsb0JBQW9CLENBQUMscUNBQXFDLENBQUMsRUFBRSxLQUFLO0NBQ2xFLGlCQUFpQixDQUFDLENBQUM7Q0FDbkIsZ0JBQWdCLElBQUksTUFBTSxFQUFFO0NBQzVCLG9CQUFvQixhQUFhLENBQUMsSUFBSSxDQUFDO0NBQ3ZDLHdCQUF3QixDQUFDLG9EQUFvRCxDQUFDLEVBQUUsTUFBTTtDQUN0RixxQkFBcUIsQ0FBQyxDQUFDO0NBQ3ZCLGlCQUFpQjtDQUNqQixhQUFhO0NBQ2IsU0FBUztDQUNUO0NBQ0E7Q0FDQSxRQUFRLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUM7Q0FDdEMsUUFBUSxJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUU7Q0FDN0QsWUFBdUQ7Q0FDdkQsZ0JBQWdCLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyx5Q0FBeUMsQ0FBQztDQUM5RSxvQkFBb0IsQ0FBQyxnQ0FBZ0MsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUNsRSxhQUFhO0NBQ2IsWUFBWSxPQUFPLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztDQUMxRCxTQUFTO0NBQ1QsUUFBUSxJQUFJLENBQUMsT0FBTyxFQUFFO0NBQ3RCLFlBQXVEO0NBQ3ZEO0NBQ0E7Q0FDQSxnQkFBZ0IsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLG9CQUFvQixFQUFFLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUMzRSxhQUFhO0NBQ2IsWUFBWSxPQUFPO0NBQ25CLFNBQVM7Q0FDVCxRQUFtRDtDQUNuRDtDQUNBO0NBQ0EsWUFBWSxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMseUJBQXlCLEVBQUUsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQ3JGLFlBQVksYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsS0FBSztDQUMzQyxnQkFBZ0IsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFO0NBQ3hDLG9CQUFvQixNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7Q0FDdkMsaUJBQWlCO0NBQ2pCLHFCQUFxQjtDQUNyQixvQkFBb0IsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztDQUNwQyxpQkFBaUI7Q0FDakIsYUFBYSxDQUFDLENBQUM7Q0FDZixZQUFZLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztDQUM5QixTQUFTO0NBQ1Q7Q0FDQTtDQUNBLFFBQVEsSUFBSSxlQUFlLENBQUM7Q0FDNUIsUUFBUSxJQUFJO0NBQ1osWUFBWSxlQUFlLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7Q0FDOUUsU0FBUztDQUNULFFBQVEsT0FBTyxHQUFHLEVBQUU7Q0FDcEIsWUFBWSxlQUFlLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztDQUNsRCxTQUFTO0NBQ1QsUUFBUSxJQUFJLGVBQWUsWUFBWSxPQUFPLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRTtDQUN0RSxZQUFZLGVBQWUsR0FBRyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxLQUFLO0NBQzdELGdCQUEyRDtDQUMzRDtDQUNBO0NBQ0Esb0JBQW9CLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxpQ0FBaUMsQ0FBQztDQUM3RSx3QkFBd0IsQ0FBQyxDQUFDLEVBQUUsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDLGdDQUFnQyxDQUFDLENBQUMsQ0FBQztDQUNuRixvQkFBb0IsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLGdCQUFnQixDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7Q0FDNUQsb0JBQW9CLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7Q0FDdEMsb0JBQW9CLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztDQUN0QyxpQkFBaUI7Q0FDakIsZ0JBQWdCLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7Q0FDMUUsYUFBYSxDQUFDLENBQUM7Q0FDZixTQUFTO0NBQ1QsUUFBUSxPQUFPLGVBQWUsQ0FBQztDQUMvQixLQUFLO0NBQ0w7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLGlCQUFpQixDQUFDLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLEVBQUU7Q0FDM0QsUUFBUSxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO0NBQzlELFFBQVEsS0FBSyxNQUFNLEtBQUssSUFBSSxNQUFNLEVBQUU7Q0FDcEMsWUFBWSxJQUFJLE1BQU0sQ0FBQztDQUN2QixZQUFZLE1BQU0sV0FBVyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxHQUFHLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO0NBQ2pGLFlBQVksSUFBSSxXQUFXLEVBQUU7Q0FDN0IsZ0JBQTJEO0NBQzNEO0NBQ0E7Q0FDQSxvQkFBb0IsSUFBSSxXQUFXLFlBQVksT0FBTyxFQUFFO0NBQ3hELHdCQUF3QixNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsY0FBYyxFQUFFLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxXQUFXLENBQUM7Q0FDckYsNEJBQTRCLENBQUMsb0RBQW9ELENBQUM7Q0FDbEYsNEJBQTRCLENBQUMsNERBQTRELENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztDQUNuRyxxQkFBcUI7Q0FDckIsaUJBQWlCO0NBQ2pCO0NBQ0EsZ0JBQWdCLE1BQU0sR0FBRyxXQUFXLENBQUM7Q0FDckMsZ0JBQWdCLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtDQUM1RTtDQUNBLG9CQUFvQixNQUFNLEdBQUcsU0FBUyxDQUFDO0NBQ3ZDLGlCQUFpQjtDQUNqQixxQkFBcUIsS0FBSyxXQUFXLENBQUMsV0FBVyxLQUFLLE1BQU07Q0FDNUQsb0JBQW9CLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsR0FBRztDQUM1RDtDQUNBLG9CQUFvQixNQUFNLEdBQUcsU0FBUyxDQUFDO0NBQ3ZDLGlCQUFpQjtDQUNqQixxQkFBcUIsSUFBSSxPQUFPLFdBQVcsS0FBSyxTQUFTLEVBQUU7Q0FDM0Q7Q0FDQTtDQUNBO0NBQ0Esb0JBQW9CLE1BQU0sR0FBRyxTQUFTLENBQUM7Q0FDdkMsaUJBQWlCO0NBQ2pCO0NBQ0EsZ0JBQWdCLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLENBQUM7Q0FDekMsYUFBYTtDQUNiLFNBQVM7Q0FDVDtDQUNBLFFBQVEsT0FBTyxFQUFFLENBQUM7Q0FDbEIsS0FBSztDQUNMO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxNQUFNLEdBQUcsYUFBYSxFQUFFO0NBQ3ZELFFBQVEsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztDQUN2RSxLQUFLO0NBQ0w7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLGVBQWUsQ0FBQyxPQUFPLEVBQUU7Q0FDN0IsUUFBUSxJQUFJLENBQUMsYUFBYSxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0NBQ3ZELEtBQUs7Q0FDTDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxhQUFhLENBQUMsS0FBSyxFQUFFO0NBQ3pCLFFBQW1EO0NBQ25ELFlBQVlBLGtCQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUU7Q0FDM0MsZ0JBQWdCLFVBQVUsRUFBRSxpQkFBaUI7Q0FDN0MsZ0JBQWdCLFNBQVMsRUFBRSxRQUFRO0NBQ25DLGdCQUFnQixRQUFRLEVBQUUsZUFBZTtDQUN6QyxnQkFBZ0IsU0FBUyxFQUFFLE9BQU87Q0FDbEMsYUFBYSxDQUFDLENBQUM7Q0FDZixZQUFZQSxrQkFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFO0NBQzdDLGdCQUFnQixVQUFVLEVBQUUsaUJBQWlCO0NBQzdDLGdCQUFnQixTQUFTLEVBQUUsUUFBUTtDQUNuQyxnQkFBZ0IsUUFBUSxFQUFFLGVBQWU7Q0FDekMsZ0JBQWdCLFNBQVMsRUFBRSxPQUFPO0NBQ2xDLGFBQWEsQ0FBQyxDQUFDO0NBQ2YsWUFBWUEsa0JBQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUU7Q0FDbkQsZ0JBQWdCLFVBQVUsRUFBRSxpQkFBaUI7Q0FDN0MsZ0JBQWdCLFNBQVMsRUFBRSxRQUFRO0NBQ25DLGdCQUFnQixRQUFRLEVBQUUsZUFBZTtDQUN6QyxnQkFBZ0IsU0FBUyxFQUFFLE9BQU87Q0FDbEMsYUFBYSxDQUFDLENBQUM7Q0FDZixZQUFZQSxrQkFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRTtDQUN0RCxnQkFBZ0IsVUFBVSxFQUFFLGlCQUFpQjtDQUM3QyxnQkFBZ0IsU0FBUyxFQUFFLFFBQVE7Q0FDbkMsZ0JBQWdCLFFBQVEsRUFBRSxlQUFlO0NBQ3pDLGdCQUFnQixTQUFTLEVBQUUsZUFBZTtDQUMxQyxhQUFhLENBQUMsQ0FBQztDQUNmLFlBQVlBLGtCQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFO0NBQ2xELGdCQUFnQixVQUFVLEVBQUUsaUJBQWlCO0NBQzdDLGdCQUFnQixTQUFTLEVBQUUsUUFBUTtDQUNuQyxnQkFBZ0IsUUFBUSxFQUFFLGVBQWU7Q0FDekMsZ0JBQWdCLFNBQVMsRUFBRSxjQUFjO0NBQ3pDLGFBQWEsQ0FBQyxDQUFDO0NBQ2YsU0FBUztDQUNULFFBQVEsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRTtDQUM3QyxZQUFZLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUM7Q0FDL0MsU0FBUztDQUNUO0NBQ0E7Q0FDQSxRQUFRLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7Q0FDbkQsS0FBSztDQUNMO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLGVBQWUsQ0FBQyxLQUFLLEVBQUU7Q0FDM0IsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFO0NBQzdDLFlBQVksTUFBTSxJQUFJLFlBQVksQ0FBQyw0Q0FBNEMsRUFBRTtDQUNqRixnQkFBZ0IsTUFBTSxFQUFFLEtBQUssQ0FBQyxNQUFNO0NBQ3BDLGFBQWEsQ0FBQyxDQUFDO0NBQ2YsU0FBUztDQUNULFFBQVEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztDQUN6RSxRQUFRLElBQUksVUFBVSxHQUFHLENBQUMsQ0FBQyxFQUFFO0NBQzdCLFlBQVksSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUM7Q0FDakUsU0FBUztDQUNULGFBQWE7Q0FDYixZQUFZLE1BQU0sSUFBSSxZQUFZLENBQUMsdUNBQXVDLENBQUMsQ0FBQztDQUM1RSxTQUFTO0NBQ1QsS0FBSztDQUNMOztDQ3RXQTtDQUNBO0FBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUdBLElBQUksYUFBYSxDQUFDO0NBQ2xCO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ08sTUFBTSx3QkFBd0IsR0FBRyxNQUFNO0NBQzlDLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRTtDQUN4QixRQUFRLGFBQWEsR0FBRyxJQUFJLE1BQU0sRUFBRSxDQUFDO0NBQ3JDO0NBQ0EsUUFBUSxhQUFhLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztDQUN6QyxRQUFRLGFBQWEsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO0NBQ3pDLEtBQUs7Q0FDTCxJQUFJLE9BQU8sYUFBYSxDQUFDO0NBQ3pCLENBQUM7O0NDekJEO0NBQ0E7QUFDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBT0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxTQUFTLGFBQWEsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRTtDQUNqRCxJQUFJLElBQUksS0FBSyxDQUFDO0NBQ2QsSUFBSSxJQUFJLE9BQU8sT0FBTyxLQUFLLFFBQVEsRUFBRTtDQUNyQyxRQUFRLE1BQU0sVUFBVSxHQUFHLElBQUksR0FBRyxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDM0QsUUFBbUQ7Q0FDbkQsWUFBWSxJQUFJLEVBQUUsT0FBTyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsSUFBSSxPQUFPLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUU7Q0FDMUUsZ0JBQWdCLE1BQU0sSUFBSSxZQUFZLENBQUMsZ0JBQWdCLEVBQUU7Q0FDekQsb0JBQW9CLFVBQVUsRUFBRSxpQkFBaUI7Q0FDakQsb0JBQW9CLFFBQVEsRUFBRSxlQUFlO0NBQzdDLG9CQUFvQixTQUFTLEVBQUUsU0FBUztDQUN4QyxpQkFBaUIsQ0FBQyxDQUFDO0NBQ25CLGFBQWE7Q0FDYjtDQUNBO0NBQ0EsWUFBWSxNQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQztDQUMzRCxnQkFBZ0IsVUFBVSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUM7Q0FDOUM7Q0FDQSxZQUFZLE1BQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQztDQUN2QyxZQUFZLElBQUksQ0FBQyxJQUFJLE1BQU0sQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRTtDQUNqRSxnQkFBZ0IsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLDREQUE0RCxDQUFDO0NBQzNGLG9CQUFvQixDQUFDLFdBQVcsRUFBRSxTQUFTLENBQUMseUNBQXlDLENBQUM7Q0FDdEYsb0JBQW9CLENBQUMsNERBQTRELENBQUMsQ0FBQyxDQUFDO0NBQ3BGLGFBQWE7Q0FDYixTQUFTO0NBQ1QsUUFBUSxNQUFNLGFBQWEsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLEtBQUs7Q0FDM0MsWUFBdUQ7Q0FDdkQsZ0JBQWdCLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxLQUFLLFVBQVUsQ0FBQyxRQUFRO0NBQ3pELHFCQUFxQixHQUFHLENBQUMsTUFBTSxLQUFLLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRTtDQUN4RCxvQkFBb0IsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLDZDQUE2QyxDQUFDO0NBQzFGLHdCQUF3QixDQUFDLEVBQUUsR0FBRyxDQUFDLG9EQUFvRCxDQUFDO0NBQ3BGLHdCQUF3QixDQUFDLDZCQUE2QixDQUFDLENBQUMsQ0FBQztDQUN6RCxpQkFBaUI7Q0FDakIsYUFBYTtDQUNiLFlBQVksT0FBTyxHQUFHLENBQUMsSUFBSSxLQUFLLFVBQVUsQ0FBQyxJQUFJLENBQUM7Q0FDaEQsU0FBUyxDQUFDO0NBQ1Y7Q0FDQSxRQUFRLEtBQUssR0FBRyxJQUFJLEtBQUssQ0FBQyxhQUFhLEVBQUUsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0NBQzFELEtBQUs7Q0FDTCxTQUFTLElBQUksT0FBTyxZQUFZLE1BQU0sRUFBRTtDQUN4QztDQUNBLFFBQVEsS0FBSyxHQUFHLElBQUksV0FBVyxDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUM7Q0FDMUQsS0FBSztDQUNMLFNBQVMsSUFBSSxPQUFPLE9BQU8sS0FBSyxVQUFVLEVBQUU7Q0FDNUM7Q0FDQSxRQUFRLEtBQUssR0FBRyxJQUFJLEtBQUssQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0NBQ3BELEtBQUs7Q0FDTCxTQUFTLElBQUksT0FBTyxZQUFZLEtBQUssRUFBRTtDQUN2QyxRQUFRLEtBQUssR0FBRyxPQUFPLENBQUM7Q0FDeEIsS0FBSztDQUNMLFNBQVM7Q0FDVCxRQUFRLE1BQU0sSUFBSSxZQUFZLENBQUMsd0JBQXdCLEVBQUU7Q0FDekQsWUFBWSxVQUFVLEVBQUUsaUJBQWlCO0NBQ3pDLFlBQVksUUFBUSxFQUFFLGVBQWU7Q0FDckMsWUFBWSxTQUFTLEVBQUUsU0FBUztDQUNoQyxTQUFTLENBQUMsQ0FBQztDQUNYLEtBQUs7Q0FDTCxJQUFJLE1BQU0sYUFBYSxHQUFHLHdCQUF3QixFQUFFLENBQUM7Q0FDckQsSUFBSSxhQUFhLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0NBQ3ZDLElBQUksT0FBTyxLQUFLLENBQUM7Q0FDakI7O0NDM0ZBO0NBQ0E7QUFDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBRUE7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ08sU0FBUyx5QkFBeUIsQ0FBQyxTQUFTLEVBQUUsMkJBQTJCLEdBQUcsRUFBRSxFQUFFO0NBQ3ZGO0NBQ0E7Q0FDQSxJQUFJLEtBQUssTUFBTSxTQUFTLElBQUksQ0FBQyxHQUFHLFNBQVMsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRTtDQUNoRSxRQUFRLElBQUksMkJBQTJCLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxLQUFLLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRTtDQUNsRixZQUFZLFNBQVMsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0NBQ3JELFNBQVM7Q0FDVCxLQUFLO0NBQ0wsSUFBSSxPQUFPLFNBQVMsQ0FBQztDQUNyQjs7Q0M3QkE7Q0FDQTtBQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FHQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNPLFVBQVUscUJBQXFCLENBQUMsR0FBRyxFQUFFLEVBQUUsMkJBQTJCLEdBQUcsQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLEVBQUUsY0FBYyxHQUFHLFlBQVksRUFBRSxTQUFTLEdBQUcsSUFBSSxFQUFFLGVBQWUsR0FBRyxHQUFHLEVBQUUsRUFBRTtDQUM3SyxJQUFJLE1BQU0sU0FBUyxHQUFHLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDbEQsSUFBSSxTQUFTLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztDQUN4QixJQUFJLE1BQU0sU0FBUyxDQUFDLElBQUksQ0FBQztDQUN6QixJQUFJLE1BQU0sdUJBQXVCLEdBQUcseUJBQXlCLENBQUMsU0FBUyxFQUFFLDJCQUEyQixDQUFDLENBQUM7Q0FDdEcsSUFBSSxNQUFNLHVCQUF1QixDQUFDLElBQUksQ0FBQztDQUN2QyxJQUFJLElBQUksY0FBYyxJQUFJLHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7Q0FDMUUsUUFBUSxNQUFNLFlBQVksR0FBRyxJQUFJLEdBQUcsQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNuRSxRQUFRLFlBQVksQ0FBQyxRQUFRLElBQUksY0FBYyxDQUFDO0NBQ2hELFFBQVEsTUFBTSxZQUFZLENBQUMsSUFBSSxDQUFDO0NBQ2hDLEtBQUs7Q0FDTCxJQUFJLElBQUksU0FBUyxFQUFFO0NBQ25CLFFBQVEsTUFBTSxRQUFRLEdBQUcsSUFBSSxHQUFHLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDL0QsUUFBUSxRQUFRLENBQUMsUUFBUSxJQUFJLE9BQU8sQ0FBQztDQUNyQyxRQUFRLE1BQU0sUUFBUSxDQUFDLElBQUksQ0FBQztDQUM1QixLQUFLO0NBQ0wsSUFBSSxJQUFJLGVBQWUsRUFBRTtDQUN6QixRQUFRLE1BQU0sY0FBYyxHQUFHLGVBQWUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDO0NBQ25FLFFBQVEsS0FBSyxNQUFNLFlBQVksSUFBSSxjQUFjLEVBQUU7Q0FDbkQsWUFBWSxNQUFNLFlBQVksQ0FBQyxJQUFJLENBQUM7Q0FDcEMsU0FBUztDQUNULEtBQUs7Q0FDTDs7Q0N6Q0E7Q0FDQTtBQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FNQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxNQUFNLGFBQWEsU0FBUyxLQUFLLENBQUM7Q0FDbEM7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLFdBQVcsQ0FBQyxrQkFBa0IsRUFBRSxPQUFPLEVBQUU7Q0FDN0MsUUFBUSxNQUFNLEtBQUssR0FBRyxDQUFDLEVBQUUsT0FBTyxFQUFFLEtBQUs7Q0FDdkMsWUFBWSxNQUFNLGVBQWUsR0FBRyxrQkFBa0IsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO0NBQzVFLFlBQVksS0FBSyxNQUFNLFdBQVcsSUFBSSxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxFQUFFO0NBQ25GLGdCQUFnQixNQUFNLFFBQVEsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0NBQ2xFLGdCQUFnQixJQUFJLFFBQVEsRUFBRTtDQUM5QixvQkFBb0IsT0FBTyxFQUFFLFFBQVEsRUFBRSxDQUFDO0NBQ3hDLGlCQUFpQjtDQUNqQixhQUFhO0NBQ2IsWUFBdUQ7Q0FDdkQsZ0JBQWdCLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxvQ0FBb0MsQ0FBQztDQUNuRSxvQkFBb0IsY0FBYyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0NBQ2pELGFBQWE7Q0FDYixZQUFZLE9BQU87Q0FDbkIsU0FBUyxDQUFDO0NBQ1YsUUFBUSxLQUFLLENBQUMsS0FBSyxFQUFFLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxDQUFDO0NBQ2xELEtBQUs7Q0FDTDs7Q0N2REE7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBS0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsU0FBUyxRQUFRLENBQUMsT0FBTyxFQUFFO0NBQzNCLElBQUksTUFBTSxrQkFBa0IsR0FBRyw2QkFBNkIsRUFBRSxDQUFDO0NBQy9ELElBQUksTUFBTSxhQUFhLEdBQUcsSUFBSSxhQUFhLENBQUMsa0JBQWtCLEVBQUUsT0FBTyxDQUFDLENBQUM7Q0FDekUsSUFBSSxhQUFhLENBQUMsYUFBYSxDQUFDLENBQUM7Q0FDakM7O0NDN0JBO0NBQ0E7QUFDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBR0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxTQUFTLFFBQVEsQ0FBQyxPQUFPLEVBQUU7Q0FDM0IsSUFBSSxNQUFNLGtCQUFrQixHQUFHLDZCQUE2QixFQUFFLENBQUM7Q0FDL0QsSUFBSSxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDekM7O0NDL0JBO0NBQ0E7QUFDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBSUE7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLFNBQVMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRTtDQUM1QyxJQUFJLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztDQUN0QixJQUFJLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztDQUN0Qjs7Q0MzQkE7Q0FDQTtBQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FJTyxNQUFNQyxVQUFRLEdBQUc7Q0FDeEIsSUFBSSxhQUFhLEVBQUUsQ0FBQyxZQUFZLEVBQUUsT0FBTyxLQUFLLENBQUMsTUFBTSxFQUFFLFlBQVksQ0FBQyxnQkFBZ0IsRUFBRSxjQUFjLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUNwSCxJQUFJLGtCQUFrQixFQUFFLENBQUMsUUFBUSxLQUFLO0NBQ3RDLFFBQVEsSUFBSSxRQUFRLEVBQUU7Q0FDdEIsWUFBWSxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsNkJBQTZCLENBQUMsQ0FBQyxDQUFDO0NBQ25FLFlBQVksTUFBTSxDQUFDLEdBQUcsQ0FBQyxRQUFRLElBQUksd0JBQXdCLENBQUMsQ0FBQztDQUM3RCxZQUFZLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztDQUM5QixTQUFTO0NBQ1QsS0FBSztDQUNMLENBQUM7O0NDbkJEO0NBQ0E7QUFDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBT0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLE1BQU0sVUFBVSxTQUFTLFFBQVEsQ0FBQztDQUNsQztDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksTUFBTSxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRTtDQUNwQyxRQUFRLE1BQU0sSUFBSSxHQUFHLEVBQUUsQ0FBQztDQUN4QixRQUFtRDtDQUNuRCxZQUFZRCxrQkFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFO0NBQ2hELGdCQUFnQixVQUFVLEVBQUUsb0JBQW9CO0NBQ2hELGdCQUFnQixTQUFTLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJO0NBQ2hELGdCQUFnQixRQUFRLEVBQUUsYUFBYTtDQUN2QyxnQkFBZ0IsU0FBUyxFQUFFLFNBQVM7Q0FDcEMsYUFBYSxDQUFDLENBQUM7Q0FDZixTQUFTO0NBQ1QsUUFBUSxJQUFJLFFBQVEsR0FBRyxNQUFNLE9BQU8sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDekQsUUFBUSxJQUFJLEtBQUssQ0FBQztDQUNsQixRQUFRLElBQUksQ0FBQyxRQUFRLEVBQUU7Q0FDdkIsWUFBdUQ7Q0FDdkQsZ0JBQWdCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQywwQkFBMEIsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQztDQUNoRixvQkFBb0IsQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDLENBQUM7Q0FDNUQsYUFBYTtDQUNiLFlBQVksSUFBSTtDQUNoQixnQkFBZ0IsUUFBUSxHQUFHLE1BQU0sT0FBTyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0NBQ25FLGFBQWE7Q0FDYixZQUFZLE9BQU8sR0FBRyxFQUFFO0NBQ3hCLGdCQUFnQixLQUFLLEdBQUcsR0FBRyxDQUFDO0NBQzVCLGFBQWE7Q0FDYixZQUF1RDtDQUN2RCxnQkFBZ0IsSUFBSSxRQUFRLEVBQUU7Q0FDOUIsb0JBQW9CLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQywwQkFBMEIsQ0FBQyxDQUFDLENBQUM7Q0FDNUQsaUJBQWlCO0NBQ2pCLHFCQUFxQjtDQUNyQixvQkFBb0IsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLDBDQUEwQyxDQUFDLENBQUMsQ0FBQztDQUM1RSxpQkFBaUI7Q0FDakIsYUFBYTtDQUNiLFNBQVM7Q0FDVCxhQUFhO0NBQ2IsWUFBdUQ7Q0FDdkQsZ0JBQWdCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxnQ0FBZ0MsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7Q0FDdkYsYUFBYTtDQUNiLFNBQVM7Q0FDVCxRQUFtRDtDQUNuRCxZQUFZLE1BQU0sQ0FBQyxjQUFjLENBQUNDLFVBQVEsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztDQUMxRixZQUFZLEtBQUssTUFBTSxHQUFHLElBQUksSUFBSSxFQUFFO0NBQ3BDLGdCQUFnQixNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQ2hDLGFBQWE7Q0FDYixZQUFZQSxVQUFRLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLENBQUM7Q0FDbEQsWUFBWSxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUM7Q0FDOUIsU0FBUztDQUNULFFBQVEsSUFBSSxDQUFDLFFBQVEsRUFBRTtDQUN2QixZQUFZLE1BQU0sSUFBSSxZQUFZLENBQUMsYUFBYSxFQUFFLEVBQUUsR0FBRyxFQUFFLE9BQU8sQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztDQUMvRSxTQUFTO0NBQ1QsUUFBUSxPQUFPLFFBQVEsQ0FBQztDQUN4QixLQUFLO0NBQ0w7O0NDckZBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUVBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDTyxTQUFTLFdBQVcsQ0FBQyxPQUFPLEVBQUU7Q0FDckM7Q0FDQSxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztDQUM1Qjs7Q0NmQTtDQUNBO0FBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUVBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ08sTUFBTSxTQUFTLENBQUM7Q0FDdkI7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxXQUFXLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxFQUFFLGVBQWUsRUFBRSxlQUFlLEdBQUcsR0FBRyxFQUFFLEVBQUU7Q0FDM0UsUUFBUSxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQztDQUN4QixRQUFRLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0NBQzFCLFFBQVEsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUM7Q0FDaEMsUUFBUSxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsZUFBZSxDQUFDO0NBQ2hELFFBQVEsSUFBSSxDQUFDLGdCQUFnQixHQUFHLGVBQWUsS0FBSyxNQUFNLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0NBQ3hFLEtBQUs7Q0FDTDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLElBQUksRUFBRSxHQUFHO0NBQ2IsUUFBUSxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUM7Q0FDeEIsS0FBSztDQUNMO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxNQUFNLElBQUksR0FBRztDQUNqQixRQUFRLElBQUksSUFBSSxDQUFDLEdBQUc7Q0FDcEIsWUFBWSxPQUFPO0NBQ25CLFFBQVEsSUFBSSxDQUFDLEdBQUcsR0FBRyxNQUFNLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLE1BQU0sS0FBSztDQUMxRDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsWUFBWSxJQUFJLG1CQUFtQixHQUFHLEtBQUssQ0FBQztDQUM1QyxZQUFZLFVBQVUsQ0FBQyxNQUFNO0NBQzdCLGdCQUFnQixtQkFBbUIsR0FBRyxJQUFJLENBQUM7Q0FDM0MsZ0JBQWdCLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDLENBQUM7Q0FDaEYsYUFBYSxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztDQUNsQyxZQUFZLE1BQU0sV0FBVyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7Q0FDMUUsWUFBWSxXQUFXLENBQUMsT0FBTyxHQUFHLE1BQU0sTUFBTSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztDQUNsRSxZQUFZLFdBQVcsQ0FBQyxlQUFlLEdBQUcsQ0FBQyxHQUFHLEtBQUs7Q0FDbkQsZ0JBQWdCLElBQUksbUJBQW1CLEVBQUU7Q0FDekMsb0JBQW9CLFdBQVcsQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLENBQUM7Q0FDcEQsb0JBQW9CLFdBQVcsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUM7Q0FDL0MsaUJBQWlCO0NBQ2pCLHFCQUFxQixJQUFJLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixLQUFLLFVBQVUsRUFBRTtDQUN0RSxvQkFBb0IsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQy9DLGlCQUFpQjtDQUNqQixhQUFhLENBQUM7Q0FDZCxZQUFZLFdBQVcsQ0FBQyxTQUFTLEdBQUcsTUFBTTtDQUMxQyxnQkFBZ0IsTUFBTSxFQUFFLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQztDQUM5QyxnQkFBZ0IsSUFBSSxtQkFBbUIsRUFBRTtDQUN6QyxvQkFBb0IsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDO0NBQy9CLGlCQUFpQjtDQUNqQixxQkFBcUI7Q0FDckIsb0JBQW9CLEVBQUUsQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUMxRSxvQkFBb0IsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0NBQ2hDLGlCQUFpQjtDQUNqQixhQUFhLENBQUM7Q0FDZCxTQUFTLENBQUMsQ0FBQztDQUNYLFFBQVEsT0FBTyxJQUFJLENBQUM7Q0FDcEIsS0FBSztDQUNMO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksTUFBTSxNQUFNLENBQUMsU0FBUyxFQUFFLEtBQUssRUFBRTtDQUNuQyxRQUFRLE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztDQUMvRCxLQUFLO0NBQ0w7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLE1BQU0sTUFBTSxDQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFO0NBQzFDLFFBQVEsT0FBTyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsU0FBUyxFQUFFLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7Q0FDdEUsS0FBSztDQUNMO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxNQUFNLFVBQVUsQ0FBQyxTQUFTLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtDQUM5QyxRQUFRLE1BQU0sT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLEVBQUUsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0NBQ2xHLFFBQVEsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxLQUFLLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztDQUNqRCxLQUFLO0NBQ0w7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksTUFBTSxjQUFjLENBQUMsU0FBUyxFQUFFLEVBQUUsS0FBSyxFQUFFLEtBQUssR0FBRyxJQUFJO0NBQ3pELElBQUksU0FBUyxHQUFHLE1BQU0sRUFBRSxLQUFLLEVBQUUsV0FBVyxHQUFHLEtBQUssR0FBRyxHQUFHLEVBQUUsRUFBRTtDQUM1RCxRQUFRLE9BQU8sTUFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUUsVUFBVSxFQUFFLENBQUMsR0FBRyxFQUFFLElBQUksS0FBSztDQUM5RSxZQUFZLE1BQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7Q0FDckQsWUFBWSxNQUFNLE1BQU0sR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUM7Q0FDOUQsWUFBWSxNQUFNLE9BQU8sR0FBRyxFQUFFLENBQUM7Q0FDL0IsWUFBWSxNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsQ0FBQztDQUNoRSxZQUFZLE9BQU8sQ0FBQyxTQUFTLEdBQUcsTUFBTTtDQUN0QyxnQkFBZ0IsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQztDQUM5QyxnQkFBZ0IsSUFBSSxNQUFNLEVBQUU7Q0FDNUIsb0JBQW9CLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxHQUFHLE1BQU0sR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7Q0FDdEUsb0JBQW9CLElBQUksS0FBSyxJQUFJLE9BQU8sQ0FBQyxNQUFNLElBQUksS0FBSyxFQUFFO0NBQzFELHdCQUF3QixJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDdEMscUJBQXFCO0NBQ3JCLHlCQUF5QjtDQUN6Qix3QkFBd0IsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO0NBQzFDLHFCQUFxQjtDQUNyQixpQkFBaUI7Q0FDakIscUJBQXFCO0NBQ3JCLG9CQUFvQixJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDbEMsaUJBQWlCO0NBQ2pCLGFBQWEsQ0FBQztDQUNkLFNBQVMsQ0FBQyxDQUFDO0NBQ1gsS0FBSztDQUNMO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLE1BQU0sV0FBVyxDQUFDLFVBQVUsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFO0NBQ2xELFFBQVEsTUFBTSxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7Q0FDMUIsUUFBUSxPQUFPLE1BQU0sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxLQUFLO0NBQ3RELFlBQVksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO0NBQy9ELFlBQVksR0FBRyxDQUFDLE9BQU8sR0FBRyxNQUFNLE1BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7Q0FDbEQsWUFBWSxHQUFHLENBQUMsVUFBVSxHQUFHLE1BQU0sT0FBTyxFQUFFLENBQUM7Q0FDN0MsWUFBWSxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsS0FBSyxLQUFLLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0NBQ3JELFNBQVMsQ0FBQyxDQUFDO0NBQ1gsS0FBSztDQUNMO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxNQUFNLEtBQUssQ0FBQyxNQUFNLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxHQUFHLElBQUksRUFBRTtDQUNsRCxRQUFRLE1BQU0sUUFBUSxHQUFHLENBQUMsR0FBRyxFQUFFLElBQUksS0FBSztDQUN4QyxZQUFZLE1BQU0sUUFBUSxHQUFHLEdBQUcsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7Q0FDeEQ7Q0FDQTtDQUNBLFlBQVksTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7Q0FDbkUsWUFBWSxPQUFPLENBQUMsU0FBUyxHQUFHLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztDQUMzRCxTQUFTLENBQUM7Q0FDVixRQUFRLE9BQU8sTUFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0NBQ25FLEtBQUs7Q0FDTDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksS0FBSyxHQUFHO0NBQ1osUUFBUSxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUU7Q0FDdEIsWUFBWSxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDO0NBQzdCLFlBQVksSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUM7Q0FDNUIsU0FBUztDQUNULEtBQUs7Q0FDTCxDQUFDO0NBQ0Q7Q0FDQTtDQUNBLFNBQVMsQ0FBQyxTQUFTLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztDQUN4QztDQUNBLE1BQU0sYUFBYSxHQUFHO0NBQ3RCLElBQUksUUFBUSxFQUFFLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFlBQVksQ0FBQztDQUNoRSxJQUFJLFNBQVMsRUFBRSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLFFBQVEsQ0FBQztDQUNoRCxDQUFDLENBQUM7Q0FDRixLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsRUFBRTtDQUM3RCxJQUFJLEtBQUssTUFBTSxNQUFNLElBQUksT0FBTyxFQUFFO0NBQ2xDLFFBQVEsSUFBSSxNQUFNLElBQUksY0FBYyxDQUFDLFNBQVMsRUFBRTtDQUNoRDtDQUNBLFlBQVksU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUM7Q0FDdkMsZ0JBQWdCLGdCQUFnQixTQUFTLEVBQUUsR0FBRyxJQUFJLEVBQUU7Q0FDcEQsb0JBQW9CLE9BQU8sTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUM7Q0FDOUUsaUJBQWlCLENBQUM7Q0FDbEIsU0FBUztDQUNULEtBQUs7Q0FDTDs7Q0MxUEE7Q0FDQTtBQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FFQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDTyxNQUFNLGNBQWMsR0FBRyxPQUFPLElBQUksS0FBSztDQUM5QyxJQUFJLE1BQU0sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxLQUFLO0NBQzNDLFFBQVEsTUFBTSxPQUFPLEdBQUcsU0FBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUN2RCxRQUFRLE9BQU8sQ0FBQyxPQUFPLEdBQUcsTUFBTTtDQUNoQyxZQUFZLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7Q0FDbEMsU0FBUyxDQUFDO0NBQ1YsUUFBUSxPQUFPLENBQUMsU0FBUyxHQUFHLE1BQU07Q0FDbEMsWUFBWSxNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO0NBQ2hELFNBQVMsQ0FBQztDQUNWLFFBQVEsT0FBTyxDQUFDLFNBQVMsR0FBRyxNQUFNO0NBQ2xDLFlBQVksT0FBTyxFQUFFLENBQUM7Q0FDdEIsU0FBUyxDQUFDO0NBQ1YsS0FBSyxDQUFDLENBQUM7Q0FDUCxDQUFDOztDQzdCRDtDQUNBLElBQUk7Q0FDSixJQUFJLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO0NBQzVDLENBQUM7Q0FDRCxPQUFPLENBQUMsRUFBRTs7Q0NMVjtDQUNBO0FBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUlBLE1BQU0sT0FBTyxHQUFHLG9CQUFvQixDQUFDO0NBQ3JDLE1BQU0saUJBQWlCLEdBQUcsZUFBZSxDQUFDO0NBQzFDLE1BQU0sWUFBWSxHQUFHLENBQUMsZUFBZSxLQUFLO0NBQzFDLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsZUFBZSxFQUFFLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUN4RCxJQUFJLEdBQUcsQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0NBQ2xCLElBQUksT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDO0NBQ3BCLENBQUMsQ0FBQztDQUNGO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxNQUFNLG9CQUFvQixDQUFDO0NBQzNCO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksV0FBVyxDQUFDLFNBQVMsRUFBRTtDQUMzQixRQUFRLElBQUksQ0FBQyxVQUFVLEdBQUcsU0FBUyxDQUFDO0NBQ3BDLFFBQVEsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLFNBQVMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxFQUFFO0NBQzdDLFlBQVksZUFBZSxFQUFFLENBQUMsS0FBSyxLQUFLLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDO0NBQ2xFLFNBQVMsQ0FBQyxDQUFDO0NBQ1gsS0FBSztDQUNMO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxjQUFjLENBQUMsS0FBSyxFQUFFO0NBQzFCLFFBQVEsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUM7Q0FDdkM7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxRQUFRLE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxpQkFBaUIsRUFBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0NBQ3BGO0NBQ0E7Q0FDQTtDQUNBLFFBQVEsUUFBUSxDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7Q0FDMUUsUUFBUSxRQUFRLENBQUMsV0FBVyxDQUFDLFdBQVcsRUFBRSxXQUFXLEVBQUUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztDQUMxRTtDQUNBO0NBQ0EsUUFBUSxjQUFjLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0NBQ3hDLEtBQUs7Q0FDTDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLE1BQU0sWUFBWSxDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUU7Q0FDdkMsUUFBUSxHQUFHLEdBQUcsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQ2hDLFFBQVEsTUFBTSxLQUFLLEdBQUc7Q0FDdEIsWUFBWSxHQUFHO0NBQ2YsWUFBWSxTQUFTO0NBQ3JCLFlBQVksU0FBUyxFQUFFLElBQUksQ0FBQyxVQUFVO0NBQ3RDO0NBQ0E7Q0FDQTtDQUNBLFlBQVksRUFBRSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDO0NBQ2hDLFNBQVMsQ0FBQztDQUNWLFFBQVEsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsRUFBRSxLQUFLLENBQUMsQ0FBQztDQUNyRCxLQUFLO0NBQ0w7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksTUFBTSxZQUFZLENBQUMsR0FBRyxFQUFFO0NBQzVCLFFBQVEsTUFBTSxLQUFLLEdBQUcsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7Q0FDOUUsUUFBUSxPQUFPLEtBQUssQ0FBQyxTQUFTLENBQUM7Q0FDL0IsS0FBSztDQUNMO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLE1BQU0sYUFBYSxDQUFDLFlBQVksRUFBRSxRQUFRLEVBQUU7Q0FDaEQsUUFBUSxNQUFNLGVBQWUsR0FBRyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLGlCQUFpQixFQUFFLFdBQVcsRUFBRSxDQUFDLEdBQUcsRUFBRSxJQUFJLEtBQUs7Q0FDMUcsWUFBWSxNQUFNLEtBQUssR0FBRyxHQUFHLENBQUMsV0FBVyxDQUFDLGlCQUFpQixDQUFDLENBQUM7Q0FDN0QsWUFBWSxNQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7Q0FDOUUsWUFBWSxNQUFNLGVBQWUsR0FBRyxFQUFFLENBQUM7Q0FDdkMsWUFBWSxJQUFJLHNCQUFzQixHQUFHLENBQUMsQ0FBQztDQUMzQyxZQUFZLE9BQU8sQ0FBQyxTQUFTLEdBQUcsTUFBTTtDQUN0QyxnQkFBZ0IsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQztDQUM5QyxnQkFBZ0IsSUFBSSxNQUFNLEVBQUU7Q0FDNUIsb0JBQW9CLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUM7Q0FDaEQ7Q0FDQTtDQUNBLG9CQUFvQixJQUFJLE1BQU0sQ0FBQyxTQUFTLEtBQUssSUFBSSxDQUFDLFVBQVUsRUFBRTtDQUM5RDtDQUNBO0NBQ0Esd0JBQXdCLElBQUksQ0FBQyxZQUFZLElBQUksTUFBTSxDQUFDLFNBQVMsR0FBRyxZQUFZO0NBQzVFLDZCQUE2QixRQUFRLElBQUksc0JBQXNCLElBQUksUUFBUSxDQUFDLEVBQUU7Q0FDOUU7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLDRCQUE0QixlQUFlLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztDQUMvRCx5QkFBeUI7Q0FDekIsNkJBQTZCO0NBQzdCLDRCQUE0QixzQkFBc0IsRUFBRSxDQUFDO0NBQ3JELHlCQUF5QjtDQUN6QixxQkFBcUI7Q0FDckIsb0JBQW9CLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztDQUN0QyxpQkFBaUI7Q0FDakIscUJBQXFCO0NBQ3JCLG9CQUFvQixJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7Q0FDMUMsaUJBQWlCO0NBQ2pCLGFBQWEsQ0FBQztDQUNkLFNBQVMsQ0FBQyxDQUFDO0NBQ1g7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxRQUFRLE1BQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQztDQUMvQixRQUFRLEtBQUssTUFBTSxLQUFLLElBQUksZUFBZSxFQUFFO0NBQzdDLFlBQVksTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7Q0FDL0QsWUFBWSxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztDQUN4QyxTQUFTO0NBQ1QsUUFBUSxPQUFPLFdBQVcsQ0FBQztDQUMzQixLQUFLO0NBQ0w7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksTUFBTSxDQUFDLEdBQUcsRUFBRTtDQUNoQjtDQUNBO0NBQ0E7Q0FDQSxRQUFRLE9BQU8sSUFBSSxDQUFDLFVBQVUsR0FBRyxHQUFHLEdBQUcsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQ3pELEtBQUs7Q0FDTDs7Q0NuS0E7Q0FDQTtBQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FPQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLE1BQU0sZUFBZSxDQUFDO0NBQ3RCO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxXQUFXLENBQUMsU0FBUyxFQUFFLE1BQU0sR0FBRyxFQUFFLEVBQUU7Q0FDeEMsUUFBUSxJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztDQUNoQyxRQUFRLElBQUksQ0FBQyxlQUFlLEdBQUcsS0FBSyxDQUFDO0NBQ3JDLFFBQW1EO0NBQ25ELFlBQVlELGtCQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxRQUFRLEVBQUU7Q0FDL0MsZ0JBQWdCLFVBQVUsRUFBRSxvQkFBb0I7Q0FDaEQsZ0JBQWdCLFNBQVMsRUFBRSxpQkFBaUI7Q0FDNUMsZ0JBQWdCLFFBQVEsRUFBRSxhQUFhO0NBQ3ZDLGdCQUFnQixTQUFTLEVBQUUsV0FBVztDQUN0QyxhQUFhLENBQUMsQ0FBQztDQUNmLFlBQVksSUFBSSxFQUFFLE1BQU0sQ0FBQyxVQUFVLElBQUksTUFBTSxDQUFDLGFBQWEsQ0FBQyxFQUFFO0NBQzlELGdCQUFnQixNQUFNLElBQUksWUFBWSxDQUFDLDZCQUE2QixFQUFFO0NBQ3RFLG9CQUFvQixVQUFVLEVBQUUsb0JBQW9CO0NBQ3BELG9CQUFvQixTQUFTLEVBQUUsaUJBQWlCO0NBQ2hELG9CQUFvQixRQUFRLEVBQUUsYUFBYTtDQUMzQyxpQkFBaUIsQ0FBQyxDQUFDO0NBQ25CLGFBQWE7Q0FDYixZQUFZLElBQUksTUFBTSxDQUFDLFVBQVUsRUFBRTtDQUNuQyxnQkFBZ0JBLGtCQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsUUFBUSxFQUFFO0NBQzNELG9CQUFvQixVQUFVLEVBQUUsb0JBQW9CO0NBQ3BELG9CQUFvQixTQUFTLEVBQUUsaUJBQWlCO0NBQ2hELG9CQUFvQixRQUFRLEVBQUUsYUFBYTtDQUMzQyxvQkFBb0IsU0FBUyxFQUFFLG1CQUFtQjtDQUNsRCxpQkFBaUIsQ0FBQyxDQUFDO0NBQ25CLGFBQWE7Q0FDYixZQUFZLElBQUksTUFBTSxDQUFDLGFBQWEsRUFBRTtDQUN0QyxnQkFBZ0JBLGtCQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLEVBQUUsUUFBUSxFQUFFO0NBQzlELG9CQUFvQixVQUFVLEVBQUUsb0JBQW9CO0NBQ3BELG9CQUFvQixTQUFTLEVBQUUsaUJBQWlCO0NBQ2hELG9CQUFvQixRQUFRLEVBQUUsYUFBYTtDQUMzQyxvQkFBb0IsU0FBUyxFQUFFLHNCQUFzQjtDQUNyRCxpQkFBaUIsQ0FBQyxDQUFDO0NBQ25CLGFBQWE7Q0FDYixTQUFTO0NBQ1QsUUFBUSxJQUFJLENBQUMsV0FBVyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUM7Q0FDN0MsUUFBUSxJQUFJLENBQUMsY0FBYyxHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUM7Q0FDbkQsUUFBUSxJQUFJLENBQUMsYUFBYSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUM7Q0FDakQsUUFBUSxJQUFJLENBQUMsVUFBVSxHQUFHLFNBQVMsQ0FBQztDQUNwQyxRQUFRLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztDQUNuRSxLQUFLO0NBQ0w7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxNQUFNLGFBQWEsR0FBRztDQUMxQixRQUFRLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtDQUM3QixZQUFZLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDO0NBQ3hDLFlBQVksT0FBTztDQUNuQixTQUFTO0NBQ1QsUUFBUSxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztDQUMvQixRQUFRLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxjQUFjO0NBQ2hELFlBQVksSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQzFELFFBQVEsTUFBTSxXQUFXLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLGFBQWEsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0NBQ3JHO0NBQ0EsUUFBUSxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztDQUM5RCxRQUFRLEtBQUssTUFBTSxHQUFHLElBQUksV0FBVyxFQUFFO0NBQ3ZDLFlBQVksTUFBTSxLQUFLLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7Q0FDeEQsU0FBUztDQUNULFFBQW1EO0NBQ25ELFlBQVksSUFBSSxXQUFXLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtDQUN4QyxnQkFBZ0IsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztDQUN0RSxvQkFBb0IsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxHQUFHLE9BQU8sR0FBRyxTQUFTLENBQUMsYUFBYSxDQUFDO0NBQ3BGLG9CQUFvQixDQUFDLEVBQUUsV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLEdBQUcsSUFBSSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUM7Q0FDM0Usb0JBQW9CLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztDQUNuRCxnQkFBZ0IsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLHNCQUFzQixFQUFFLFdBQVcsQ0FBQyxNQUFNLEtBQUssQ0FBQztBQUM1RSxvQkFBb0IsS0FBSyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQ3ZDLGdCQUFnQixXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxLQUFLLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDdkUsZ0JBQWdCLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztDQUNsQyxhQUFhO0NBQ2IsaUJBQWlCO0NBQ2pCLGdCQUFnQixNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsb0RBQW9ELENBQUMsQ0FBQyxDQUFDO0NBQ3JGLGFBQWE7Q0FDYixTQUFTO0NBQ1QsUUFBUSxJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztDQUNoQyxRQUFRLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRTtDQUNsQyxZQUFZLElBQUksQ0FBQyxlQUFlLEdBQUcsS0FBSyxDQUFDO0NBQ3pDLFlBQVksV0FBVyxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO0NBQzlDLFNBQVM7Q0FDVCxLQUFLO0NBQ0w7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLE1BQU0sZUFBZSxDQUFDLEdBQUcsRUFBRTtDQUMvQixRQUFtRDtDQUNuRCxZQUFZQSxrQkFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsUUFBUSxFQUFFO0NBQ3pDLGdCQUFnQixVQUFVLEVBQUUsb0JBQW9CO0NBQ2hELGdCQUFnQixTQUFTLEVBQUUsaUJBQWlCO0NBQzVDLGdCQUFnQixRQUFRLEVBQUUsaUJBQWlCO0NBQzNDLGdCQUFnQixTQUFTLEVBQUUsS0FBSztDQUNoQyxhQUFhLENBQUMsQ0FBQztDQUNmLFNBQVM7Q0FDVCxRQUFRLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0NBQ2pFLEtBQUs7Q0FDTDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxNQUFNLFlBQVksQ0FBQyxHQUFHLEVBQUU7Q0FDNUIsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRTtDQUNsQyxZQUF1RDtDQUN2RCxnQkFBZ0IsTUFBTSxJQUFJLFlBQVksQ0FBQyxDQUFDLDRCQUE0QixDQUFDLEVBQUU7Q0FDdkUsb0JBQW9CLFVBQVUsRUFBRSxjQUFjO0NBQzlDLG9CQUFvQixTQUFTLEVBQUUsZUFBZTtDQUM5QyxpQkFBaUIsQ0FBQyxDQUFDO0NBQ25CLGFBQWE7Q0FFYixTQUFTO0NBQ1QsYUFBYTtDQUNiLFlBQVksTUFBTSxTQUFTLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQztDQUMzRSxZQUFZLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxDQUFDO0NBQzlFLFlBQVksUUFBUSxTQUFTLEdBQUcsZUFBZSxFQUFFO0NBQ2pELFNBQVM7Q0FDVCxLQUFLO0NBQ0w7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxJQUFJLE1BQU0sTUFBTSxHQUFHO0NBQ25CO0NBQ0E7Q0FDQSxRQUFRLElBQUksQ0FBQyxlQUFlLEdBQUcsS0FBSyxDQUFDO0NBQ3JDLFFBQVEsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztDQUMzRCxLQUFLO0NBQ0w7O0NDdktBO0NBQ0E7QUFDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBS0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxTQUFTLDBCQUEwQixDQUFDLFFBQVEsRUFBRTtDQUM5QyxJQUErQztDQUMvQyxRQUFRQSxrQkFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsVUFBVSxFQUFFO0NBQzVDLFlBQVksVUFBVSxFQUFFLGNBQWM7Q0FDdEMsWUFBWSxRQUFRLEVBQUUsVUFBVTtDQUNoQyxZQUFZLFNBQVMsRUFBRSxVQUFVO0NBQ2pDLFNBQVMsQ0FBQyxDQUFDO0NBQ1gsS0FBSztDQUNMLElBQUksbUJBQW1CLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0NBQ3RDLElBQStDO0NBQy9DLFFBQVEsTUFBTSxDQUFDLEdBQUcsQ0FBQyxtREFBbUQsRUFBRSxRQUFRLENBQUMsQ0FBQztDQUNsRixLQUFLO0NBQ0w7O0NDOUJBO0NBQ0E7QUFDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBVUE7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLE1BQU0sZ0JBQWdCLENBQUM7Q0FDdkI7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksV0FBVyxDQUFDLE1BQU0sR0FBRyxFQUFFLEVBQUU7Q0FDN0I7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLFFBQVEsSUFBSSxDQUFDLHdCQUF3QixHQUFHLE9BQU8sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxjQUFjLEVBQUUsS0FBSztDQUNqRyxZQUFZLElBQUksQ0FBQyxjQUFjLEVBQUU7Q0FDakMsZ0JBQWdCLE9BQU8sSUFBSSxDQUFDO0NBQzVCLGFBQWE7Q0FDYixZQUFZLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztDQUN0RTtDQUNBO0NBQ0EsWUFBWSxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsU0FBUyxDQUFDLENBQUM7Q0FDeEUsWUFBWSxXQUFXLENBQUMsZUFBZSxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUM7Q0FDekQ7Q0FDQTtDQUNBLFlBQVksTUFBTSxtQkFBbUIsR0FBRyxlQUFlLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztDQUNyRixZQUFZLElBQUksS0FBSyxFQUFFO0NBQ3ZCLGdCQUFnQixJQUFJO0NBQ3BCLG9CQUFvQixLQUFLLENBQUMsU0FBUyxDQUFDLG1CQUFtQixDQUFDLENBQUM7Q0FDekQsaUJBQWlCO0NBQ2pCLGdCQUFnQixPQUFPLEtBQUssRUFBRTtDQUM5QixvQkFBK0Q7Q0FDL0Q7Q0FDQSx3QkFBd0IsSUFBSSxTQUFTLElBQUksS0FBSyxFQUFFO0NBQ2hELDRCQUE0QixNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsaURBQWlELENBQUM7Q0FDM0YsZ0NBQWdDLENBQUMseUJBQXlCLENBQUM7Q0FDM0QsZ0NBQWdDLENBQUMsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Q0FDM0UseUJBQXlCO0NBQ3pCLHFCQUFxQjtDQUNyQixpQkFBaUI7Q0FDakIsYUFBYTtDQUNiLFlBQVksT0FBTyxPQUFPLEdBQUcsY0FBYyxHQUFHLElBQUksQ0FBQztDQUNuRCxTQUFTLENBQUM7Q0FDVjtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLFFBQVEsSUFBSSxDQUFDLGNBQWMsR0FBRyxPQUFPLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxLQUFLO0NBQ2hFLFlBQXVEO0NBQ3ZELGdCQUFnQkEsa0JBQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLFFBQVEsRUFBRTtDQUNuRCxvQkFBb0IsVUFBVSxFQUFFLG9CQUFvQjtDQUNwRCxvQkFBb0IsU0FBUyxFQUFFLFFBQVE7Q0FDdkMsb0JBQW9CLFFBQVEsRUFBRSxnQkFBZ0I7Q0FDOUMsb0JBQW9CLFNBQVMsRUFBRSxXQUFXO0NBQzFDLGlCQUFpQixDQUFDLENBQUM7Q0FDbkIsZ0JBQWdCQSxrQkFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFO0NBQ3BELG9CQUFvQixVQUFVLEVBQUUsb0JBQW9CO0NBQ3BELG9CQUFvQixTQUFTLEVBQUUsUUFBUTtDQUN2QyxvQkFBb0IsUUFBUSxFQUFFLGdCQUFnQjtDQUM5QyxvQkFBb0IsU0FBUyxFQUFFLFNBQVM7Q0FDeEMsaUJBQWlCLENBQUMsQ0FBQztDQUNuQixhQUFhO0NBQ2IsWUFBWSxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsU0FBUyxDQUFDLENBQUM7Q0FDeEUsWUFBWSxNQUFNLGVBQWUsQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQy9ELFlBQVksTUFBTSxlQUFlLENBQUMsYUFBYSxFQUFFLENBQUM7Q0FDbEQsU0FBUyxDQUFDO0NBQ1YsUUFBbUQ7Q0FDbkQsWUFBWSxJQUFJLEVBQUUsTUFBTSxDQUFDLFVBQVUsSUFBSSxNQUFNLENBQUMsYUFBYSxDQUFDLEVBQUU7Q0FDOUQsZ0JBQWdCLE1BQU0sSUFBSSxZQUFZLENBQUMsNkJBQTZCLEVBQUU7Q0FDdEUsb0JBQW9CLFVBQVUsRUFBRSxvQkFBb0I7Q0FDcEQsb0JBQW9CLFNBQVMsRUFBRSxRQUFRO0NBQ3ZDLG9CQUFvQixRQUFRLEVBQUUsYUFBYTtDQUMzQyxpQkFBaUIsQ0FBQyxDQUFDO0NBQ25CLGFBQWE7Q0FDYixZQUFZLElBQUksTUFBTSxDQUFDLFVBQVUsRUFBRTtDQUNuQyxnQkFBZ0JBLGtCQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsUUFBUSxFQUFFO0NBQzNELG9CQUFvQixVQUFVLEVBQUUsb0JBQW9CO0NBQ3BELG9CQUFvQixTQUFTLEVBQUUsUUFBUTtDQUN2QyxvQkFBb0IsUUFBUSxFQUFFLGFBQWE7Q0FDM0Msb0JBQW9CLFNBQVMsRUFBRSxtQkFBbUI7Q0FDbEQsaUJBQWlCLENBQUMsQ0FBQztDQUNuQixhQUFhO0NBQ2IsWUFBWSxJQUFJLE1BQU0sQ0FBQyxhQUFhLEVBQUU7Q0FDdEMsZ0JBQWdCQSxrQkFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFFLFFBQVEsRUFBRTtDQUM5RCxvQkFBb0IsVUFBVSxFQUFFLG9CQUFvQjtDQUNwRCxvQkFBb0IsU0FBUyxFQUFFLFFBQVE7Q0FDdkMsb0JBQW9CLFFBQVEsRUFBRSxhQUFhO0NBQzNDLG9CQUFvQixTQUFTLEVBQUUsc0JBQXNCO0NBQ3JELGlCQUFpQixDQUFDLENBQUM7Q0FDbkIsYUFBYTtDQUNiLFNBQVM7Q0FDVCxRQUFRLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO0NBQzlCLFFBQVEsSUFBSSxDQUFDLGNBQWMsR0FBRyxNQUFNLENBQUMsYUFBYSxDQUFDO0NBQ25ELFFBQVEsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7Q0FDM0MsUUFBUSxJQUFJLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRTtDQUN0QyxZQUFZLDBCQUEwQixDQUFDLE1BQU0sSUFBSSxDQUFDLHNCQUFzQixFQUFFLENBQUMsQ0FBQztDQUM1RSxTQUFTO0NBQ1QsS0FBSztDQUNMO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksbUJBQW1CLENBQUMsU0FBUyxFQUFFO0NBQ25DLFFBQVEsSUFBSSxTQUFTLEtBQUssVUFBVSxDQUFDLGNBQWMsRUFBRSxFQUFFO0NBQ3ZELFlBQVksTUFBTSxJQUFJLFlBQVksQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO0NBQ2hFLFNBQVM7Q0FDVCxRQUFRLElBQUksZUFBZSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7Q0FDcEUsUUFBUSxJQUFJLENBQUMsZUFBZSxFQUFFO0NBQzlCLFlBQVksZUFBZSxHQUFHLElBQUksZUFBZSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDM0UsWUFBWSxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxlQUFlLENBQUMsQ0FBQztDQUNuRSxTQUFTO0NBQ1QsUUFBUSxPQUFPLGVBQWUsQ0FBQztDQUMvQixLQUFLO0NBQ0w7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsSUFBSSxvQkFBb0IsQ0FBQyxjQUFjLEVBQUU7Q0FDekMsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRTtDQUNsQztDQUNBLFlBQVksT0FBTyxJQUFJLENBQUM7Q0FDeEIsU0FBUztDQUNUO0NBQ0E7Q0FDQTtDQUNBLFFBQVEsTUFBTSxtQkFBbUIsR0FBRyxJQUFJLENBQUMsdUJBQXVCLENBQUMsY0FBYyxDQUFDLENBQUM7Q0FDakYsUUFBUSxJQUFJLG1CQUFtQixLQUFLLElBQUksRUFBRTtDQUMxQztDQUNBLFlBQVksT0FBTyxJQUFJLENBQUM7Q0FDeEIsU0FBUztDQUNUO0NBQ0E7Q0FDQSxRQUFRLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztDQUMvQixRQUFRLE9BQU8sbUJBQW1CLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLENBQUM7Q0FDekUsS0FBSztDQUNMO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksdUJBQXVCLENBQUMsY0FBYyxFQUFFO0NBQzVDLFFBQVEsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFO0NBQ2pELFlBQVksT0FBTyxJQUFJLENBQUM7Q0FDeEIsU0FBUztDQUNULFFBQVEsTUFBTSxVQUFVLEdBQUcsY0FBYyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7Q0FDOUQsUUFBUSxNQUFNLFVBQVUsR0FBRyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztDQUNoRCxRQUFRLE1BQU0sVUFBVSxHQUFHLFVBQVUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztDQUNoRDtDQUNBO0NBQ0EsUUFBUSxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUMsRUFBRTtDQUMvQixZQUFZLE9BQU8sSUFBSSxDQUFDO0NBQ3hCLFNBQVM7Q0FDVCxRQUFRLE9BQU8sVUFBVSxDQUFDO0NBQzFCLEtBQUs7Q0FDTDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLElBQUksTUFBTSxzQkFBc0IsR0FBRztDQUNuQztDQUNBO0NBQ0EsUUFBUSxLQUFLLE1BQU0sQ0FBQyxTQUFTLEVBQUUsZUFBZSxDQUFDLElBQUksSUFBSSxDQUFDLGlCQUFpQixFQUFFO0NBQzNFLFlBQVksTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztDQUNoRCxZQUFZLE1BQU0sZUFBZSxDQUFDLE1BQU0sRUFBRSxDQUFDO0NBQzNDLFNBQVM7Q0FDVDtDQUNBLFFBQVEsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7Q0FDM0MsS0FBSztDQUNMOztDQy9PQSxJQUFJLENBQUMscUJBQXFCLEdBQUcsSUFBSSxDQUFDO0FBQ2xDO0NBQ0EsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7Q0FDeEIsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDeEI7Q0FDQSxhQUFhO0NBQ2I7Q0FDQSxFQUFFLElBQUksTUFBTSxDQUFDLDhDQUE4QyxDQUFDO0NBQzVELEVBQUUsSUFBSSxVQUFVLENBQUM7Q0FDakIsSUFBSSxTQUFTLEVBQUUsQ0FBQyxhQUFhLEVBQUUsU0FBUyxDQUFDLENBQUM7Q0FDMUMsSUFBSSxPQUFPLEVBQUU7Q0FDYixNQUFNLElBQUksZ0JBQWdCLENBQUM7Q0FDM0IsUUFBUSxVQUFVLEVBQUUsRUFBRTtDQUN0QixRQUFRLGFBQWEsRUFBRSxJQUFJLEdBQUcsRUFBRTtDQUNoQyxPQUFPLENBQUM7Q0FDUixLQUFLO0NBQ0wsR0FBRyxDQUFDO0NBQ0osQ0FBQzs7Ozs7OyJ9
