(function () {
	'use strict';

	// This file is generated by Sapper â€” do not edit it!
	const timestamp = 1608182847585;

	const files = [
		"/service-worker-index.html",
		"/resources/android-chrome-192x192.png",
		"/resources/android-chrome-512x512.png",
		"/resources/apple-touch-icon.png",
		"/resources/browserconfig.xml",
		"/resources/favicon-16x16.png",
		"/resources/favicon-32x32.png",
		"/resources/favicon.ico",
		"/resources/favicon.png",
		"/resources/global.css",
		"/resources/location.svg",
		"/resources/logo-192.png",
		"/resources/logo-512.png",
		"/resources/manifest.webmanifest",
		"/resources/mstile-144x144.png",
		"/resources/mstile-150x150.png",
		"/resources/mstile-310x150.png",
		"/resources/mstile-310x310.png",
		"/resources/mstile-70x70.png",
		"/resources/safari-pinned-tab.svg"
	];

	const shell = [
		"/client/client.f049a04a.js",
		"/client/inject_styles.5607aec6.js",
		"/client/index.b3414786.js",
		"/client/Geocoder.87d3a6e3.js",
		"/client/partners.a2c337c0.js",
		"/client/about.04427203.js",
		"/client/index.220629c5.js",
		"/client/[id].d8da9e97.js",
		"/client/_commonjsHelpers.91583ccb.js",
		"/client/sapper-dev-client.1e7a4a5e.js",
		"/client/autoComplete.min.86378da8.js"
	];

	// @ts-ignore
	try {
	    self['workbox:core:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const messages = {
	    'invalid-value': ({ paramName, validValueDescription, value }) => {
	        if (!paramName || !validValueDescription) {
	            throw new Error(`Unexpected input to 'invalid-value' error.`);
	        }
	        return `The '${paramName}' parameter was given a value with an ` +
	            `unexpected value. ${validValueDescription} Received a value of ` +
	            `${JSON.stringify(value)}.`;
	    },
	    'not-an-array': ({ moduleName, className, funcName, paramName }) => {
	        if (!moduleName || !className || !funcName || !paramName) {
	            throw new Error(`Unexpected input to 'not-an-array' error.`);
	        }
	        return `The parameter '${paramName}' passed into ` +
	            `'${moduleName}.${className}.${funcName}()' must be an array.`;
	    },
	    'incorrect-type': ({ expectedType, paramName, moduleName, className, funcName }) => {
	        if (!expectedType || !paramName || !moduleName || !funcName) {
	            throw new Error(`Unexpected input to 'incorrect-type' error.`);
	        }
	        return `The parameter '${paramName}' passed into ` +
	            `'${moduleName}.${className ? (className + '.') : ''}` +
	            `${funcName}()' must be of type ${expectedType}.`;
	    },
	    'incorrect-class': ({ expectedClass, paramName, moduleName, className, funcName, isReturnValueProblem }) => {
	        if (!expectedClass || !moduleName || !funcName) {
	            throw new Error(`Unexpected input to 'incorrect-class' error.`);
	        }
	        if (isReturnValueProblem) {
	            return `The return value from ` +
	                `'${moduleName}.${className ? (className + '.') : ''}${funcName}()' ` +
	                `must be an instance of class ${expectedClass.name}.`;
	        }
	        return `The parameter '${paramName}' passed into ` +
	            `'${moduleName}.${className ? (className + '.') : ''}${funcName}()' ` +
	            `must be an instance of class ${expectedClass.name}.`;
	    },
	    'missing-a-method': ({ expectedMethod, paramName, moduleName, className, funcName }) => {
	        if (!expectedMethod || !paramName || !moduleName || !className
	            || !funcName) {
	            throw new Error(`Unexpected input to 'missing-a-method' error.`);
	        }
	        return `${moduleName}.${className}.${funcName}() expected the ` +
	            `'${paramName}' parameter to expose a '${expectedMethod}' method.`;
	    },
	    'add-to-cache-list-unexpected-type': ({ entry }) => {
	        return `An unexpected entry was passed to ` +
	            `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` +
	            `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` +
	            `strings with one or more characters, objects with a url property or ` +
	            `Request objects.`;
	    },
	    'add-to-cache-list-conflicting-entries': ({ firstEntry, secondEntry }) => {
	        if (!firstEntry || !secondEntry) {
	            throw new Error(`Unexpected input to ` +
	                `'add-to-cache-list-duplicate-entries' error.`);
	        }
	        return `Two of the entries passed to ` +
	            `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` +
	            `${firstEntry._entryId} but different revision details. Workbox is ` +
	            `unable to cache and version the asset correctly. Please remove one ` +
	            `of the entries.`;
	    },
	    'plugin-error-request-will-fetch': ({ thrownError }) => {
	        if (!thrownError) {
	            throw new Error(`Unexpected input to ` +
	                `'plugin-error-request-will-fetch', error.`);
	        }
	        return `An error was thrown by a plugins 'requestWillFetch()' method. ` +
	            `The thrown error message was: '${thrownError.message}'.`;
	    },
	    'invalid-cache-name': ({ cacheNameId, value }) => {
	        if (!cacheNameId) {
	            throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);
	        }
	        return `You must provide a name containing at least one character for ` +
	            `setCacheDetails({${cacheNameId}: '...'}). Received a value of ` +
	            `'${JSON.stringify(value)}'`;
	    },
	    'unregister-route-but-not-found-with-method': ({ method }) => {
	        if (!method) {
	            throw new Error(`Unexpected input to ` +
	                `'unregister-route-but-not-found-with-method' error.`);
	        }
	        return `The route you're trying to unregister was not  previously ` +
	            `registered for the method type '${method}'.`;
	    },
	    'unregister-route-route-not-registered': () => {
	        return `The route you're trying to unregister was not previously ` +
	            `registered.`;
	    },
	    'queue-replay-failed': ({ name }) => {
	        return `Replaying the background sync queue '${name}' failed.`;
	    },
	    'duplicate-queue-name': ({ name }) => {
	        return `The Queue name '${name}' is already being used. ` +
	            `All instances of backgroundSync.Queue must be given unique names.`;
	    },
	    'expired-test-without-max-age': ({ methodName, paramName }) => {
	        return `The '${methodName}()' method can only be used when the ` +
	            `'${paramName}' is used in the constructor.`;
	    },
	    'unsupported-route-type': ({ moduleName, className, funcName, paramName }) => {
	        return `The supplied '${paramName}' parameter was an unsupported type. ` +
	            `Please check the docs for ${moduleName}.${className}.${funcName} for ` +
	            `valid input types.`;
	    },
	    'not-array-of-class': ({ value, expectedClass, moduleName, className, funcName, paramName }) => {
	        return `The supplied '${paramName}' parameter must be an array of ` +
	            `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` +
	            `Please check the call to ${moduleName}.${className}.${funcName}() ` +
	            `to fix the issue.`;
	    },
	    'max-entries-or-age-required': ({ moduleName, className, funcName }) => {
	        return `You must define either config.maxEntries or config.maxAgeSeconds` +
	            `in ${moduleName}.${className}.${funcName}`;
	    },
	    'statuses-or-headers-required': ({ moduleName, className, funcName }) => {
	        return `You must define either config.statuses or config.headers` +
	            `in ${moduleName}.${className}.${funcName}`;
	    },
	    'invalid-string': ({ moduleName, funcName, paramName }) => {
	        if (!paramName || !moduleName || !funcName) {
	            throw new Error(`Unexpected input to 'invalid-string' error.`);
	        }
	        return `When using strings, the '${paramName}' parameter must start with ` +
	            `'http' (for cross-origin matches) or '/' (for same-origin matches). ` +
	            `Please see the docs for ${moduleName}.${funcName}() for ` +
	            `more info.`;
	    },
	    'channel-name-required': () => {
	        return `You must provide a channelName to construct a ` +
	            `BroadcastCacheUpdate instance.`;
	    },
	    'invalid-responses-are-same-args': () => {
	        return `The arguments passed into responsesAreSame() appear to be ` +
	            `invalid. Please ensure valid Responses are used.`;
	    },
	    'expire-custom-caches-only': () => {
	        return `You must provide a 'cacheName' property when using the ` +
	            `expiration plugin with a runtime caching strategy.`;
	    },
	    'unit-must-be-bytes': ({ normalizedRangeHeader }) => {
	        if (!normalizedRangeHeader) {
	            throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);
	        }
	        return `The 'unit' portion of the Range header must be set to 'bytes'. ` +
	            `The Range header provided was "${normalizedRangeHeader}"`;
	    },
	    'single-range-only': ({ normalizedRangeHeader }) => {
	        if (!normalizedRangeHeader) {
	            throw new Error(`Unexpected input to 'single-range-only' error.`);
	        }
	        return `Multiple ranges are not supported. Please use a  single start ` +
	            `value, and optional end value. The Range header provided was ` +
	            `"${normalizedRangeHeader}"`;
	    },
	    'invalid-range-values': ({ normalizedRangeHeader }) => {
	        if (!normalizedRangeHeader) {
	            throw new Error(`Unexpected input to 'invalid-range-values' error.`);
	        }
	        return `The Range header is missing both start and end values. At least ` +
	            `one of those values is needed. The Range header provided was ` +
	            `"${normalizedRangeHeader}"`;
	    },
	    'no-range-header': () => {
	        return `No Range header was found in the Request provided.`;
	    },
	    'range-not-satisfiable': ({ size, start, end }) => {
	        return `The start (${start}) and end (${end}) values in the Range are ` +
	            `not satisfiable by the cached response, which is ${size} bytes.`;
	    },
	    'attempt-to-cache-non-get-request': ({ url, method }) => {
	        return `Unable to cache '${url}' because it is a '${method}' request and ` +
	            `only 'GET' requests can be cached.`;
	    },
	    'cache-put-with-no-response': ({ url }) => {
	        return `There was an attempt to cache '${url}' but the response was not ` +
	            `defined.`;
	    },
	    'no-response': ({ url, error }) => {
	        let message = `The strategy could not generate a response for '${url}'.`;
	        if (error) {
	            message += ` The underlying error is ${error}.`;
	        }
	        return message;
	    },
	    'bad-precaching-response': ({ url, status }) => {
	        return `The precaching request for '${url}' failed` +
	            (status ? ` with an HTTP status of ${status}.` : `.`);
	    },
	    'non-precached-url': ({ url }) => {
	        return `createHandlerBoundToURL('${url}') was called, but that URL is ` +
	            `not precached. Please pass in a URL that is precached instead.`;
	    },
	    'add-to-cache-list-conflicting-integrities': ({ url }) => {
	        return `Two of the entries passed to ` +
	            `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` +
	            `${url} with different integrity values. Please remove one of them.`;
	    },
	    'missing-precache-entry': ({ cacheName, url }) => {
	        return `Unable to find a precached response in ${cacheName} for ${url}.`;
	    },
	    'cross-origin-copy-response': ({ origin }) => {
	        return `workbox-core.copyResponse() can only be used with same-origin ` +
	            `responses. It was passed a response with origin ${origin}.`;
	    },
	};

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const generatorFunction = (code, details = {}) => {
	    const message = messages[code];
	    if (!message) {
	        throw new Error(`Unable to find message for code '${code}'.`);
	    }
	    return message(details);
	};
	const messageGenerator =  generatorFunction;

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Workbox errors should be thrown with this class.
	 * This allows use to ensure the type easily in tests,
	 * helps developers identify errors from workbox
	 * easily and allows use to optimise error
	 * messages correctly.
	 *
	 * @private
	 */
	class WorkboxError extends Error {
	    /**
	     *
	     * @param {string} errorCode The error code that
	     * identifies this particular error.
	     * @param {Object=} details Any relevant arguments
	     * that will help developers identify issues should
	     * be added as a key on the context object.
	     */
	    constructor(errorCode, details) {
	        const message = messageGenerator(errorCode, details);
	        super(message);
	        this.name = errorCode;
	        this.details = details;
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/*
	 * This method throws if the supplied value is not an array.
	 * The destructed values are required to produce a meaningful error for users.
	 * The destructed and restructured object is so it's clear what is
	 * needed.
	 */
	const isArray = (value, details) => {
	    if (!Array.isArray(value)) {
	        throw new WorkboxError('not-an-array', details);
	    }
	};
	const hasMethod = (object, expectedMethod, details) => {
	    const type = typeof object[expectedMethod];
	    if (type !== 'function') {
	        details['expectedMethod'] = expectedMethod;
	        throw new WorkboxError('missing-a-method', details);
	    }
	};
	const isType = (object, expectedType, details) => {
	    if (typeof object !== expectedType) {
	        details['expectedType'] = expectedType;
	        throw new WorkboxError('incorrect-type', details);
	    }
	};
	const isInstance = (object, expectedClass, details) => {
	    if (!(object instanceof expectedClass)) {
	        details['expectedClass'] = expectedClass;
	        throw new WorkboxError('incorrect-class', details);
	    }
	};
	const isOneOf = (value, validValues, details) => {
	    if (!validValues.includes(value)) {
	        details['validValueDescription'] =
	            `Valid values are ${JSON.stringify(validValues)}.`;
	        throw new WorkboxError('invalid-value', details);
	    }
	};
	const isArrayOfClass = (value, expectedClass, details) => {
	    const error = new WorkboxError('not-array-of-class', details);
	    if (!Array.isArray(value)) {
	        throw error;
	    }
	    for (const item of value) {
	        if (!(item instanceof expectedClass)) {
	            throw error;
	        }
	    }
	};
	const finalAssertExports =  {
	    hasMethod,
	    isArray,
	    isInstance,
	    isOneOf,
	    isType,
	    isArrayOfClass,
	};

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const _cacheNameDetails = {
	    googleAnalytics: 'googleAnalytics',
	    precache: 'precache-v2',
	    prefix: 'workbox',
	    runtime: 'runtime',
	    suffix: typeof registration !== 'undefined' ? registration.scope : '',
	};
	const _createCacheName = (cacheName) => {
	    return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix]
	        .filter((value) => value && value.length > 0)
	        .join('-');
	};
	const eachCacheNameDetail = (fn) => {
	    for (const key of Object.keys(_cacheNameDetails)) {
	        fn(key);
	    }
	};
	const cacheNames = {
	    updateDetails: (details) => {
	        eachCacheNameDetail((key) => {
	            if (typeof details[key] === 'string') {
	                _cacheNameDetails[key] = details[key];
	            }
	        });
	    },
	    getGoogleAnalyticsName: (userCacheName) => {
	        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);
	    },
	    getPrecacheName: (userCacheName) => {
	        return userCacheName || _createCacheName(_cacheNameDetails.precache);
	    },
	    getPrefix: () => {
	        return _cacheNameDetails.prefix;
	    },
	    getRuntimeName: (userCacheName) => {
	        return userCacheName || _createCacheName(_cacheNameDetails.runtime);
	    },
	    getSuffix: () => {
	        return _cacheNameDetails.suffix;
	    },
	};

	/*
	  Copyright 2019 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const logger = ( (() => {
	    // Don't overwrite this value if it's already set.
	    // See https://github.com/GoogleChrome/workbox/pull/2284#issuecomment-560470923
	    if (!('__WB_DISABLE_DEV_LOGS' in self)) {
	        self.__WB_DISABLE_DEV_LOGS = false;
	    }
	    let inGroup = false;
	    const methodToColorMap = {
	        debug: `#7f8c8d`,
	        log: `#2ecc71`,
	        warn: `#f39c12`,
	        error: `#c0392b`,
	        groupCollapsed: `#3498db`,
	        groupEnd: null,
	    };
	    const print = function (method, args) {
	        if (self.__WB_DISABLE_DEV_LOGS) {
	            return;
	        }
	        if (method === 'groupCollapsed') {
	            // Safari doesn't print all console.groupCollapsed() arguments:
	            // https://bugs.webkit.org/show_bug.cgi?id=182754
	            if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
	                console[method](...args);
	                return;
	            }
	        }
	        const styles = [
	            `background: ${methodToColorMap[method]}`,
	            `border-radius: 0.5em`,
	            `color: white`,
	            `font-weight: bold`,
	            `padding: 2px 0.5em`,
	        ];
	        // When in a group, the workbox prefix is not displayed.
	        const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];
	        console[method](...logPrefix, ...args);
	        if (method === 'groupCollapsed') {
	            inGroup = true;
	        }
	        if (method === 'groupEnd') {
	            inGroup = false;
	        }
	    };
	    const api = {};
	    const loggerMethods = Object.keys(methodToColorMap);
	    for (const key of loggerMethods) {
	        const method = key;
	        api[method] = (...args) => {
	            print(method, args);
	        };
	    }
	    return api;
	})());

	/*
	  Copyright 2020 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A utility method that makes it easier to use `event.waitUntil` with
	 * async functions and return the result.
	 *
	 * @param {ExtendableEvent} event
	 * @param {Function} asyncFn
	 * @return {Function}
	 * @private
	 */
	function waitUntil(event, asyncFn) {
	    const returnPromise = asyncFn();
	    event.waitUntil(returnPromise);
	    return returnPromise;
	}

	// @ts-ignore
	try {
	    self['workbox:precaching:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	// Name of the search parameter used to store revision info.
	const REVISION_SEARCH_PARAM = '__WB_REVISION__';
	/**
	 * Converts a manifest entry into a versioned URL suitable for precaching.
	 *
	 * @param {Object|string} entry
	 * @return {string} A URL with versioning info.
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function createCacheKey(entry) {
	    if (!entry) {
	        throw new WorkboxError('add-to-cache-list-unexpected-type', { entry });
	    }
	    // If a precache manifest entry is a string, it's assumed to be a versioned
	    // URL, like '/app.abcd1234.js'. Return as-is.
	    if (typeof entry === 'string') {
	        const urlObject = new URL(entry, location.href);
	        return {
	            cacheKey: urlObject.href,
	            url: urlObject.href,
	        };
	    }
	    const { revision, url } = entry;
	    if (!url) {
	        throw new WorkboxError('add-to-cache-list-unexpected-type', { entry });
	    }
	    // If there's just a URL and no revision, then it's also assumed to be a
	    // versioned URL.
	    if (!revision) {
	        const urlObject = new URL(url, location.href);
	        return {
	            cacheKey: urlObject.href,
	            url: urlObject.href,
	        };
	    }
	    // Otherwise, construct a properly versioned URL using the custom Workbox
	    // search parameter along with the revision info.
	    const cacheKeyURL = new URL(url, location.href);
	    const originalURL = new URL(url, location.href);
	    cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);
	    return {
	        cacheKey: cacheKeyURL.href,
	        url: originalURL.href,
	    };
	}

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A plugin, designed to be used with PrecacheController, to determine the
	 * of assets that were updated (or not updated) during the install event.
	 *
	 * @private
	 */
	class PrecacheInstallReportPlugin {
	    constructor() {
	        this.updatedURLs = [];
	        this.notUpdatedURLs = [];
	        this.handlerWillStart = async ({ request, state, }) => {
	            // TODO: `state` should never be undefined...
	            if (state) {
	                state.originalRequest = request;
	            }
	        };
	        this.cachedResponseWillBeUsed = async ({ event, state, cachedResponse, }) => {
	            if (event.type === 'install') {
	                // TODO: `state` should never be undefined...
	                const url = state.originalRequest.url;
	                if (cachedResponse) {
	                    this.notUpdatedURLs.push(url);
	                }
	                else {
	                    this.updatedURLs.push(url);
	                }
	            }
	            return cachedResponse;
	        };
	    }
	}

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A plugin, designed to be used with PrecacheController, to translate URLs into
	 * the corresponding cache key, based on the current revision info.
	 *
	 * @private
	 */
	class PrecacheCacheKeyPlugin {
	    constructor({ precacheController }) {
	        this.cacheKeyWillBeUsed = async ({ request, params, }) => {
	            const cacheKey = params && params.cacheKey ||
	                this._precacheController.getCacheKeyForURL(request.url);
	            return cacheKey ? new Request(cacheKey) : request;
	        };
	        this._precacheController = precacheController;
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * @param {string} groupTitle
	 * @param {Array<string>} deletedURLs
	 *
	 * @private
	 */
	const logGroup = (groupTitle, deletedURLs) => {
	    logger.groupCollapsed(groupTitle);
	    for (const url of deletedURLs) {
	        logger.log(url);
	    }
	    logger.groupEnd();
	};
	/**
	 * @param {Array<string>} deletedURLs
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function printCleanupDetails(deletedURLs) {
	    const deletionCount = deletedURLs.length;
	    if (deletionCount > 0) {
	        logger.groupCollapsed(`During precaching cleanup, ` +
	            `${deletionCount} cached ` +
	            `request${deletionCount === 1 ? ' was' : 's were'} deleted.`);
	        logGroup('Deleted Cache Requests', deletedURLs);
	        logger.groupEnd();
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * @param {string} groupTitle
	 * @param {Array<string>} urls
	 *
	 * @private
	 */
	function _nestedGroup(groupTitle, urls) {
	    if (urls.length === 0) {
	        return;
	    }
	    logger.groupCollapsed(groupTitle);
	    for (const url of urls) {
	        logger.log(url);
	    }
	    logger.groupEnd();
	}
	/**
	 * @param {Array<string>} urlsToPrecache
	 * @param {Array<string>} urlsAlreadyPrecached
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function printInstallDetails(urlsToPrecache, urlsAlreadyPrecached) {
	    const precachedCount = urlsToPrecache.length;
	    const alreadyPrecachedCount = urlsAlreadyPrecached.length;
	    if (precachedCount || alreadyPrecachedCount) {
	        let message = `Precaching ${precachedCount} file${precachedCount === 1 ? '' : 's'}.`;
	        if (alreadyPrecachedCount > 0) {
	            message += ` ${alreadyPrecachedCount} ` +
	                `file${alreadyPrecachedCount === 1 ? ' is' : 's are'} already cached.`;
	        }
	        logger.groupCollapsed(message);
	        _nestedGroup(`View newly precached URLs.`, urlsToPrecache);
	        _nestedGroup(`View previously precached URLs.`, urlsAlreadyPrecached);
	        logger.groupEnd();
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	let supportStatus;
	/**
	 * A utility function that determines whether the current browser supports
	 * constructing a new `Response` from a `response.body` stream.
	 *
	 * @return {boolean} `true`, if the current browser can successfully
	 *     construct a `Response` from a `response.body` stream, `false` otherwise.
	 *
	 * @private
	 */
	function canConstructResponseFromBodyStream() {
	    if (supportStatus === undefined) {
	        const testResponse = new Response('');
	        if ('body' in testResponse) {
	            try {
	                new Response(testResponse.body);
	                supportStatus = true;
	            }
	            catch (error) {
	                supportStatus = false;
	            }
	        }
	        supportStatus = false;
	    }
	    return supportStatus;
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Allows developers to copy a response and modify its `headers`, `status`,
	 * or `statusText` values (the values settable via a
	 * [`ResponseInit`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#Syntax}
	 * object in the constructor).
	 * To modify these values, pass a function as the second argument. That
	 * function will be invoked with a single object with the response properties
	 * `{headers, status, statusText}`. The return value of this function will
	 * be used as the `ResponseInit` for the new `Response`. To change the values
	 * either modify the passed parameter(s) and return it, or return a totally
	 * new object.
	 *
	 * This method is intentionally limited to same-origin responses, regardless of
	 * whether CORS was used or not.
	 *
	 * @param {Response} response
	 * @param {Function} modifier
	 * @memberof module:workbox-core
	 */
	async function copyResponse(response, modifier) {
	    let origin = null;
	    // If response.url isn't set, assume it's cross-origin and keep origin null.
	    if (response.url) {
	        const responseURL = new URL(response.url);
	        origin = responseURL.origin;
	    }
	    if (origin !== self.location.origin) {
	        throw new WorkboxError('cross-origin-copy-response', { origin });
	    }
	    const clonedResponse = response.clone();
	    // Create a fresh `ResponseInit` object by cloning the headers.
	    const responseInit = {
	        headers: new Headers(clonedResponse.headers),
	        status: clonedResponse.status,
	        statusText: clonedResponse.statusText,
	    };
	    // Apply any user modifications.
	    const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;
	    // Create the new response from the body stream and `ResponseInit`
	    // modifications. Note: not all browsers support the Response.body stream,
	    // so fall back to reading the entire body into memory as a blob.
	    const body = canConstructResponseFromBodyStream() ?
	        clonedResponse.body : await clonedResponse.blob();
	    return new Response(body, modifiedResponseInit);
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const getFriendlyURL = (url) => {
	    const urlObj = new URL(String(url), location.href);
	    // See https://github.com/GoogleChrome/workbox/issues/2323
	    // We want to include everything, except for the origin if it's same-origin.
	    return urlObj.href.replace(new RegExp(`^${location.origin}`), '');
	};

	/*
	  Copyright 2020 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	function stripParams(fullURL, ignoreParams) {
	    const strippedURL = new URL(fullURL);
	    for (const param of ignoreParams) {
	        strippedURL.searchParams.delete(param);
	    }
	    return strippedURL.href;
	}
	/**
	 * Matches an item in the cache, ignoring specific URL params. This is similar
	 * to the `ignoreSearch` option, but it allows you to ignore just specific
	 * params (while continuing to match on the others).
	 *
	 * @private
	 * @param {Cache} cache
	 * @param {Request} request
	 * @param {Object} matchOptions
	 * @param {Array<string>} ignoreParams
	 * @return {Promise<Response|undefined>}
	 */
	async function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {
	    const strippedRequestURL = stripParams(request.url, ignoreParams);
	    // If the request doesn't include any ignored params, match as normal.
	    if (request.url === strippedRequestURL) {
	        return cache.match(request, matchOptions);
	    }
	    // Otherwise, match by comparing keys
	    const keysOptions = { ...matchOptions, ignoreSearch: true };
	    const cacheKeys = await cache.keys(request, keysOptions);
	    for (const cacheKey of cacheKeys) {
	        const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);
	        if (strippedRequestURL === strippedCacheKeyURL) {
	            return cache.match(cacheKey, matchOptions);
	        }
	    }
	    return;
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * The Deferred class composes Promises in a way that allows for them to be
	 * resolved or rejected from outside the constructor. In most cases promises
	 * should be used directly, but Deferreds can be necessary when the logic to
	 * resolve a promise must be separate.
	 *
	 * @private
	 */
	class Deferred {
	    /**
	     * Creates a promise and exposes its resolve and reject functions as methods.
	     */
	    constructor() {
	        this.promise = new Promise((resolve, reject) => {
	            this.resolve = resolve;
	            this.reject = reject;
	        });
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	// Callbacks to be executed whenever there's a quota error.
	const quotaErrorCallbacks = new Set();

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Runs all of the callback functions, one at a time sequentially, in the order
	 * in which they were registered.
	 *
	 * @memberof module:workbox-core
	 * @private
	 */
	async function executeQuotaErrorCallbacks() {
	    {
	        logger.log(`About to run ${quotaErrorCallbacks.size} ` +
	            `callbacks to clean up caches.`);
	    }
	    for (const callback of quotaErrorCallbacks) {
	        await callback();
	        {
	            logger.log(callback, 'is complete.');
	        }
	    }
	    {
	        logger.log('Finished running callbacks.');
	    }
	}

	/*
	  Copyright 2019 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Returns a promise that resolves and the passed number of milliseconds.
	 * This utility is an async/await-friendly version of `setTimeout`.
	 *
	 * @param {number} ms
	 * @return {Promise}
	 * @private
	 */
	function timeout(ms) {
	    return new Promise((resolve) => setTimeout(resolve, ms));
	}

	// @ts-ignore
	try {
	    self['workbox:strategies:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	function toRequest(input) {
	    return (typeof input === 'string') ? new Request(input) : input;
	}
	/**
	 * A class created every time a Strategy instance instance calls
	 * [handle()]{@link module:workbox-strategies.Strategy~handle} or
	 * [handleAll()]{@link module:workbox-strategies.Strategy~handleAll} that wraps all fetch and
	 * cache actions around plugin callbacks and keeps track of when the strategy
	 * is "done" (i.e. all added `event.waitUntil()` promises have resolved).
	 *
	 * @memberof module:workbox-strategies
	 */
	class StrategyHandler {
	    /**
	     * Creates a new instance associated with the passed strategy and event
	     * that's handling the request.
	     *
	     * The constructor also initializes the state that will be passed to each of
	     * the plugins handling this request.
	     *
	     * @param {module:workbox-strategies.Strategy} strategy
	     * @param {Object} options
	     * @param {Request|string} options.request A request to run this strategy for.
	     * @param {ExtendableEvent} options.event The event associated with the
	     *     request.
	     * @param {URL} [options.url]
	     * @param {*} [options.params]
	     *     [match callback]{@link module:workbox-routing~matchCallback},
	     *     (if applicable).
	     */
	    constructor(strategy, options) {
	        this._cacheKeys = {};
	        /**
	         * The request the strategy is performing (passed to the strategy's
	         * `handle()` or `handleAll()` method).
	         * @name request
	         * @instance
	         * @type {Request}
	         * @memberof module:workbox-strategies.StrategyHandler
	         */
	        /**
	         * The event associated with this request.
	         * @name event
	         * @instance
	         * @type {ExtendableEvent}
	         * @memberof module:workbox-strategies.StrategyHandler
	         */
	        /**
	         * A `URL` instance of `request.url` (if passed to the strategy's
	         * `handle()` or `handleAll()` method).
	         * Note: the `url` param will be present if the strategy was invoked
	         * from a workbox `Route` object.
	         * @name url
	         * @instance
	         * @type {URL|undefined}
	         * @memberof module:workbox-strategies.StrategyHandler
	         */
	        /**
	         * A `param` value (if passed to the strategy's
	         * `handle()` or `handleAll()` method).
	         * Note: the `param` param will be present if the strategy was invoked
	         * from a workbox `Route` object and the
	         * [match callback]{@link module:workbox-routing~matchCallback} returned
	         * a truthy value (it will be that value).
	         * @name params
	         * @instance
	         * @type {*|undefined}
	         * @memberof module:workbox-strategies.StrategyHandler
	         */
	        {
	            finalAssertExports.isInstance(options.event, ExtendableEvent, {
	                moduleName: 'workbox-strategies',
	                className: 'StrategyHandler',
	                funcName: 'constructor',
	                paramName: 'options.event',
	            });
	        }
	        Object.assign(this, options);
	        this.event = options.event;
	        this._strategy = strategy;
	        this._handlerDeferred = new Deferred();
	        this._extendLifetimePromises = [];
	        // Copy the plugins list (since it's mutable on the strategy),
	        // so any mutations don't affect this handler instance.
	        this._plugins = [...strategy.plugins];
	        this._pluginStateMap = new Map();
	        for (const plugin of this._plugins) {
	            this._pluginStateMap.set(plugin, {});
	        }
	        this.event.waitUntil(this._handlerDeferred.promise);
	    }
	    /**
	     * Fetches a given request (and invokes any applicable plugin callback
	     * methods) using the `fetchOptions` and `plugins` defined on the strategy
	     * object.
	     *
	     * The following plugin lifecycle methods are invoked when using this method:
	     * - `requestWillFetch()`
	     * - `fetchDidSucceed()`
	     * - `fetchDidFail()`
	     *
	     * @param {Request|string} input The URL or request to fetch.
	     * @return {Promise<Response>}
	     */
	    fetch(input) {
	        return this.waitUntil((async () => {
	            const { event } = this;
	            let request = toRequest(input);
	            if (request.mode === 'navigate' &&
	                event instanceof FetchEvent &&
	                event.preloadResponse) {
	                const possiblePreloadResponse = await event.preloadResponse;
	                if (possiblePreloadResponse) {
	                    {
	                        logger.log(`Using a preloaded navigation response for ` +
	                            `'${getFriendlyURL(request.url)}'`);
	                    }
	                    return possiblePreloadResponse;
	                }
	            }
	            // If there is a fetchDidFail plugin, we need to save a clone of the
	            // original request before it's either modified by a requestWillFetch
	            // plugin or before the original request's body is consumed via fetch().
	            const originalRequest = this.hasCallback('fetchDidFail') ?
	                request.clone() : null;
	            try {
	                for (const cb of this.iterateCallbacks('requestWillFetch')) {
	                    request = await cb({ request: request.clone(), event });
	                }
	            }
	            catch (err) {
	                throw new WorkboxError('plugin-error-request-will-fetch', {
	                    thrownError: err,
	                });
	            }
	            // The request can be altered by plugins with `requestWillFetch` making
	            // the original request (most likely from a `fetch` event) different
	            // from the Request we make. Pass both to `fetchDidFail` to aid debugging.
	            const pluginFilteredRequest = request.clone();
	            try {
	                let fetchResponse;
	                // See https://github.com/GoogleChrome/workbox/issues/1796
	                fetchResponse = await fetch(request, request.mode === 'navigate' ?
	                    undefined : this._strategy.fetchOptions);
	                if ("development" !== 'production') {
	                    logger.debug(`Network request for ` +
	                        `'${getFriendlyURL(request.url)}' returned a response with ` +
	                        `status '${fetchResponse.status}'.`);
	                }
	                for (const callback of this.iterateCallbacks('fetchDidSucceed')) {
	                    fetchResponse = await callback({
	                        event,
	                        request: pluginFilteredRequest,
	                        response: fetchResponse,
	                    });
	                }
	                return fetchResponse;
	            }
	            catch (error) {
	                {
	                    logger.error(`Network request for ` +
	                        `'${getFriendlyURL(request.url)}' threw an error.`, error);
	                }
	                // `originalRequest` will only exist if a `fetchDidFail` callback
	                // is being used (see above).
	                if (originalRequest) {
	                    await this.runCallbacks('fetchDidFail', {
	                        error,
	                        event,
	                        originalRequest: originalRequest.clone(),
	                        request: pluginFilteredRequest.clone(),
	                    });
	                }
	                throw error;
	            }
	        })());
	    }
	    /**
	     * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on
	     * the response generated by `this.fetch()`.
	     *
	     * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,
	     * so you do not have to manually call `waitUntil()` on the event.
	     *
	     * @param {Request|string} input The request or URL to fetch and cache.
	     * @return {Promise<Response>}
	     */
	    async fetchAndCachePut(input) {
	        const response = await this.fetch(input);
	        const responseClone = response.clone();
	        this.waitUntil(this.cachePut(input, responseClone));
	        return response;
	    }
	    /**
	     * Matches a request from the cache (and invokes any applicable plugin
	     * callback methods) using the `cacheName`, `matchOptions`, and `plugins`
	     * defined on the strategy object.
	     *
	     * The following plugin lifecycle methods are invoked when using this method:
	     * - cacheKeyWillByUsed()
	     * - cachedResponseWillByUsed()
	     *
	     * @param {Request|string} key The Request or URL to use as the cache key.
	     * @return {Promise<Response|undefined>} A matching response, if found.
	     */
	    cacheMatch(key) {
	        return this.waitUntil((async () => {
	            const request = toRequest(key);
	            let cachedResponse;
	            const { cacheName, matchOptions } = this._strategy;
	            const effectiveRequest = await this.getCacheKey(request, 'read');
	            const multiMatchOptions = { ...matchOptions, ...{ cacheName } };
	            cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);
	            {
	                if (cachedResponse) {
	                    logger.debug(`Found a cached response in '${cacheName}'.`);
	                }
	                else {
	                    logger.debug(`No cached response found in '${cacheName}'.`);
	                }
	            }
	            for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {
	                cachedResponse = (await callback({
	                    cacheName,
	                    matchOptions,
	                    cachedResponse,
	                    request: effectiveRequest,
	                    event: this.event,
	                })) || undefined;
	            }
	            return cachedResponse;
	        })());
	    }
	    /**
	     * Puts a request/response pair in the cache (and invokes any applicable
	     * plugin callback methods) using the `cacheName` and `plugins` defined on
	     * the strategy object.
	     *
	     * The following plugin lifecycle methods are invoked when using this method:
	     * - cacheKeyWillByUsed()
	     * - cacheWillUpdate()
	     * - cacheDidUpdate()
	     *
	     * @param {Request|string} key The request or URL to use as the cache key.
	     * @param {Promise<void>} response The response to cache.
	     */
	    async cachePut(key, response) {
	        const request = toRequest(key);
	        // Run in the next task to avoid blocking other cache reads.
	        // https://github.com/w3c/ServiceWorker/issues/1397
	        await timeout(0);
	        const effectiveRequest = await this.getCacheKey(request, 'write');
	        {
	            if (effectiveRequest.method && effectiveRequest.method !== 'GET') {
	                throw new WorkboxError('attempt-to-cache-non-get-request', {
	                    url: getFriendlyURL(effectiveRequest.url),
	                    method: effectiveRequest.method,
	                });
	            }
	        }
	        if (!response) {
	            {
	                logger.error(`Cannot cache non-existent response for ` +
	                    `'${getFriendlyURL(effectiveRequest.url)}'.`);
	            }
	            throw new WorkboxError('cache-put-with-no-response', {
	                url: getFriendlyURL(effectiveRequest.url),
	            });
	        }
	        const responseToCache = await this._ensureResponseSafeToCache(response);
	        if (!responseToCache) {
	            {
	                logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` +
	                    `will not be cached.`, responseToCache);
	            }
	            return;
	        }
	        const { cacheName, matchOptions } = this._strategy;
	        const cache = await self.caches.open(cacheName);
	        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');
	        const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams(
	        // TODO(philipwalton): the `__WB_REVISION__` param is a precaching
	        // feature. Consider into ways to only add this behavior if using
	        // precaching.
	        cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions) :
	            null;
	        {
	            logger.debug(`Updating the '${cacheName}' cache with a new Response ` +
	                `for ${getFriendlyURL(effectiveRequest.url)}.`);
	        }
	        try {
	            await cache.put(effectiveRequest, hasCacheUpdateCallback ?
	                responseToCache.clone() : responseToCache);
	        }
	        catch (error) {
	            // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError
	            if (error.name === 'QuotaExceededError') {
	                await executeQuotaErrorCallbacks();
	            }
	            throw error;
	        }
	        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {
	            await callback({
	                cacheName,
	                oldResponse,
	                newResponse: responseToCache.clone(),
	                request: effectiveRequest,
	                event: this.event,
	            });
	        }
	    }
	    /**
	     * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and
	     * executes any of those callbacks found in sequence. The final `Request`
	     * object returned by the last plugin is treated as the cache key for cache
	     * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have
	     * been registered, the passed request is returned unmodified
	     *
	     * @param {Request} request
	     * @param {string} mode
	     * @return {Promise<Request>}
	     */
	    async getCacheKey(request, mode) {
	        if (!this._cacheKeys[mode]) {
	            let effectiveRequest = request;
	            for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {
	                effectiveRequest = toRequest(await callback({
	                    mode,
	                    request: effectiveRequest,
	                    event: this.event,
	                    params: this.params,
	                }));
	            }
	            this._cacheKeys[mode] = effectiveRequest;
	        }
	        return this._cacheKeys[mode];
	    }
	    /**
	     * Returns true if the strategy has at least one plugin with the given
	     * callback.
	     *
	     * @param {string} name The name of the callback to check for.
	     * @return {boolean}
	     */
	    hasCallback(name) {
	        for (const plugin of this._strategy.plugins) {
	            if (name in plugin) {
	                return true;
	            }
	        }
	        return false;
	    }
	    /**
	     * Runs all plugin callbacks matching the given name, in order, passing the
	     * given param object (merged ith the current plugin state) as the only
	     * argument.
	     *
	     * Note: since this method runs all plugins, it's not suitable for cases
	     * where the return value of a callback needs to be applied prior to calling
	     * the next callback. See
	     * [`iterateCallbacks()`]{@link module:workbox-strategies.StrategyHandler#iterateCallbacks}
	     * below for how to handle that case.
	     *
	     * @param {string} name The name of the callback to run within each plugin.
	     * @param {Object} param The object to pass as the first (and only) param
	     *     when executing each callback. This object will be merged with the
	     *     current plugin state prior to callback execution.
	     */
	    async runCallbacks(name, param) {
	        for (const callback of this.iterateCallbacks(name)) {
	            // TODO(philipwalton): not sure why `any` is needed. It seems like
	            // this should work with `as WorkboxPluginCallbackParam[C]`.
	            await callback(param);
	        }
	    }
	    /**
	     * Accepts a callback and returns an iterable of matching plugin callbacks,
	     * where each callback is wrapped with the current handler state (i.e. when
	     * you call each callback, whatever object parameter you pass it will
	     * be merged with the plugin's current state).
	     *
	     * @param {string} name The name fo the callback to run
	     * @return {Array<Function>}
	     */
	    *iterateCallbacks(name) {
	        for (const plugin of this._strategy.plugins) {
	            if (typeof plugin[name] === 'function') {
	                const state = this._pluginStateMap.get(plugin);
	                const statefulCallback = (param) => {
	                    const statefulParam = { ...param, state };
	                    // TODO(philipwalton): not sure why `any` is needed. It seems like
	                    // this should work with `as WorkboxPluginCallbackParam[C]`.
	                    return plugin[name](statefulParam);
	                };
	                yield statefulCallback;
	            }
	        }
	    }
	    /**
	     * Adds a promise to the
	     * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}
	     * of the event event associated with the request being handled (usually a
	     * `FetchEvent`).
	     *
	     * Note: you can await
	     * [`doneWaiting()`]{@link module:workbox-strategies.StrategyHandler~doneWaiting}
	     * to know when all added promises have settled.
	     *
	     * @param {Promise} promise A promise to add to the extend lifetime promises
	     *     of the event that triggered the request.
	     */
	    waitUntil(promise) {
	        this._extendLifetimePromises.push(promise);
	        return promise;
	    }
	    /**
	     * Returns a promise that resolves once all promises passed to
	     * [`waitUntil()`]{@link module:workbox-strategies.StrategyHandler~waitUntil}
	     * have settled.
	     *
	     * Note: any work done after `doneWaiting()` settles should be manually
	     * passed to an event's `waitUntil()` method (not this handler's
	     * `waitUntil()` method), otherwise the service worker thread my be killed
	     * prior to your work completing.
	     */
	    async doneWaiting() {
	        let promise;
	        while (promise = this._extendLifetimePromises.shift()) {
	            await promise;
	        }
	    }
	    /**
	     * Stops running the strategy and immediately resolves any pending
	     * `waitUntil()` promises.
	     */
	    destroy() {
	        this._handlerDeferred.resolve();
	    }
	    /**
	     * This method will call cacheWillUpdate on the available plugins (or use
	     * status === 200) to determine if the Response is safe and valid to cache.
	     *
	     * @param {Request} options.request
	     * @param {Response} options.response
	     * @return {Promise<Response|undefined>}
	     *
	     * @private
	     */
	    async _ensureResponseSafeToCache(response) {
	        let responseToCache = response;
	        let pluginsUsed = false;
	        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {
	            responseToCache = (await callback({
	                request: this.request,
	                response: responseToCache,
	                event: this.event,
	            })) || undefined;
	            pluginsUsed = true;
	            if (!responseToCache) {
	                break;
	            }
	        }
	        if (!pluginsUsed) {
	            if (responseToCache && responseToCache.status !== 200) {
	                responseToCache = undefined;
	            }
	            {
	                if (responseToCache) {
	                    if (responseToCache.status !== 200) {
	                        if (responseToCache.status === 0) {
	                            logger.warn(`The response for '${this.request.url}' ` +
	                                `is an opaque response. The caching strategy that you're ` +
	                                `using will not cache opaque responses by default.`);
	                        }
	                        else {
	                            logger.debug(`The response for '${this.request.url}' ` +
	                                `returned a status code of '${response.status}' and won't ` +
	                                `be cached as a result.`);
	                        }
	                    }
	                }
	            }
	        }
	        return responseToCache;
	    }
	}

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * An abstract base class that all other strategy classes must extend from:
	 *
	 * @memberof module:workbox-strategies
	 */
	class Strategy {
	    /**
	     * Creates a new instance of the strategy and sets all documented option
	     * properties as public instance properties.
	     *
	     * Note: if a custom strategy class extends the base Strategy class and does
	     * not need more than these properties, it does not need to define its own
	     * constructor.
	     *
	     * @param {Object} [options]
	     * @param {string} [options.cacheName] Cache name to store and retrieve
	     * requests. Defaults to the cache names provided by
	     * [workbox-core]{@link module:workbox-core.cacheNames}.
	     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
	     * to use in conjunction with this caching strategy.
	     * @param {Object} [options.fetchOptions] Values passed along to the
	     * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}
	     * of all fetch() requests made by this strategy.
	     * @param {Object} [options.matchOptions] The
	     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
	     * for any `cache.match()` or `cache.put()` calls made by this strategy.
	     */
	    constructor(options = {}) {
	        /**
	         * Cache name to store and retrieve
	         * requests. Defaults to the cache names provided by
	         * [workbox-core]{@link module:workbox-core.cacheNames}.
	         *
	         * @type {string}
	         */
	        this.cacheName = cacheNames.getRuntimeName(options.cacheName);
	        /**
	         * The list
	         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
	         * used by this strategy.
	         *
	         * @type {Array<Object>}
	         */
	        this.plugins = options.plugins || [];
	        /**
	         * Values passed along to the
	         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}
	         * of all fetch() requests made by this strategy.
	         *
	         * @type {Object}
	         */
	        this.fetchOptions = options.fetchOptions;
	        /**
	         * The
	         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
	         * for any `cache.match()` or `cache.put()` calls made by this strategy.
	         *
	         * @type {Object}
	         */
	        this.matchOptions = options.matchOptions;
	    }
	    /**
	     * Perform a request strategy and returns a `Promise` that will resolve with
	     * a `Response`, invoking all relevant plugin callbacks.
	     *
	     * When a strategy instance is registered with a Workbox
	     * [route]{@link module:workbox-routing.Route}, this method is automatically
	     * called when the route matches.
	     *
	     * Alternatively, this method can be used in a standalone `FetchEvent`
	     * listener by passing it to `event.respondWith()`.
	     *
	     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
	     *     properties listed below.
	     * @param {Request|string} options.request A request to run this strategy for.
	     * @param {ExtendableEvent} options.event The event associated with the
	     *     request.
	     * @param {URL} [options.url]
	     * @param {*} [options.params]
	     */
	    handle(options) {
	        const [responseDone] = this.handleAll(options);
	        return responseDone;
	    }
	    /**
	     * Similar to [`handle()`]{@link module:workbox-strategies.Strategy~handle}, but
	     * instead of just returning a `Promise` that resolves to a `Response` it
	     * it will return an tuple of [response, done] promises, where the former
	     * (`response`) is equivalent to what `handle()` returns, and the latter is a
	     * Promise that will resolve once any promises that were added to
	     * `event.waitUntil()` as part of performing the strategy have completed.
	     *
	     * You can await the `done` promise to ensure any extra work performed by
	     * the strategy (usually caching responses) completes successfully.
	     *
	     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
	     *     properties listed below.
	     * @param {Request|string} options.request A request to run this strategy for.
	     * @param {ExtendableEvent} options.event The event associated with the
	     *     request.
	     * @param {URL} [options.url]
	     * @param {*} [options.params]
	     * @return {Array<Promise>} A tuple of [response, done]
	     *     promises that can be used to determine when the response resolves as
	     *     well as when the handler has completed all its work.
	     */
	    handleAll(options) {
	        // Allow for flexible options to be passed.
	        if (options instanceof FetchEvent) {
	            options = {
	                event: options,
	                request: options.request,
	            };
	        }
	        const event = options.event;
	        const request = typeof options.request === 'string' ?
	            new Request(options.request) :
	            options.request;
	        const params = 'params' in options ? options.params : undefined;
	        const handler = new StrategyHandler(this, { event, request, params });
	        const responseDone = this._getResponse(handler, request, event);
	        const handlerDone = this._awaitComplete(responseDone, handler, request, event);
	        // Return an array of promises, suitable for use with Promise.all().
	        return [responseDone, handlerDone];
	    }
	    async _getResponse(handler, request, event) {
	        await handler.runCallbacks('handlerWillStart', { event, request });
	        let response = undefined;
	        try {
	            response = await this._handle(request, handler);
	            // The "official" Strategy subclasses all throw this error automatically,
	            // but in case a third-party Strategy doesn't, ensure that we have a
	            // consistent failure when there's no response or an error response.
	            if (!response || response.type === 'error') {
	                throw new WorkboxError('no-response', { url: request.url });
	            }
	        }
	        catch (error) {
	            for (const callback of handler.iterateCallbacks('handlerDidError')) {
	                response = await callback({ error, event, request });
	                if (response) {
	                    break;
	                }
	            }
	            if (!response) {
	                throw error;
	            }
	            else {
	                logger.log(`While responding to '${getFriendlyURL(request.url)}', ` +
	                    `an ${error} error occurred. Using a fallback response provided by ` +
	                    `a handlerDidError plugin.`);
	            }
	        }
	        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {
	            response = await callback({ event, request, response });
	        }
	        return response;
	    }
	    async _awaitComplete(responseDone, handler, request, event) {
	        let response;
	        let error;
	        try {
	            response = await responseDone;
	        }
	        catch (error) {
	            // Ignore errors, as response errors should be caught via the `response`
	            // promise above. The `done` promise will only throw for errors in
	            // promises passed to `handler.waitUntil()`.
	        }
	        try {
	            await handler.runCallbacks('handlerDidRespond', {
	                event,
	                request,
	                response,
	            });
	            await handler.doneWaiting();
	        }
	        catch (waitUntilError) {
	            error = waitUntilError;
	        }
	        await handler.runCallbacks('handlerDidComplete', {
	            event,
	            request,
	            response,
	            error,
	        });
	        handler.destroy();
	        if (error) {
	            throw error;
	        }
	    }
	}
	/**
	 * Classes extending the `Strategy` based class should implement this method,
	 * and leverage the [`handler`]{@link module:workbox-strategies.StrategyHandler}
	 * arg to perform all fetching and cache logic, which will ensure all relevant
	 * cache, cache options, fetch options and plugins are used (per the current
	 * strategy instance).
	 *
	 * @name _handle
	 * @instance
	 * @abstract
	 * @function
	 * @param {Request} request
	 * @param {module:workbox-strategies.StrategyHandler} handler
	 * @return {Promise<Response>}
	 *
	 * @memberof module:workbox-strategies.Strategy
	 */

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const copyRedirectedCacheableResponsesPlugin = {
	    async cacheWillUpdate({ response }) {
	        return response.redirected ? await copyResponse(response) : response;
	    }
	};
	/**
	 * A [Strategy]{@link module:workbox-strategies.Strategy} implementation
	 * specifically designed to work with
	 * [PrecacheController]{@link module:workbox-precaching.PrecacheController}
	 * to both cache and fetch precached assets.
	 *
	 * Note: an instance of this class is created automatically when creating a
	 * `PrecacheController`; it's generally not necessary to create this yourself.
	 *
	 * @extends module:workbox-strategies.Strategy
	 * @memberof module:workbox-precaching
	 */
	class PrecacheStrategy extends Strategy {
	    /**
	     *
	     * @param {Object} [options]
	     * @param {string} [options.cacheName] Cache name to store and retrieve
	     * requests. Defaults to the cache names provided by
	     * [workbox-core]{@link module:workbox-core.cacheNames}.
	     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
	     * to use in conjunction with this caching strategy.
	     * @param {Object} [options.fetchOptions] Values passed along to the
	     * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}
	     * of all fetch() requests made by this strategy.
	     * @param {Object} [options.matchOptions] The
	     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
	     * for any `cache.match()` or `cache.put()` calls made by this strategy.
	     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
	     * get the response from the network if there's a precache miss.
	     */
	    constructor(options = {}) {
	        options.cacheName = cacheNames.getPrecacheName(options.cacheName);
	        super(options);
	        this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true;
	        // Redirected responses cannot be used to satisfy a navigation request, so
	        // any redirected response must be "copied" rather than cloned, so the new
	        // response doesn't contain the `redirected` flag. See:
	        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1
	        this.plugins.push(copyRedirectedCacheableResponsesPlugin);
	    }
	    /**
	     * @private
	     * @param {Request|string} request A request to run this strategy for.
	     * @param {module:workbox-strategies.StrategyHandler} handler The event that
	     *     triggered the request.
	     * @return {Promise<Response>}
	     */
	    async _handle(request, handler) {
	        const response = await handler.cacheMatch(request);
	        if (!response) {
	            // If this is an `install` event then populate the cache. If this is a
	            // `fetch` event (or any other event) then respond with the cached
	            // response.
	            if (handler.event && handler.event.type === 'install') {
	                return await this._handleInstall(request, handler);
	            }
	            return await this._handleFetch(request, handler);
	        }
	        return response;
	    }
	    async _handleFetch(request, handler) {
	        let response;
	        // Fall back to the network if we don't have a cached response
	        // (perhaps due to manual cache cleanup).
	        if (this._fallbackToNetwork) {
	            {
	                logger.warn(`The precached response for ` +
	                    `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` +
	                    `found. Falling back to the network instead.`);
	            }
	            response = await handler.fetch(request);
	        }
	        else {
	            // This shouldn't normally happen, but there are edge cases:
	            // https://github.com/GoogleChrome/workbox/issues/1441
	            throw new WorkboxError('missing-precache-entry', {
	                cacheName: this.cacheName,
	                url: request.url,
	            });
	        }
	        {
	            const cacheKey = handler.params && handler.params.cacheKey ||
	                await handler.getCacheKey(request, 'read');
	            // Workbox is going to handle the route.
	            // print the routing details to the console.
	            logger.groupCollapsed(`Precaching is responding to: ` +
	                getFriendlyURL(request.url));
	            logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey.url)}`);
	            logger.groupCollapsed(`View request details here.`);
	            logger.log(request);
	            logger.groupEnd();
	            logger.groupCollapsed(`View response details here.`);
	            logger.log(response);
	            logger.groupEnd();
	            logger.groupEnd();
	        }
	        return response;
	    }
	    async _handleInstall(request, handler) {
	        const response = await handler.fetchAndCachePut(request);
	        // Any time there's no response, consider it a precaching error.
	        let responseSafeToPrecache = Boolean(response);
	        // Also consider it an error if the user didn't pass their own
	        // cacheWillUpdate plugin, and the response is a 400+ (note: this means
	        // that by default opaque responses can be precached).
	        if (response && response.status >= 400 &&
	            !this._usesCustomCacheableResponseLogic()) {
	            responseSafeToPrecache = false;
	        }
	        if (!responseSafeToPrecache) {
	            // Throwing here will lead to the `install` handler failing, which
	            // we want to do if *any* of the responses aren't safe to cache.
	            throw new WorkboxError('bad-precaching-response', {
	                url: request.url,
	                status: response.status,
	            });
	        }
	        return response;
	    }
	    /**
	     * Returns true if any users plugins were added containing their own
	     * `cacheWillUpdate` callback.
	     *
	     * This method indicates whether the default cacheable response logic (i.e.
	     * <400, including opaque responses) should be used. If a custom plugin
	     * with a `cacheWillUpdate` callback is passed, then the strategy should
	     * defer to that plugin's logic.
	     *
	     * @private
	     */
	    _usesCustomCacheableResponseLogic() {
	        return this.plugins.some((plugin) => plugin.cacheWillUpdate &&
	            plugin !== copyRedirectedCacheableResponsesPlugin);
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Performs efficient precaching of assets.
	 *
	 * @memberof module:workbox-precaching
	 */
	class PrecacheController {
	    /**
	     * Create a new PrecacheController.
	     *
	     * @param {Object} [options]
	     * @param {string} [options.cacheName] The cache to use for precaching.
	     * @param {string} [options.plugins] Plugins to use when precaching as well
	     * as responding to fetch events for precached assets.
	     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
	     * get the response from the network if there's a precache miss.
	     */
	    constructor({ cacheName, plugins = [], fallbackToNetwork = true } = {}) {
	        this._urlsToCacheKeys = new Map();
	        this._urlsToCacheModes = new Map();
	        this._cacheKeysToIntegrities = new Map();
	        this._strategy = new PrecacheStrategy({
	            cacheName: cacheNames.getPrecacheName(cacheName),
	            plugins: [
	                ...plugins,
	                new PrecacheCacheKeyPlugin({ precacheController: this }),
	            ],
	            fallbackToNetwork,
	        });
	        // Bind the install and activate methods to the instance.
	        this.install = this.install.bind(this);
	        this.activate = this.activate.bind(this);
	    }
	    /**
	     * @type {module:workbox-precaching.PrecacheStrategy} The strategy created by this controller and
	     * used to cache assets and respond to fetch events.
	     */
	    get strategy() {
	        return this._strategy;
	    }
	    /**
	     * Adds items to the precache list, removing any duplicates and
	     * stores the files in the
	     * ["precache cache"]{@link module:workbox-core.cacheNames} when the service
	     * worker installs.
	     *
	     * This method can be called multiple times.
	     *
	     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.
	     */
	    precache(entries) {
	        this.addToCacheList(entries);
	        if (!this._installAndActiveListenersAdded) {
	            self.addEventListener('install', this.install);
	            self.addEventListener('activate', this.activate);
	            this._installAndActiveListenersAdded = true;
	        }
	    }
	    /**
	     * This method will add items to the precache list, removing duplicates
	     * and ensuring the information is valid.
	     *
	     * @param {Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>} entries
	     *     Array of entries to precache.
	     */
	    addToCacheList(entries) {
	        {
	            finalAssertExports.isArray(entries, {
	                moduleName: 'workbox-precaching',
	                className: 'PrecacheController',
	                funcName: 'addToCacheList',
	                paramName: 'entries',
	            });
	        }
	        const urlsToWarnAbout = [];
	        for (const entry of entries) {
	            // See https://github.com/GoogleChrome/workbox/issues/2259
	            if (typeof entry === 'string') {
	                urlsToWarnAbout.push(entry);
	            }
	            else if (entry && entry.revision === undefined) {
	                urlsToWarnAbout.push(entry.url);
	            }
	            const { cacheKey, url } = createCacheKey(entry);
	            const cacheMode = (typeof entry !== 'string' && entry.revision) ?
	                'reload' : 'default';
	            if (this._urlsToCacheKeys.has(url) &&
	                this._urlsToCacheKeys.get(url) !== cacheKey) {
	                throw new WorkboxError('add-to-cache-list-conflicting-entries', {
	                    firstEntry: this._urlsToCacheKeys.get(url),
	                    secondEntry: cacheKey,
	                });
	            }
	            if (typeof entry !== 'string' && entry.integrity) {
	                if (this._cacheKeysToIntegrities.has(cacheKey) &&
	                    this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {
	                    throw new WorkboxError('add-to-cache-list-conflicting-integrities', {
	                        url,
	                    });
	                }
	                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);
	            }
	            this._urlsToCacheKeys.set(url, cacheKey);
	            this._urlsToCacheModes.set(url, cacheMode);
	            if (urlsToWarnAbout.length > 0) {
	                const warningMessage = `Workbox is precaching URLs without revision ` +
	                    `info: ${urlsToWarnAbout.join(', ')}\nThis is generally NOT safe. ` +
	                    `Learn more at https://bit.ly/wb-precache`;
	                {
	                    logger.warn(warningMessage);
	                }
	            }
	        }
	    }
	    /**
	     * Precaches new and updated assets. Call this method from the service worker
	     * install event.
	     *
	     * Note: this method calls `event.waitUntil()` for you, so you do not need
	     * to call it yourself in your event handlers.
	     *
	     * @param {Object} options
	     * @param {Event} options.event The install event.
	     * @return {Promise<module:workbox-precaching.InstallResult>}
	     */
	    install(event) {
	        return waitUntil(event, async () => {
	            const installReportPlugin = new PrecacheInstallReportPlugin();
	            this.strategy.plugins.push(installReportPlugin);
	            // Cache entries one at a time.
	            // See https://github.com/GoogleChrome/workbox/issues/2528
	            for (const [url, cacheKey] of this._urlsToCacheKeys) {
	                const integrity = this._cacheKeysToIntegrities.get(cacheKey);
	                const cacheMode = this._urlsToCacheModes.get(url);
	                const request = new Request(url, {
	                    integrity,
	                    cache: cacheMode,
	                    credentials: 'same-origin',
	                });
	                await Promise.all(this.strategy.handleAll({
	                    params: { cacheKey },
	                    request,
	                    event,
	                }));
	            }
	            const { updatedURLs, notUpdatedURLs } = installReportPlugin;
	            {
	                printInstallDetails(updatedURLs, notUpdatedURLs);
	            }
	            return { updatedURLs, notUpdatedURLs };
	        });
	    }
	    /**
	     * Deletes assets that are no longer present in the current precache manifest.
	     * Call this method from the service worker activate event.
	     *
	     * Note: this method calls `event.waitUntil()` for you, so you do not need
	     * to call it yourself in your event handlers.
	     *
	     * @param {ExtendableEvent}
	     * @return {Promise<module:workbox-precaching.CleanupResult>}
	     */
	    activate(event) {
	        return waitUntil(event, async () => {
	            const cache = await self.caches.open(this.strategy.cacheName);
	            const currentlyCachedRequests = await cache.keys();
	            const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());
	            const deletedURLs = [];
	            for (const request of currentlyCachedRequests) {
	                if (!expectedCacheKeys.has(request.url)) {
	                    await cache.delete(request);
	                    deletedURLs.push(request.url);
	                }
	            }
	            {
	                printCleanupDetails(deletedURLs);
	            }
	            return { deletedURLs };
	        });
	    }
	    /**
	     * Returns a mapping of a precached URL to the corresponding cache key, taking
	     * into account the revision information for the URL.
	     *
	     * @return {Map<string, string>} A URL to cache key mapping.
	     */
	    getURLsToCacheKeys() {
	        return this._urlsToCacheKeys;
	    }
	    /**
	     * Returns a list of all the URLs that have been precached by the current
	     * service worker.
	     *
	     * @return {Array<string>} The precached URLs.
	     */
	    getCachedURLs() {
	        return [...this._urlsToCacheKeys.keys()];
	    }
	    /**
	     * Returns the cache key used for storing a given URL. If that URL is
	     * unversioned, like `/index.html', then the cache key will be the original
	     * URL with a search parameter appended to it.
	     *
	     * @param {string} url A URL whose cache key you want to look up.
	     * @return {string} The versioned URL that corresponds to a cache key
	     * for the original URL, or undefined if that URL isn't precached.
	     */
	    getCacheKeyForURL(url) {
	        const urlObject = new URL(url, location.href);
	        return this._urlsToCacheKeys.get(urlObject.href);
	    }
	    /**
	     * This acts as a drop-in replacement for
	     * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)
	     * with the following differences:
	     *
	     * - It knows what the name of the precache is, and only checks in that cache.
	     * - It allows you to pass in an "original" URL without versioning parameters,
	     * and it will automatically look up the correct cache key for the currently
	     * active revision of that URL.
	     *
	     * E.g., `matchPrecache('index.html')` will find the correct precached
	     * response for the currently active service worker, even if the actual cache
	     * key is `'/index.html?__WB_REVISION__=1234abcd'`.
	     *
	     * @param {string|Request} request The key (without revisioning parameters)
	     * to look up in the precache.
	     * @return {Promise<Response|undefined>}
	     */
	    async matchPrecache(request) {
	        const url = request instanceof Request ? request.url : request;
	        const cacheKey = this.getCacheKeyForURL(url);
	        if (cacheKey) {
	            const cache = await self.caches.open(this.strategy.cacheName);
	            return cache.match(cacheKey);
	        }
	        return undefined;
	    }
	    /**
	     * Returns a function that looks up `url` in the precache (taking into
	     * account revision information), and returns the corresponding `Response`.
	     *
	     * @param {string} url The precached URL which will be used to lookup the
	     * `Response`.
	     * @return {module:workbox-routing~handlerCallback}
	     */
	    createHandlerBoundToURL(url) {
	        const cacheKey = this.getCacheKeyForURL(url);
	        if (!cacheKey) {
	            throw new WorkboxError('non-precached-url', { url });
	        }
	        return (options) => {
	            options.request = new Request(url);
	            options.params = { cacheKey, ...options.params };
	            return this.strategy.handle(options);
	        };
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	let precacheController;
	/**
	 * @return {PrecacheController}
	 * @private
	 */
	const getOrCreatePrecacheController = () => {
	    if (!precacheController) {
	        precacheController = new PrecacheController();
	    }
	    return precacheController;
	};

	// @ts-ignore
	try {
	    self['workbox:routing:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * The default HTTP method, 'GET', used when there's no specific method
	 * configured for a route.
	 *
	 * @type {string}
	 *
	 * @private
	 */
	const defaultMethod = 'GET';
	/**
	 * The list of valid HTTP methods associated with requests that could be routed.
	 *
	 * @type {Array<string>}
	 *
	 * @private
	 */
	const validMethods = [
	    'DELETE',
	    'GET',
	    'HEAD',
	    'PATCH',
	    'POST',
	    'PUT',
	];

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * @param {function()|Object} handler Either a function, or an object with a
	 * 'handle' method.
	 * @return {Object} An object with a handle method.
	 *
	 * @private
	 */
	const normalizeHandler = (handler) => {
	    if (handler && typeof handler === 'object') {
	        {
	            finalAssertExports.hasMethod(handler, 'handle', {
	                moduleName: 'workbox-routing',
	                className: 'Route',
	                funcName: 'constructor',
	                paramName: 'handler',
	            });
	        }
	        return handler;
	    }
	    else {
	        {
	            finalAssertExports.isType(handler, 'function', {
	                moduleName: 'workbox-routing',
	                className: 'Route',
	                funcName: 'constructor',
	                paramName: 'handler',
	            });
	        }
	        return { handle: handler };
	    }
	};

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A `Route` consists of a pair of callback functions, "match" and "handler".
	 * The "match" callback determine if a route should be used to "handle" a
	 * request by returning a non-falsy value if it can. The "handler" callback
	 * is called when there is a match and should return a Promise that resolves
	 * to a `Response`.
	 *
	 * @memberof module:workbox-routing
	 */
	class Route {
	    /**
	     * Constructor for Route class.
	     *
	     * @param {module:workbox-routing~matchCallback} match
	     * A callback function that determines whether the route matches a given
	     * `fetch` event by returning a non-falsy value.
	     * @param {module:workbox-routing~handlerCallback} handler A callback
	     * function that returns a Promise resolving to a Response.
	     * @param {string} [method='GET'] The HTTP method to match the Route
	     * against.
	     */
	    constructor(match, handler, method = defaultMethod) {
	        {
	            finalAssertExports.isType(match, 'function', {
	                moduleName: 'workbox-routing',
	                className: 'Route',
	                funcName: 'constructor',
	                paramName: 'match',
	            });
	            if (method) {
	                finalAssertExports.isOneOf(method, validMethods, { paramName: 'method' });
	            }
	        }
	        // These values are referenced directly by Router so cannot be
	        // altered by minificaton.
	        this.handler = normalizeHandler(handler);
	        this.match = match;
	        this.method = method;
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * RegExpRoute makes it easy to create a regular expression based
	 * [Route]{@link module:workbox-routing.Route}.
	 *
	 * For same-origin requests the RegExp only needs to match part of the URL. For
	 * requests against third-party servers, you must define a RegExp that matches
	 * the start of the URL.
	 *
	 * [See the module docs for info.]{@link https://developers.google.com/web/tools/workbox/modules/workbox-routing}
	 *
	 * @memberof module:workbox-routing
	 * @extends module:workbox-routing.Route
	 */
	class RegExpRoute extends Route {
	    /**
	     * If the regular expression contains
	     * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},
	     * the captured values will be passed to the
	     * [handler's]{@link module:workbox-routing~handlerCallback} `params`
	     * argument.
	     *
	     * @param {RegExp} regExp The regular expression to match against URLs.
	     * @param {module:workbox-routing~handlerCallback} handler A callback
	     * function that returns a Promise resulting in a Response.
	     * @param {string} [method='GET'] The HTTP method to match the Route
	     * against.
	     */
	    constructor(regExp, handler, method) {
	        {
	            finalAssertExports.isInstance(regExp, RegExp, {
	                moduleName: 'workbox-routing',
	                className: 'RegExpRoute',
	                funcName: 'constructor',
	                paramName: 'pattern',
	            });
	        }
	        const match = ({ url }) => {
	            const result = regExp.exec(url.href);
	            // Return immediately if there's no match.
	            if (!result) {
	                return;
	            }
	            // Require that the match start at the first character in the URL string
	            // if it's a cross-origin request.
	            // See https://github.com/GoogleChrome/workbox/issues/281 for the context
	            // behind this behavior.
	            if ((url.origin !== location.origin) && (result.index !== 0)) {
	                {
	                    logger.debug(`The regular expression '${regExp}' only partially matched ` +
	                        `against the cross-origin URL '${url}'. RegExpRoute's will only ` +
	                        `handle cross-origin requests if they match the entire URL.`);
	                }
	                return;
	            }
	            // If the route matches, but there aren't any capture groups defined, then
	            // this will return [], which is truthy and therefore sufficient to
	            // indicate a match.
	            // If there are capture groups, then it will return their values.
	            return result.slice(1);
	        };
	        super(match, handler, method);
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * The Router can be used to process a FetchEvent through one or more
	 * [Routes]{@link module:workbox-routing.Route} responding  with a Request if
	 * a matching route exists.
	 *
	 * If no route matches a given a request, the Router will use a "default"
	 * handler if one is defined.
	 *
	 * Should the matching Route throw an error, the Router will use a "catch"
	 * handler if one is defined to gracefully deal with issues and respond with a
	 * Request.
	 *
	 * If a request matches multiple routes, the **earliest** registered route will
	 * be used to respond to the request.
	 *
	 * @memberof module:workbox-routing
	 */
	class Router {
	    /**
	     * Initializes a new Router.
	     */
	    constructor() {
	        this._routes = new Map();
	        this._defaultHandlerMap = new Map();
	    }
	    /**
	     * @return {Map<string, Array<module:workbox-routing.Route>>} routes A `Map` of HTTP
	     * method name ('GET', etc.) to an array of all the corresponding `Route`
	     * instances that are registered.
	     */
	    get routes() {
	        return this._routes;
	    }
	    /**
	     * Adds a fetch event listener to respond to events when a route matches
	     * the event's request.
	     */
	    addFetchListener() {
	        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
	        self.addEventListener('fetch', ((event) => {
	            const { request } = event;
	            const responsePromise = this.handleRequest({ request, event });
	            if (responsePromise) {
	                event.respondWith(responsePromise);
	            }
	        }));
	    }
	    /**
	     * Adds a message event listener for URLs to cache from the window.
	     * This is useful to cache resources loaded on the page prior to when the
	     * service worker started controlling it.
	     *
	     * The format of the message data sent from the window should be as follows.
	     * Where the `urlsToCache` array may consist of URL strings or an array of
	     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).
	     *
	     * ```
	     * {
	     *   type: 'CACHE_URLS',
	     *   payload: {
	     *     urlsToCache: [
	     *       './script1.js',
	     *       './script2.js',
	     *       ['./script3.js', {mode: 'no-cors'}],
	     *     ],
	     *   },
	     * }
	     * ```
	     */
	    addCacheListener() {
	        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
	        self.addEventListener('message', ((event) => {
	            if (event.data && event.data.type === 'CACHE_URLS') {
	                const { payload } = event.data;
	                {
	                    logger.debug(`Caching URLs from the window`, payload.urlsToCache);
	                }
	                const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {
	                    if (typeof entry === 'string') {
	                        entry = [entry];
	                    }
	                    const request = new Request(...entry);
	                    return this.handleRequest({ request, event });
	                    // TODO(philipwalton): TypeScript errors without this typecast for
	                    // some reason (probably a bug). The real type here should work but
	                    // doesn't: `Array<Promise<Response> | undefined>`.
	                })); // TypeScript
	                event.waitUntil(requestPromises);
	                // If a MessageChannel was used, reply to the message on success.
	                if (event.ports && event.ports[0]) {
	                    requestPromises.then(() => event.ports[0].postMessage(true));
	                }
	            }
	        }));
	    }
	    /**
	     * Apply the routing rules to a FetchEvent object to get a Response from an
	     * appropriate Route's handler.
	     *
	     * @param {Object} options
	     * @param {Request} options.request The request to handle.
	     * @param {ExtendableEvent} options.event The event that triggered the
	     *     request.
	     * @return {Promise<Response>|undefined} A promise is returned if a
	     *     registered route can handle the request. If there is no matching
	     *     route and there's no `defaultHandler`, `undefined` is returned.
	     */
	    handleRequest({ request, event }) {
	        {
	            finalAssertExports.isInstance(request, Request, {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'handleRequest',
	                paramName: 'options.request',
	            });
	        }
	        const url = new URL(request.url, location.href);
	        if (!url.protocol.startsWith('http')) {
	            {
	                logger.debug(`Workbox Router only supports URLs that start with 'http'.`);
	            }
	            return;
	        }
	        const sameOrigin = url.origin === location.origin;
	        const { params, route } = this.findMatchingRoute({
	            event,
	            request,
	            sameOrigin,
	            url,
	        });
	        let handler = route && route.handler;
	        const debugMessages = [];
	        {
	            if (handler) {
	                debugMessages.push([
	                    `Found a route to handle this request:`, route,
	                ]);
	                if (params) {
	                    debugMessages.push([
	                        `Passing the following params to the route's handler:`, params,
	                    ]);
	                }
	            }
	        }
	        // If we don't have a handler because there was no matching route, then
	        // fall back to defaultHandler if that's defined.
	        const method = request.method;
	        if (!handler && this._defaultHandlerMap.has(method)) {
	            {
	                debugMessages.push(`Failed to find a matching route. Falling ` +
	                    `back to the default handler for ${method}.`);
	            }
	            handler = this._defaultHandlerMap.get(method);
	        }
	        if (!handler) {
	            {
	                // No handler so Workbox will do nothing. If logs is set of debug
	                // i.e. verbose, we should print out this information.
	                logger.debug(`No route found for: ${getFriendlyURL(url)}`);
	            }
	            return;
	        }
	        {
	            // We have a handler, meaning Workbox is going to handle the route.
	            // print the routing details to the console.
	            logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);
	            debugMessages.forEach((msg) => {
	                if (Array.isArray(msg)) {
	                    logger.log(...msg);
	                }
	                else {
	                    logger.log(msg);
	                }
	            });
	            logger.groupEnd();
	        }
	        // Wrap in try and catch in case the handle method throws a synchronous
	        // error. It should still callback to the catch handler.
	        let responsePromise;
	        try {
	            responsePromise = handler.handle({ url, request, event, params });
	        }
	        catch (err) {
	            responsePromise = Promise.reject(err);
	        }
	        if (responsePromise instanceof Promise && this._catchHandler) {
	            responsePromise = responsePromise.catch((err) => {
	                {
	                    // Still include URL here as it will be async from the console group
	                    // and may not make sense without the URL
	                    logger.groupCollapsed(`Error thrown when responding to: ` +
	                        ` ${getFriendlyURL(url)}. Falling back to Catch Handler.`);
	                    logger.error(`Error thrown by:`, route);
	                    logger.error(err);
	                    logger.groupEnd();
	                }
	                return this._catchHandler.handle({ url, request, event });
	            });
	        }
	        return responsePromise;
	    }
	    /**
	     * Checks a request and URL (and optionally an event) against the list of
	     * registered routes, and if there's a match, returns the corresponding
	     * route along with any params generated by the match.
	     *
	     * @param {Object} options
	     * @param {URL} options.url
	     * @param {Request} options.request The request to match.
	     * @param {Event} options.event The corresponding event.
	     * @return {Object} An object with `route` and `params` properties.
	     *     They are populated if a matching route was found or `undefined`
	     *     otherwise.
	     */
	    findMatchingRoute({ url, sameOrigin, request, event }) {
	        const routes = this._routes.get(request.method) || [];
	        for (const route of routes) {
	            let params;
	            const matchResult = route.match({ url, sameOrigin, request, event });
	            if (matchResult) {
	                {
	                    // Warn developers that using an async matchCallback is almost always
	                    // not the right thing to do. 
	                    if (matchResult instanceof Promise) {
	                        logger.warn(`While routing ${getFriendlyURL(url)}, an async ` +
	                            `matchCallback function was used. Please convert the ` +
	                            `following route to use a synchronous matchCallback function:`, route);
	                    }
	                }
	                // See https://github.com/GoogleChrome/workbox/issues/2079
	                params = matchResult;
	                if (Array.isArray(matchResult) && matchResult.length === 0) {
	                    // Instead of passing an empty array in as params, use undefined.
	                    params = undefined;
	                }
	                else if ((matchResult.constructor === Object &&
	                    Object.keys(matchResult).length === 0)) {
	                    // Instead of passing an empty object in as params, use undefined.
	                    params = undefined;
	                }
	                else if (typeof matchResult === 'boolean') {
	                    // For the boolean value true (rather than just something truth-y),
	                    // don't set params.
	                    // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353
	                    params = undefined;
	                }
	                // Return early if have a match.
	                return { route, params };
	            }
	        }
	        // If no match was found above, return and empty object.
	        return {};
	    }
	    /**
	     * Define a default `handler` that's called when no routes explicitly
	     * match the incoming request.
	     *
	     * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.
	     *
	     * Without a default handler, unmatched requests will go against the
	     * network as if there were no service worker present.
	     *
	     * @param {module:workbox-routing~handlerCallback} handler A callback
	     * function that returns a Promise resulting in a Response.
	     * @param {string} [method='GET'] The HTTP method to associate with this
	     * default handler. Each method has its own default.
	     */
	    setDefaultHandler(handler, method = defaultMethod) {
	        this._defaultHandlerMap.set(method, normalizeHandler(handler));
	    }
	    /**
	     * If a Route throws an error while handling a request, this `handler`
	     * will be called and given a chance to provide a response.
	     *
	     * @param {module:workbox-routing~handlerCallback} handler A callback
	     * function that returns a Promise resulting in a Response.
	     */
	    setCatchHandler(handler) {
	        this._catchHandler = normalizeHandler(handler);
	    }
	    /**
	     * Registers a route with the router.
	     *
	     * @param {module:workbox-routing.Route} route The route to register.
	     */
	    registerRoute(route) {
	        {
	            finalAssertExports.isType(route, 'object', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route',
	            });
	            finalAssertExports.hasMethod(route, 'match', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route',
	            });
	            finalAssertExports.isType(route.handler, 'object', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route',
	            });
	            finalAssertExports.hasMethod(route.handler, 'handle', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route.handler',
	            });
	            finalAssertExports.isType(route.method, 'string', {
	                moduleName: 'workbox-routing',
	                className: 'Router',
	                funcName: 'registerRoute',
	                paramName: 'route.method',
	            });
	        }
	        if (!this._routes.has(route.method)) {
	            this._routes.set(route.method, []);
	        }
	        // Give precedence to all of the earlier routes by adding this additional
	        // route to the end of the array.
	        this._routes.get(route.method).push(route);
	    }
	    /**
	     * Unregisters a route with the router.
	     *
	     * @param {module:workbox-routing.Route} route The route to unregister.
	     */
	    unregisterRoute(route) {
	        if (!this._routes.has(route.method)) {
	            throw new WorkboxError('unregister-route-but-not-found-with-method', {
	                method: route.method,
	            });
	        }
	        const routeIndex = this._routes.get(route.method).indexOf(route);
	        if (routeIndex > -1) {
	            this._routes.get(route.method).splice(routeIndex, 1);
	        }
	        else {
	            throw new WorkboxError('unregister-route-route-not-registered');
	        }
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	let defaultRouter;
	/**
	 * Creates a new, singleton Router instance if one does not exist. If one
	 * does already exist, that instance is returned.
	 *
	 * @private
	 * @return {Router}
	 */
	const getOrCreateDefaultRouter = () => {
	    if (!defaultRouter) {
	        defaultRouter = new Router();
	        // The helpers that use the default Router assume these listeners exist.
	        defaultRouter.addFetchListener();
	        defaultRouter.addCacheListener();
	    }
	    return defaultRouter;
	};

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Easily register a RegExp, string, or function with a caching
	 * strategy to a singleton Router instance.
	 *
	 * This method will generate a Route for you if needed and
	 * call [registerRoute()]{@link module:workbox-routing.Router#registerRoute}.
	 *
	 * @param {RegExp|string|module:workbox-routing.Route~matchCallback|module:workbox-routing.Route} capture
	 * If the capture param is a `Route`, all other arguments will be ignored.
	 * @param {module:workbox-routing~handlerCallback} [handler] A callback
	 * function that returns a Promise resulting in a Response. This parameter
	 * is required if `capture` is not a `Route` object.
	 * @param {string} [method='GET'] The HTTP method to match the Route
	 * against.
	 * @return {module:workbox-routing.Route} The generated `Route`(Useful for
	 * unregistering).
	 *
	 * @memberof module:workbox-routing
	 */
	function registerRoute(capture, handler, method) {
	    let route;
	    if (typeof capture === 'string') {
	        const captureUrl = new URL(capture, location.href);
	        {
	            if (!(capture.startsWith('/') || capture.startsWith('http'))) {
	                throw new WorkboxError('invalid-string', {
	                    moduleName: 'workbox-routing',
	                    funcName: 'registerRoute',
	                    paramName: 'capture',
	                });
	            }
	            // We want to check if Express-style wildcards are in the pathname only.
	            // TODO: Remove this log message in v4.
	            const valueToCheck = capture.startsWith('http') ?
	                captureUrl.pathname : capture;
	            // See https://github.com/pillarjs/path-to-regexp#parameters
	            const wildcards = '[*:?+]';
	            if ((new RegExp(`${wildcards}`)).exec(valueToCheck)) {
	                logger.debug(`The '$capture' parameter contains an Express-style wildcard ` +
	                    `character (${wildcards}). Strings are now always interpreted as ` +
	                    `exact matches; use a RegExp for partial or wildcard matches.`);
	            }
	        }
	        const matchCallback = ({ url }) => {
	            {
	                if ((url.pathname === captureUrl.pathname) &&
	                    (url.origin !== captureUrl.origin)) {
	                    logger.debug(`${capture} only partially matches the cross-origin URL ` +
	                        `${url}. This route will only handle cross-origin requests ` +
	                        `if they match the entire URL.`);
	                }
	            }
	            return url.href === captureUrl.href;
	        };
	        // If `capture` is a string then `handler` and `method` must be present.
	        route = new Route(matchCallback, handler, method);
	    }
	    else if (capture instanceof RegExp) {
	        // If `capture` is a `RegExp` then `handler` and `method` must be present.
	        route = new RegExpRoute(capture, handler, method);
	    }
	    else if (typeof capture === 'function') {
	        // If `capture` is a function then `handler` and `method` must be present.
	        route = new Route(capture, handler, method);
	    }
	    else if (capture instanceof Route) {
	        route = capture;
	    }
	    else {
	        throw new WorkboxError('unsupported-route-type', {
	            moduleName: 'workbox-routing',
	            funcName: 'registerRoute',
	            paramName: 'capture',
	        });
	    }
	    const defaultRouter = getOrCreateDefaultRouter();
	    defaultRouter.registerRoute(route);
	    return route;
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Removes any URL search parameters that should be ignored.
	 *
	 * @param {URL} urlObject The original URL.
	 * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against
	 * each search parameter name. Matches mean that the search parameter should be
	 * ignored.
	 * @return {URL} The URL with any ignored search parameters removed.
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching = []) {
	    // Convert the iterable into an array at the start of the loop to make sure
	    // deletion doesn't mess up iteration.
	    for (const paramName of [...urlObject.searchParams.keys()]) {
	        if (ignoreURLParametersMatching.some((regExp) => regExp.test(paramName))) {
	            urlObject.searchParams.delete(paramName);
	        }
	    }
	    return urlObject;
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Generator function that yields possible variations on the original URL to
	 * check, one at a time.
	 *
	 * @param {string} url
	 * @param {Object} options
	 *
	 * @private
	 * @memberof module:workbox-precaching
	 */
	function* generateURLVariations(url, { ignoreURLParametersMatching = [/^utm_/, /^fbclid$/], directoryIndex = 'index.html', cleanURLs = true, urlManipulation, } = {}) {
	    const urlObject = new URL(url, location.href);
	    urlObject.hash = '';
	    yield urlObject.href;
	    const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);
	    yield urlWithoutIgnoredParams.href;
	    if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {
	        const directoryURL = new URL(urlWithoutIgnoredParams.href);
	        directoryURL.pathname += directoryIndex;
	        yield directoryURL.href;
	    }
	    if (cleanURLs) {
	        const cleanURL = new URL(urlWithoutIgnoredParams.href);
	        cleanURL.pathname += '.html';
	        yield cleanURL.href;
	    }
	    if (urlManipulation) {
	        const additionalURLs = urlManipulation({ url: urlObject });
	        for (const urlToAttempt of additionalURLs) {
	            yield urlToAttempt.href;
	        }
	    }
	}

	/*
	  Copyright 2020 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A subclass of [Route]{@link module:workbox-routing.Route} that takes a
	 * [PrecacheController]{@link module:workbox-precaching.PrecacheController}
	 * instance and uses it to match incoming requests and handle fetching
	 * responses from the precache.
	 *
	 * @memberof module:workbox-precaching
	 * @extends module:workbox-routing.Route
	 */
	class PrecacheRoute extends Route {
	    /**
	     * @param {PrecacheController} precacheController A `PrecacheController`
	     * instance used to both match requests and respond to fetch events.
	     * @param {Object} [options] Options to control how requests are matched
	     * against the list of precached URLs.
	     * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will
	     * check cache entries for a URLs ending with '/' to see if there is a hit when
	     * appending the `directoryIndex` value.
	     * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An
	     * array of regex's to remove search params when looking for a cache match.
	     * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will
	     * check the cache for the URL with a `.html` added to the end of the end.
	     * @param {module:workbox-precaching~urlManipulation} [options.urlManipulation]
	     * This is a function that should take a URL and return an array of
	     * alternative URLs that should be checked for precache matches.
	     */
	    constructor(precacheController, options) {
	        const match = ({ request }) => {
	            const urlsToCacheKeys = precacheController.getURLsToCacheKeys();
	            for (const possibleURL of generateURLVariations(request.url, options)) {
	                const cacheKey = urlsToCacheKeys.get(possibleURL);
	                if (cacheKey) {
	                    return { cacheKey };
	                }
	            }
	            {
	                logger.debug(`Precaching did not find a match for ` +
	                    getFriendlyURL(request.url));
	            }
	            return;
	        };
	        super(match, precacheController.strategy);
	    }
	}

	/*
	  Copyright 2019 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Add a `fetch` listener to the service worker that will
	 * respond to
	 * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}
	 * with precached assets.
	 *
	 * Requests for assets that aren't precached, the `FetchEvent` will not be
	 * responded to, allowing the event to fall through to other `fetch` event
	 * listeners.
	 *
	 * @param {Object} [options] See
	 * [PrecacheRoute options]{@link module:workbox-precaching.PrecacheRoute}.
	 *
	 * @memberof module:workbox-precaching
	 */
	function addRoute(options) {
	    const precacheController = getOrCreatePrecacheController();
	    const precacheRoute = new PrecacheRoute(precacheController, options);
	    registerRoute(precacheRoute);
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Adds items to the precache list, removing any duplicates and
	 * stores the files in the
	 * ["precache cache"]{@link module:workbox-core.cacheNames} when the service
	 * worker installs.
	 *
	 * This method can be called multiple times.
	 *
	 * Please note: This method **will not** serve any of the cached files for you.
	 * It only precaches files. To respond to a network request you call
	 * [addRoute()]{@link module:workbox-precaching.addRoute}.
	 *
	 * If you have a single array of files to precache, you can just call
	 * [precacheAndRoute()]{@link module:workbox-precaching.precacheAndRoute}.
	 *
	 * @param {Array<Object|string>} [entries=[]] Array of entries to precache.
	 *
	 * @memberof module:workbox-precaching
	 */
	function precache(entries) {
	    const precacheController = getOrCreatePrecacheController();
	    precacheController.precache(entries);
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * This method will add entries to the precache list and add a route to
	 * respond to fetch events.
	 *
	 * This is a convenience method that will call
	 * [precache()]{@link module:workbox-precaching.precache} and
	 * [addRoute()]{@link module:workbox-precaching.addRoute} in a single call.
	 *
	 * @param {Array<Object|string>} entries Array of entries to precache.
	 * @param {Object} [options] See
	 * [PrecacheRoute options]{@link module:workbox-precaching.PrecacheRoute}.
	 *
	 * @memberof module:workbox-precaching
	 */
	function precacheAndRoute(entries, options) {
	    precache(entries);
	    addRoute(options);
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const messages$1 = {
	    strategyStart: (strategyName, request) => `Using ${strategyName} to respond to '${getFriendlyURL(request.url)}'`,
	    printFinalResponse: (response) => {
	        if (response) {
	            logger.groupCollapsed(`View the final response here.`);
	            logger.log(response || '[No response returned]');
	            logger.groupEnd();
	        }
	    },
	};

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}
	 * request strategy.
	 *
	 * A cache first strategy is useful for assets that have been revisioned,
	 * such as URLs like `/styles/example.a8f5f1.css`, since they
	 * can be cached for long periods of time.
	 *
	 * If the network request fails, and there is no cache match, this will throw
	 * a `WorkboxError` exception.
	 *
	 * @extends module:workbox-strategies.Strategy
	 * @memberof module:workbox-strategies
	 */
	class CacheFirst extends Strategy {
	    /**
	     * @private
	     * @param {Request|string} request A request to run this strategy for.
	     * @param {module:workbox-strategies.StrategyHandler} handler The event that
	     *     triggered the request.
	     * @return {Promise<Response>}
	     */
	    async _handle(request, handler) {
	        const logs = [];
	        {
	            finalAssertExports.isInstance(request, Request, {
	                moduleName: 'workbox-strategies',
	                className: this.constructor.name,
	                funcName: 'makeRequest',
	                paramName: 'request',
	            });
	        }
	        let response = await handler.cacheMatch(request);
	        let error;
	        if (!response) {
	            {
	                logs.push(`No response found in the '${this.cacheName}' cache. ` +
	                    `Will respond with a network request.`);
	            }
	            try {
	                response = await handler.fetchAndCachePut(request);
	            }
	            catch (err) {
	                error = err;
	            }
	            {
	                if (response) {
	                    logs.push(`Got response from network.`);
	                }
	                else {
	                    logs.push(`Unable to get a response from the network.`);
	                }
	            }
	        }
	        else {
	            {
	                logs.push(`Found a cached response in the '${this.cacheName}' cache.`);
	            }
	        }
	        {
	            logger.groupCollapsed(messages$1.strategyStart(this.constructor.name, request));
	            for (const log of logs) {
	                logger.log(log);
	            }
	            messages$1.printFinalResponse(response);
	            logger.groupEnd();
	        }
	        if (!response) {
	            throw new WorkboxError('no-response', { url: request.url, error });
	        }
	        return response;
	    }
	}

	/*
	  Copyright 2019 Google LLC
	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A helper function that prevents a promise from being flagged as unused.
	 *
	 * @private
	 **/
	function dontWaitFor(promise) {
	    // Effective no-op.
	    promise.then(() => { });
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * A class that wraps common IndexedDB functionality in a promise-based API.
	 * It exposes all the underlying power and functionality of IndexedDB, but
	 * wraps the most commonly used features in a way that's much simpler to use.
	 *
	 * @private
	 */
	class DBWrapper {
	    /**
	     * @param {string} name
	     * @param {number} version
	     * @param {Object=} [callback]
	     * @param {!Function} [callbacks.onupgradeneeded]
	     * @param {!Function} [callbacks.onversionchange] Defaults to
	     *     DBWrapper.prototype._onversionchange when not specified.
	     * @private
	     */
	    constructor(name, version, { onupgradeneeded, onversionchange, } = {}) {
	        this._db = null;
	        this._name = name;
	        this._version = version;
	        this._onupgradeneeded = onupgradeneeded;
	        this._onversionchange = onversionchange || (() => this.close());
	    }
	    /**
	     * Returns the IDBDatabase instance (not normally needed).
	     * @return {IDBDatabase|undefined}
	     *
	     * @private
	     */
	    get db() {
	        return this._db;
	    }
	    /**
	     * Opens a connected to an IDBDatabase, invokes any onupgradedneeded
	     * callback, and added an onversionchange callback to the database.
	     *
	     * @return {IDBDatabase}
	     * @private
	     */
	    async open() {
	        if (this._db)
	            return;
	        this._db = await new Promise((resolve, reject) => {
	            // This flag is flipped to true if the timeout callback runs prior
	            // to the request failing or succeeding. Note: we use a timeout instead
	            // of an onblocked handler since there are cases where onblocked will
	            // never never run. A timeout better handles all possible scenarios:
	            // https://github.com/w3c/IndexedDB/issues/223
	            let openRequestTimedOut = false;
	            setTimeout(() => {
	                openRequestTimedOut = true;
	                reject(new Error('The open request was blocked and timed out'));
	            }, this.OPEN_TIMEOUT);
	            const openRequest = indexedDB.open(this._name, this._version);
	            openRequest.onerror = () => reject(openRequest.error);
	            openRequest.onupgradeneeded = (evt) => {
	                if (openRequestTimedOut) {
	                    openRequest.transaction.abort();
	                    openRequest.result.close();
	                }
	                else if (typeof this._onupgradeneeded === 'function') {
	                    this._onupgradeneeded(evt);
	                }
	            };
	            openRequest.onsuccess = () => {
	                const db = openRequest.result;
	                if (openRequestTimedOut) {
	                    db.close();
	                }
	                else {
	                    db.onversionchange = this._onversionchange.bind(this);
	                    resolve(db);
	                }
	            };
	        });
	        return this;
	    }
	    /**
	     * Polyfills the native `getKey()` method. Note, this is overridden at
	     * runtime if the browser supports the native method.
	     *
	     * @param {string} storeName
	     * @param {*} query
	     * @return {Array}
	     * @private
	     */
	    async getKey(storeName, query) {
	        return (await this.getAllKeys(storeName, query, 1))[0];
	    }
	    /**
	     * Polyfills the native `getAll()` method. Note, this is overridden at
	     * runtime if the browser supports the native method.
	     *
	     * @param {string} storeName
	     * @param {*} query
	     * @param {number} count
	     * @return {Array}
	     * @private
	     */
	    async getAll(storeName, query, count) {
	        return await this.getAllMatching(storeName, { query, count });
	    }
	    /**
	     * Polyfills the native `getAllKeys()` method. Note, this is overridden at
	     * runtime if the browser supports the native method.
	     *
	     * @param {string} storeName
	     * @param {*} query
	     * @param {number} count
	     * @return {Array}
	     * @private
	     */
	    async getAllKeys(storeName, query, count) {
	        const entries = await this.getAllMatching(storeName, { query, count, includeKeys: true });
	        return entries.map((entry) => entry.key);
	    }
	    /**
	     * Supports flexible lookup in an object store by specifying an index,
	     * query, direction, and count. This method returns an array of objects
	     * with the signature .
	     *
	     * @param {string} storeName
	     * @param {Object} [opts]
	     * @param {string} [opts.index] The index to use (if specified).
	     * @param {*} [opts.query]
	     * @param {IDBCursorDirection} [opts.direction]
	     * @param {number} [opts.count] The max number of results to return.
	     * @param {boolean} [opts.includeKeys] When true, the structure of the
	     *     returned objects is changed from an array of values to an array of
	     *     objects in the form {key, primaryKey, value}.
	     * @return {Array}
	     * @private
	     */
	    async getAllMatching(storeName, { index, query = null, // IE/Edge errors if query === `undefined`.
	    direction = 'next', count, includeKeys = false, } = {}) {
	        return await this.transaction([storeName], 'readonly', (txn, done) => {
	            const store = txn.objectStore(storeName);
	            const target = index ? store.index(index) : store;
	            const results = [];
	            const request = target.openCursor(query, direction);
	            request.onsuccess = () => {
	                const cursor = request.result;
	                if (cursor) {
	                    results.push(includeKeys ? cursor : cursor.value);
	                    if (count && results.length >= count) {
	                        done(results);
	                    }
	                    else {
	                        cursor.continue();
	                    }
	                }
	                else {
	                    done(results);
	                }
	            };
	        });
	    }
	    /**
	     * Accepts a list of stores, a transaction type, and a callback and
	     * performs a transaction. A promise is returned that resolves to whatever
	     * value the callback chooses. The callback holds all the transaction logic
	     * and is invoked with two arguments:
	     *   1. The IDBTransaction object
	     *   2. A `done` function, that's used to resolve the promise when
	     *      when the transaction is done, if passed a value, the promise is
	     *      resolved to that value.
	     *
	     * @param {Array<string>} storeNames An array of object store names
	     *     involved in the transaction.
	     * @param {string} type Can be `readonly` or `readwrite`.
	     * @param {!Function} callback
	     * @return {*} The result of the transaction ran by the callback.
	     * @private
	     */
	    async transaction(storeNames, type, callback) {
	        await this.open();
	        return await new Promise((resolve, reject) => {
	            const txn = this._db.transaction(storeNames, type);
	            txn.onabort = () => reject(txn.error);
	            txn.oncomplete = () => resolve();
	            callback(txn, (value) => resolve(value));
	        });
	    }
	    /**
	     * Delegates async to a native IDBObjectStore method.
	     *
	     * @param {string} method The method name.
	     * @param {string} storeName The object store name.
	     * @param {string} type Can be `readonly` or `readwrite`.
	     * @param {...*} args The list of args to pass to the native method.
	     * @return {*} The result of the transaction.
	     * @private
	     */
	    async _call(method, storeName, type, ...args) {
	        const callback = (txn, done) => {
	            const objStore = txn.objectStore(storeName);
	            // TODO(philipwalton): Fix this underlying TS2684 error.
	            // @ts-ignore
	            const request = objStore[method].apply(objStore, args);
	            request.onsuccess = () => done(request.result);
	        };
	        return await this.transaction([storeName], type, callback);
	    }
	    /**
	     * Closes the connection opened by `DBWrapper.open()`. Generally this method
	     * doesn't need to be called since:
	     *   1. It's usually better to keep a connection open since opening
	     *      a new connection is somewhat slow.
	     *   2. Connections are automatically closed when the reference is
	     *      garbage collected.
	     * The primary use case for needing to close a connection is when another
	     * reference (typically in another tab) needs to upgrade it and would be
	     * blocked by the current, open connection.
	     *
	     * @private
	     */
	    close() {
	        if (this._db) {
	            this._db.close();
	            this._db = null;
	        }
	    }
	}
	// Exposed on the prototype to let users modify the default timeout on a
	// per-instance or global basis.
	DBWrapper.prototype.OPEN_TIMEOUT = 2000;
	// Wrap native IDBObjectStore methods according to their mode.
	const methodsToWrap = {
	    readonly: ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],
	    readwrite: ['add', 'put', 'clear', 'delete'],
	};
	for (const [mode, methods] of Object.entries(methodsToWrap)) {
	    for (const method of methods) {
	        if (method in IDBObjectStore.prototype) {
	            // Don't use arrow functions here since we're outside of the class.
	            DBWrapper.prototype[method] =
	                async function (storeName, ...args) {
	                    return await this._call(method, storeName, mode, ...args);
	                };
	        }
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Deletes the database.
	 * Note: this is exported separately from the DBWrapper module because most
	 * usages of IndexedDB in workbox dont need deleting, and this way it can be
	 * reused in tests to delete databases without creating DBWrapper instances.
	 *
	 * @param {string} name The database name.
	 * @private
	 */
	const deleteDatabase = async (name) => {
	    await new Promise((resolve, reject) => {
	        const request = indexedDB.deleteDatabase(name);
	        request.onerror = () => {
	            reject(request.error);
	        };
	        request.onblocked = () => {
	            reject(new Error('Delete blocked'));
	        };
	        request.onsuccess = () => {
	            resolve();
	        };
	    });
	};

	// @ts-ignore
	try {
	    self['workbox:expiration:6.0.2'] && _();
	}
	catch (e) { }

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	const DB_NAME = 'workbox-expiration';
	const OBJECT_STORE_NAME = 'cache-entries';
	const normalizeURL = (unNormalizedUrl) => {
	    const url = new URL(unNormalizedUrl, location.href);
	    url.hash = '';
	    return url.href;
	};
	/**
	 * Returns the timestamp model.
	 *
	 * @private
	 */
	class CacheTimestampsModel {
	    /**
	     *
	     * @param {string} cacheName
	     *
	     * @private
	     */
	    constructor(cacheName) {
	        this._cacheName = cacheName;
	        this._db = new DBWrapper(DB_NAME, 1, {
	            onupgradeneeded: (event) => this._handleUpgrade(event),
	        });
	    }
	    /**
	     * Should perform an upgrade of indexedDB.
	     *
	     * @param {Event} event
	     *
	     * @private
	     */
	    _handleUpgrade(event) {
	        const db = event.target.result;
	        // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we
	        // have to use the `id` keyPath here and create our own values (a
	        // concatenation of `url + cacheName`) instead of simply using
	        // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.
	        const objStore = db.createObjectStore(OBJECT_STORE_NAME, { keyPath: 'id' });
	        // TODO(philipwalton): once we don't have to support EdgeHTML, we can
	        // create a single index with the keyPath `['cacheName', 'timestamp']`
	        // instead of doing both these indexes.
	        objStore.createIndex('cacheName', 'cacheName', { unique: false });
	        objStore.createIndex('timestamp', 'timestamp', { unique: false });
	        // Previous versions of `workbox-expiration` used `this._cacheName`
	        // as the IDBDatabase name.
	        deleteDatabase(this._cacheName);
	    }
	    /**
	     * @param {string} url
	     * @param {number} timestamp
	     *
	     * @private
	     */
	    async setTimestamp(url, timestamp) {
	        url = normalizeURL(url);
	        const entry = {
	            url,
	            timestamp,
	            cacheName: this._cacheName,
	            // Creating an ID from the URL and cache name won't be necessary once
	            // Edge switches to Chromium and all browsers we support work with
	            // array keyPaths.
	            id: this._getId(url),
	        };
	        await this._db.put(OBJECT_STORE_NAME, entry);
	    }
	    /**
	     * Returns the timestamp stored for a given URL.
	     *
	     * @param {string} url
	     * @return {number}
	     *
	     * @private
	     */
	    async getTimestamp(url) {
	        const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));
	        return entry.timestamp;
	    }
	    /**
	     * Iterates through all the entries in the object store (from newest to
	     * oldest) and removes entries once either `maxCount` is reached or the
	     * entry's timestamp is less than `minTimestamp`.
	     *
	     * @param {number} minTimestamp
	     * @param {number} maxCount
	     * @return {Array<string>}
	     *
	     * @private
	     */
	    async expireEntries(minTimestamp, maxCount) {
	        const entriesToDelete = await this._db.transaction(OBJECT_STORE_NAME, 'readwrite', (txn, done) => {
	            const store = txn.objectStore(OBJECT_STORE_NAME);
	            const request = store.index('timestamp').openCursor(null, 'prev');
	            const entriesToDelete = [];
	            let entriesNotDeletedCount = 0;
	            request.onsuccess = () => {
	                const cursor = request.result;
	                if (cursor) {
	                    const result = cursor.value;
	                    // TODO(philipwalton): once we can use a multi-key index, we
	                    // won't have to check `cacheName` here.
	                    if (result.cacheName === this._cacheName) {
	                        // Delete an entry if it's older than the max age or
	                        // if we already have the max number allowed.
	                        if ((minTimestamp && result.timestamp < minTimestamp) ||
	                            (maxCount && entriesNotDeletedCount >= maxCount)) {
	                            // TODO(philipwalton): we should be able to delete the
	                            // entry right here, but doing so causes an iteration
	                            // bug in Safari stable (fixed in TP). Instead we can
	                            // store the keys of the entries to delete, and then
	                            // delete the separate transactions.
	                            // https://github.com/GoogleChrome/workbox/issues/1978
	                            // cursor.delete();
	                            // We only need to return the URL, not the whole entry.
	                            entriesToDelete.push(cursor.value);
	                        }
	                        else {
	                            entriesNotDeletedCount++;
	                        }
	                    }
	                    cursor.continue();
	                }
	                else {
	                    done(entriesToDelete);
	                }
	            };
	        });
	        // TODO(philipwalton): once the Safari bug in the following issue is fixed,
	        // we should be able to remove this loop and do the entry deletion in the
	        // cursor loop above:
	        // https://github.com/GoogleChrome/workbox/issues/1978
	        const urlsDeleted = [];
	        for (const entry of entriesToDelete) {
	            await this._db.delete(OBJECT_STORE_NAME, entry.id);
	            urlsDeleted.push(entry.url);
	        }
	        return urlsDeleted;
	    }
	    /**
	     * Takes a URL and returns an ID that will be unique in the object store.
	     *
	     * @param {string} url
	     * @return {string}
	     *
	     * @private
	     */
	    _getId(url) {
	        // Creating an ID from the URL and cache name won't be necessary once
	        // Edge switches to Chromium and all browsers we support work with
	        // array keyPaths.
	        return this._cacheName + '|' + normalizeURL(url);
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * The `CacheExpiration` class allows you define an expiration and / or
	 * limit on the number of responses stored in a
	 * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).
	 *
	 * @memberof module:workbox-expiration
	 */
	class CacheExpiration {
	    /**
	     * To construct a new CacheExpiration instance you must provide at least
	     * one of the `config` properties.
	     *
	     * @param {string} cacheName Name of the cache to apply restrictions to.
	     * @param {Object} config
	     * @param {number} [config.maxEntries] The maximum number of entries to cache.
	     * Entries used the least will be removed as the maximum is reached.
	     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before
	     * it's treated as stale and removed.
	     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)
	     * that will be used when calling `delete()` on the cache.
	     */
	    constructor(cacheName, config = {}) {
	        this._isRunning = false;
	        this._rerunRequested = false;
	        {
	            finalAssertExports.isType(cacheName, 'string', {
	                moduleName: 'workbox-expiration',
	                className: 'CacheExpiration',
	                funcName: 'constructor',
	                paramName: 'cacheName',
	            });
	            if (!(config.maxEntries || config.maxAgeSeconds)) {
	                throw new WorkboxError('max-entries-or-age-required', {
	                    moduleName: 'workbox-expiration',
	                    className: 'CacheExpiration',
	                    funcName: 'constructor',
	                });
	            }
	            if (config.maxEntries) {
	                finalAssertExports.isType(config.maxEntries, 'number', {
	                    moduleName: 'workbox-expiration',
	                    className: 'CacheExpiration',
	                    funcName: 'constructor',
	                    paramName: 'config.maxEntries',
	                });
	            }
	            if (config.maxAgeSeconds) {
	                finalAssertExports.isType(config.maxAgeSeconds, 'number', {
	                    moduleName: 'workbox-expiration',
	                    className: 'CacheExpiration',
	                    funcName: 'constructor',
	                    paramName: 'config.maxAgeSeconds',
	                });
	            }
	        }
	        this._maxEntries = config.maxEntries;
	        this._maxAgeSeconds = config.maxAgeSeconds;
	        this._matchOptions = config.matchOptions;
	        this._cacheName = cacheName;
	        this._timestampModel = new CacheTimestampsModel(cacheName);
	    }
	    /**
	     * Expires entries for the given cache and given criteria.
	     */
	    async expireEntries() {
	        if (this._isRunning) {
	            this._rerunRequested = true;
	            return;
	        }
	        this._isRunning = true;
	        const minTimestamp = this._maxAgeSeconds ?
	            Date.now() - (this._maxAgeSeconds * 1000) : 0;
	        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);
	        // Delete URLs from the cache
	        const cache = await self.caches.open(this._cacheName);
	        for (const url of urlsExpired) {
	            await cache.delete(url, this._matchOptions);
	        }
	        {
	            if (urlsExpired.length > 0) {
	                logger.groupCollapsed(`Expired ${urlsExpired.length} ` +
	                    `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +
	                    `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +
	                    `'${this._cacheName}' cache.`);
	                logger.log(`Expired the following ${urlsExpired.length === 1 ?
                    'URL' : 'URLs'}:`);
	                urlsExpired.forEach((url) => logger.log(`    ${url}`));
	                logger.groupEnd();
	            }
	            else {
	                logger.debug(`Cache expiration ran and found no entries to remove.`);
	            }
	        }
	        this._isRunning = false;
	        if (this._rerunRequested) {
	            this._rerunRequested = false;
	            dontWaitFor(this.expireEntries());
	        }
	    }
	    /**
	     * Update the timestamp for the given URL. This ensures the when
	     * removing entries based on maximum entries, most recently used
	     * is accurate or when expiring, the timestamp is up-to-date.
	     *
	     * @param {string} url
	     */
	    async updateTimestamp(url) {
	        {
	            finalAssertExports.isType(url, 'string', {
	                moduleName: 'workbox-expiration',
	                className: 'CacheExpiration',
	                funcName: 'updateTimestamp',
	                paramName: 'url',
	            });
	        }
	        await this._timestampModel.setTimestamp(url, Date.now());
	    }
	    /**
	     * Can be used to check if a URL has expired or not before it's used.
	     *
	     * This requires a look up from IndexedDB, so can be slow.
	     *
	     * Note: This method will not remove the cached entry, call
	     * `expireEntries()` to remove indexedDB and Cache entries.
	     *
	     * @param {string} url
	     * @return {boolean}
	     */
	    async isURLExpired(url) {
	        if (!this._maxAgeSeconds) {
	            {
	                throw new WorkboxError(`expired-test-without-max-age`, {
	                    methodName: 'isURLExpired',
	                    paramName: 'maxAgeSeconds',
	                });
	            }
	        }
	        else {
	            const timestamp = await this._timestampModel.getTimestamp(url);
	            const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);
	            return (timestamp < expireOlderThan);
	        }
	    }
	    /**
	     * Removes the IndexedDB object store used to keep track of cache expiration
	     * metadata.
	     */
	    async delete() {
	        // Make sure we don't attempt another rerun if we're called in the middle of
	        // a cache expiration.
	        this._rerunRequested = false;
	        await this._timestampModel.expireEntries(Infinity); // Expires all.
	    }
	}

	/*
	  Copyright 2019 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * Adds a function to the set of quotaErrorCallbacks that will be executed if
	 * there's a quota error.
	 *
	 * @param {Function} callback
	 * @memberof module:workbox-core
	 */
	function registerQuotaErrorCallback(callback) {
	    {
	        finalAssertExports.isType(callback, 'function', {
	            moduleName: 'workbox-core',
	            funcName: 'register',
	            paramName: 'callback',
	        });
	    }
	    quotaErrorCallbacks.add(callback);
	    {
	        logger.log('Registered a callback to respond to quota errors.', callback);
	    }
	}

	/*
	  Copyright 2018 Google LLC

	  Use of this source code is governed by an MIT-style
	  license that can be found in the LICENSE file or at
	  https://opensource.org/licenses/MIT.
	*/
	/**
	 * This plugin can be used in a `workbox-strategy` to regularly enforce a
	 * limit on the age and / or the number of cached requests.
	 *
	 * It can only be used with `workbox-strategy` instances that have a
	 * [custom `cacheName` property set](/web/tools/workbox/guides/configure-workbox#custom_cache_names_in_strategies).
	 * In other words, it can't be used to expire entries in strategy that uses the
	 * default runtime cache name.
	 *
	 * Whenever a cached request is used or updated, this plugin will look
	 * at the associated cache and remove any old or extra requests.
	 *
	 * When using `maxAgeSeconds`, requests may be used *once* after expiring
	 * because the expiration clean up will not have occurred until *after* the
	 * cached request has been used. If the request has a "Date" header, then
	 * a light weight expiration check is performed and the request will not be
	 * used immediately.
	 *
	 * When using `maxEntries`, the entry least-recently requested will be removed
	 * from the cache first.
	 *
	 * @memberof module:workbox-expiration
	 */
	class ExpirationPlugin {
	    /**
	     * @param {Object} config
	     * @param {number} [config.maxEntries] The maximum number of entries to cache.
	     * Entries used the least will be removed as the maximum is reached.
	     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before
	     * it's treated as stale and removed.
	     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)
	     * that will be used when calling `delete()` on the cache.
	     * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to
	     * automatic deletion if the available storage quota has been exceeded.
	     */
	    constructor(config = {}) {
	        /**
	         * A "lifecycle" callback that will be triggered automatically by the
	         * `workbox-strategies` handlers when a `Response` is about to be returned
	         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to
	         * the handler. It allows the `Response` to be inspected for freshness and
	         * prevents it from being used if the `Response`'s `Date` header value is
	         * older than the configured `maxAgeSeconds`.
	         *
	         * @param {Object} options
	         * @param {string} options.cacheName Name of the cache the response is in.
	         * @param {Response} options.cachedResponse The `Response` object that's been
	         *     read from a cache and whose freshness should be checked.
	         * @return {Response} Either the `cachedResponse`, if it's
	         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.
	         *
	         * @private
	         */
	        this.cachedResponseWillBeUsed = async ({ event, request, cacheName, cachedResponse }) => {
	            if (!cachedResponse) {
	                return null;
	            }
	            const isFresh = this._isResponseDateFresh(cachedResponse);
	            // Expire entries to ensure that even if the expiration date has
	            // expired, it'll only be used once.
	            const cacheExpiration = this._getCacheExpiration(cacheName);
	            dontWaitFor(cacheExpiration.expireEntries());
	            // Update the metadata for the request URL to the current timestamp,
	            // but don't `await` it as we don't want to block the response.
	            const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);
	            if (event) {
	                try {
	                    event.waitUntil(updateTimestampDone);
	                }
	                catch (error) {
	                    {
	                        // The event may not be a fetch event; only log the URL if it is.
	                        if ('request' in event) {
	                            logger.warn(`Unable to ensure service worker stays alive when ` +
	                                `updating cache entry for ` +
	                                `'${getFriendlyURL(event.request.url)}'.`);
	                        }
	                    }
	                }
	            }
	            return isFresh ? cachedResponse : null;
	        };
	        /**
	         * A "lifecycle" callback that will be triggered automatically by the
	         * `workbox-strategies` handlers when an entry is added to a cache.
	         *
	         * @param {Object} options
	         * @param {string} options.cacheName Name of the cache that was updated.
	         * @param {string} options.request The Request for the cached entry.
	         *
	         * @private
	         */
	        this.cacheDidUpdate = async ({ cacheName, request }) => {
	            {
	                finalAssertExports.isType(cacheName, 'string', {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'cacheDidUpdate',
	                    paramName: 'cacheName',
	                });
	                finalAssertExports.isInstance(request, Request, {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'cacheDidUpdate',
	                    paramName: 'request',
	                });
	            }
	            const cacheExpiration = this._getCacheExpiration(cacheName);
	            await cacheExpiration.updateTimestamp(request.url);
	            await cacheExpiration.expireEntries();
	        };
	        {
	            if (!(config.maxEntries || config.maxAgeSeconds)) {
	                throw new WorkboxError('max-entries-or-age-required', {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'constructor',
	                });
	            }
	            if (config.maxEntries) {
	                finalAssertExports.isType(config.maxEntries, 'number', {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'constructor',
	                    paramName: 'config.maxEntries',
	                });
	            }
	            if (config.maxAgeSeconds) {
	                finalAssertExports.isType(config.maxAgeSeconds, 'number', {
	                    moduleName: 'workbox-expiration',
	                    className: 'Plugin',
	                    funcName: 'constructor',
	                    paramName: 'config.maxAgeSeconds',
	                });
	            }
	        }
	        this._config = config;
	        this._maxAgeSeconds = config.maxAgeSeconds;
	        this._cacheExpirations = new Map();
	        if (config.purgeOnQuotaError) {
	            registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());
	        }
	    }
	    /**
	     * A simple helper method to return a CacheExpiration instance for a given
	     * cache name.
	     *
	     * @param {string} cacheName
	     * @return {CacheExpiration}
	     *
	     * @private
	     */
	    _getCacheExpiration(cacheName) {
	        if (cacheName === cacheNames.getRuntimeName()) {
	            throw new WorkboxError('expire-custom-caches-only');
	        }
	        let cacheExpiration = this._cacheExpirations.get(cacheName);
	        if (!cacheExpiration) {
	            cacheExpiration = new CacheExpiration(cacheName, this._config);
	            this._cacheExpirations.set(cacheName, cacheExpiration);
	        }
	        return cacheExpiration;
	    }
	    /**
	     * @param {Response} cachedResponse
	     * @return {boolean}
	     *
	     * @private
	     */
	    _isResponseDateFresh(cachedResponse) {
	        if (!this._maxAgeSeconds) {
	            // We aren't expiring by age, so return true, it's fresh
	            return true;
	        }
	        // Check if the 'date' header will suffice a quick expiration check.
	        // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for
	        // discussion.
	        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);
	        if (dateHeaderTimestamp === null) {
	            // Unable to parse date, so assume it's fresh.
	            return true;
	        }
	        // If we have a valid headerTime, then our response is fresh iff the
	        // headerTime plus maxAgeSeconds is greater than the current time.
	        const now = Date.now();
	        return dateHeaderTimestamp >= now - (this._maxAgeSeconds * 1000);
	    }
	    /**
	     * This method will extract the data header and parse it into a useful
	     * value.
	     *
	     * @param {Response} cachedResponse
	     * @return {number|null}
	     *
	     * @private
	     */
	    _getDateHeaderTimestamp(cachedResponse) {
	        if (!cachedResponse.headers.has('date')) {
	            return null;
	        }
	        const dateHeader = cachedResponse.headers.get('date');
	        const parsedDate = new Date(dateHeader);
	        const headerTime = parsedDate.getTime();
	        // If the Date header was invalid for some reason, parsedDate.getTime()
	        // will return NaN.
	        if (isNaN(headerTime)) {
	            return null;
	        }
	        return headerTime;
	    }
	    /**
	     * This is a helper method that performs two operations:
	     *
	     * - Deletes *all* the underlying Cache instances associated with this plugin
	     * instance, by calling caches.delete() on your behalf.
	     * - Deletes the metadata from IndexedDB used to keep track of expiration
	     * details for each Cache instance.
	     *
	     * When using cache expiration, calling this method is preferable to calling
	     * `caches.delete()` directly, since this will ensure that the IndexedDB
	     * metadata is also cleanly removed and open IndexedDB instances are deleted.
	     *
	     * Note that if you're *not* using cache expiration for a given cache, calling
	     * `caches.delete()` and passing in the cache's name should be sufficient.
	     * There is no Workbox-specific method needed for cleanup in that case.
	     */
	    async deleteCacheAndMetadata() {
	        // Do this one at a time instead of all at once via `Promise.all()` to
	        // reduce the chance of inconsistency if a promise rejects.
	        for (const [cacheName, cacheExpiration] of this._cacheExpirations) {
	            await self.caches.delete(cacheName);
	            await cacheExpiration.delete();
	        }
	        // Reset this._cacheExpirations to its initial state.
	        this._cacheExpirations = new Map();
	    }
	}

	self.__WB_DISABLE_DEV_LOGS = true;

	precacheAndRoute(shell);
	precacheAndRoute(files);

	registerRoute(
	/* eslint-disable-next-line */
	  new RegExp('https:\/\/producteursagri\.opendatasoft\.com'),
	  new CacheFirst({
	    cacheName: `ods-requests-${timestamp}`,
	    plugins: [
	      new ExpirationPlugin({
	        maxEntries: 50,
	        maxAgeSeconds: 3600 * 24,
	      }),
	    ],
	  }),
	);

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VydmljZS13b3JrZXIuanMiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ub2RlX21vZHVsZXMvQHNhcHBlci9zZXJ2aWNlLXdvcmtlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvX3ZlcnNpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL21vZGVscy9tZXNzYWdlcy9tZXNzYWdlcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvbW9kZWxzL21lc3NhZ2VzL21lc3NhZ2VHZW5lcmF0b3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtY29yZS9fcHJpdmF0ZS9jYWNoZU5hbWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL3dhaXRVbnRpbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXByZWNhY2hpbmcvX3ZlcnNpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL2NyZWF0ZUNhY2hlS2V5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy91dGlscy9QcmVjYWNoZUluc3RhbGxSZXBvcnRQbHVnaW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL1ByZWNhY2hlQ2FjaGVLZXlQbHVnaW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL3ByaW50Q2xlYW51cERldGFpbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL3ByaW50SW5zdGFsbERldGFpbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL2NhbkNvbnN0cnVjdFJlc3BvbnNlRnJvbUJvZHlTdHJlYW0uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL2NvcHlSZXNwb25zZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL2NhY2hlTWF0Y2hJZ25vcmVQYXJhbXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL0RlZmVycmVkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtY29yZS9tb2RlbHMvcXVvdGFFcnJvckNhbGxiYWNrcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWNvcmUvX3ByaXZhdGUvZXhlY3V0ZVF1b3RhRXJyb3JDYWxsYmFja3MuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL3RpbWVvdXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1zdHJhdGVnaWVzL192ZXJzaW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtc3RyYXRlZ2llcy9TdHJhdGVneUhhbmRsZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1zdHJhdGVnaWVzL1N0cmF0ZWd5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy9QcmVjYWNoZVN0cmF0ZWd5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy9QcmVjYWNoZUNvbnRyb2xsZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL2dldE9yQ3JlYXRlUHJlY2FjaGVDb250cm9sbGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcm91dGluZy9fdmVyc2lvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXJvdXRpbmcvdXRpbHMvY29uc3RhbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcm91dGluZy91dGlscy9ub3JtYWxpemVIYW5kbGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcm91dGluZy9Sb3V0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXJvdXRpbmcvUmVnRXhwUm91dGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1yb3V0aW5nL1JvdXRlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXJvdXRpbmcvdXRpbHMvZ2V0T3JDcmVhdGVEZWZhdWx0Um91dGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcm91dGluZy9yZWdpc3RlclJvdXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy91dGlscy9yZW1vdmVJZ25vcmVkU2VhcmNoUGFyYW1zLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy91dGlscy9nZW5lcmF0ZVVSTFZhcmlhdGlvbnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL1ByZWNhY2hlUm91dGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1wcmVjYWNoaW5nL2FkZFJvdXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtcHJlY2FjaGluZy9wcmVjYWNoZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXByZWNhY2hpbmcvcHJlY2FjaGVBbmRSb3V0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LXN0cmF0ZWdpZXMvdXRpbHMvbWVzc2FnZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1zdHJhdGVnaWVzL0NhY2hlRmlyc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL2RvbnRXYWl0Rm9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtY29yZS9fcHJpdmF0ZS9EQldyYXBwZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL19wcml2YXRlL2RlbGV0ZURhdGFiYXNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtZXhwaXJhdGlvbi9fdmVyc2lvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93b3JrYm94LWV4cGlyYXRpb24vbW9kZWxzL0NhY2hlVGltZXN0YW1wc01vZGVsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtZXhwaXJhdGlvbi9DYWNoZUV4cGlyYXRpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd29ya2JveC1jb3JlL3JlZ2lzdGVyUXVvdGFFcnJvckNhbGxiYWNrLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtib3gtZXhwaXJhdGlvbi9FeHBpcmF0aW9uUGx1Z2luLmpzIiwiLi4vLi4vc3JjL3NlcnZpY2Utd29ya2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgU2FwcGVyIOKAlCBkbyBub3QgZWRpdCBpdCFcbmV4cG9ydCBjb25zdCB0aW1lc3RhbXAgPSAxNjA4MTgyODQ3NTg1O1xuXG5leHBvcnQgY29uc3QgZmlsZXMgPSBbXG5cdFwiL3NlcnZpY2Utd29ya2VyLWluZGV4Lmh0bWxcIixcblx0XCIvcmVzb3VyY2VzL2FuZHJvaWQtY2hyb21lLTE5MngxOTIucG5nXCIsXG5cdFwiL3Jlc291cmNlcy9hbmRyb2lkLWNocm9tZS01MTJ4NTEyLnBuZ1wiLFxuXHRcIi9yZXNvdXJjZXMvYXBwbGUtdG91Y2gtaWNvbi5wbmdcIixcblx0XCIvcmVzb3VyY2VzL2Jyb3dzZXJjb25maWcueG1sXCIsXG5cdFwiL3Jlc291cmNlcy9mYXZpY29uLTE2eDE2LnBuZ1wiLFxuXHRcIi9yZXNvdXJjZXMvZmF2aWNvbi0zMngzMi5wbmdcIixcblx0XCIvcmVzb3VyY2VzL2Zhdmljb24uaWNvXCIsXG5cdFwiL3Jlc291cmNlcy9mYXZpY29uLnBuZ1wiLFxuXHRcIi9yZXNvdXJjZXMvZ2xvYmFsLmNzc1wiLFxuXHRcIi9yZXNvdXJjZXMvbG9jYXRpb24uc3ZnXCIsXG5cdFwiL3Jlc291cmNlcy9sb2dvLTE5Mi5wbmdcIixcblx0XCIvcmVzb3VyY2VzL2xvZ28tNTEyLnBuZ1wiLFxuXHRcIi9yZXNvdXJjZXMvbWFuaWZlc3Qud2VibWFuaWZlc3RcIixcblx0XCIvcmVzb3VyY2VzL21zdGlsZS0xNDR4MTQ0LnBuZ1wiLFxuXHRcIi9yZXNvdXJjZXMvbXN0aWxlLTE1MHgxNTAucG5nXCIsXG5cdFwiL3Jlc291cmNlcy9tc3RpbGUtMzEweDE1MC5wbmdcIixcblx0XCIvcmVzb3VyY2VzL21zdGlsZS0zMTB4MzEwLnBuZ1wiLFxuXHRcIi9yZXNvdXJjZXMvbXN0aWxlLTcweDcwLnBuZ1wiLFxuXHRcIi9yZXNvdXJjZXMvc2FmYXJpLXBpbm5lZC10YWIuc3ZnXCJcbl07XG5leHBvcnQgeyBmaWxlcyBhcyBhc3NldHMgfTsgLy8gbGVnYWN5XG5cbmV4cG9ydCBjb25zdCBzaGVsbCA9IFtcblx0XCIvY2xpZW50L2NsaWVudC5mMDQ5YTA0YS5qc1wiLFxuXHRcIi9jbGllbnQvaW5qZWN0X3N0eWxlcy41NjA3YWVjNi5qc1wiLFxuXHRcIi9jbGllbnQvaW5kZXguYjM0MTQ3ODYuanNcIixcblx0XCIvY2xpZW50L0dlb2NvZGVyLjg3ZDNhNmUzLmpzXCIsXG5cdFwiL2NsaWVudC9wYXJ0bmVycy5hMmMzMzdjMC5qc1wiLFxuXHRcIi9jbGllbnQvYWJvdXQuMDQ0MjcyMDMuanNcIixcblx0XCIvY2xpZW50L2luZGV4LjIyMDYyOWM1LmpzXCIsXG5cdFwiL2NsaWVudC9baWRdLmQ4ZGE5ZTk3LmpzXCIsXG5cdFwiL2NsaWVudC9fY29tbW9uanNIZWxwZXJzLjkxNTgzY2NiLmpzXCIsXG5cdFwiL2NsaWVudC9zYXBwZXItZGV2LWNsaWVudC4xZTdhNGE1ZS5qc1wiLFxuXHRcIi9jbGllbnQvYXV0b0NvbXBsZXRlLm1pbi44NjM3OGRhOC5qc1wiXG5dO1xuXG5leHBvcnQgY29uc3Qgcm91dGVzID0gW1xuXHR7IHBhdHRlcm46IC9eXFwvJC8gfSxcblx0eyBwYXR0ZXJuOiAvXlxcL3BhcnRuZXJzXFwvPyQvIH0sXG5cdHsgcGF0dGVybjogL15cXC9hYm91dFxcLz8kLyB9LFxuXHR7IHBhdHRlcm46IC9eXFwvZmFybXNcXC8/JC8gfSxcblx0eyBwYXR0ZXJuOiAvXlxcL2Zhcm1zXFwvKFteL10rPylcXC8/JC8gfVxuXTsiLCJcInVzZSBzdHJpY3RcIjtcbi8vIEB0cy1pZ25vcmVcbnRyeSB7XG4gICAgc2VsZlsnd29ya2JveDpjb3JlOjYuMC4yJ10gJiYgXygpO1xufVxuY2F0Y2ggKGUpIHsgfVxuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi8uLi9fdmVyc2lvbi5qcyc7XG5leHBvcnQgY29uc3QgbWVzc2FnZXMgPSB7XG4gICAgJ2ludmFsaWQtdmFsdWUnOiAoeyBwYXJhbU5hbWUsIHZhbGlkVmFsdWVEZXNjcmlwdGlvbiwgdmFsdWUgfSkgPT4ge1xuICAgICAgICBpZiAoIXBhcmFtTmFtZSB8fCAhdmFsaWRWYWx1ZURlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ2ludmFsaWQtdmFsdWUnIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgVGhlICcke3BhcmFtTmFtZX0nIHBhcmFtZXRlciB3YXMgZ2l2ZW4gYSB2YWx1ZSB3aXRoIGFuIGAgK1xuICAgICAgICAgICAgYHVuZXhwZWN0ZWQgdmFsdWUuICR7dmFsaWRWYWx1ZURlc2NyaXB0aW9ufSBSZWNlaXZlZCBhIHZhbHVlIG9mIGAgK1xuICAgICAgICAgICAgYCR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfS5gO1xuICAgIH0sXG4gICAgJ25vdC1hbi1hcnJheSc6ICh7IG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUsIHBhcmFtTmFtZSB9KSA9PiB7XG4gICAgICAgIGlmICghbW9kdWxlTmFtZSB8fCAhY2xhc3NOYW1lIHx8ICFmdW5jTmFtZSB8fCAhcGFyYW1OYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ25vdC1hbi1hcnJheScgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBUaGUgcGFyYW1ldGVyICcke3BhcmFtTmFtZX0nIHBhc3NlZCBpbnRvIGAgK1xuICAgICAgICAgICAgYCcke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lfS4ke2Z1bmNOYW1lfSgpJyBtdXN0IGJlIGFuIGFycmF5LmA7XG4gICAgfSxcbiAgICAnaW5jb3JyZWN0LXR5cGUnOiAoeyBleHBlY3RlZFR5cGUsIHBhcmFtTmFtZSwgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSB9KSA9PiB7XG4gICAgICAgIGlmICghZXhwZWN0ZWRUeXBlIHx8ICFwYXJhbU5hbWUgfHwgIW1vZHVsZU5hbWUgfHwgIWZ1bmNOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ2luY29ycmVjdC10eXBlJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFRoZSBwYXJhbWV0ZXIgJyR7cGFyYW1OYW1lfScgcGFzc2VkIGludG8gYCArXG4gICAgICAgICAgICBgJyR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWUgPyAoY2xhc3NOYW1lICsgJy4nKSA6ICcnfWAgK1xuICAgICAgICAgICAgYCR7ZnVuY05hbWV9KCknIG11c3QgYmUgb2YgdHlwZSAke2V4cGVjdGVkVHlwZX0uYDtcbiAgICB9LFxuICAgICdpbmNvcnJlY3QtY2xhc3MnOiAoeyBleHBlY3RlZENsYXNzLCBwYXJhbU5hbWUsIG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUsIGlzUmV0dXJuVmFsdWVQcm9ibGVtIH0pID0+IHtcbiAgICAgICAgaWYgKCFleHBlY3RlZENsYXNzIHx8ICFtb2R1bGVOYW1lIHx8ICFmdW5jTmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0IHRvICdpbmNvcnJlY3QtY2xhc3MnIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1JldHVyblZhbHVlUHJvYmxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGBUaGUgcmV0dXJuIHZhbHVlIGZyb20gYCArXG4gICAgICAgICAgICAgICAgYCcke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lID8gKGNsYXNzTmFtZSArICcuJykgOiAnJ30ke2Z1bmNOYW1lfSgpJyBgICtcbiAgICAgICAgICAgICAgICBgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBjbGFzcyAke2V4cGVjdGVkQ2xhc3MubmFtZX0uYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFRoZSBwYXJhbWV0ZXIgJyR7cGFyYW1OYW1lfScgcGFzc2VkIGludG8gYCArXG4gICAgICAgICAgICBgJyR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWUgPyAoY2xhc3NOYW1lICsgJy4nKSA6ICcnfSR7ZnVuY05hbWV9KCknIGAgK1xuICAgICAgICAgICAgYG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgY2xhc3MgJHtleHBlY3RlZENsYXNzLm5hbWV9LmA7XG4gICAgfSxcbiAgICAnbWlzc2luZy1hLW1ldGhvZCc6ICh7IGV4cGVjdGVkTWV0aG9kLCBwYXJhbU5hbWUsIG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUgfSkgPT4ge1xuICAgICAgICBpZiAoIWV4cGVjdGVkTWV0aG9kIHx8ICFwYXJhbU5hbWUgfHwgIW1vZHVsZU5hbWUgfHwgIWNsYXNzTmFtZVxuICAgICAgICAgICAgfHwgIWZ1bmNOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ21pc3NpbmctYS1tZXRob2QnIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHttb2R1bGVOYW1lfS4ke2NsYXNzTmFtZX0uJHtmdW5jTmFtZX0oKSBleHBlY3RlZCB0aGUgYCArXG4gICAgICAgICAgICBgJyR7cGFyYW1OYW1lfScgcGFyYW1ldGVyIHRvIGV4cG9zZSBhICcke2V4cGVjdGVkTWV0aG9kfScgbWV0aG9kLmA7XG4gICAgfSxcbiAgICAnYWRkLXRvLWNhY2hlLWxpc3QtdW5leHBlY3RlZC10eXBlJzogKHsgZW50cnkgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYEFuIHVuZXhwZWN0ZWQgZW50cnkgd2FzIHBhc3NlZCB0byBgICtcbiAgICAgICAgICAgIGAnd29ya2JveC1wcmVjYWNoaW5nLlByZWNhY2hlQ29udHJvbGxlci5hZGRUb0NhY2hlTGlzdCgpJyBUaGUgZW50cnkgYCArXG4gICAgICAgICAgICBgJyR7SlNPTi5zdHJpbmdpZnkoZW50cnkpfScgaXNuJ3Qgc3VwcG9ydGVkLiBZb3UgbXVzdCBzdXBwbHkgYW4gYXJyYXkgb2YgYCArXG4gICAgICAgICAgICBgc3RyaW5ncyB3aXRoIG9uZSBvciBtb3JlIGNoYXJhY3RlcnMsIG9iamVjdHMgd2l0aCBhIHVybCBwcm9wZXJ0eSBvciBgICtcbiAgICAgICAgICAgIGBSZXF1ZXN0IG9iamVjdHMuYDtcbiAgICB9LFxuICAgICdhZGQtdG8tY2FjaGUtbGlzdC1jb25mbGljdGluZy1lbnRyaWVzJzogKHsgZmlyc3RFbnRyeSwgc2Vjb25kRW50cnkgfSkgPT4ge1xuICAgICAgICBpZiAoIWZpcnN0RW50cnkgfHwgIXNlY29uZEVudHJ5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gYCArXG4gICAgICAgICAgICAgICAgYCdhZGQtdG8tY2FjaGUtbGlzdC1kdXBsaWNhdGUtZW50cmllcycgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBUd28gb2YgdGhlIGVudHJpZXMgcGFzc2VkIHRvIGAgK1xuICAgICAgICAgICAgYCd3b3JrYm94LXByZWNhY2hpbmcuUHJlY2FjaGVDb250cm9sbGVyLmFkZFRvQ2FjaGVMaXN0KCknIGhhZCB0aGUgVVJMIGAgK1xuICAgICAgICAgICAgYCR7Zmlyc3RFbnRyeS5fZW50cnlJZH0gYnV0IGRpZmZlcmVudCByZXZpc2lvbiBkZXRhaWxzLiBXb3JrYm94IGlzIGAgK1xuICAgICAgICAgICAgYHVuYWJsZSB0byBjYWNoZSBhbmQgdmVyc2lvbiB0aGUgYXNzZXQgY29ycmVjdGx5LiBQbGVhc2UgcmVtb3ZlIG9uZSBgICtcbiAgICAgICAgICAgIGBvZiB0aGUgZW50cmllcy5gO1xuICAgIH0sXG4gICAgJ3BsdWdpbi1lcnJvci1yZXF1ZXN0LXdpbGwtZmV0Y2gnOiAoeyB0aHJvd25FcnJvciB9KSA9PiB7XG4gICAgICAgIGlmICghdGhyb3duRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byBgICtcbiAgICAgICAgICAgICAgICBgJ3BsdWdpbi1lcnJvci1yZXF1ZXN0LXdpbGwtZmV0Y2gnLCBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYEFuIGVycm9yIHdhcyB0aHJvd24gYnkgYSBwbHVnaW5zICdyZXF1ZXN0V2lsbEZldGNoKCknIG1ldGhvZC4gYCArXG4gICAgICAgICAgICBgVGhlIHRocm93biBlcnJvciBtZXNzYWdlIHdhczogJyR7dGhyb3duRXJyb3IubWVzc2FnZX0nLmA7XG4gICAgfSxcbiAgICAnaW52YWxpZC1jYWNoZS1uYW1lJzogKHsgY2FjaGVOYW1lSWQsIHZhbHVlIH0pID0+IHtcbiAgICAgICAgaWYgKCFjYWNoZU5hbWVJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhICdjYWNoZU5hbWVJZCcgZm9yIGVycm9yICdpbnZhbGlkLWNhY2hlLW5hbWUnYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBZb3UgbXVzdCBwcm92aWRlIGEgbmFtZSBjb250YWluaW5nIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgZm9yIGAgK1xuICAgICAgICAgICAgYHNldENhY2hlRGV0YWlscyh7JHtjYWNoZU5hbWVJZH06ICcuLi4nfSkuIFJlY2VpdmVkIGEgdmFsdWUgb2YgYCArXG4gICAgICAgICAgICBgJyR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSdgO1xuICAgIH0sXG4gICAgJ3VucmVnaXN0ZXItcm91dGUtYnV0LW5vdC1mb3VuZC13aXRoLW1ldGhvZCc6ICh7IG1ldGhvZCB9KSA9PiB7XG4gICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gYCArXG4gICAgICAgICAgICAgICAgYCd1bnJlZ2lzdGVyLXJvdXRlLWJ1dC1ub3QtZm91bmQtd2l0aC1tZXRob2QnIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgVGhlIHJvdXRlIHlvdSdyZSB0cnlpbmcgdG8gdW5yZWdpc3RlciB3YXMgbm90ICBwcmV2aW91c2x5IGAgK1xuICAgICAgICAgICAgYHJlZ2lzdGVyZWQgZm9yIHRoZSBtZXRob2QgdHlwZSAnJHttZXRob2R9Jy5gO1xuICAgIH0sXG4gICAgJ3VucmVnaXN0ZXItcm91dGUtcm91dGUtbm90LXJlZ2lzdGVyZWQnOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBgVGhlIHJvdXRlIHlvdSdyZSB0cnlpbmcgdG8gdW5yZWdpc3RlciB3YXMgbm90IHByZXZpb3VzbHkgYCArXG4gICAgICAgICAgICBgcmVnaXN0ZXJlZC5gO1xuICAgIH0sXG4gICAgJ3F1ZXVlLXJlcGxheS1mYWlsZWQnOiAoeyBuYW1lIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGBSZXBsYXlpbmcgdGhlIGJhY2tncm91bmQgc3luYyBxdWV1ZSAnJHtuYW1lfScgZmFpbGVkLmA7XG4gICAgfSxcbiAgICAnZHVwbGljYXRlLXF1ZXVlLW5hbWUnOiAoeyBuYW1lIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGBUaGUgUXVldWUgbmFtZSAnJHtuYW1lfScgaXMgYWxyZWFkeSBiZWluZyB1c2VkLiBgICtcbiAgICAgICAgICAgIGBBbGwgaW5zdGFuY2VzIG9mIGJhY2tncm91bmRTeW5jLlF1ZXVlIG11c3QgYmUgZ2l2ZW4gdW5pcXVlIG5hbWVzLmA7XG4gICAgfSxcbiAgICAnZXhwaXJlZC10ZXN0LXdpdGhvdXQtbWF4LWFnZSc6ICh7IG1ldGhvZE5hbWUsIHBhcmFtTmFtZSB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgVGhlICcke21ldGhvZE5hbWV9KCknIG1ldGhvZCBjYW4gb25seSBiZSB1c2VkIHdoZW4gdGhlIGAgK1xuICAgICAgICAgICAgYCcke3BhcmFtTmFtZX0nIGlzIHVzZWQgaW4gdGhlIGNvbnN0cnVjdG9yLmA7XG4gICAgfSxcbiAgICAndW5zdXBwb3J0ZWQtcm91dGUtdHlwZSc6ICh7IG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUsIHBhcmFtTmFtZSB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgVGhlIHN1cHBsaWVkICcke3BhcmFtTmFtZX0nIHBhcmFtZXRlciB3YXMgYW4gdW5zdXBwb3J0ZWQgdHlwZS4gYCArXG4gICAgICAgICAgICBgUGxlYXNlIGNoZWNrIHRoZSBkb2NzIGZvciAke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lfS4ke2Z1bmNOYW1lfSBmb3IgYCArXG4gICAgICAgICAgICBgdmFsaWQgaW5wdXQgdHlwZXMuYDtcbiAgICB9LFxuICAgICdub3QtYXJyYXktb2YtY2xhc3MnOiAoeyB2YWx1ZSwgZXhwZWN0ZWRDbGFzcywgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSwgcGFyYW1OYW1lIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGBUaGUgc3VwcGxpZWQgJyR7cGFyYW1OYW1lfScgcGFyYW1ldGVyIG11c3QgYmUgYW4gYXJyYXkgb2YgYCArXG4gICAgICAgICAgICBgJyR7ZXhwZWN0ZWRDbGFzc30nIG9iamVjdHMuIFJlY2VpdmVkICcke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0sJy4gYCArXG4gICAgICAgICAgICBgUGxlYXNlIGNoZWNrIHRoZSBjYWxsIHRvICR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWV9LiR7ZnVuY05hbWV9KCkgYCArXG4gICAgICAgICAgICBgdG8gZml4IHRoZSBpc3N1ZS5gO1xuICAgIH0sXG4gICAgJ21heC1lbnRyaWVzLW9yLWFnZS1yZXF1aXJlZCc6ICh7IG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFlvdSBtdXN0IGRlZmluZSBlaXRoZXIgY29uZmlnLm1heEVudHJpZXMgb3IgY29uZmlnLm1heEFnZVNlY29uZHNgICtcbiAgICAgICAgICAgIGBpbiAke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lfS4ke2Z1bmNOYW1lfWA7XG4gICAgfSxcbiAgICAnc3RhdHVzZXMtb3ItaGVhZGVycy1yZXF1aXJlZCc6ICh7IG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFlvdSBtdXN0IGRlZmluZSBlaXRoZXIgY29uZmlnLnN0YXR1c2VzIG9yIGNvbmZpZy5oZWFkZXJzYCArXG4gICAgICAgICAgICBgaW4gJHttb2R1bGVOYW1lfS4ke2NsYXNzTmFtZX0uJHtmdW5jTmFtZX1gO1xuICAgIH0sXG4gICAgJ2ludmFsaWQtc3RyaW5nJzogKHsgbW9kdWxlTmFtZSwgZnVuY05hbWUsIHBhcmFtTmFtZSB9KSA9PiB7XG4gICAgICAgIGlmICghcGFyYW1OYW1lIHx8ICFtb2R1bGVOYW1lIHx8ICFmdW5jTmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0IHRvICdpbnZhbGlkLXN0cmluZycgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBXaGVuIHVzaW5nIHN0cmluZ3MsIHRoZSAnJHtwYXJhbU5hbWV9JyBwYXJhbWV0ZXIgbXVzdCBzdGFydCB3aXRoIGAgK1xuICAgICAgICAgICAgYCdodHRwJyAoZm9yIGNyb3NzLW9yaWdpbiBtYXRjaGVzKSBvciAnLycgKGZvciBzYW1lLW9yaWdpbiBtYXRjaGVzKS4gYCArXG4gICAgICAgICAgICBgUGxlYXNlIHNlZSB0aGUgZG9jcyBmb3IgJHttb2R1bGVOYW1lfS4ke2Z1bmNOYW1lfSgpIGZvciBgICtcbiAgICAgICAgICAgIGBtb3JlIGluZm8uYDtcbiAgICB9LFxuICAgICdjaGFubmVsLW5hbWUtcmVxdWlyZWQnOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBgWW91IG11c3QgcHJvdmlkZSBhIGNoYW5uZWxOYW1lIHRvIGNvbnN0cnVjdCBhIGAgK1xuICAgICAgICAgICAgYEJyb2FkY2FzdENhY2hlVXBkYXRlIGluc3RhbmNlLmA7XG4gICAgfSxcbiAgICAnaW52YWxpZC1yZXNwb25zZXMtYXJlLXNhbWUtYXJncyc6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGBUaGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIHJlc3BvbnNlc0FyZVNhbWUoKSBhcHBlYXIgdG8gYmUgYCArXG4gICAgICAgICAgICBgaW52YWxpZC4gUGxlYXNlIGVuc3VyZSB2YWxpZCBSZXNwb25zZXMgYXJlIHVzZWQuYDtcbiAgICB9LFxuICAgICdleHBpcmUtY3VzdG9tLWNhY2hlcy1vbmx5JzogKCkgPT4ge1xuICAgICAgICByZXR1cm4gYFlvdSBtdXN0IHByb3ZpZGUgYSAnY2FjaGVOYW1lJyBwcm9wZXJ0eSB3aGVuIHVzaW5nIHRoZSBgICtcbiAgICAgICAgICAgIGBleHBpcmF0aW9uIHBsdWdpbiB3aXRoIGEgcnVudGltZSBjYWNoaW5nIHN0cmF0ZWd5LmA7XG4gICAgfSxcbiAgICAndW5pdC1tdXN0LWJlLWJ5dGVzJzogKHsgbm9ybWFsaXplZFJhbmdlSGVhZGVyIH0pID0+IHtcbiAgICAgICAgaWYgKCFub3JtYWxpemVkUmFuZ2VIZWFkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAndW5pdC1tdXN0LWJlLWJ5dGVzJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFRoZSAndW5pdCcgcG9ydGlvbiBvZiB0aGUgUmFuZ2UgaGVhZGVyIG11c3QgYmUgc2V0IHRvICdieXRlcycuIGAgK1xuICAgICAgICAgICAgYFRoZSBSYW5nZSBoZWFkZXIgcHJvdmlkZWQgd2FzIFwiJHtub3JtYWxpemVkUmFuZ2VIZWFkZXJ9XCJgO1xuICAgIH0sXG4gICAgJ3NpbmdsZS1yYW5nZS1vbmx5JzogKHsgbm9ybWFsaXplZFJhbmdlSGVhZGVyIH0pID0+IHtcbiAgICAgICAgaWYgKCFub3JtYWxpemVkUmFuZ2VIZWFkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAnc2luZ2xlLXJhbmdlLW9ubHknIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgTXVsdGlwbGUgcmFuZ2VzIGFyZSBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIGEgIHNpbmdsZSBzdGFydCBgICtcbiAgICAgICAgICAgIGB2YWx1ZSwgYW5kIG9wdGlvbmFsIGVuZCB2YWx1ZS4gVGhlIFJhbmdlIGhlYWRlciBwcm92aWRlZCB3YXMgYCArXG4gICAgICAgICAgICBgXCIke25vcm1hbGl6ZWRSYW5nZUhlYWRlcn1cImA7XG4gICAgfSxcbiAgICAnaW52YWxpZC1yYW5nZS12YWx1ZXMnOiAoeyBub3JtYWxpemVkUmFuZ2VIZWFkZXIgfSkgPT4ge1xuICAgICAgICBpZiAoIW5vcm1hbGl6ZWRSYW5nZUhlYWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0IHRvICdpbnZhbGlkLXJhbmdlLXZhbHVlcycgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBUaGUgUmFuZ2UgaGVhZGVyIGlzIG1pc3NpbmcgYm90aCBzdGFydCBhbmQgZW5kIHZhbHVlcy4gQXQgbGVhc3QgYCArXG4gICAgICAgICAgICBgb25lIG9mIHRob3NlIHZhbHVlcyBpcyBuZWVkZWQuIFRoZSBSYW5nZSBoZWFkZXIgcHJvdmlkZWQgd2FzIGAgK1xuICAgICAgICAgICAgYFwiJHtub3JtYWxpemVkUmFuZ2VIZWFkZXJ9XCJgO1xuICAgIH0sXG4gICAgJ25vLXJhbmdlLWhlYWRlcic6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGBObyBSYW5nZSBoZWFkZXIgd2FzIGZvdW5kIGluIHRoZSBSZXF1ZXN0IHByb3ZpZGVkLmA7XG4gICAgfSxcbiAgICAncmFuZ2Utbm90LXNhdGlzZmlhYmxlJzogKHsgc2l6ZSwgc3RhcnQsIGVuZCB9KSA9PiB7XG4gICAgICAgIHJldHVybiBgVGhlIHN0YXJ0ICgke3N0YXJ0fSkgYW5kIGVuZCAoJHtlbmR9KSB2YWx1ZXMgaW4gdGhlIFJhbmdlIGFyZSBgICtcbiAgICAgICAgICAgIGBub3Qgc2F0aXNmaWFibGUgYnkgdGhlIGNhY2hlZCByZXNwb25zZSwgd2hpY2ggaXMgJHtzaXplfSBieXRlcy5gO1xuICAgIH0sXG4gICAgJ2F0dGVtcHQtdG8tY2FjaGUtbm9uLWdldC1yZXF1ZXN0JzogKHsgdXJsLCBtZXRob2QgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFVuYWJsZSB0byBjYWNoZSAnJHt1cmx9JyBiZWNhdXNlIGl0IGlzIGEgJyR7bWV0aG9kfScgcmVxdWVzdCBhbmQgYCArXG4gICAgICAgICAgICBgb25seSAnR0VUJyByZXF1ZXN0cyBjYW4gYmUgY2FjaGVkLmA7XG4gICAgfSxcbiAgICAnY2FjaGUtcHV0LXdpdGgtbm8tcmVzcG9uc2UnOiAoeyB1cmwgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFRoZXJlIHdhcyBhbiBhdHRlbXB0IHRvIGNhY2hlICcke3VybH0nIGJ1dCB0aGUgcmVzcG9uc2Ugd2FzIG5vdCBgICtcbiAgICAgICAgICAgIGBkZWZpbmVkLmA7XG4gICAgfSxcbiAgICAnbm8tcmVzcG9uc2UnOiAoeyB1cmwsIGVycm9yIH0pID0+IHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBgVGhlIHN0cmF0ZWd5IGNvdWxkIG5vdCBnZW5lcmF0ZSBhIHJlc3BvbnNlIGZvciAnJHt1cmx9Jy5gO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYCBUaGUgdW5kZXJseWluZyBlcnJvciBpcyAke2Vycm9yfS5gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgJ2JhZC1wcmVjYWNoaW5nLXJlc3BvbnNlJzogKHsgdXJsLCBzdGF0dXMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYFRoZSBwcmVjYWNoaW5nIHJlcXVlc3QgZm9yICcke3VybH0nIGZhaWxlZGAgK1xuICAgICAgICAgICAgKHN0YXR1cyA/IGAgd2l0aCBhbiBIVFRQIHN0YXR1cyBvZiAke3N0YXR1c30uYCA6IGAuYCk7XG4gICAgfSxcbiAgICAnbm9uLXByZWNhY2hlZC11cmwnOiAoeyB1cmwgfSkgPT4ge1xuICAgICAgICByZXR1cm4gYGNyZWF0ZUhhbmRsZXJCb3VuZFRvVVJMKCcke3VybH0nKSB3YXMgY2FsbGVkLCBidXQgdGhhdCBVUkwgaXMgYCArXG4gICAgICAgICAgICBgbm90IHByZWNhY2hlZC4gUGxlYXNlIHBhc3MgaW4gYSBVUkwgdGhhdCBpcyBwcmVjYWNoZWQgaW5zdGVhZC5gO1xuICAgIH0sXG4gICAgJ2FkZC10by1jYWNoZS1saXN0LWNvbmZsaWN0aW5nLWludGVncml0aWVzJzogKHsgdXJsIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGBUd28gb2YgdGhlIGVudHJpZXMgcGFzc2VkIHRvIGAgK1xuICAgICAgICAgICAgYCd3b3JrYm94LXByZWNhY2hpbmcuUHJlY2FjaGVDb250cm9sbGVyLmFkZFRvQ2FjaGVMaXN0KCknIGhhZCB0aGUgVVJMIGAgK1xuICAgICAgICAgICAgYCR7dXJsfSB3aXRoIGRpZmZlcmVudCBpbnRlZ3JpdHkgdmFsdWVzLiBQbGVhc2UgcmVtb3ZlIG9uZSBvZiB0aGVtLmA7XG4gICAgfSxcbiAgICAnbWlzc2luZy1wcmVjYWNoZS1lbnRyeSc6ICh7IGNhY2hlTmFtZSwgdXJsIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGBVbmFibGUgdG8gZmluZCBhIHByZWNhY2hlZCByZXNwb25zZSBpbiAke2NhY2hlTmFtZX0gZm9yICR7dXJsfS5gO1xuICAgIH0sXG4gICAgJ2Nyb3NzLW9yaWdpbi1jb3B5LXJlc3BvbnNlJzogKHsgb3JpZ2luIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGB3b3JrYm94LWNvcmUuY29weVJlc3BvbnNlKCkgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHNhbWUtb3JpZ2luIGAgK1xuICAgICAgICAgICAgYHJlc3BvbnNlcy4gSXQgd2FzIHBhc3NlZCBhIHJlc3BvbnNlIHdpdGggb3JpZ2luICR7b3JpZ2lufS5gO1xuICAgIH0sXG59O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgbWVzc2FnZXMgfSBmcm9tICcuL21lc3NhZ2VzLmpzJztcbmltcG9ydCAnLi4vLi4vX3ZlcnNpb24uanMnO1xuY29uc3QgZmFsbGJhY2sgPSAoY29kZSwgLi4uYXJncykgPT4ge1xuICAgIGxldCBtc2cgPSBjb2RlO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbXNnICs9IGAgOjogJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gO1xuICAgIH1cbiAgICByZXR1cm4gbXNnO1xufTtcbmNvbnN0IGdlbmVyYXRvckZ1bmN0aW9uID0gKGNvZGUsIGRldGFpbHMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tjb2RlXTtcbiAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBtZXNzYWdlIGZvciBjb2RlICcke2NvZGV9Jy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2UoZGV0YWlscyk7XG59O1xuZXhwb3J0IGNvbnN0IG1lc3NhZ2VHZW5lcmF0b3IgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykgP1xuICAgIGZhbGxiYWNrIDogZ2VuZXJhdG9yRnVuY3Rpb247XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBtZXNzYWdlR2VuZXJhdG9yIH0gZnJvbSAnLi4vbW9kZWxzL21lc3NhZ2VzL21lc3NhZ2VHZW5lcmF0b3IuanMnO1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIFdvcmtib3ggZXJyb3JzIHNob3VsZCBiZSB0aHJvd24gd2l0aCB0aGlzIGNsYXNzLlxuICogVGhpcyBhbGxvd3MgdXNlIHRvIGVuc3VyZSB0aGUgdHlwZSBlYXNpbHkgaW4gdGVzdHMsXG4gKiBoZWxwcyBkZXZlbG9wZXJzIGlkZW50aWZ5IGVycm9ycyBmcm9tIHdvcmtib3hcbiAqIGVhc2lseSBhbmQgYWxsb3dzIHVzZSB0byBvcHRpbWlzZSBlcnJvclxuICogbWVzc2FnZXMgY29ycmVjdGx5LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFdvcmtib3hFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlcnJvckNvZGUgVGhlIGVycm9yIGNvZGUgdGhhdFxuICAgICAqIGlkZW50aWZpZXMgdGhpcyBwYXJ0aWN1bGFyIGVycm9yLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZGV0YWlscyBBbnkgcmVsZXZhbnQgYXJndW1lbnRzXG4gICAgICogdGhhdCB3aWxsIGhlbHAgZGV2ZWxvcGVycyBpZGVudGlmeSBpc3N1ZXMgc2hvdWxkXG4gICAgICogYmUgYWRkZWQgYXMgYSBrZXkgb24gdGhlIGNvbnRleHQgb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVycm9yQ29kZSwgZGV0YWlscykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZUdlbmVyYXRvcihlcnJvckNvZGUsIGRldGFpbHMpO1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZXJyb3JDb2RlO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cbn1cbmV4cG9ydCB7IFdvcmtib3hFcnJvciB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgV29ya2JveEVycm9yIH0gZnJvbSAnLi4vX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLypcbiAqIFRoaXMgbWV0aG9kIHRocm93cyBpZiB0aGUgc3VwcGxpZWQgdmFsdWUgaXMgbm90IGFuIGFycmF5LlxuICogVGhlIGRlc3RydWN0ZWQgdmFsdWVzIGFyZSByZXF1aXJlZCB0byBwcm9kdWNlIGEgbWVhbmluZ2Z1bCBlcnJvciBmb3IgdXNlcnMuXG4gKiBUaGUgZGVzdHJ1Y3RlZCBhbmQgcmVzdHJ1Y3R1cmVkIG9iamVjdCBpcyBzbyBpdCdzIGNsZWFyIHdoYXQgaXNcbiAqIG5lZWRlZC5cbiAqL1xuY29uc3QgaXNBcnJheSA9ICh2YWx1ZSwgZGV0YWlscykgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignbm90LWFuLWFycmF5JywgZGV0YWlscyk7XG4gICAgfVxufTtcbmNvbnN0IGhhc01ldGhvZCA9IChvYmplY3QsIGV4cGVjdGVkTWV0aG9kLCBkZXRhaWxzKSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBvYmplY3RbZXhwZWN0ZWRNZXRob2RdO1xuICAgIGlmICh0eXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRldGFpbHNbJ2V4cGVjdGVkTWV0aG9kJ10gPSBleHBlY3RlZE1ldGhvZDtcbiAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignbWlzc2luZy1hLW1ldGhvZCcsIGRldGFpbHMpO1xuICAgIH1cbn07XG5jb25zdCBpc1R5cGUgPSAob2JqZWN0LCBleHBlY3RlZFR5cGUsIGRldGFpbHMpID0+IHtcbiAgICBpZiAodHlwZW9mIG9iamVjdCAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIGRldGFpbHNbJ2V4cGVjdGVkVHlwZSddID0gZXhwZWN0ZWRUeXBlO1xuICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdpbmNvcnJlY3QtdHlwZScsIGRldGFpbHMpO1xuICAgIH1cbn07XG5jb25zdCBpc0luc3RhbmNlID0gKG9iamVjdCwgZXhwZWN0ZWRDbGFzcywgZGV0YWlscykgPT4ge1xuICAgIGlmICghKG9iamVjdCBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIGRldGFpbHNbJ2V4cGVjdGVkQ2xhc3MnXSA9IGV4cGVjdGVkQ2xhc3M7XG4gICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2luY29ycmVjdC1jbGFzcycsIGRldGFpbHMpO1xuICAgIH1cbn07XG5jb25zdCBpc09uZU9mID0gKHZhbHVlLCB2YWxpZFZhbHVlcywgZGV0YWlscykgPT4ge1xuICAgIGlmICghdmFsaWRWYWx1ZXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIGRldGFpbHNbJ3ZhbGlkVmFsdWVEZXNjcmlwdGlvbiddID1cbiAgICAgICAgICAgIGBWYWxpZCB2YWx1ZXMgYXJlICR7SlNPTi5zdHJpbmdpZnkodmFsaWRWYWx1ZXMpfS5gO1xuICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdpbnZhbGlkLXZhbHVlJywgZGV0YWlscyk7XG4gICAgfVxufTtcbmNvbnN0IGlzQXJyYXlPZkNsYXNzID0gKHZhbHVlLCBleHBlY3RlZENsYXNzLCBkZXRhaWxzKSA9PiB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgV29ya2JveEVycm9yKCdub3QtYXJyYXktb2YtY2xhc3MnLCBkZXRhaWxzKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBmaW5hbEFzc2VydEV4cG9ydHMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nID8gbnVsbCA6IHtcbiAgICBoYXNNZXRob2QsXG4gICAgaXNBcnJheSxcbiAgICBpc0luc3RhbmNlLFxuICAgIGlzT25lT2YsXG4gICAgaXNUeXBlLFxuICAgIGlzQXJyYXlPZkNsYXNzLFxufTtcbmV4cG9ydCB7IGZpbmFsQXNzZXJ0RXhwb3J0cyBhcyBhc3NlcnQgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuY29uc3QgX2NhY2hlTmFtZURldGFpbHMgPSB7XG4gICAgZ29vZ2xlQW5hbHl0aWNzOiAnZ29vZ2xlQW5hbHl0aWNzJyxcbiAgICBwcmVjYWNoZTogJ3ByZWNhY2hlLXYyJyxcbiAgICBwcmVmaXg6ICd3b3JrYm94JyxcbiAgICBydW50aW1lOiAncnVudGltZScsXG4gICAgc3VmZml4OiB0eXBlb2YgcmVnaXN0cmF0aW9uICE9PSAndW5kZWZpbmVkJyA/IHJlZ2lzdHJhdGlvbi5zY29wZSA6ICcnLFxufTtcbmNvbnN0IF9jcmVhdGVDYWNoZU5hbWUgPSAoY2FjaGVOYW1lKSA9PiB7XG4gICAgcmV0dXJuIFtfY2FjaGVOYW1lRGV0YWlscy5wcmVmaXgsIGNhY2hlTmFtZSwgX2NhY2hlTmFtZURldGFpbHMuc3VmZml4XVxuICAgICAgICAuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUgJiYgdmFsdWUubGVuZ3RoID4gMClcbiAgICAgICAgLmpvaW4oJy0nKTtcbn07XG5jb25zdCBlYWNoQ2FjaGVOYW1lRGV0YWlsID0gKGZuKSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoX2NhY2hlTmFtZURldGFpbHMpKSB7XG4gICAgICAgIGZuKGtleSk7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBjYWNoZU5hbWVzID0ge1xuICAgIHVwZGF0ZURldGFpbHM6IChkZXRhaWxzKSA9PiB7XG4gICAgICAgIGVhY2hDYWNoZU5hbWVEZXRhaWwoKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXRhaWxzW2tleV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgX2NhY2hlTmFtZURldGFpbHNba2V5XSA9IGRldGFpbHNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRHb29nbGVBbmFseXRpY3NOYW1lOiAodXNlckNhY2hlTmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gdXNlckNhY2hlTmFtZSB8fCBfY3JlYXRlQ2FjaGVOYW1lKF9jYWNoZU5hbWVEZXRhaWxzLmdvb2dsZUFuYWx5dGljcyk7XG4gICAgfSxcbiAgICBnZXRQcmVjYWNoZU5hbWU6ICh1c2VyQ2FjaGVOYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiB1c2VyQ2FjaGVOYW1lIHx8IF9jcmVhdGVDYWNoZU5hbWUoX2NhY2hlTmFtZURldGFpbHMucHJlY2FjaGUpO1xuICAgIH0sXG4gICAgZ2V0UHJlZml4OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBfY2FjaGVOYW1lRGV0YWlscy5wcmVmaXg7XG4gICAgfSxcbiAgICBnZXRSdW50aW1lTmFtZTogKHVzZXJDYWNoZU5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHVzZXJDYWNoZU5hbWUgfHwgX2NyZWF0ZUNhY2hlTmFtZShfY2FjaGVOYW1lRGV0YWlscy5ydW50aW1lKTtcbiAgICB9LFxuICAgIGdldFN1ZmZpeDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gX2NhY2hlTmFtZURldGFpbHMuc3VmZml4O1xuICAgIH0sXG59O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuY29uc3QgbG9nZ2VyID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyBudWxsIDogKCgpID0+IHtcbiAgICAvLyBEb24ndCBvdmVyd3JpdGUgdGhpcyB2YWx1ZSBpZiBpdCdzIGFscmVhZHkgc2V0LlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL3dvcmtib3gvcHVsbC8yMjg0I2lzc3VlY29tbWVudC01NjA0NzA5MjNcbiAgICBpZiAoISgnX19XQl9ESVNBQkxFX0RFVl9MT0dTJyBpbiBzZWxmKSkge1xuICAgICAgICBzZWxmLl9fV0JfRElTQUJMRV9ERVZfTE9HUyA9IGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaW5Hcm91cCA9IGZhbHNlO1xuICAgIGNvbnN0IG1ldGhvZFRvQ29sb3JNYXAgPSB7XG4gICAgICAgIGRlYnVnOiBgIzdmOGM4ZGAsXG4gICAgICAgIGxvZzogYCMyZWNjNzFgLFxuICAgICAgICB3YXJuOiBgI2YzOWMxMmAsXG4gICAgICAgIGVycm9yOiBgI2MwMzkyYmAsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBgIzM0OThkYmAsXG4gICAgICAgIGdyb3VwRW5kOiBudWxsLFxuICAgIH07XG4gICAgY29uc3QgcHJpbnQgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmdzKSB7XG4gICAgICAgIGlmIChzZWxmLl9fV0JfRElTQUJMRV9ERVZfTE9HUykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgPT09ICdncm91cENvbGxhcHNlZCcpIHtcbiAgICAgICAgICAgIC8vIFNhZmFyaSBkb2Vzbid0IHByaW50IGFsbCBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKCkgYXJndW1lbnRzOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4Mjc1NFxuICAgICAgICAgICAgaWYgKC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlW21ldGhvZF0oLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IFtcbiAgICAgICAgICAgIGBiYWNrZ3JvdW5kOiAke21ldGhvZFRvQ29sb3JNYXBbbWV0aG9kXX1gLFxuICAgICAgICAgICAgYGJvcmRlci1yYWRpdXM6IDAuNWVtYCxcbiAgICAgICAgICAgIGBjb2xvcjogd2hpdGVgLFxuICAgICAgICAgICAgYGZvbnQtd2VpZ2h0OiBib2xkYCxcbiAgICAgICAgICAgIGBwYWRkaW5nOiAycHggMC41ZW1gLFxuICAgICAgICBdO1xuICAgICAgICAvLyBXaGVuIGluIGEgZ3JvdXAsIHRoZSB3b3JrYm94IHByZWZpeCBpcyBub3QgZGlzcGxheWVkLlxuICAgICAgICBjb25zdCBsb2dQcmVmaXggPSBpbkdyb3VwID8gW10gOiBbJyVjd29ya2JveCcsIHN0eWxlcy5qb2luKCc7JyldO1xuICAgICAgICBjb25zb2xlW21ldGhvZF0oLi4ubG9nUHJlZml4LCAuLi5hcmdzKTtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ2dyb3VwQ29sbGFwc2VkJykge1xuICAgICAgICAgICAgaW5Hcm91cCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ2dyb3VwRW5kJykge1xuICAgICAgICAgICAgaW5Hcm91cCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhcGkgPSB7fTtcbiAgICBjb25zdCBsb2dnZXJNZXRob2RzID0gT2JqZWN0LmtleXMobWV0aG9kVG9Db2xvck1hcCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgbG9nZ2VyTWV0aG9kcykge1xuICAgICAgICBjb25zdCBtZXRob2QgPSBrZXk7XG4gICAgICAgIGFwaVttZXRob2RdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHByaW50KG1ldGhvZCwgYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBhcGk7XG59KSgpKTtcbmV4cG9ydCB7IGxvZ2dlciB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBBIHV0aWxpdHkgbWV0aG9kIHRoYXQgbWFrZXMgaXQgZWFzaWVyIHRvIHVzZSBgZXZlbnQud2FpdFVudGlsYCB3aXRoXG4gKiBhc3luYyBmdW5jdGlvbnMgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSB7RXh0ZW5kYWJsZUV2ZW50fSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXN5bmNGblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB3YWl0VW50aWwoZXZlbnQsIGFzeW5jRm4pIHtcbiAgICBjb25zdCByZXR1cm5Qcm9taXNlID0gYXN5bmNGbigpO1xuICAgIGV2ZW50LndhaXRVbnRpbChyZXR1cm5Qcm9taXNlKTtcbiAgICByZXR1cm4gcmV0dXJuUHJvbWlzZTtcbn1cbmV4cG9ydCB7IHdhaXRVbnRpbCB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBAdHMtaWdub3JlXG50cnkge1xuICAgIHNlbGZbJ3dvcmtib3g6cHJlY2FjaGluZzo2LjAuMiddICYmIF8oKTtcbn1cbmNhdGNoIChlKSB7IH1cbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IFdvcmtib3hFcnJvciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9Xb3JrYm94RXJyb3IuanMnO1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vLyBOYW1lIG9mIHRoZSBzZWFyY2ggcGFyYW1ldGVyIHVzZWQgdG8gc3RvcmUgcmV2aXNpb24gaW5mby5cbmNvbnN0IFJFVklTSU9OX1NFQVJDSF9QQVJBTSA9ICdfX1dCX1JFVklTSU9OX18nO1xuLyoqXG4gKiBDb252ZXJ0cyBhIG1hbmlmZXN0IGVudHJ5IGludG8gYSB2ZXJzaW9uZWQgVVJMIHN1aXRhYmxlIGZvciBwcmVjYWNoaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gZW50cnlcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBVUkwgd2l0aCB2ZXJzaW9uaW5nIGluZm8uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDYWNoZUtleShlbnRyeSkge1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignYWRkLXRvLWNhY2hlLWxpc3QtdW5leHBlY3RlZC10eXBlJywgeyBlbnRyeSB9KTtcbiAgICB9XG4gICAgLy8gSWYgYSBwcmVjYWNoZSBtYW5pZmVzdCBlbnRyeSBpcyBhIHN0cmluZywgaXQncyBhc3N1bWVkIHRvIGJlIGEgdmVyc2lvbmVkXG4gICAgLy8gVVJMLCBsaWtlICcvYXBwLmFiY2QxMjM0LmpzJy4gUmV0dXJuIGFzLWlzLlxuICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwoZW50cnksIGxvY2F0aW9uLmhyZWYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FjaGVLZXk6IHVybE9iamVjdC5ocmVmLFxuICAgICAgICAgICAgdXJsOiB1cmxPYmplY3QuaHJlZixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgeyByZXZpc2lvbiwgdXJsIH0gPSBlbnRyeTtcbiAgICBpZiAoIXVybCkge1xuICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdhZGQtdG8tY2FjaGUtbGlzdC11bmV4cGVjdGVkLXR5cGUnLCB7IGVudHJ5IH0pO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIGp1c3QgYSBVUkwgYW5kIG5vIHJldmlzaW9uLCB0aGVuIGl0J3MgYWxzbyBhc3N1bWVkIHRvIGJlIGFcbiAgICAvLyB2ZXJzaW9uZWQgVVJMLlxuICAgIGlmICghcmV2aXNpb24pIHtcbiAgICAgICAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLmhyZWYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FjaGVLZXk6IHVybE9iamVjdC5ocmVmLFxuICAgICAgICAgICAgdXJsOiB1cmxPYmplY3QuaHJlZixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCBjb25zdHJ1Y3QgYSBwcm9wZXJseSB2ZXJzaW9uZWQgVVJMIHVzaW5nIHRoZSBjdXN0b20gV29ya2JveFxuICAgIC8vIHNlYXJjaCBwYXJhbWV0ZXIgYWxvbmcgd2l0aCB0aGUgcmV2aXNpb24gaW5mby5cbiAgICBjb25zdCBjYWNoZUtleVVSTCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5ocmVmKTtcbiAgICBjb25zdCBvcmlnaW5hbFVSTCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5ocmVmKTtcbiAgICBjYWNoZUtleVVSTC5zZWFyY2hQYXJhbXMuc2V0KFJFVklTSU9OX1NFQVJDSF9QQVJBTSwgcmV2aXNpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNhY2hlS2V5OiBjYWNoZUtleVVSTC5ocmVmLFxuICAgICAgICB1cmw6IG9yaWdpbmFsVVJMLmhyZWYsXG4gICAgfTtcbn1cbiIsIi8qXG4gIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBBIHBsdWdpbiwgZGVzaWduZWQgdG8gYmUgdXNlZCB3aXRoIFByZWNhY2hlQ29udHJvbGxlciwgdG8gZGV0ZXJtaW5lIHRoZVxuICogb2YgYXNzZXRzIHRoYXQgd2VyZSB1cGRhdGVkIChvciBub3QgdXBkYXRlZCkgZHVyaW5nIHRoZSBpbnN0YWxsIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFByZWNhY2hlSW5zdGFsbFJlcG9ydFBsdWdpbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlZFVSTHMgPSBbXTtcbiAgICAgICAgdGhpcy5ub3RVcGRhdGVkVVJMcyA9IFtdO1xuICAgICAgICB0aGlzLmhhbmRsZXJXaWxsU3RhcnQgPSBhc3luYyAoeyByZXF1ZXN0LCBzdGF0ZSwgfSkgPT4ge1xuICAgICAgICAgICAgLy8gVE9ETzogYHN0YXRlYCBzaG91bGQgbmV2ZXIgYmUgdW5kZWZpbmVkLi4uXG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcmlnaW5hbFJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNhY2hlZFJlc3BvbnNlV2lsbEJlVXNlZCA9IGFzeW5jICh7IGV2ZW50LCBzdGF0ZSwgY2FjaGVkUmVzcG9uc2UsIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAnaW5zdGFsbCcpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBgc3RhdGVgIHNob3VsZCBuZXZlciBiZSB1bmRlZmluZWQuLi5cbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBzdGF0ZS5vcmlnaW5hbFJlcXVlc3QudXJsO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdFVwZGF0ZWRVUkxzLnB1c2godXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlZFVSTHMucHVzaCh1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXNwb25zZTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgeyBQcmVjYWNoZUluc3RhbGxSZXBvcnRQbHVnaW4gfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBBIHBsdWdpbiwgZGVzaWduZWQgdG8gYmUgdXNlZCB3aXRoIFByZWNhY2hlQ29udHJvbGxlciwgdG8gdHJhbnNsYXRlIFVSTHMgaW50b1xuICogdGhlIGNvcnJlc3BvbmRpbmcgY2FjaGUga2V5LCBiYXNlZCBvbiB0aGUgY3VycmVudCByZXZpc2lvbiBpbmZvLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFByZWNhY2hlQ2FjaGVLZXlQbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKHsgcHJlY2FjaGVDb250cm9sbGVyIH0pIHtcbiAgICAgICAgdGhpcy5jYWNoZUtleVdpbGxCZVVzZWQgPSBhc3luYyAoeyByZXF1ZXN0LCBwYXJhbXMsIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gcGFyYW1zICYmIHBhcmFtcy5jYWNoZUtleSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZWNhY2hlQ29udHJvbGxlci5nZXRDYWNoZUtleUZvclVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVLZXkgPyBuZXcgUmVxdWVzdChjYWNoZUtleSkgOiByZXF1ZXN0O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wcmVjYWNoZUNvbnRyb2xsZXIgPSBwcmVjYWNoZUNvbnRyb2xsZXI7XG4gICAgfVxufVxuZXhwb3J0IHsgUHJlY2FjaGVDYWNoZUtleVBsdWdpbiB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGdyb3VwVGl0bGVcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZGVsZXRlZFVSTHNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBsb2dHcm91cCA9IChncm91cFRpdGxlLCBkZWxldGVkVVJMcykgPT4ge1xuICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChncm91cFRpdGxlKTtcbiAgICBmb3IgKGNvbnN0IHVybCBvZiBkZWxldGVkVVJMcykge1xuICAgICAgICBsb2dnZXIubG9nKHVybCk7XG4gICAgfVxuICAgIGxvZ2dlci5ncm91cEVuZCgpO1xufTtcbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBkZWxldGVkVVJMc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRDbGVhbnVwRGV0YWlscyhkZWxldGVkVVJMcykge1xuICAgIGNvbnN0IGRlbGV0aW9uQ291bnQgPSBkZWxldGVkVVJMcy5sZW5ndGg7XG4gICAgaWYgKGRlbGV0aW9uQ291bnQgPiAwKSB7XG4gICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgRHVyaW5nIHByZWNhY2hpbmcgY2xlYW51cCwgYCArXG4gICAgICAgICAgICBgJHtkZWxldGlvbkNvdW50fSBjYWNoZWQgYCArXG4gICAgICAgICAgICBgcmVxdWVzdCR7ZGVsZXRpb25Db3VudCA9PT0gMSA/ICcgd2FzJyA6ICdzIHdlcmUnfSBkZWxldGVkLmApO1xuICAgICAgICBsb2dHcm91cCgnRGVsZXRlZCBDYWNoZSBSZXF1ZXN0cycsIGRlbGV0ZWRVUkxzKTtcbiAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgfVxufVxuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGdyb3VwVGl0bGVcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdXJsc1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9uZXN0ZWRHcm91cChncm91cFRpdGxlLCB1cmxzKSB7XG4gICAgaWYgKHVybHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGdyb3VwVGl0bGUpO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIHVybHMpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyh1cmwpO1xuICAgIH1cbiAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB1cmxzVG9QcmVjYWNoZVxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB1cmxzQWxyZWFkeVByZWNhY2hlZFxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRJbnN0YWxsRGV0YWlscyh1cmxzVG9QcmVjYWNoZSwgdXJsc0FscmVhZHlQcmVjYWNoZWQpIHtcbiAgICBjb25zdCBwcmVjYWNoZWRDb3VudCA9IHVybHNUb1ByZWNhY2hlLmxlbmd0aDtcbiAgICBjb25zdCBhbHJlYWR5UHJlY2FjaGVkQ291bnQgPSB1cmxzQWxyZWFkeVByZWNhY2hlZC5sZW5ndGg7XG4gICAgaWYgKHByZWNhY2hlZENvdW50IHx8IGFscmVhZHlQcmVjYWNoZWRDb3VudCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IGBQcmVjYWNoaW5nICR7cHJlY2FjaGVkQ291bnR9IGZpbGUke3ByZWNhY2hlZENvdW50ID09PSAxID8gJycgOiAncyd9LmA7XG4gICAgICAgIGlmIChhbHJlYWR5UHJlY2FjaGVkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IGAgJHthbHJlYWR5UHJlY2FjaGVkQ291bnR9IGAgK1xuICAgICAgICAgICAgICAgIGBmaWxlJHthbHJlYWR5UHJlY2FjaGVkQ291bnQgPT09IDEgPyAnIGlzJyA6ICdzIGFyZSd9IGFscmVhZHkgY2FjaGVkLmA7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKG1lc3NhZ2UpO1xuICAgICAgICBfbmVzdGVkR3JvdXAoYFZpZXcgbmV3bHkgcHJlY2FjaGVkIFVSTHMuYCwgdXJsc1RvUHJlY2FjaGUpO1xuICAgICAgICBfbmVzdGVkR3JvdXAoYFZpZXcgcHJldmlvdXNseSBwcmVjYWNoZWQgVVJMcy5gLCB1cmxzQWxyZWFkeVByZWNhY2hlZCk7XG4gICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgIH1cbn1cbiIsIi8qXG4gIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xubGV0IHN1cHBvcnRTdGF0dXM7XG4vKipcbiAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzXG4gKiBjb25zdHJ1Y3RpbmcgYSBuZXcgYFJlc3BvbnNlYCBmcm9tIGEgYHJlc3BvbnNlLmJvZHlgIHN0cmVhbS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAsIGlmIHRoZSBjdXJyZW50IGJyb3dzZXIgY2FuIHN1Y2Nlc3NmdWxseVxuICogICAgIGNvbnN0cnVjdCBhIGBSZXNwb25zZWAgZnJvbSBhIGByZXNwb25zZS5ib2R5YCBzdHJlYW0sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbkNvbnN0cnVjdFJlc3BvbnNlRnJvbUJvZHlTdHJlYW0oKSB7XG4gICAgaWYgKHN1cHBvcnRTdGF0dXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0ZXN0UmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoJycpO1xuICAgICAgICBpZiAoJ2JvZHknIGluIHRlc3RSZXNwb25zZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXcgUmVzcG9uc2UodGVzdFJlc3BvbnNlLmJvZHkpO1xuICAgICAgICAgICAgICAgIHN1cHBvcnRTdGF0dXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cHBvcnRTdGF0dXMgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRTdGF0dXM7XG59XG5leHBvcnQgeyBjYW5Db25zdHJ1Y3RSZXNwb25zZUZyb21Cb2R5U3RyZWFtIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBjYW5Db25zdHJ1Y3RSZXNwb25zZUZyb21Cb2R5U3RyZWFtIH0gZnJvbSAnLi9fcHJpdmF0ZS9jYW5Db25zdHJ1Y3RSZXNwb25zZUZyb21Cb2R5U3RyZWFtLmpzJztcbmltcG9ydCB7IFdvcmtib3hFcnJvciB9IGZyb20gJy4vX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEFsbG93cyBkZXZlbG9wZXJzIHRvIGNvcHkgYSByZXNwb25zZSBhbmQgbW9kaWZ5IGl0cyBgaGVhZGVyc2AsIGBzdGF0dXNgLFxuICogb3IgYHN0YXR1c1RleHRgIHZhbHVlcyAodGhlIHZhbHVlcyBzZXR0YWJsZSB2aWEgYVxuICogW2BSZXNwb25zZUluaXRgXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUmVzcG9uc2UvUmVzcG9uc2UjU3ludGF4fVxuICogb2JqZWN0IGluIHRoZSBjb25zdHJ1Y3RvcikuXG4gKiBUbyBtb2RpZnkgdGhlc2UgdmFsdWVzLCBwYXNzIGEgZnVuY3Rpb24gYXMgdGhlIHNlY29uZCBhcmd1bWVudC4gVGhhdFxuICogZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIHdpdGggYSBzaW5nbGUgb2JqZWN0IHdpdGggdGhlIHJlc3BvbnNlIHByb3BlcnRpZXNcbiAqIGB7aGVhZGVycywgc3RhdHVzLCBzdGF0dXNUZXh0fWAuIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbiB3aWxsXG4gKiBiZSB1c2VkIGFzIHRoZSBgUmVzcG9uc2VJbml0YCBmb3IgdGhlIG5ldyBgUmVzcG9uc2VgLiBUbyBjaGFuZ2UgdGhlIHZhbHVlc1xuICogZWl0aGVyIG1vZGlmeSB0aGUgcGFzc2VkIHBhcmFtZXRlcihzKSBhbmQgcmV0dXJuIGl0LCBvciByZXR1cm4gYSB0b3RhbGx5XG4gKiBuZXcgb2JqZWN0LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGludGVudGlvbmFsbHkgbGltaXRlZCB0byBzYW1lLW9yaWdpbiByZXNwb25zZXMsIHJlZ2FyZGxlc3Mgb2ZcbiAqIHdoZXRoZXIgQ09SUyB3YXMgdXNlZCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtY29yZVxuICovXG5hc3luYyBmdW5jdGlvbiBjb3B5UmVzcG9uc2UocmVzcG9uc2UsIG1vZGlmaWVyKSB7XG4gICAgbGV0IG9yaWdpbiA9IG51bGw7XG4gICAgLy8gSWYgcmVzcG9uc2UudXJsIGlzbid0IHNldCwgYXNzdW1lIGl0J3MgY3Jvc3Mtb3JpZ2luIGFuZCBrZWVwIG9yaWdpbiBudWxsLlxuICAgIGlmIChyZXNwb25zZS51cmwpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VVUkwgPSBuZXcgVVJMKHJlc3BvbnNlLnVybCk7XG4gICAgICAgIG9yaWdpbiA9IHJlc3BvbnNlVVJMLm9yaWdpbjtcbiAgICB9XG4gICAgaWYgKG9yaWdpbiAhPT0gc2VsZi5sb2NhdGlvbi5vcmlnaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignY3Jvc3Mtb3JpZ2luLWNvcHktcmVzcG9uc2UnLCB7IG9yaWdpbiB9KTtcbiAgICB9XG4gICAgY29uc3QgY2xvbmVkUmVzcG9uc2UgPSByZXNwb25zZS5jbG9uZSgpO1xuICAgIC8vIENyZWF0ZSBhIGZyZXNoIGBSZXNwb25zZUluaXRgIG9iamVjdCBieSBjbG9uaW5nIHRoZSBoZWFkZXJzLlxuICAgIGNvbnN0IHJlc3BvbnNlSW5pdCA9IHtcbiAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoY2xvbmVkUmVzcG9uc2UuaGVhZGVycyksXG4gICAgICAgIHN0YXR1czogY2xvbmVkUmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiBjbG9uZWRSZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgIH07XG4gICAgLy8gQXBwbHkgYW55IHVzZXIgbW9kaWZpY2F0aW9ucy5cbiAgICBjb25zdCBtb2RpZmllZFJlc3BvbnNlSW5pdCA9IG1vZGlmaWVyID8gbW9kaWZpZXIocmVzcG9uc2VJbml0KSA6IHJlc3BvbnNlSW5pdDtcbiAgICAvLyBDcmVhdGUgdGhlIG5ldyByZXNwb25zZSBmcm9tIHRoZSBib2R5IHN0cmVhbSBhbmQgYFJlc3BvbnNlSW5pdGBcbiAgICAvLyBtb2RpZmljYXRpb25zLiBOb3RlOiBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdGhlIFJlc3BvbnNlLmJvZHkgc3RyZWFtLFxuICAgIC8vIHNvIGZhbGwgYmFjayB0byByZWFkaW5nIHRoZSBlbnRpcmUgYm9keSBpbnRvIG1lbW9yeSBhcyBhIGJsb2IuXG4gICAgY29uc3QgYm9keSA9IGNhbkNvbnN0cnVjdFJlc3BvbnNlRnJvbUJvZHlTdHJlYW0oKSA/XG4gICAgICAgIGNsb25lZFJlc3BvbnNlLmJvZHkgOiBhd2FpdCBjbG9uZWRSZXNwb25zZS5ibG9iKCk7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShib2R5LCBtb2RpZmllZFJlc3BvbnNlSW5pdCk7XG59XG5leHBvcnQgeyBjb3B5UmVzcG9uc2UgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuY29uc3QgZ2V0RnJpZW5kbHlVUkwgPSAodXJsKSA9PiB7XG4gICAgY29uc3QgdXJsT2JqID0gbmV3IFVSTChTdHJpbmcodXJsKSwgbG9jYXRpb24uaHJlZik7XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvd29ya2JveC9pc3N1ZXMvMjMyM1xuICAgIC8vIFdlIHdhbnQgdG8gaW5jbHVkZSBldmVyeXRoaW5nLCBleGNlcHQgZm9yIHRoZSBvcmlnaW4gaWYgaXQncyBzYW1lLW9yaWdpbi5cbiAgICByZXR1cm4gdXJsT2JqLmhyZWYucmVwbGFjZShuZXcgUmVnRXhwKGBeJHtsb2NhdGlvbi5vcmlnaW59YCksICcnKTtcbn07XG5leHBvcnQgeyBnZXRGcmllbmRseVVSTCB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuZnVuY3Rpb24gc3RyaXBQYXJhbXMoZnVsbFVSTCwgaWdub3JlUGFyYW1zKSB7XG4gICAgY29uc3Qgc3RyaXBwZWRVUkwgPSBuZXcgVVJMKGZ1bGxVUkwpO1xuICAgIGZvciAoY29uc3QgcGFyYW0gb2YgaWdub3JlUGFyYW1zKSB7XG4gICAgICAgIHN0cmlwcGVkVVJMLnNlYXJjaFBhcmFtcy5kZWxldGUocGFyYW0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaXBwZWRVUkwuaHJlZjtcbn1cbi8qKlxuICogTWF0Y2hlcyBhbiBpdGVtIGluIHRoZSBjYWNoZSwgaWdub3Jpbmcgc3BlY2lmaWMgVVJMIHBhcmFtcy4gVGhpcyBpcyBzaW1pbGFyXG4gKiB0byB0aGUgYGlnbm9yZVNlYXJjaGAgb3B0aW9uLCBidXQgaXQgYWxsb3dzIHlvdSB0byBpZ25vcmUganVzdCBzcGVjaWZpY1xuICogcGFyYW1zICh3aGlsZSBjb250aW51aW5nIHRvIG1hdGNoIG9uIHRoZSBvdGhlcnMpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0NhY2hlfSBjYWNoZVxuICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gbWF0Y2hPcHRpb25zXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGlnbm9yZVBhcmFtc1xuICogQHJldHVybiB7UHJvbWlzZTxSZXNwb25zZXx1bmRlZmluZWQ+fVxuICovXG5hc3luYyBmdW5jdGlvbiBjYWNoZU1hdGNoSWdub3JlUGFyYW1zKGNhY2hlLCByZXF1ZXN0LCBpZ25vcmVQYXJhbXMsIG1hdGNoT3B0aW9ucykge1xuICAgIGNvbnN0IHN0cmlwcGVkUmVxdWVzdFVSTCA9IHN0cmlwUGFyYW1zKHJlcXVlc3QudXJsLCBpZ25vcmVQYXJhbXMpO1xuICAgIC8vIElmIHRoZSByZXF1ZXN0IGRvZXNuJ3QgaW5jbHVkZSBhbnkgaWdub3JlZCBwYXJhbXMsIG1hdGNoIGFzIG5vcm1hbC5cbiAgICBpZiAocmVxdWVzdC51cmwgPT09IHN0cmlwcGVkUmVxdWVzdFVSTCkge1xuICAgICAgICByZXR1cm4gY2FjaGUubWF0Y2gocmVxdWVzdCwgbWF0Y2hPcHRpb25zKTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCBtYXRjaCBieSBjb21wYXJpbmcga2V5c1xuICAgIGNvbnN0IGtleXNPcHRpb25zID0geyAuLi5tYXRjaE9wdGlvbnMsIGlnbm9yZVNlYXJjaDogdHJ1ZSB9O1xuICAgIGNvbnN0IGNhY2hlS2V5cyA9IGF3YWl0IGNhY2hlLmtleXMocmVxdWVzdCwga2V5c09wdGlvbnMpO1xuICAgIGZvciAoY29uc3QgY2FjaGVLZXkgb2YgY2FjaGVLZXlzKSB7XG4gICAgICAgIGNvbnN0IHN0cmlwcGVkQ2FjaGVLZXlVUkwgPSBzdHJpcFBhcmFtcyhjYWNoZUtleS51cmwsIGlnbm9yZVBhcmFtcyk7XG4gICAgICAgIGlmIChzdHJpcHBlZFJlcXVlc3RVUkwgPT09IHN0cmlwcGVkQ2FjaGVLZXlVUkwpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5tYXRjaChjYWNoZUtleSwgbWF0Y2hPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG59XG5leHBvcnQgeyBjYWNoZU1hdGNoSWdub3JlUGFyYW1zIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogVGhlIERlZmVycmVkIGNsYXNzIGNvbXBvc2VzIFByb21pc2VzIGluIGEgd2F5IHRoYXQgYWxsb3dzIGZvciB0aGVtIHRvIGJlXG4gKiByZXNvbHZlZCBvciByZWplY3RlZCBmcm9tIG91dHNpZGUgdGhlIGNvbnN0cnVjdG9yLiBJbiBtb3N0IGNhc2VzIHByb21pc2VzXG4gKiBzaG91bGQgYmUgdXNlZCBkaXJlY3RseSwgYnV0IERlZmVycmVkcyBjYW4gYmUgbmVjZXNzYXJ5IHdoZW4gdGhlIGxvZ2ljIHRvXG4gKiByZXNvbHZlIGEgcHJvbWlzZSBtdXN0IGJlIHNlcGFyYXRlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIERlZmVycmVkIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcHJvbWlzZSBhbmQgZXhwb3NlcyBpdHMgcmVzb2x2ZSBhbmQgcmVqZWN0IGZ1bmN0aW9ucyBhcyBtZXRob2RzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCB7IERlZmVycmVkIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8vIENhbGxiYWNrcyB0byBiZSBleGVjdXRlZCB3aGVuZXZlciB0aGVyZSdzIGEgcXVvdGEgZXJyb3IuXG5jb25zdCBxdW90YUVycm9yQ2FsbGJhY2tzID0gbmV3IFNldCgpO1xuZXhwb3J0IHsgcXVvdGFFcnJvckNhbGxiYWNrcyB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IHF1b3RhRXJyb3JDYWxsYmFja3MgfSBmcm9tICcuLi9tb2RlbHMvcXVvdGFFcnJvckNhbGxiYWNrcy5qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogUnVucyBhbGwgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucywgb25lIGF0IGEgdGltZSBzZXF1ZW50aWFsbHksIGluIHRoZSBvcmRlclxuICogaW4gd2hpY2ggdGhleSB3ZXJlIHJlZ2lzdGVyZWQuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LWNvcmVcbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVRdW90YUVycm9yQ2FsbGJhY2tzKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGxvZ2dlci5sb2coYEFib3V0IHRvIHJ1biAke3F1b3RhRXJyb3JDYWxsYmFja3Muc2l6ZX0gYCArXG4gICAgICAgICAgICBgY2FsbGJhY2tzIHRvIGNsZWFuIHVwIGNhY2hlcy5gKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBxdW90YUVycm9yQ2FsbGJhY2tzKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrKCk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGNhbGxiYWNrLCAnaXMgY29tcGxldGUuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnRmluaXNoZWQgcnVubmluZyBjYWxsYmFja3MuJyk7XG4gICAgfVxufVxuZXhwb3J0IHsgZXhlY3V0ZVF1b3RhRXJyb3JDYWxsYmFja3MgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhbmQgdGhlIHBhc3NlZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICogVGhpcyB1dGlsaXR5IGlzIGFuIGFzeW5jL2F3YWl0LWZyaWVuZGx5IHZlcnNpb24gb2YgYHNldFRpbWVvdXRgLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBtc1xuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aW1lb3V0KG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIEB0cy1pZ25vcmVcbnRyeSB7XG4gICAgc2VsZlsnd29ya2JveDpzdHJhdGVnaWVzOjYuMC4yJ10gJiYgXygpO1xufVxuY2F0Y2ggKGUpIHsgfVxuIiwiLypcbiAgQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBjYWNoZU1hdGNoSWdub3JlUGFyYW1zIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2NhY2hlTWF0Y2hJZ25vcmVQYXJhbXMuanMnO1xuaW1wb3J0IHsgRGVmZXJyZWQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvRGVmZXJyZWQuanMnO1xuaW1wb3J0IHsgZXhlY3V0ZVF1b3RhRXJyb3JDYWxsYmFja3MgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZXhlY3V0ZVF1b3RhRXJyb3JDYWxsYmFja3MuanMnO1xuaW1wb3J0IHsgZ2V0RnJpZW5kbHlVUkwgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwuanMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5qcyc7XG5pbXBvcnQgeyB0aW1lb3V0IH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL3RpbWVvdXQuanMnO1xuaW1wb3J0IHsgV29ya2JveEVycm9yIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuZnVuY3Rpb24gdG9SZXF1ZXN0KGlucHV0KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSA/IG5ldyBSZXF1ZXN0KGlucHV0KSA6IGlucHV0O1xufVxuLyoqXG4gKiBBIGNsYXNzIGNyZWF0ZWQgZXZlcnkgdGltZSBhIFN0cmF0ZWd5IGluc3RhbmNlIGluc3RhbmNlIGNhbGxzXG4gKiBbaGFuZGxlKClde0BsaW5rIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3l+aGFuZGxlfSBvclxuICogW2hhbmRsZUFsbCgpXXtAbGluayBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5fmhhbmRsZUFsbH0gdGhhdCB3cmFwcyBhbGwgZmV0Y2ggYW5kXG4gKiBjYWNoZSBhY3Rpb25zIGFyb3VuZCBwbHVnaW4gY2FsbGJhY2tzIGFuZCBrZWVwcyB0cmFjayBvZiB3aGVuIHRoZSBzdHJhdGVneVxuICogaXMgXCJkb25lXCIgKGkuZS4gYWxsIGFkZGVkIGBldmVudC53YWl0VW50aWwoKWAgcHJvbWlzZXMgaGF2ZSByZXNvbHZlZCkuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXNcbiAqL1xuY2xhc3MgU3RyYXRlZ3lIYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcGFzc2VkIHN0cmF0ZWd5IGFuZCBldmVudFxuICAgICAqIHRoYXQncyBoYW5kbGluZyB0aGUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBhbHNvIGluaXRpYWxpemVzIHRoZSBzdGF0ZSB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIGVhY2ggb2ZcbiAgICAgKiB0aGUgcGx1Z2lucyBoYW5kbGluZyB0aGlzIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3l9IHN0cmF0ZWd5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R8c3RyaW5nfSBvcHRpb25zLnJlcXVlc3QgQSByZXF1ZXN0IHRvIHJ1biB0aGlzIHN0cmF0ZWd5IGZvci5cbiAgICAgKiBAcGFyYW0ge0V4dGVuZGFibGVFdmVudH0gb3B0aW9ucy5ldmVudCBUaGUgZXZlbnQgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgICAqICAgICByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7VVJMfSBbb3B0aW9ucy51cmxdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5wYXJhbXNdXG4gICAgICogICAgIFttYXRjaCBjYWxsYmFja117QGxpbmsgbW9kdWxlOndvcmtib3gtcm91dGluZ35tYXRjaENhbGxiYWNrfSxcbiAgICAgKiAgICAgKGlmIGFwcGxpY2FibGUpLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0cmF0ZWd5LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlS2V5cyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlcXVlc3QgdGhlIHN0cmF0ZWd5IGlzIHBlcmZvcm1pbmcgKHBhc3NlZCB0byB0aGUgc3RyYXRlZ3knc1xuICAgICAgICAgKiBgaGFuZGxlKClgIG9yIGBoYW5kbGVBbGwoKWAgbWV0aG9kKS5cbiAgICAgICAgICogQG5hbWUgcmVxdWVzdFxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUge1JlcXVlc3R9XG4gICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5SGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBldmVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyByZXF1ZXN0LlxuICAgICAgICAgKiBAbmFtZSBldmVudFxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUge0V4dGVuZGFibGVFdmVudH1cbiAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3lIYW5kbGVyXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBgVVJMYCBpbnN0YW5jZSBvZiBgcmVxdWVzdC51cmxgIChpZiBwYXNzZWQgdG8gdGhlIHN0cmF0ZWd5J3NcbiAgICAgICAgICogYGhhbmRsZSgpYCBvciBgaGFuZGxlQWxsKClgIG1ldGhvZCkuXG4gICAgICAgICAqIE5vdGU6IHRoZSBgdXJsYCBwYXJhbSB3aWxsIGJlIHByZXNlbnQgaWYgdGhlIHN0cmF0ZWd5IHdhcyBpbnZva2VkXG4gICAgICAgICAqIGZyb20gYSB3b3JrYm94IGBSb3V0ZWAgb2JqZWN0LlxuICAgICAgICAgKiBAbmFtZSB1cmxcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHtVUkx8dW5kZWZpbmVkfVxuICAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneUhhbmRsZXJcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGBwYXJhbWAgdmFsdWUgKGlmIHBhc3NlZCB0byB0aGUgc3RyYXRlZ3knc1xuICAgICAgICAgKiBgaGFuZGxlKClgIG9yIGBoYW5kbGVBbGwoKWAgbWV0aG9kKS5cbiAgICAgICAgICogTm90ZTogdGhlIGBwYXJhbWAgcGFyYW0gd2lsbCBiZSBwcmVzZW50IGlmIHRoZSBzdHJhdGVneSB3YXMgaW52b2tlZFxuICAgICAgICAgKiBmcm9tIGEgd29ya2JveCBgUm91dGVgIG9iamVjdCBhbmQgdGhlXG4gICAgICAgICAqIFttYXRjaCBjYWxsYmFja117QGxpbmsgbW9kdWxlOndvcmtib3gtcm91dGluZ35tYXRjaENhbGxiYWNrfSByZXR1cm5lZFxuICAgICAgICAgKiBhIHRydXRoeSB2YWx1ZSAoaXQgd2lsbCBiZSB0aGF0IHZhbHVlKS5cbiAgICAgICAgICogQG5hbWUgcGFyYW1zXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7Knx1bmRlZmluZWR9XG4gICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5SGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc0luc3RhbmNlKG9wdGlvbnMuZXZlbnQsIEV4dGVuZGFibGVFdmVudCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXN0cmF0ZWdpZXMnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1N0cmF0ZWd5SGFuZGxlcicsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnb3B0aW9ucy5ldmVudCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmV2ZW50ID0gb3B0aW9ucy5ldmVudDtcbiAgICAgICAgdGhpcy5fc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICAgICAgdGhpcy5faGFuZGxlckRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMuX2V4dGVuZExpZmV0aW1lUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgLy8gQ29weSB0aGUgcGx1Z2lucyBsaXN0IChzaW5jZSBpdCdzIG11dGFibGUgb24gdGhlIHN0cmF0ZWd5KSxcbiAgICAgICAgLy8gc28gYW55IG11dGF0aW9ucyBkb24ndCBhZmZlY3QgdGhpcyBoYW5kbGVyIGluc3RhbmNlLlxuICAgICAgICB0aGlzLl9wbHVnaW5zID0gWy4uLnN0cmF0ZWd5LnBsdWdpbnNdO1xuICAgICAgICB0aGlzLl9wbHVnaW5TdGF0ZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5fcGx1Z2lucykge1xuICAgICAgICAgICAgdGhpcy5fcGx1Z2luU3RhdGVNYXAuc2V0KHBsdWdpbiwge30pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnQud2FpdFVudGlsKHRoaXMuX2hhbmRsZXJEZWZlcnJlZC5wcm9taXNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIGdpdmVuIHJlcXVlc3QgKGFuZCBpbnZva2VzIGFueSBhcHBsaWNhYmxlIHBsdWdpbiBjYWxsYmFja1xuICAgICAqIG1ldGhvZHMpIHVzaW5nIHRoZSBgZmV0Y2hPcHRpb25zYCBhbmQgYHBsdWdpbnNgIGRlZmluZWQgb24gdGhlIHN0cmF0ZWd5XG4gICAgICogb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBwbHVnaW4gbGlmZWN5Y2xlIG1ldGhvZHMgYXJlIGludm9rZWQgd2hlbiB1c2luZyB0aGlzIG1ldGhvZDpcbiAgICAgKiAtIGByZXF1ZXN0V2lsbEZldGNoKClgXG4gICAgICogLSBgZmV0Y2hEaWRTdWNjZWVkKClgXG4gICAgICogLSBgZmV0Y2hEaWRGYWlsKClgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R8c3RyaW5nfSBpbnB1dCBUaGUgVVJMIG9yIHJlcXVlc3QgdG8gZmV0Y2guXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxSZXNwb25zZT59XG4gICAgICovXG4gICAgZmV0Y2goaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2FpdFVudGlsKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGV2ZW50IH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSB0b1JlcXVlc3QoaW5wdXQpO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ25hdmlnYXRlJyAmJlxuICAgICAgICAgICAgICAgIGV2ZW50IGluc3RhbmNlb2YgRmV0Y2hFdmVudCAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LnByZWxvYWRSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlUHJlbG9hZFJlc3BvbnNlID0gYXdhaXQgZXZlbnQucHJlbG9hZFJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZVByZWxvYWRSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgVXNpbmcgYSBwcmVsb2FkZWQgbmF2aWdhdGlvbiByZXNwb25zZSBmb3IgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCcke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0nYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc3NpYmxlUHJlbG9hZFJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgZmV0Y2hEaWRGYWlsIHBsdWdpbiwgd2UgbmVlZCB0byBzYXZlIGEgY2xvbmUgb2YgdGhlXG4gICAgICAgICAgICAvLyBvcmlnaW5hbCByZXF1ZXN0IGJlZm9yZSBpdCdzIGVpdGhlciBtb2RpZmllZCBieSBhIHJlcXVlc3RXaWxsRmV0Y2hcbiAgICAgICAgICAgIC8vIHBsdWdpbiBvciBiZWZvcmUgdGhlIG9yaWdpbmFsIHJlcXVlc3QncyBib2R5IGlzIGNvbnN1bWVkIHZpYSBmZXRjaCgpLlxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxSZXF1ZXN0ID0gdGhpcy5oYXNDYWxsYmFjaygnZmV0Y2hEaWRGYWlsJykgP1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuY2xvbmUoKSA6IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2Igb2YgdGhpcy5pdGVyYXRlQ2FsbGJhY2tzKCdyZXF1ZXN0V2lsbEZldGNoJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IGF3YWl0IGNiKHsgcmVxdWVzdDogcmVxdWVzdC5jbG9uZSgpLCBldmVudCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcigncGx1Z2luLWVycm9yLXJlcXVlc3Qtd2lsbC1mZXRjaCcsIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3duRXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSByZXF1ZXN0IGNhbiBiZSBhbHRlcmVkIGJ5IHBsdWdpbnMgd2l0aCBgcmVxdWVzdFdpbGxGZXRjaGAgbWFraW5nXG4gICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwgcmVxdWVzdCAobW9zdCBsaWtlbHkgZnJvbSBhIGBmZXRjaGAgZXZlbnQpIGRpZmZlcmVudFxuICAgICAgICAgICAgLy8gZnJvbSB0aGUgUmVxdWVzdCB3ZSBtYWtlLiBQYXNzIGJvdGggdG8gYGZldGNoRGlkRmFpbGAgdG8gYWlkIGRlYnVnZ2luZy5cbiAgICAgICAgICAgIGNvbnN0IHBsdWdpbkZpbHRlcmVkUmVxdWVzdCA9IHJlcXVlc3QuY2xvbmUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGZldGNoUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvd29ya2JveC9pc3N1ZXMvMTc5NlxuICAgICAgICAgICAgICAgIGZldGNoUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0LCByZXF1ZXN0Lm1vZGUgPT09ICduYXZpZ2F0ZScgP1xuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgOiB0aGlzLl9zdHJhdGVneS5mZXRjaE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgTmV0d29yayByZXF1ZXN0IGZvciBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAnJHtnZXRGcmllbmRseVVSTChyZXF1ZXN0LnVybCl9JyByZXR1cm5lZCBhIHJlc3BvbnNlIHdpdGggYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgc3RhdHVzICcke2ZldGNoUmVzcG9uc2Uuc3RhdHVzfScuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5pdGVyYXRlQ2FsbGJhY2tzKCdmZXRjaERpZFN1Y2NlZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaFJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBwbHVnaW5GaWx0ZXJlZFJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogZmV0Y2hSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaFJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOZXR3b3JrIHJlcXVlc3QgZm9yIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCcke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0nIHRocmV3IGFuIGVycm9yLmAsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYG9yaWdpbmFsUmVxdWVzdGAgd2lsbCBvbmx5IGV4aXN0IGlmIGEgYGZldGNoRGlkRmFpbGAgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyBpcyBiZWluZyB1c2VkIChzZWUgYWJvdmUpLlxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5ydW5DYWxsYmFja3MoJ2ZldGNoRGlkRmFpbCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFJlcXVlc3Q6IG9yaWdpbmFsUmVxdWVzdC5jbG9uZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogcGx1Z2luRmlsdGVyZWRSZXF1ZXN0LmNsb25lKCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxzIGB0aGlzLmZldGNoKClgIGFuZCAoaW4gdGhlIGJhY2tncm91bmQpIHJ1bnMgYHRoaXMuY2FjaGVQdXQoKWAgb25cbiAgICAgKiB0aGUgcmVzcG9uc2UgZ2VuZXJhdGVkIGJ5IGB0aGlzLmZldGNoKClgLlxuICAgICAqXG4gICAgICogVGhlIGNhbGwgdG8gYHRoaXMuY2FjaGVQdXQoKWAgYXV0b21hdGljYWxseSBpbnZva2VzIGB0aGlzLndhaXRVbnRpbCgpYCxcbiAgICAgKiBzbyB5b3UgZG8gbm90IGhhdmUgdG8gbWFudWFsbHkgY2FsbCBgd2FpdFVudGlsKClgIG9uIHRoZSBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVxdWVzdHxzdHJpbmd9IGlucHV0IFRoZSByZXF1ZXN0IG9yIFVSTCB0byBmZXRjaCBhbmQgY2FjaGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxSZXNwb25zZT59XG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hBbmRDYWNoZVB1dChpbnB1dCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2goaW5wdXQpO1xuICAgICAgICBjb25zdCByZXNwb25zZUNsb25lID0gcmVzcG9uc2UuY2xvbmUoKTtcbiAgICAgICAgdGhpcy53YWl0VW50aWwodGhpcy5jYWNoZVB1dChpbnB1dCwgcmVzcG9uc2VDbG9uZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoZXMgYSByZXF1ZXN0IGZyb20gdGhlIGNhY2hlIChhbmQgaW52b2tlcyBhbnkgYXBwbGljYWJsZSBwbHVnaW5cbiAgICAgKiBjYWxsYmFjayBtZXRob2RzKSB1c2luZyB0aGUgYGNhY2hlTmFtZWAsIGBtYXRjaE9wdGlvbnNgLCBhbmQgYHBsdWdpbnNgXG4gICAgICogZGVmaW5lZCBvbiB0aGUgc3RyYXRlZ3kgb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBwbHVnaW4gbGlmZWN5Y2xlIG1ldGhvZHMgYXJlIGludm9rZWQgd2hlbiB1c2luZyB0aGlzIG1ldGhvZDpcbiAgICAgKiAtIGNhY2hlS2V5V2lsbEJ5VXNlZCgpXG4gICAgICogLSBjYWNoZWRSZXNwb25zZVdpbGxCeVVzZWQoKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fHN0cmluZ30ga2V5IFRoZSBSZXF1ZXN0IG9yIFVSTCB0byB1c2UgYXMgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJlc3BvbnNlfHVuZGVmaW5lZD59IEEgbWF0Y2hpbmcgcmVzcG9uc2UsIGlmIGZvdW5kLlxuICAgICAqL1xuICAgIGNhY2hlTWF0Y2goa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLndhaXRVbnRpbCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRvUmVxdWVzdChrZXkpO1xuICAgICAgICAgICAgbGV0IGNhY2hlZFJlc3BvbnNlO1xuICAgICAgICAgICAgY29uc3QgeyBjYWNoZU5hbWUsIG1hdGNoT3B0aW9ucyB9ID0gdGhpcy5fc3RyYXRlZ3k7XG4gICAgICAgICAgICBjb25zdCBlZmZlY3RpdmVSZXF1ZXN0ID0gYXdhaXQgdGhpcy5nZXRDYWNoZUtleShyZXF1ZXN0LCAncmVhZCcpO1xuICAgICAgICAgICAgY29uc3QgbXVsdGlNYXRjaE9wdGlvbnMgPSB7IC4uLm1hdGNoT3B0aW9ucywgLi4ueyBjYWNoZU5hbWUgfSB9O1xuICAgICAgICAgICAgY2FjaGVkUmVzcG9uc2UgPSBhd2FpdCBjYWNoZXMubWF0Y2goZWZmZWN0aXZlUmVxdWVzdCwgbXVsdGlNYXRjaE9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBGb3VuZCBhIGNhY2hlZCByZXNwb25zZSBpbiAnJHtjYWNoZU5hbWV9Jy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgTm8gY2FjaGVkIHJlc3BvbnNlIGZvdW5kIGluICcke2NhY2hlTmFtZX0nLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5pdGVyYXRlQ2FsbGJhY2tzKCdjYWNoZWRSZXNwb25zZVdpbGxCZVVzZWQnKSkge1xuICAgICAgICAgICAgICAgIGNhY2hlZFJlc3BvbnNlID0gKGF3YWl0IGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBlZmZlY3RpdmVSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgICAgICAgICAgICB9KSkgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3BvbnNlO1xuICAgICAgICB9KSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHV0cyBhIHJlcXVlc3QvcmVzcG9uc2UgcGFpciBpbiB0aGUgY2FjaGUgKGFuZCBpbnZva2VzIGFueSBhcHBsaWNhYmxlXG4gICAgICogcGx1Z2luIGNhbGxiYWNrIG1ldGhvZHMpIHVzaW5nIHRoZSBgY2FjaGVOYW1lYCBhbmQgYHBsdWdpbnNgIGRlZmluZWQgb25cbiAgICAgKiB0aGUgc3RyYXRlZ3kgb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBwbHVnaW4gbGlmZWN5Y2xlIG1ldGhvZHMgYXJlIGludm9rZWQgd2hlbiB1c2luZyB0aGlzIG1ldGhvZDpcbiAgICAgKiAtIGNhY2hlS2V5V2lsbEJ5VXNlZCgpXG4gICAgICogLSBjYWNoZVdpbGxVcGRhdGUoKVxuICAgICAqIC0gY2FjaGVEaWRVcGRhdGUoKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fHN0cmluZ30ga2V5IFRoZSByZXF1ZXN0IG9yIFVSTCB0byB1c2UgYXMgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcGFyYW0ge1Byb21pc2U8dm9pZD59IHJlc3BvbnNlIFRoZSByZXNwb25zZSB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBhc3luYyBjYWNoZVB1dChrZXksIHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0b1JlcXVlc3Qoa2V5KTtcbiAgICAgICAgLy8gUnVuIGluIHRoZSBuZXh0IHRhc2sgdG8gYXZvaWQgYmxvY2tpbmcgb3RoZXIgY2FjaGUgcmVhZHMuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvU2VydmljZVdvcmtlci9pc3N1ZXMvMTM5N1xuICAgICAgICBhd2FpdCB0aW1lb3V0KDApO1xuICAgICAgICBjb25zdCBlZmZlY3RpdmVSZXF1ZXN0ID0gYXdhaXQgdGhpcy5nZXRDYWNoZUtleShyZXF1ZXN0LCAnd3JpdGUnKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3RpdmVSZXF1ZXN0Lm1ldGhvZCAmJiBlZmZlY3RpdmVSZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdhdHRlbXB0LXRvLWNhY2hlLW5vbi1nZXQtcmVxdWVzdCcsIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBnZXRGcmllbmRseVVSTChlZmZlY3RpdmVSZXF1ZXN0LnVybCksXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogZWZmZWN0aXZlUmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYENhbm5vdCBjYWNoZSBub24tZXhpc3RlbnQgcmVzcG9uc2UgZm9yIGAgK1xuICAgICAgICAgICAgICAgICAgICBgJyR7Z2V0RnJpZW5kbHlVUkwoZWZmZWN0aXZlUmVxdWVzdC51cmwpfScuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdjYWNoZS1wdXQtd2l0aC1uby1yZXNwb25zZScsIHtcbiAgICAgICAgICAgICAgICB1cmw6IGdldEZyaWVuZGx5VVJMKGVmZmVjdGl2ZVJlcXVlc3QudXJsKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVG9DYWNoZSA9IGF3YWl0IHRoaXMuX2Vuc3VyZVJlc3BvbnNlU2FmZVRvQ2FjaGUocmVzcG9uc2UpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlVG9DYWNoZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFJlc3BvbnNlICcke2dldEZyaWVuZGx5VVJMKGVmZmVjdGl2ZVJlcXVlc3QudXJsKX0nIGAgK1xuICAgICAgICAgICAgICAgICAgICBgd2lsbCBub3QgYmUgY2FjaGVkLmAsIHJlc3BvbnNlVG9DYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjYWNoZU5hbWUsIG1hdGNoT3B0aW9ucyB9ID0gdGhpcy5fc3RyYXRlZ3k7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgc2VsZi5jYWNoZXMub3BlbihjYWNoZU5hbWUpO1xuICAgICAgICBjb25zdCBoYXNDYWNoZVVwZGF0ZUNhbGxiYWNrID0gdGhpcy5oYXNDYWxsYmFjaygnY2FjaGVEaWRVcGRhdGUnKTtcbiAgICAgICAgY29uc3Qgb2xkUmVzcG9uc2UgPSBoYXNDYWNoZVVwZGF0ZUNhbGxiYWNrID8gYXdhaXQgY2FjaGVNYXRjaElnbm9yZVBhcmFtcyhcbiAgICAgICAgLy8gVE9ETyhwaGlsaXB3YWx0b24pOiB0aGUgYF9fV0JfUkVWSVNJT05fX2AgcGFyYW0gaXMgYSBwcmVjYWNoaW5nXG4gICAgICAgIC8vIGZlYXR1cmUuIENvbnNpZGVyIGludG8gd2F5cyB0byBvbmx5IGFkZCB0aGlzIGJlaGF2aW9yIGlmIHVzaW5nXG4gICAgICAgIC8vIHByZWNhY2hpbmcuXG4gICAgICAgIGNhY2hlLCBlZmZlY3RpdmVSZXF1ZXN0LmNsb25lKCksIFsnX19XQl9SRVZJU0lPTl9fJ10sIG1hdGNoT3B0aW9ucykgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgVXBkYXRpbmcgdGhlICcke2NhY2hlTmFtZX0nIGNhY2hlIHdpdGggYSBuZXcgUmVzcG9uc2UgYCArXG4gICAgICAgICAgICAgICAgYGZvciAke2dldEZyaWVuZGx5VVJMKGVmZmVjdGl2ZVJlcXVlc3QudXJsKX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlLnB1dChlZmZlY3RpdmVSZXF1ZXN0LCBoYXNDYWNoZVVwZGF0ZUNhbGxiYWNrID9cbiAgICAgICAgICAgICAgICByZXNwb25zZVRvQ2FjaGUuY2xvbmUoKSA6IHJlc3BvbnNlVG9DYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RPTUV4Y2VwdGlvbiNleGNlcHRpb24tUXVvdGFFeGNlZWRlZEVycm9yXG4gICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ1F1b3RhRXhjZWVkZWRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBleGVjdXRlUXVvdGFFcnJvckNhbGxiYWNrcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiB0aGlzLml0ZXJhdGVDYWxsYmFja3MoJ2NhY2hlRGlkVXBkYXRlJykpIHtcbiAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICBjYWNoZU5hbWUsXG4gICAgICAgICAgICAgICAgb2xkUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgbmV3UmVzcG9uc2U6IHJlc3BvbnNlVG9DYWNoZS5jbG9uZSgpLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGVmZmVjdGl2ZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIGxpc3Qgb2YgcGx1Z2lucyBmb3IgdGhlIGBjYWNoZUtleVdpbGxCZVVzZWRgIGNhbGxiYWNrLCBhbmRcbiAgICAgKiBleGVjdXRlcyBhbnkgb2YgdGhvc2UgY2FsbGJhY2tzIGZvdW5kIGluIHNlcXVlbmNlLiBUaGUgZmluYWwgYFJlcXVlc3RgXG4gICAgICogb2JqZWN0IHJldHVybmVkIGJ5IHRoZSBsYXN0IHBsdWdpbiBpcyB0cmVhdGVkIGFzIHRoZSBjYWNoZSBrZXkgZm9yIGNhY2hlXG4gICAgICogcmVhZHMgYW5kL29yIHdyaXRlcy4gSWYgbm8gYGNhY2hlS2V5V2lsbEJlVXNlZGAgcGx1Z2luIGNhbGxiYWNrcyBoYXZlXG4gICAgICogYmVlbiByZWdpc3RlcmVkLCB0aGUgcGFzc2VkIHJlcXVlc3QgaXMgcmV0dXJuZWQgdW5tb2RpZmllZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJlcXVlc3Q+fVxuICAgICAqL1xuICAgIGFzeW5jIGdldENhY2hlS2V5KHJlcXVlc3QsIG1vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZUtleXNbbW9kZV0pIHtcbiAgICAgICAgICAgIGxldCBlZmZlY3RpdmVSZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5pdGVyYXRlQ2FsbGJhY2tzKCdjYWNoZUtleVdpbGxCZVVzZWQnKSkge1xuICAgICAgICAgICAgICAgIGVmZmVjdGl2ZVJlcXVlc3QgPSB0b1JlcXVlc3QoYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBlZmZlY3RpdmVSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB0aGlzLnBhcmFtcyxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUtleXNbbW9kZV0gPSBlZmZlY3RpdmVSZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZUtleXNbbW9kZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3RyYXRlZ3kgaGFzIGF0IGxlYXN0IG9uZSBwbHVnaW4gd2l0aCB0aGUgZ2l2ZW5cbiAgICAgKiBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjYWxsYmFjayB0byBjaGVjayBmb3IuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNDYWxsYmFjayhuYW1lKSB7XG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMuX3N0cmF0ZWd5LnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGlmIChuYW1lIGluIHBsdWdpbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVucyBhbGwgcGx1Z2luIGNhbGxiYWNrcyBtYXRjaGluZyB0aGUgZ2l2ZW4gbmFtZSwgaW4gb3JkZXIsIHBhc3NpbmcgdGhlXG4gICAgICogZ2l2ZW4gcGFyYW0gb2JqZWN0IChtZXJnZWQgaXRoIHRoZSBjdXJyZW50IHBsdWdpbiBzdGF0ZSkgYXMgdGhlIG9ubHlcbiAgICAgKiBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIE5vdGU6IHNpbmNlIHRoaXMgbWV0aG9kIHJ1bnMgYWxsIHBsdWdpbnMsIGl0J3Mgbm90IHN1aXRhYmxlIGZvciBjYXNlc1xuICAgICAqIHdoZXJlIHRoZSByZXR1cm4gdmFsdWUgb2YgYSBjYWxsYmFjayBuZWVkcyB0byBiZSBhcHBsaWVkIHByaW9yIHRvIGNhbGxpbmdcbiAgICAgKiB0aGUgbmV4dCBjYWxsYmFjay4gU2VlXG4gICAgICogW2BpdGVyYXRlQ2FsbGJhY2tzKClgXXtAbGluayBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5SGFuZGxlciNpdGVyYXRlQ2FsbGJhY2tzfVxuICAgICAqIGJlbG93IGZvciBob3cgdG8gaGFuZGxlIHRoYXQgY2FzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjYWxsYmFjayB0byBydW4gd2l0aGluIGVhY2ggcGx1Z2luLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbSBUaGUgb2JqZWN0IHRvIHBhc3MgYXMgdGhlIGZpcnN0IChhbmQgb25seSkgcGFyYW1cbiAgICAgKiAgICAgd2hlbiBleGVjdXRpbmcgZWFjaCBjYWxsYmFjay4gVGhpcyBvYmplY3Qgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGVcbiAgICAgKiAgICAgY3VycmVudCBwbHVnaW4gc3RhdGUgcHJpb3IgdG8gY2FsbGJhY2sgZXhlY3V0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHJ1bkNhbGxiYWNrcyhuYW1lLCBwYXJhbSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuaXRlcmF0ZUNhbGxiYWNrcyhuYW1lKSkge1xuICAgICAgICAgICAgLy8gVE9ETyhwaGlsaXB3YWx0b24pOiBub3Qgc3VyZSB3aHkgYGFueWAgaXMgbmVlZGVkLiBJdCBzZWVtcyBsaWtlXG4gICAgICAgICAgICAvLyB0aGlzIHNob3VsZCB3b3JrIHdpdGggYGFzIFdvcmtib3hQbHVnaW5DYWxsYmFja1BhcmFtW0NdYC5cbiAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrKHBhcmFtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY2NlcHRzIGEgY2FsbGJhY2sgYW5kIHJldHVybnMgYW4gaXRlcmFibGUgb2YgbWF0Y2hpbmcgcGx1Z2luIGNhbGxiYWNrcyxcbiAgICAgKiB3aGVyZSBlYWNoIGNhbGxiYWNrIGlzIHdyYXBwZWQgd2l0aCB0aGUgY3VycmVudCBoYW5kbGVyIHN0YXRlIChpLmUuIHdoZW5cbiAgICAgKiB5b3UgY2FsbCBlYWNoIGNhbGxiYWNrLCB3aGF0ZXZlciBvYmplY3QgcGFyYW1ldGVyIHlvdSBwYXNzIGl0IHdpbGxcbiAgICAgKiBiZSBtZXJnZWQgd2l0aCB0aGUgcGx1Z2luJ3MgY3VycmVudCBzdGF0ZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBmbyB0aGUgY2FsbGJhY2sgdG8gcnVuXG4gICAgICogQHJldHVybiB7QXJyYXk8RnVuY3Rpb24+fVxuICAgICAqL1xuICAgICppdGVyYXRlQ2FsbGJhY2tzKG5hbWUpIHtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5fc3RyYXRlZ3kucGx1Z2lucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwbHVnaW5bbmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3BsdWdpblN0YXRlTWFwLmdldChwbHVnaW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlZnVsQ2FsbGJhY2sgPSAocGFyYW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGVmdWxQYXJhbSA9IHsgLi4ucGFyYW0sIHN0YXRlIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8ocGhpbGlwd2FsdG9uKTogbm90IHN1cmUgd2h5IGBhbnlgIGlzIG5lZWRlZC4gSXQgc2VlbXMgbGlrZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHNob3VsZCB3b3JrIHdpdGggYGFzIFdvcmtib3hQbHVnaW5DYWxsYmFja1BhcmFtW0NdYC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbltuYW1lXShzdGF0ZWZ1bFBhcmFtKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHlpZWxkIHN0YXRlZnVsQ2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHByb21pc2UgdG8gdGhlXG4gICAgICogW2V4dGVuZCBsaWZldGltZSBwcm9taXNlc117QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2V4dGVuZGFibGVldmVudC1leHRlbmQtbGlmZXRpbWUtcHJvbWlzZXN9XG4gICAgICogb2YgdGhlIGV2ZW50IGV2ZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVxdWVzdCBiZWluZyBoYW5kbGVkICh1c3VhbGx5IGFcbiAgICAgKiBgRmV0Y2hFdmVudGApLlxuICAgICAqXG4gICAgICogTm90ZTogeW91IGNhbiBhd2FpdFxuICAgICAqIFtgZG9uZVdhaXRpbmcoKWBde0BsaW5rIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3lIYW5kbGVyfmRvbmVXYWl0aW5nfVxuICAgICAqIHRvIGtub3cgd2hlbiBhbGwgYWRkZWQgcHJvbWlzZXMgaGF2ZSBzZXR0bGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQcm9taXNlfSBwcm9taXNlIEEgcHJvbWlzZSB0byBhZGQgdG8gdGhlIGV4dGVuZCBsaWZldGltZSBwcm9taXNlc1xuICAgICAqICAgICBvZiB0aGUgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgd2FpdFVudGlsKHByb21pc2UpIHtcbiAgICAgICAgdGhpcy5fZXh0ZW5kTGlmZXRpbWVQcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIGFsbCBwcm9taXNlcyBwYXNzZWQgdG9cbiAgICAgKiBbYHdhaXRVbnRpbCgpYF17QGxpbmsgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneUhhbmRsZXJ+d2FpdFVudGlsfVxuICAgICAqIGhhdmUgc2V0dGxlZC5cbiAgICAgKlxuICAgICAqIE5vdGU6IGFueSB3b3JrIGRvbmUgYWZ0ZXIgYGRvbmVXYWl0aW5nKClgIHNldHRsZXMgc2hvdWxkIGJlIG1hbnVhbGx5XG4gICAgICogcGFzc2VkIHRvIGFuIGV2ZW50J3MgYHdhaXRVbnRpbCgpYCBtZXRob2QgKG5vdCB0aGlzIGhhbmRsZXInc1xuICAgICAqIGB3YWl0VW50aWwoKWAgbWV0aG9kKSwgb3RoZXJ3aXNlIHRoZSBzZXJ2aWNlIHdvcmtlciB0aHJlYWQgbXkgYmUga2lsbGVkXG4gICAgICogcHJpb3IgdG8geW91ciB3b3JrIGNvbXBsZXRpbmcuXG4gICAgICovXG4gICAgYXN5bmMgZG9uZVdhaXRpbmcoKSB7XG4gICAgICAgIGxldCBwcm9taXNlO1xuICAgICAgICB3aGlsZSAocHJvbWlzZSA9IHRoaXMuX2V4dGVuZExpZmV0aW1lUHJvbWlzZXMuc2hpZnQoKSkge1xuICAgICAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyBydW5uaW5nIHRoZSBzdHJhdGVneSBhbmQgaW1tZWRpYXRlbHkgcmVzb2x2ZXMgYW55IHBlbmRpbmdcbiAgICAgKiBgd2FpdFVudGlsKClgIHByb21pc2VzLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZXJEZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2FsbCBjYWNoZVdpbGxVcGRhdGUgb24gdGhlIGF2YWlsYWJsZSBwbHVnaW5zIChvciB1c2VcbiAgICAgKiBzdGF0dXMgPT09IDIwMCkgdG8gZGV0ZXJtaW5lIGlmIHRoZSBSZXNwb25zZSBpcyBzYWZlIGFuZCB2YWxpZCB0byBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVxdWVzdH0gb3B0aW9ucy5yZXF1ZXN0XG4gICAgICogQHBhcmFtIHtSZXNwb25zZX0gb3B0aW9ucy5yZXNwb25zZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8UmVzcG9uc2V8dW5kZWZpbmVkPn1cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgX2Vuc3VyZVJlc3BvbnNlU2FmZVRvQ2FjaGUocmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlVG9DYWNoZSA9IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGx1Z2luc1VzZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiB0aGlzLml0ZXJhdGVDYWxsYmFja3MoJ2NhY2hlV2lsbFVwZGF0ZScpKSB7XG4gICAgICAgICAgICByZXNwb25zZVRvQ2FjaGUgPSAoYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHRoaXMucmVxdWVzdCxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2VUb0NhY2hlLFxuICAgICAgICAgICAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgICAgICAgfSkpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHBsdWdpbnNVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VUb0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwbHVnaW5zVXNlZCkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlVG9DYWNoZSAmJiByZXNwb25zZVRvQ2FjaGUuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZVRvQ2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVRvQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlVG9DYWNoZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlVG9DYWNoZS5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgVGhlIHJlc3BvbnNlIGZvciAnJHt0aGlzLnJlcXVlc3QudXJsfScgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBpcyBhbiBvcGFxdWUgcmVzcG9uc2UuIFRoZSBjYWNoaW5nIHN0cmF0ZWd5IHRoYXQgeW91J3JlIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgdXNpbmcgd2lsbCBub3QgY2FjaGUgb3BhcXVlIHJlc3BvbnNlcyBieSBkZWZhdWx0LmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBUaGUgcmVzcG9uc2UgZm9yICcke3RoaXMucmVxdWVzdC51cmx9JyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYHJldHVybmVkIGEgc3RhdHVzIGNvZGUgb2YgJyR7cmVzcG9uc2Uuc3RhdHVzfScgYW5kIHdvbid0IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYmUgY2FjaGVkIGFzIGEgcmVzdWx0LmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZVRvQ2FjaGU7XG4gICAgfVxufVxuZXhwb3J0IHsgU3RyYXRlZ3lIYW5kbGVyIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBjYWNoZU5hbWVzIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2NhY2hlTmFtZXMuanMnO1xuaW1wb3J0IHsgV29ya2JveEVycm9yIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IGdldEZyaWVuZGx5VVJMIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2dldEZyaWVuZGx5VVJMLmpzJztcbmltcG9ydCB7IFN0cmF0ZWd5SGFuZGxlciB9IGZyb20gJy4vU3RyYXRlZ3lIYW5kbGVyLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEFuIGFic3RyYWN0IGJhc2UgY2xhc3MgdGhhdCBhbGwgb3RoZXIgc3RyYXRlZ3kgY2xhc3NlcyBtdXN0IGV4dGVuZCBmcm9tOlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzXG4gKi9cbmNsYXNzIFN0cmF0ZWd5IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBzdHJhdGVneSBhbmQgc2V0cyBhbGwgZG9jdW1lbnRlZCBvcHRpb25cbiAgICAgKiBwcm9wZXJ0aWVzIGFzIHB1YmxpYyBpbnN0YW5jZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogTm90ZTogaWYgYSBjdXN0b20gc3RyYXRlZ3kgY2xhc3MgZXh0ZW5kcyB0aGUgYmFzZSBTdHJhdGVneSBjbGFzcyBhbmQgZG9lc1xuICAgICAqIG5vdCBuZWVkIG1vcmUgdGhhbiB0aGVzZSBwcm9wZXJ0aWVzLCBpdCBkb2VzIG5vdCBuZWVkIHRvIGRlZmluZSBpdHMgb3duXG4gICAgICogY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNhY2hlTmFtZV0gQ2FjaGUgbmFtZSB0byBzdG9yZSBhbmQgcmV0cmlldmVcbiAgICAgKiByZXF1ZXN0cy4gRGVmYXVsdHMgdG8gdGhlIGNhY2hlIG5hbWVzIHByb3ZpZGVkIGJ5XG4gICAgICogW3dvcmtib3gtY29yZV17QGxpbmsgbW9kdWxlOndvcmtib3gtY29yZS5jYWNoZU5hbWVzfS5cbiAgICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IFtvcHRpb25zLnBsdWdpbnNdIFtQbHVnaW5zXXtAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdG9vbHMvd29ya2JveC9ndWlkZXMvdXNpbmctcGx1Z2luc31cbiAgICAgKiB0byB1c2UgaW4gY29uanVuY3Rpb24gd2l0aCB0aGlzIGNhY2hpbmcgc3RyYXRlZ3kuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmZldGNoT3B0aW9uc10gVmFsdWVzIHBhc3NlZCBhbG9uZyB0byB0aGVcbiAgICAgKiBbYGluaXRgXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93T3JXb3JrZXJHbG9iYWxTY29wZS9mZXRjaCNQYXJhbWV0ZXJzfVxuICAgICAqIG9mIGFsbCBmZXRjaCgpIHJlcXVlc3RzIG1hZGUgYnkgdGhpcyBzdHJhdGVneS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubWF0Y2hPcHRpb25zXSBUaGVcbiAgICAgKiBbYENhY2hlUXVlcnlPcHRpb25zYF17QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2RpY3RkZWYtY2FjaGVxdWVyeW9wdGlvbnN9XG4gICAgICogZm9yIGFueSBgY2FjaGUubWF0Y2goKWAgb3IgYGNhY2hlLnB1dCgpYCBjYWxscyBtYWRlIGJ5IHRoaXMgc3RyYXRlZ3kuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWNoZSBuYW1lIHRvIHN0b3JlIGFuZCByZXRyaWV2ZVxuICAgICAgICAgKiByZXF1ZXN0cy4gRGVmYXVsdHMgdG8gdGhlIGNhY2hlIG5hbWVzIHByb3ZpZGVkIGJ5XG4gICAgICAgICAqIFt3b3JrYm94LWNvcmVde0BsaW5rIG1vZHVsZTp3b3JrYm94LWNvcmUuY2FjaGVOYW1lc30uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhY2hlTmFtZSA9IGNhY2hlTmFtZXMuZ2V0UnVudGltZU5hbWUob3B0aW9ucy5jYWNoZU5hbWUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3RcbiAgICAgICAgICogW1BsdWdpbnNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi90b29scy93b3JrYm94L2d1aWRlcy91c2luZy1wbHVnaW5zfVxuICAgICAgICAgKiB1c2VkIGJ5IHRoaXMgc3RyYXRlZ3kuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxPYmplY3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wbHVnaW5zID0gb3B0aW9ucy5wbHVnaW5zIHx8IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWVzIHBhc3NlZCBhbG9uZyB0byB0aGVcbiAgICAgICAgICogW2Bpbml0YF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd09yV29ya2VyR2xvYmFsU2NvcGUvZmV0Y2gjUGFyYW1ldGVyc31cbiAgICAgICAgICogb2YgYWxsIGZldGNoKCkgcmVxdWVzdHMgbWFkZSBieSB0aGlzIHN0cmF0ZWd5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mZXRjaE9wdGlvbnMgPSBvcHRpb25zLmZldGNoT3B0aW9ucztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZVxuICAgICAgICAgKiBbYENhY2hlUXVlcnlPcHRpb25zYF17QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2RpY3RkZWYtY2FjaGVxdWVyeW9wdGlvbnN9XG4gICAgICAgICAqIGZvciBhbnkgYGNhY2hlLm1hdGNoKClgIG9yIGBjYWNoZS5wdXQoKWAgY2FsbHMgbWFkZSBieSB0aGlzIHN0cmF0ZWd5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXRjaE9wdGlvbnMgPSBvcHRpb25zLm1hdGNoT3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIHJlcXVlc3Qgc3RyYXRlZ3kgYW5kIHJldHVybnMgYSBgUHJvbWlzZWAgdGhhdCB3aWxsIHJlc29sdmUgd2l0aFxuICAgICAqIGEgYFJlc3BvbnNlYCwgaW52b2tpbmcgYWxsIHJlbGV2YW50IHBsdWdpbiBjYWxsYmFja3MuXG4gICAgICpcbiAgICAgKiBXaGVuIGEgc3RyYXRlZ3kgaW5zdGFuY2UgaXMgcmVnaXN0ZXJlZCB3aXRoIGEgV29ya2JveFxuICAgICAqIFtyb3V0ZV17QGxpbmsgbW9kdWxlOndvcmtib3gtcm91dGluZy5Sb3V0ZX0sIHRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHlcbiAgICAgKiBjYWxsZWQgd2hlbiB0aGUgcm91dGUgbWF0Y2hlcy5cbiAgICAgKlxuICAgICAqIEFsdGVybmF0aXZlbHksIHRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGluIGEgc3RhbmRhbG9uZSBgRmV0Y2hFdmVudGBcbiAgICAgKiBsaXN0ZW5lciBieSBwYXNzaW5nIGl0IHRvIGBldmVudC5yZXNwb25kV2l0aCgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmV0Y2hFdmVudHxPYmplY3R9IG9wdGlvbnMgQSBgRmV0Y2hFdmVudGAgb3IgYW4gb2JqZWN0IHdpdGggdGhlXG4gICAgICogICAgIHByb3BlcnRpZXMgbGlzdGVkIGJlbG93LlxuICAgICAqIEBwYXJhbSB7UmVxdWVzdHxzdHJpbmd9IG9wdGlvbnMucmVxdWVzdCBBIHJlcXVlc3QgdG8gcnVuIHRoaXMgc3RyYXRlZ3kgZm9yLlxuICAgICAqIEBwYXJhbSB7RXh0ZW5kYWJsZUV2ZW50fSBvcHRpb25zLmV2ZW50IFRoZSBldmVudCBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgICogICAgIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHtVUkx9IFtvcHRpb25zLnVybF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLnBhcmFtc11cbiAgICAgKi9cbiAgICBoYW5kbGUob3B0aW9ucykge1xuICAgICAgICBjb25zdCBbcmVzcG9uc2VEb25lXSA9IHRoaXMuaGFuZGxlQWxsKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VEb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIFtgaGFuZGxlKClgXXtAbGluayBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5fmhhbmRsZX0sIGJ1dFxuICAgICAqIGluc3RlYWQgb2YganVzdCByZXR1cm5pbmcgYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB0byBhIGBSZXNwb25zZWAgaXRcbiAgICAgKiBpdCB3aWxsIHJldHVybiBhbiB0dXBsZSBvZiBbcmVzcG9uc2UsIGRvbmVdIHByb21pc2VzLCB3aGVyZSB0aGUgZm9ybWVyXG4gICAgICogKGByZXNwb25zZWApIGlzIGVxdWl2YWxlbnQgdG8gd2hhdCBgaGFuZGxlKClgIHJldHVybnMsIGFuZCB0aGUgbGF0dGVyIGlzIGFcbiAgICAgKiBQcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9uY2UgYW55IHByb21pc2VzIHRoYXQgd2VyZSBhZGRlZCB0b1xuICAgICAqIGBldmVudC53YWl0VW50aWwoKWAgYXMgcGFydCBvZiBwZXJmb3JtaW5nIHRoZSBzdHJhdGVneSBoYXZlIGNvbXBsZXRlZC5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYXdhaXQgdGhlIGBkb25lYCBwcm9taXNlIHRvIGVuc3VyZSBhbnkgZXh0cmEgd29yayBwZXJmb3JtZWQgYnlcbiAgICAgKiB0aGUgc3RyYXRlZ3kgKHVzdWFsbHkgY2FjaGluZyByZXNwb25zZXMpIGNvbXBsZXRlcyBzdWNjZXNzZnVsbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ZldGNoRXZlbnR8T2JqZWN0fSBvcHRpb25zIEEgYEZldGNoRXZlbnRgIG9yIGFuIG9iamVjdCB3aXRoIHRoZVxuICAgICAqICAgICBwcm9wZXJ0aWVzIGxpc3RlZCBiZWxvdy5cbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R8c3RyaW5nfSBvcHRpb25zLnJlcXVlc3QgQSByZXF1ZXN0IHRvIHJ1biB0aGlzIHN0cmF0ZWd5IGZvci5cbiAgICAgKiBAcGFyYW0ge0V4dGVuZGFibGVFdmVudH0gb3B0aW9ucy5ldmVudCBUaGUgZXZlbnQgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgICAqICAgICByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7VVJMfSBbb3B0aW9ucy51cmxdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5wYXJhbXNdXG4gICAgICogQHJldHVybiB7QXJyYXk8UHJvbWlzZT59IEEgdHVwbGUgb2YgW3Jlc3BvbnNlLCBkb25lXVxuICAgICAqICAgICBwcm9taXNlcyB0aGF0IGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSB3aGVuIHRoZSByZXNwb25zZSByZXNvbHZlcyBhc1xuICAgICAqICAgICB3ZWxsIGFzIHdoZW4gdGhlIGhhbmRsZXIgaGFzIGNvbXBsZXRlZCBhbGwgaXRzIHdvcmsuXG4gICAgICovXG4gICAgaGFuZGxlQWxsKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQWxsb3cgZm9yIGZsZXhpYmxlIG9wdGlvbnMgdG8gYmUgcGFzc2VkLlxuICAgICAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEZldGNoRXZlbnQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogb3B0aW9ucy5yZXF1ZXN0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudCA9IG9wdGlvbnMuZXZlbnQ7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0eXBlb2Ygb3B0aW9ucy5yZXF1ZXN0ID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICBuZXcgUmVxdWVzdChvcHRpb25zLnJlcXVlc3QpIDpcbiAgICAgICAgICAgIG9wdGlvbnMucmVxdWVzdDtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gJ3BhcmFtcycgaW4gb3B0aW9ucyA/IG9wdGlvbnMucGFyYW1zIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gbmV3IFN0cmF0ZWd5SGFuZGxlcih0aGlzLCB7IGV2ZW50LCByZXF1ZXN0LCBwYXJhbXMgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRG9uZSA9IHRoaXMuX2dldFJlc3BvbnNlKGhhbmRsZXIsIHJlcXVlc3QsIGV2ZW50KTtcbiAgICAgICAgY29uc3QgaGFuZGxlckRvbmUgPSB0aGlzLl9hd2FpdENvbXBsZXRlKHJlc3BvbnNlRG9uZSwgaGFuZGxlciwgcmVxdWVzdCwgZXZlbnQpO1xuICAgICAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgcHJvbWlzZXMsIHN1aXRhYmxlIGZvciB1c2Ugd2l0aCBQcm9taXNlLmFsbCgpLlxuICAgICAgICByZXR1cm4gW3Jlc3BvbnNlRG9uZSwgaGFuZGxlckRvbmVdO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0UmVzcG9uc2UoaGFuZGxlciwgcmVxdWVzdCwgZXZlbnQpIHtcbiAgICAgICAgYXdhaXQgaGFuZGxlci5ydW5DYWxsYmFja3MoJ2hhbmRsZXJXaWxsU3RhcnQnLCB7IGV2ZW50LCByZXF1ZXN0IH0pO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2hhbmRsZShyZXF1ZXN0LCBoYW5kbGVyKTtcbiAgICAgICAgICAgIC8vIFRoZSBcIm9mZmljaWFsXCIgU3RyYXRlZ3kgc3ViY2xhc3NlcyBhbGwgdGhyb3cgdGhpcyBlcnJvciBhdXRvbWF0aWNhbGx5LFxuICAgICAgICAgICAgLy8gYnV0IGluIGNhc2UgYSB0aGlyZC1wYXJ0eSBTdHJhdGVneSBkb2Vzbid0LCBlbnN1cmUgdGhhdCB3ZSBoYXZlIGFcbiAgICAgICAgICAgIC8vIGNvbnNpc3RlbnQgZmFpbHVyZSB3aGVuIHRoZXJlJ3Mgbm8gcmVzcG9uc2Ugb3IgYW4gZXJyb3IgcmVzcG9uc2UuXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlIHx8IHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCduby1yZXNwb25zZScsIHsgdXJsOiByZXF1ZXN0LnVybCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgaGFuZGxlci5pdGVyYXRlQ2FsbGJhY2tzKCdoYW5kbGVyRGlkRXJyb3InKSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2soeyBlcnJvciwgZXZlbnQsIHJlcXVlc3QgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBXaGlsZSByZXNwb25kaW5nIHRvICcke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0nLCBgICtcbiAgICAgICAgICAgICAgICAgICAgYGFuICR7ZXJyb3J9IGVycm9yIG9jY3VycmVkLiBVc2luZyBhIGZhbGxiYWNrIHJlc3BvbnNlIHByb3ZpZGVkIGJ5IGAgK1xuICAgICAgICAgICAgICAgICAgICBgYSBoYW5kbGVyRGlkRXJyb3IgcGx1Z2luLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgaGFuZGxlci5pdGVyYXRlQ2FsbGJhY2tzKCdoYW5kbGVyV2lsbFJlc3BvbmQnKSkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFjayh7IGV2ZW50LCByZXF1ZXN0LCByZXNwb25zZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIF9hd2FpdENvbXBsZXRlKHJlc3BvbnNlRG9uZSwgaGFuZGxlciwgcmVxdWVzdCwgZXZlbnQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlRG9uZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMsIGFzIHJlc3BvbnNlIGVycm9ycyBzaG91bGQgYmUgY2F1Z2h0IHZpYSB0aGUgYHJlc3BvbnNlYFxuICAgICAgICAgICAgLy8gcHJvbWlzZSBhYm92ZS4gVGhlIGBkb25lYCBwcm9taXNlIHdpbGwgb25seSB0aHJvdyBmb3IgZXJyb3JzIGluXG4gICAgICAgICAgICAvLyBwcm9taXNlcyBwYXNzZWQgdG8gYGhhbmRsZXIud2FpdFVudGlsKClgLlxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVyLnJ1bkNhbGxiYWNrcygnaGFuZGxlckRpZFJlc3BvbmQnLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5kb25lV2FpdGluZygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoICh3YWl0VW50aWxFcnJvcikge1xuICAgICAgICAgICAgZXJyb3IgPSB3YWl0VW50aWxFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBoYW5kbGVyLnJ1bkNhbGxiYWNrcygnaGFuZGxlckRpZENvbXBsZXRlJywge1xuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgICAgIGhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IHsgU3RyYXRlZ3kgfTtcbi8qKlxuICogQ2xhc3NlcyBleHRlbmRpbmcgdGhlIGBTdHJhdGVneWAgYmFzZWQgY2xhc3Mgc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCxcbiAqIGFuZCBsZXZlcmFnZSB0aGUgW2BoYW5kbGVyYF17QGxpbmsgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneUhhbmRsZXJ9XG4gKiBhcmcgdG8gcGVyZm9ybSBhbGwgZmV0Y2hpbmcgYW5kIGNhY2hlIGxvZ2ljLCB3aGljaCB3aWxsIGVuc3VyZSBhbGwgcmVsZXZhbnRcbiAqIGNhY2hlLCBjYWNoZSBvcHRpb25zLCBmZXRjaCBvcHRpb25zIGFuZCBwbHVnaW5zIGFyZSB1c2VkIChwZXIgdGhlIGN1cnJlbnRcbiAqIHN0cmF0ZWd5IGluc3RhbmNlKS5cbiAqXG4gKiBAbmFtZSBfaGFuZGxlXG4gKiBAaW5zdGFuY2VcbiAqIEBhYnN0cmFjdFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneUhhbmRsZXJ9IGhhbmRsZXJcbiAqIEByZXR1cm4ge1Byb21pc2U8UmVzcG9uc2U+fVxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1zdHJhdGVnaWVzLlN0cmF0ZWd5XG4gKi9cbiIsIi8qXG4gIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGNvcHlSZXNwb25zZSB9IGZyb20gJ3dvcmtib3gtY29yZS9jb3B5UmVzcG9uc2UuanMnO1xuaW1wb3J0IHsgY2FjaGVOYW1lcyB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9jYWNoZU5hbWVzLmpzJztcbmltcG9ydCB7IGdldEZyaWVuZGx5VVJMIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2dldEZyaWVuZGx5VVJMLmpzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMnO1xuaW1wb3J0IHsgV29ya2JveEVycm9yIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5qcyc7XG5pbXBvcnQgeyBTdHJhdGVneSB9IGZyb20gJ3dvcmtib3gtc3RyYXRlZ2llcy9TdHJhdGVneS5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuY29uc3QgY29weVJlZGlyZWN0ZWRDYWNoZWFibGVSZXNwb25zZXNQbHVnaW4gPSB7XG4gICAgYXN5bmMgY2FjaGVXaWxsVXBkYXRlKHsgcmVzcG9uc2UgfSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UucmVkaXJlY3RlZCA/IGF3YWl0IGNvcHlSZXNwb25zZShyZXNwb25zZSkgOiByZXNwb25zZTtcbiAgICB9XG59O1xuLyoqXG4gKiBBIFtTdHJhdGVneV17QGxpbmsgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneX0gaW1wbGVtZW50YXRpb25cbiAqIHNwZWNpZmljYWxseSBkZXNpZ25lZCB0byB3b3JrIHdpdGhcbiAqIFtQcmVjYWNoZUNvbnRyb2xsZXJde0BsaW5rIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuUHJlY2FjaGVDb250cm9sbGVyfVxuICogdG8gYm90aCBjYWNoZSBhbmQgZmV0Y2ggcHJlY2FjaGVkIGFzc2V0cy5cbiAqXG4gKiBOb3RlOiBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGlzIGNyZWF0ZWQgYXV0b21hdGljYWxseSB3aGVuIGNyZWF0aW5nIGFcbiAqIGBQcmVjYWNoZUNvbnRyb2xsZXJgOyBpdCdzIGdlbmVyYWxseSBub3QgbmVjZXNzYXJ5IHRvIGNyZWF0ZSB0aGlzIHlvdXJzZWxmLlxuICpcbiAqIEBleHRlbmRzIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3lcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nXG4gKi9cbmNsYXNzIFByZWNhY2hlU3RyYXRlZ3kgZXh0ZW5kcyBTdHJhdGVneSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNhY2hlTmFtZV0gQ2FjaGUgbmFtZSB0byBzdG9yZSBhbmQgcmV0cmlldmVcbiAgICAgKiByZXF1ZXN0cy4gRGVmYXVsdHMgdG8gdGhlIGNhY2hlIG5hbWVzIHByb3ZpZGVkIGJ5XG4gICAgICogW3dvcmtib3gtY29yZV17QGxpbmsgbW9kdWxlOndvcmtib3gtY29yZS5jYWNoZU5hbWVzfS5cbiAgICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IFtvcHRpb25zLnBsdWdpbnNdIFtQbHVnaW5zXXtAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdG9vbHMvd29ya2JveC9ndWlkZXMvdXNpbmctcGx1Z2luc31cbiAgICAgKiB0byB1c2UgaW4gY29uanVuY3Rpb24gd2l0aCB0aGlzIGNhY2hpbmcgc3RyYXRlZ3kuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmZldGNoT3B0aW9uc10gVmFsdWVzIHBhc3NlZCBhbG9uZyB0byB0aGVcbiAgICAgKiBbYGluaXRgXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93T3JXb3JrZXJHbG9iYWxTY29wZS9mZXRjaCNQYXJhbWV0ZXJzfVxuICAgICAqIG9mIGFsbCBmZXRjaCgpIHJlcXVlc3RzIG1hZGUgYnkgdGhpcyBzdHJhdGVneS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubWF0Y2hPcHRpb25zXSBUaGVcbiAgICAgKiBbYENhY2hlUXVlcnlPcHRpb25zYF17QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2RpY3RkZWYtY2FjaGVxdWVyeW9wdGlvbnN9XG4gICAgICogZm9yIGFueSBgY2FjaGUubWF0Y2goKWAgb3IgYGNhY2hlLnB1dCgpYCBjYWxscyBtYWRlIGJ5IHRoaXMgc3RyYXRlZ3kuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mYWxsYmFja1RvTmV0d29yaz10cnVlXSBXaGV0aGVyIHRvIGF0dGVtcHQgdG9cbiAgICAgKiBnZXQgdGhlIHJlc3BvbnNlIGZyb20gdGhlIG5ldHdvcmsgaWYgdGhlcmUncyBhIHByZWNhY2hlIG1pc3MuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIG9wdGlvbnMuY2FjaGVOYW1lID0gY2FjaGVOYW1lcy5nZXRQcmVjYWNoZU5hbWUob3B0aW9ucy5jYWNoZU5hbWUpO1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fZmFsbGJhY2tUb05ldHdvcmsgPSBvcHRpb25zLmZhbGxiYWNrVG9OZXR3b3JrID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgICAgLy8gUmVkaXJlY3RlZCByZXNwb25zZXMgY2Fubm90IGJlIHVzZWQgdG8gc2F0aXNmeSBhIG5hdmlnYXRpb24gcmVxdWVzdCwgc29cbiAgICAgICAgLy8gYW55IHJlZGlyZWN0ZWQgcmVzcG9uc2UgbXVzdCBiZSBcImNvcGllZFwiIHJhdGhlciB0aGFuIGNsb25lZCwgc28gdGhlIG5ld1xuICAgICAgICAvLyByZXNwb25zZSBkb2Vzbid0IGNvbnRhaW4gdGhlIGByZWRpcmVjdGVkYCBmbGFnLiBTZWU6XG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTY2OTM2MyZkZXNjPTIjYzFcbiAgICAgICAgdGhpcy5wbHVnaW5zLnB1c2goY29weVJlZGlyZWN0ZWRDYWNoZWFibGVSZXNwb25zZXNQbHVnaW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UmVxdWVzdHxzdHJpbmd9IHJlcXVlc3QgQSByZXF1ZXN0IHRvIHJ1biB0aGlzIHN0cmF0ZWd5IGZvci5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3lIYW5kbGVyfSBoYW5kbGVyIFRoZSBldmVudCB0aGF0XG4gICAgICogICAgIHRyaWdnZXJlZCB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJlc3BvbnNlPn1cbiAgICAgKi9cbiAgICBhc3luYyBfaGFuZGxlKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmNhY2hlTWF0Y2gocmVxdWVzdCk7XG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYW4gYGluc3RhbGxgIGV2ZW50IHRoZW4gcG9wdWxhdGUgdGhlIGNhY2hlLiBJZiB0aGlzIGlzIGFcbiAgICAgICAgICAgIC8vIGBmZXRjaGAgZXZlbnQgKG9yIGFueSBvdGhlciBldmVudCkgdGhlbiByZXNwb25kIHdpdGggdGhlIGNhY2hlZFxuICAgICAgICAgICAgLy8gcmVzcG9uc2UuXG4gICAgICAgICAgICBpZiAoaGFuZGxlci5ldmVudCAmJiBoYW5kbGVyLmV2ZW50LnR5cGUgPT09ICdpbnN0YWxsJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9oYW5kbGVJbnN0YWxsKHJlcXVlc3QsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2hhbmRsZUZldGNoKHJlcXVlc3QsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgX2hhbmRsZUZldGNoKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIG5ldHdvcmsgaWYgd2UgZG9uJ3QgaGF2ZSBhIGNhY2hlZCByZXNwb25zZVxuICAgICAgICAvLyAocGVyaGFwcyBkdWUgdG8gbWFudWFsIGNhY2hlIGNsZWFudXApLlxuICAgICAgICBpZiAodGhpcy5fZmFsbGJhY2tUb05ldHdvcmspIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFRoZSBwcmVjYWNoZWQgcmVzcG9uc2UgZm9yIGAgK1xuICAgICAgICAgICAgICAgICAgICBgJHtnZXRGcmllbmRseVVSTChyZXF1ZXN0LnVybCl9IGluICR7dGhpcy5jYWNoZU5hbWV9IHdhcyBub3QgYCArXG4gICAgICAgICAgICAgICAgICAgIGBmb3VuZC4gRmFsbGluZyBiYWNrIHRvIHRoZSBuZXR3b3JrIGluc3RlYWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGhhbmRsZXIuZmV0Y2gocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBub3JtYWxseSBoYXBwZW4sIGJ1dCB0aGVyZSBhcmUgZWRnZSBjYXNlczpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvd29ya2JveC9pc3N1ZXMvMTQ0MVxuICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignbWlzc2luZy1wcmVjYWNoZS1lbnRyeScsIHtcbiAgICAgICAgICAgICAgICBjYWNoZU5hbWU6IHRoaXMuY2FjaGVOYW1lLFxuICAgICAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBoYW5kbGVyLnBhcmFtcyAmJiBoYW5kbGVyLnBhcmFtcy5jYWNoZUtleSB8fFxuICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuZ2V0Q2FjaGVLZXkocmVxdWVzdCwgJ3JlYWQnKTtcbiAgICAgICAgICAgIC8vIFdvcmtib3ggaXMgZ29pbmcgdG8gaGFuZGxlIHRoZSByb3V0ZS5cbiAgICAgICAgICAgIC8vIHByaW50IHRoZSByb3V0aW5nIGRldGFpbHMgdG8gdGhlIGNvbnNvbGUuXG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoYFByZWNhY2hpbmcgaXMgcmVzcG9uZGluZyB0bzogYCArXG4gICAgICAgICAgICAgICAgZ2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYFNlcnZpbmcgdGhlIHByZWNhY2hlZCB1cmw6ICR7Z2V0RnJpZW5kbHlVUkwoY2FjaGVLZXkudXJsKX1gKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgVmlldyByZXF1ZXN0IGRldGFpbHMgaGVyZS5gKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2cocmVxdWVzdCk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgVmlldyByZXNwb25zZSBkZXRhaWxzIGhlcmUuYCk7XG4gICAgICAgICAgICBsb2dnZXIubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyBfaGFuZGxlSW5zdGFsbChyZXF1ZXN0LCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlci5mZXRjaEFuZENhY2hlUHV0KHJlcXVlc3QpO1xuICAgICAgICAvLyBBbnkgdGltZSB0aGVyZSdzIG5vIHJlc3BvbnNlLCBjb25zaWRlciBpdCBhIHByZWNhY2hpbmcgZXJyb3IuXG4gICAgICAgIGxldCByZXNwb25zZVNhZmVUb1ByZWNhY2hlID0gQm9vbGVhbihyZXNwb25zZSk7XG4gICAgICAgIC8vIEFsc28gY29uc2lkZXIgaXQgYW4gZXJyb3IgaWYgdGhlIHVzZXIgZGlkbid0IHBhc3MgdGhlaXIgb3duXG4gICAgICAgIC8vIGNhY2hlV2lsbFVwZGF0ZSBwbHVnaW4sIGFuZCB0aGUgcmVzcG9uc2UgaXMgYSA0MDArIChub3RlOiB0aGlzIG1lYW5zXG4gICAgICAgIC8vIHRoYXQgYnkgZGVmYXVsdCBvcGFxdWUgcmVzcG9uc2VzIGNhbiBiZSBwcmVjYWNoZWQpLlxuICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2Uuc3RhdHVzID49IDQwMCAmJlxuICAgICAgICAgICAgIXRoaXMuX3VzZXNDdXN0b21DYWNoZWFibGVSZXNwb25zZUxvZ2ljKCkpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlU2FmZVRvUHJlY2FjaGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlU2FmZVRvUHJlY2FjaGUpIHtcbiAgICAgICAgICAgIC8vIFRocm93aW5nIGhlcmUgd2lsbCBsZWFkIHRvIHRoZSBgaW5zdGFsbGAgaGFuZGxlciBmYWlsaW5nLCB3aGljaFxuICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBkbyBpZiAqYW55KiBvZiB0aGUgcmVzcG9uc2VzIGFyZW4ndCBzYWZlIHRvIGNhY2hlLlxuICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignYmFkLXByZWNhY2hpbmctcmVzcG9uc2UnLCB7XG4gICAgICAgICAgICAgICAgdXJsOiByZXF1ZXN0LnVybCxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFueSB1c2VycyBwbHVnaW5zIHdlcmUgYWRkZWQgY29udGFpbmluZyB0aGVpciBvd25cbiAgICAgKiBgY2FjaGVXaWxsVXBkYXRlYCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGluZGljYXRlcyB3aGV0aGVyIHRoZSBkZWZhdWx0IGNhY2hlYWJsZSByZXNwb25zZSBsb2dpYyAoaS5lLlxuICAgICAqIDw0MDAsIGluY2x1ZGluZyBvcGFxdWUgcmVzcG9uc2VzKSBzaG91bGQgYmUgdXNlZC4gSWYgYSBjdXN0b20gcGx1Z2luXG4gICAgICogd2l0aCBhIGBjYWNoZVdpbGxVcGRhdGVgIGNhbGxiYWNrIGlzIHBhc3NlZCwgdGhlbiB0aGUgc3RyYXRlZ3kgc2hvdWxkXG4gICAgICogZGVmZXIgdG8gdGhhdCBwbHVnaW4ncyBsb2dpYy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VzZXNDdXN0b21DYWNoZWFibGVSZXNwb25zZUxvZ2ljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wbHVnaW5zLnNvbWUoKHBsdWdpbikgPT4gcGx1Z2luLmNhY2hlV2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgcGx1Z2luICE9PSBjb3B5UmVkaXJlY3RlZENhY2hlYWJsZVJlc3BvbnNlc1BsdWdpbik7XG4gICAgfVxufVxuZXhwb3J0IHsgUHJlY2FjaGVTdHJhdGVneSB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBjYWNoZU5hbWVzIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2NhY2hlTmFtZXMuanMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5qcyc7XG5pbXBvcnQgeyBXb3JrYm94RXJyb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCB7IHdhaXRVbnRpbCB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS93YWl0VW50aWwuanMnO1xuaW1wb3J0IHsgY3JlYXRlQ2FjaGVLZXkgfSBmcm9tICcuL3V0aWxzL2NyZWF0ZUNhY2hlS2V5LmpzJztcbmltcG9ydCB7IFByZWNhY2hlSW5zdGFsbFJlcG9ydFBsdWdpbiB9IGZyb20gJy4vdXRpbHMvUHJlY2FjaGVJbnN0YWxsUmVwb3J0UGx1Z2luLmpzJztcbmltcG9ydCB7IFByZWNhY2hlQ2FjaGVLZXlQbHVnaW4gfSBmcm9tICcuL3V0aWxzL1ByZWNhY2hlQ2FjaGVLZXlQbHVnaW4uanMnO1xuaW1wb3J0IHsgcHJpbnRDbGVhbnVwRGV0YWlscyB9IGZyb20gJy4vdXRpbHMvcHJpbnRDbGVhbnVwRGV0YWlscy5qcyc7XG5pbXBvcnQgeyBwcmludEluc3RhbGxEZXRhaWxzIH0gZnJvbSAnLi91dGlscy9wcmludEluc3RhbGxEZXRhaWxzLmpzJztcbmltcG9ydCB7IFByZWNhY2hlU3RyYXRlZ3kgfSBmcm9tICcuL1ByZWNhY2hlU3RyYXRlZ3kuanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogUGVyZm9ybXMgZWZmaWNpZW50IHByZWNhY2hpbmcgb2YgYXNzZXRzLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nXG4gKi9cbmNsYXNzIFByZWNhY2hlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFByZWNhY2hlQ29udHJvbGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2FjaGVOYW1lXSBUaGUgY2FjaGUgdG8gdXNlIGZvciBwcmVjYWNoaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wbHVnaW5zXSBQbHVnaW5zIHRvIHVzZSB3aGVuIHByZWNhY2hpbmcgYXMgd2VsbFxuICAgICAqIGFzIHJlc3BvbmRpbmcgdG8gZmV0Y2ggZXZlbnRzIGZvciBwcmVjYWNoZWQgYXNzZXRzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZmFsbGJhY2tUb05ldHdvcms9dHJ1ZV0gV2hldGhlciB0byBhdHRlbXB0IHRvXG4gICAgICogZ2V0IHRoZSByZXNwb25zZSBmcm9tIHRoZSBuZXR3b3JrIGlmIHRoZXJlJ3MgYSBwcmVjYWNoZSBtaXNzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgY2FjaGVOYW1lLCBwbHVnaW5zID0gW10sIGZhbGxiYWNrVG9OZXR3b3JrID0gdHJ1ZSB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5fdXJsc1RvQ2FjaGVLZXlzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl91cmxzVG9DYWNoZU1vZGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jYWNoZUtleXNUb0ludGVncml0aWVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zdHJhdGVneSA9IG5ldyBQcmVjYWNoZVN0cmF0ZWd5KHtcbiAgICAgICAgICAgIGNhY2hlTmFtZTogY2FjaGVOYW1lcy5nZXRQcmVjYWNoZU5hbWUoY2FjaGVOYW1lKSxcbiAgICAgICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgICAgICAuLi5wbHVnaW5zLFxuICAgICAgICAgICAgICAgIG5ldyBQcmVjYWNoZUNhY2hlS2V5UGx1Z2luKHsgcHJlY2FjaGVDb250cm9sbGVyOiB0aGlzIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGZhbGxiYWNrVG9OZXR3b3JrLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQmluZCB0aGUgaW5zdGFsbCBhbmQgYWN0aXZhdGUgbWV0aG9kcyB0byB0aGUgaW5zdGFuY2UuXG4gICAgICAgIHRoaXMuaW5zdGFsbCA9IHRoaXMuaW5zdGFsbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlID0gdGhpcy5hY3RpdmF0ZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5QcmVjYWNoZVN0cmF0ZWd5fSBUaGUgc3RyYXRlZ3kgY3JlYXRlZCBieSB0aGlzIGNvbnRyb2xsZXIgYW5kXG4gICAgICogdXNlZCB0byBjYWNoZSBhc3NldHMgYW5kIHJlc3BvbmQgdG8gZmV0Y2ggZXZlbnRzLlxuICAgICAqL1xuICAgIGdldCBzdHJhdGVneSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmF0ZWd5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGl0ZW1zIHRvIHRoZSBwcmVjYWNoZSBsaXN0LCByZW1vdmluZyBhbnkgZHVwbGljYXRlcyBhbmRcbiAgICAgKiBzdG9yZXMgdGhlIGZpbGVzIGluIHRoZVxuICAgICAqIFtcInByZWNhY2hlIGNhY2hlXCJde0BsaW5rIG1vZHVsZTp3b3JrYm94LWNvcmUuY2FjaGVOYW1lc30gd2hlbiB0aGUgc2VydmljZVxuICAgICAqIHdvcmtlciBpbnN0YWxscy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdHxzdHJpbmc+fSBbZW50cmllcz1bXV0gQXJyYXkgb2YgZW50cmllcyB0byBwcmVjYWNoZS5cbiAgICAgKi9cbiAgICBwcmVjYWNoZShlbnRyaWVzKSB7XG4gICAgICAgIHRoaXMuYWRkVG9DYWNoZUxpc3QoZW50cmllcyk7XG4gICAgICAgIGlmICghdGhpcy5faW5zdGFsbEFuZEFjdGl2ZUxpc3RlbmVyc0FkZGVkKSB7XG4gICAgICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2luc3RhbGwnLCB0aGlzLmluc3RhbGwpO1xuICAgICAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdhY3RpdmF0ZScsIHRoaXMuYWN0aXZhdGUpO1xuICAgICAgICAgICAgdGhpcy5faW5zdGFsbEFuZEFjdGl2ZUxpc3RlbmVyc0FkZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGFkZCBpdGVtcyB0byB0aGUgcHJlY2FjaGUgbGlzdCwgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICAgICAqIGFuZCBlbnN1cmluZyB0aGUgaW5mb3JtYXRpb24gaXMgdmFsaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuUHJlY2FjaGVDb250cm9sbGVyLlByZWNhY2hlRW50cnl8c3RyaW5nPn0gZW50cmllc1xuICAgICAqICAgICBBcnJheSBvZiBlbnRyaWVzIHRvIHByZWNhY2hlLlxuICAgICAqL1xuICAgIGFkZFRvQ2FjaGVMaXN0KGVudHJpZXMpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc0FycmF5KGVudHJpZXMsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1wcmVjYWNoaW5nJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdQcmVjYWNoZUNvbnRyb2xsZXInLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnYWRkVG9DYWNoZUxpc3QnLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ2VudHJpZXMnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsc1RvV2FybkFib3V0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvd29ya2JveC9pc3N1ZXMvMjI1OVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB1cmxzVG9XYXJuQWJvdXQucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbnRyeSAmJiBlbnRyeS5yZXZpc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdXJsc1RvV2FybkFib3V0LnB1c2goZW50cnkudXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgY2FjaGVLZXksIHVybCB9ID0gY3JlYXRlQ2FjaGVLZXkoZW50cnkpO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVNb2RlID0gKHR5cGVvZiBlbnRyeSAhPT0gJ3N0cmluZycgJiYgZW50cnkucmV2aXNpb24pID9cbiAgICAgICAgICAgICAgICAncmVsb2FkJyA6ICdkZWZhdWx0JztcbiAgICAgICAgICAgIGlmICh0aGlzLl91cmxzVG9DYWNoZUtleXMuaGFzKHVybCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl91cmxzVG9DYWNoZUtleXMuZ2V0KHVybCkgIT09IGNhY2hlS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignYWRkLXRvLWNhY2hlLWxpc3QtY29uZmxpY3RpbmctZW50cmllcycsIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFbnRyeTogdGhpcy5fdXJsc1RvQ2FjaGVLZXlzLmdldCh1cmwpLFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRFbnRyeTogY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSAnc3RyaW5nJyAmJiBlbnRyeS5pbnRlZ3JpdHkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FjaGVLZXlzVG9JbnRlZ3JpdGllcy5oYXMoY2FjaGVLZXkpICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlS2V5c1RvSW50ZWdyaXRpZXMuZ2V0KGNhY2hlS2V5KSAhPT0gZW50cnkuaW50ZWdyaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2FkZC10by1jYWNoZS1saXN0LWNvbmZsaWN0aW5nLWludGVncml0aWVzJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXlzVG9JbnRlZ3JpdGllcy5zZXQoY2FjaGVLZXksIGVudHJ5LmludGVncml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cmxzVG9DYWNoZUtleXMuc2V0KHVybCwgY2FjaGVLZXkpO1xuICAgICAgICAgICAgdGhpcy5fdXJsc1RvQ2FjaGVNb2Rlcy5zZXQodXJsLCBjYWNoZU1vZGUpO1xuICAgICAgICAgICAgaWYgKHVybHNUb1dhcm5BYm91dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2FybmluZ01lc3NhZ2UgPSBgV29ya2JveCBpcyBwcmVjYWNoaW5nIFVSTHMgd2l0aG91dCByZXZpc2lvbiBgICtcbiAgICAgICAgICAgICAgICAgICAgYGluZm86ICR7dXJsc1RvV2FybkFib3V0LmpvaW4oJywgJyl9XFxuVGhpcyBpcyBnZW5lcmFsbHkgTk9UIHNhZmUuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgTGVhcm4gbW9yZSBhdCBodHRwczovL2JpdC5seS93Yi1wcmVjYWNoZWA7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGNvbnNvbGUgZGlyZWN0bHkgdG8gZGlzcGxheSB0aGlzIHdhcm5pbmcgd2l0aG91dCBibG9hdGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBidW5kbGUgc2l6ZXMgYnkgcHVsbGluZyBpbiBhbGwgb2YgdGhlIGxvZ2dlciBjb2RlYmFzZSBpbiBwcm9kLlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4od2FybmluZ01lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4od2FybmluZ01lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVjYWNoZXMgbmV3IGFuZCB1cGRhdGVkIGFzc2V0cy4gQ2FsbCB0aGlzIG1ldGhvZCBmcm9tIHRoZSBzZXJ2aWNlIHdvcmtlclxuICAgICAqIGluc3RhbGwgZXZlbnQuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBjYWxscyBgZXZlbnQud2FpdFVudGlsKClgIGZvciB5b3UsIHNvIHlvdSBkbyBub3QgbmVlZFxuICAgICAqIHRvIGNhbGwgaXQgeW91cnNlbGYgaW4geW91ciBldmVudCBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtFdmVudH0gb3B0aW9ucy5ldmVudCBUaGUgaW5zdGFsbCBldmVudC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuSW5zdGFsbFJlc3VsdD59XG4gICAgICovXG4gICAgaW5zdGFsbChldmVudCkge1xuICAgICAgICByZXR1cm4gd2FpdFVudGlsKGV2ZW50LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YWxsUmVwb3J0UGx1Z2luID0gbmV3IFByZWNhY2hlSW5zdGFsbFJlcG9ydFBsdWdpbigpO1xuICAgICAgICAgICAgdGhpcy5zdHJhdGVneS5wbHVnaW5zLnB1c2goaW5zdGFsbFJlcG9ydFBsdWdpbik7XG4gICAgICAgICAgICAvLyBDYWNoZSBlbnRyaWVzIG9uZSBhdCBhIHRpbWUuXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8yNTI4XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFt1cmwsIGNhY2hlS2V5XSBvZiB0aGlzLl91cmxzVG9DYWNoZUtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlZ3JpdHkgPSB0aGlzLl9jYWNoZUtleXNUb0ludGVncml0aWVzLmdldChjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVNb2RlID0gdGhpcy5fdXJsc1RvQ2FjaGVNb2Rlcy5nZXQodXJsKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodXJsLCB7XG4gICAgICAgICAgICAgICAgICAgIGludGVncml0eSxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGNhY2hlTW9kZSxcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5zdHJhdGVneS5oYW5kbGVBbGwoe1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHsgY2FjaGVLZXkgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB1cGRhdGVkVVJMcywgbm90VXBkYXRlZFVSTHMgfSA9IGluc3RhbGxSZXBvcnRQbHVnaW47XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHByaW50SW5zdGFsbERldGFpbHModXBkYXRlZFVSTHMsIG5vdFVwZGF0ZWRVUkxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHVwZGF0ZWRVUkxzLCBub3RVcGRhdGVkVVJMcyB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhc3NldHMgdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQgaW4gdGhlIGN1cnJlbnQgcHJlY2FjaGUgbWFuaWZlc3QuXG4gICAgICogQ2FsbCB0aGlzIG1ldGhvZCBmcm9tIHRoZSBzZXJ2aWNlIHdvcmtlciBhY3RpdmF0ZSBldmVudC5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGNhbGxzIGBldmVudC53YWl0VW50aWwoKWAgZm9yIHlvdSwgc28geW91IGRvIG5vdCBuZWVkXG4gICAgICogdG8gY2FsbCBpdCB5b3Vyc2VsZiBpbiB5b3VyIGV2ZW50IGhhbmRsZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFeHRlbmRhYmxlRXZlbnR9XG4gICAgICogQHJldHVybiB7UHJvbWlzZTxtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nLkNsZWFudXBSZXN1bHQ+fVxuICAgICAqL1xuICAgIGFjdGl2YXRlKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB3YWl0VW50aWwoZXZlbnQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgc2VsZi5jYWNoZXMub3Blbih0aGlzLnN0cmF0ZWd5LmNhY2hlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50bHlDYWNoZWRSZXF1ZXN0cyA9IGF3YWl0IGNhY2hlLmtleXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkQ2FjaGVLZXlzID0gbmV3IFNldCh0aGlzLl91cmxzVG9DYWNoZUtleXMudmFsdWVzKCkpO1xuICAgICAgICAgICAgY29uc3QgZGVsZXRlZFVSTHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiBjdXJyZW50bHlDYWNoZWRSZXF1ZXN0cykge1xuICAgICAgICAgICAgICAgIGlmICghZXhwZWN0ZWRDYWNoZUtleXMuaGFzKHJlcXVlc3QudXJsKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWNoZS5kZWxldGUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRVUkxzLnB1c2gocmVxdWVzdC51cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRDbGVhbnVwRGV0YWlscyhkZWxldGVkVVJMcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkZWxldGVkVVJMcyB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG1hcHBpbmcgb2YgYSBwcmVjYWNoZWQgVVJMIHRvIHRoZSBjb3JyZXNwb25kaW5nIGNhY2hlIGtleSwgdGFraW5nXG4gICAgICogaW50byBhY2NvdW50IHRoZSByZXZpc2lvbiBpbmZvcm1hdGlvbiBmb3IgdGhlIFVSTC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge01hcDxzdHJpbmcsIHN0cmluZz59IEEgVVJMIHRvIGNhY2hlIGtleSBtYXBwaW5nLlxuICAgICAqL1xuICAgIGdldFVSTHNUb0NhY2hlS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VybHNUb0NhY2hlS2V5cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHRoZSBVUkxzIHRoYXQgaGF2ZSBiZWVuIHByZWNhY2hlZCBieSB0aGUgY3VycmVudFxuICAgICAqIHNlcnZpY2Ugd29ya2VyLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gVGhlIHByZWNhY2hlZCBVUkxzLlxuICAgICAqL1xuICAgIGdldENhY2hlZFVSTHMoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5fdXJsc1RvQ2FjaGVLZXlzLmtleXMoKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNhY2hlIGtleSB1c2VkIGZvciBzdG9yaW5nIGEgZ2l2ZW4gVVJMLiBJZiB0aGF0IFVSTCBpc1xuICAgICAqIHVudmVyc2lvbmVkLCBsaWtlIGAvaW5kZXguaHRtbCcsIHRoZW4gdGhlIGNhY2hlIGtleSB3aWxsIGJlIHRoZSBvcmlnaW5hbFxuICAgICAqIFVSTCB3aXRoIGEgc2VhcmNoIHBhcmFtZXRlciBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgQSBVUkwgd2hvc2UgY2FjaGUga2V5IHlvdSB3YW50IHRvIGxvb2sgdXAuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmVyc2lvbmVkIFVSTCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgY2FjaGUga2V5XG4gICAgICogZm9yIHRoZSBvcmlnaW5hbCBVUkwsIG9yIHVuZGVmaW5lZCBpZiB0aGF0IFVSTCBpc24ndCBwcmVjYWNoZWQuXG4gICAgICovXG4gICAgZ2V0Q2FjaGVLZXlGb3JVUkwodXJsKSB7XG4gICAgICAgIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VybHNUb0NhY2hlS2V5cy5nZXQodXJsT2JqZWN0LmhyZWYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGFjdHMgYXMgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvclxuICAgICAqIFtgY2FjaGUubWF0Y2goKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYWNoZS9tYXRjaClcbiAgICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgZGlmZmVyZW5jZXM6XG4gICAgICpcbiAgICAgKiAtIEl0IGtub3dzIHdoYXQgdGhlIG5hbWUgb2YgdGhlIHByZWNhY2hlIGlzLCBhbmQgb25seSBjaGVja3MgaW4gdGhhdCBjYWNoZS5cbiAgICAgKiAtIEl0IGFsbG93cyB5b3UgdG8gcGFzcyBpbiBhbiBcIm9yaWdpbmFsXCIgVVJMIHdpdGhvdXQgdmVyc2lvbmluZyBwYXJhbWV0ZXJzLFxuICAgICAqIGFuZCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgbG9vayB1cCB0aGUgY29ycmVjdCBjYWNoZSBrZXkgZm9yIHRoZSBjdXJyZW50bHlcbiAgICAgKiBhY3RpdmUgcmV2aXNpb24gb2YgdGhhdCBVUkwuXG4gICAgICpcbiAgICAgKiBFLmcuLCBgbWF0Y2hQcmVjYWNoZSgnaW5kZXguaHRtbCcpYCB3aWxsIGZpbmQgdGhlIGNvcnJlY3QgcHJlY2FjaGVkXG4gICAgICogcmVzcG9uc2UgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIHNlcnZpY2Ugd29ya2VyLCBldmVuIGlmIHRoZSBhY3R1YWwgY2FjaGVcbiAgICAgKiBrZXkgaXMgYCcvaW5kZXguaHRtbD9fX1dCX1JFVklTSU9OX189MTIzNGFiY2QnYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfFJlcXVlc3R9IHJlcXVlc3QgVGhlIGtleSAod2l0aG91dCByZXZpc2lvbmluZyBwYXJhbWV0ZXJzKVxuICAgICAqIHRvIGxvb2sgdXAgaW4gdGhlIHByZWNhY2hlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8UmVzcG9uc2V8dW5kZWZpbmVkPn1cbiAgICAgKi9cbiAgICBhc3luYyBtYXRjaFByZWNhY2hlKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgdXJsID0gcmVxdWVzdCBpbnN0YW5jZW9mIFJlcXVlc3QgPyByZXF1ZXN0LnVybCA6IHJlcXVlc3Q7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5nZXRDYWNoZUtleUZvclVSTCh1cmwpO1xuICAgICAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgc2VsZi5jYWNoZXMub3Blbih0aGlzLnN0cmF0ZWd5LmNhY2hlTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUubWF0Y2goY2FjaGVLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGxvb2tzIHVwIGB1cmxgIGluIHRoZSBwcmVjYWNoZSAodGFraW5nIGludG9cbiAgICAgKiBhY2NvdW50IHJldmlzaW9uIGluZm9ybWF0aW9uKSwgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgYFJlc3BvbnNlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIHByZWNhY2hlZCBVUkwgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGxvb2t1cCB0aGVcbiAgICAgKiBgUmVzcG9uc2VgLlxuICAgICAqIEByZXR1cm4ge21vZHVsZTp3b3JrYm94LXJvdXRpbmd+aGFuZGxlckNhbGxiYWNrfVxuICAgICAqL1xuICAgIGNyZWF0ZUhhbmRsZXJCb3VuZFRvVVJMKHVybCkge1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuZ2V0Q2FjaGVLZXlGb3JVUkwodXJsKTtcbiAgICAgICAgaWYgKCFjYWNoZUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignbm9uLXByZWNhY2hlZC11cmwnLCB7IHVybCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIG9wdGlvbnMucmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCk7XG4gICAgICAgICAgICBvcHRpb25zLnBhcmFtcyA9IHsgY2FjaGVLZXksIC4uLm9wdGlvbnMucGFyYW1zIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJhdGVneS5oYW5kbGUob3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IHsgUHJlY2FjaGVDb250cm9sbGVyIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBQcmVjYWNoZUNvbnRyb2xsZXIgfSBmcm9tICcuLi9QcmVjYWNoZUNvbnRyb2xsZXIuanMnO1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG5sZXQgcHJlY2FjaGVDb250cm9sbGVyO1xuLyoqXG4gKiBAcmV0dXJuIHtQcmVjYWNoZUNvbnRyb2xsZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgZ2V0T3JDcmVhdGVQcmVjYWNoZUNvbnRyb2xsZXIgPSAoKSA9PiB7XG4gICAgaWYgKCFwcmVjYWNoZUNvbnRyb2xsZXIpIHtcbiAgICAgICAgcHJlY2FjaGVDb250cm9sbGVyID0gbmV3IFByZWNhY2hlQ29udHJvbGxlcigpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlY2FjaGVDb250cm9sbGVyO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gQHRzLWlnbm9yZVxudHJ5IHtcbiAgICBzZWxmWyd3b3JrYm94OnJvdXRpbmc6Ni4wLjInXSAmJiBfKCk7XG59XG5jYXRjaCAoZSkgeyB9XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogVGhlIGRlZmF1bHQgSFRUUCBtZXRob2QsICdHRVQnLCB1c2VkIHdoZW4gdGhlcmUncyBubyBzcGVjaWZpYyBtZXRob2RcbiAqIGNvbmZpZ3VyZWQgZm9yIGEgcm91dGUuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdE1ldGhvZCA9ICdHRVQnO1xuLyoqXG4gKiBUaGUgbGlzdCBvZiB2YWxpZCBIVFRQIG1ldGhvZHMgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3RzIHRoYXQgY291bGQgYmUgcm91dGVkLlxuICpcbiAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCB2YWxpZE1ldGhvZHMgPSBbXG4gICAgJ0RFTEVURScsXG4gICAgJ0dFVCcsXG4gICAgJ0hFQUQnLFxuICAgICdQQVRDSCcsXG4gICAgJ1BPU1QnLFxuICAgICdQVVQnLFxuXTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9hc3NlcnQuanMnO1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKXxPYmplY3R9IGhhbmRsZXIgRWl0aGVyIGEgZnVuY3Rpb24sIG9yIGFuIG9iamVjdCB3aXRoIGFcbiAqICdoYW5kbGUnIG1ldGhvZC5cbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggYSBoYW5kbGUgbWV0aG9kLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVIYW5kbGVyID0gKGhhbmRsZXIpID0+IHtcbiAgICBpZiAoaGFuZGxlciAmJiB0eXBlb2YgaGFuZGxlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydC5oYXNNZXRob2QoaGFuZGxlciwgJ2hhbmRsZScsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdSb3V0ZScsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnaGFuZGxlcicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBhc3NlcnQuaXNUeXBlKGhhbmRsZXIsICdmdW5jdGlvbicsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdSb3V0ZScsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnaGFuZGxlcicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBoYW5kbGU6IGhhbmRsZXIgfTtcbiAgICB9XG59O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBkZWZhdWx0TWV0aG9kLCB2YWxpZE1ldGhvZHMgfSBmcm9tICcuL3V0aWxzL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBub3JtYWxpemVIYW5kbGVyIH0gZnJvbSAnLi91dGlscy9ub3JtYWxpemVIYW5kbGVyLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEEgYFJvdXRlYCBjb25zaXN0cyBvZiBhIHBhaXIgb2YgY2FsbGJhY2sgZnVuY3Rpb25zLCBcIm1hdGNoXCIgYW5kIFwiaGFuZGxlclwiLlxuICogVGhlIFwibWF0Y2hcIiBjYWxsYmFjayBkZXRlcm1pbmUgaWYgYSByb3V0ZSBzaG91bGQgYmUgdXNlZCB0byBcImhhbmRsZVwiIGFcbiAqIHJlcXVlc3QgYnkgcmV0dXJuaW5nIGEgbm9uLWZhbHN5IHZhbHVlIGlmIGl0IGNhbi4gVGhlIFwiaGFuZGxlclwiIGNhbGxiYWNrXG4gKiBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBhIG1hdGNoIGFuZCBzaG91bGQgcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzXG4gKiB0byBhIGBSZXNwb25zZWAuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXJvdXRpbmdcbiAqL1xuY2xhc3MgUm91dGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBSb3V0ZSBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtcm91dGluZ35tYXRjaENhbGxiYWNrfSBtYXRjaFxuICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHJvdXRlIG1hdGNoZXMgYSBnaXZlblxuICAgICAqIGBmZXRjaGAgZXZlbnQgYnkgcmV0dXJuaW5nIGEgbm9uLWZhbHN5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtcm91dGluZ35oYW5kbGVyQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFja1xuICAgICAqIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIFByb21pc2UgcmVzb2x2aW5nIHRvIGEgUmVzcG9uc2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttZXRob2Q9J0dFVCddIFRoZSBIVFRQIG1ldGhvZCB0byBtYXRjaCB0aGUgUm91dGVcbiAgICAgKiBhZ2FpbnN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1hdGNoLCBoYW5kbGVyLCBtZXRob2QgPSBkZWZhdWx0TWV0aG9kKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBhc3NlcnQuaXNUeXBlKG1hdGNoLCAnZnVuY3Rpb24nLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUm91dGUnLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnY29uc3RydWN0b3InLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ21hdGNoJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGFzc2VydC5pc09uZU9mKG1ldGhvZCwgdmFsaWRNZXRob2RzLCB7IHBhcmFtTmFtZTogJ21ldGhvZCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlc2UgdmFsdWVzIGFyZSByZWZlcmVuY2VkIGRpcmVjdGx5IGJ5IFJvdXRlciBzbyBjYW5ub3QgYmVcbiAgICAgICAgLy8gYWx0ZXJlZCBieSBtaW5pZmljYXRvbi5cbiAgICAgICAgdGhpcy5oYW5kbGVyID0gbm9ybWFsaXplSGFuZGxlcihoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5tYXRjaCA9IG1hdGNoO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB9XG59XG5leHBvcnQgeyBSb3V0ZSB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IFJvdXRlIH0gZnJvbSAnLi9Sb3V0ZS5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBSZWdFeHBSb3V0ZSBtYWtlcyBpdCBlYXN5IHRvIGNyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBiYXNlZFxuICogW1JvdXRlXXtAbGluayBtb2R1bGU6d29ya2JveC1yb3V0aW5nLlJvdXRlfS5cbiAqXG4gKiBGb3Igc2FtZS1vcmlnaW4gcmVxdWVzdHMgdGhlIFJlZ0V4cCBvbmx5IG5lZWRzIHRvIG1hdGNoIHBhcnQgb2YgdGhlIFVSTC4gRm9yXG4gKiByZXF1ZXN0cyBhZ2FpbnN0IHRoaXJkLXBhcnR5IHNlcnZlcnMsIHlvdSBtdXN0IGRlZmluZSBhIFJlZ0V4cCB0aGF0IG1hdGNoZXNcbiAqIHRoZSBzdGFydCBvZiB0aGUgVVJMLlxuICpcbiAqIFtTZWUgdGhlIG1vZHVsZSBkb2NzIGZvciBpbmZvLl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3Rvb2xzL3dvcmtib3gvbW9kdWxlcy93b3JrYm94LXJvdXRpbmd9XG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXJvdXRpbmdcbiAqIEBleHRlbmRzIG1vZHVsZTp3b3JrYm94LXJvdXRpbmcuUm91dGVcbiAqL1xuY2xhc3MgUmVnRXhwUm91dGUgZXh0ZW5kcyBSb3V0ZSB7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBjb250YWluc1xuICAgICAqIFtjYXB0dXJlIGdyb3Vwc117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwI2dyb3VwaW5nLWJhY2stcmVmZXJlbmNlc30sXG4gICAgICogdGhlIGNhcHR1cmVkIHZhbHVlcyB3aWxsIGJlIHBhc3NlZCB0byB0aGVcbiAgICAgKiBbaGFuZGxlcidzXXtAbGluayBtb2R1bGU6d29ya2JveC1yb3V0aW5nfmhhbmRsZXJDYWxsYmFja30gYHBhcmFtc2BcbiAgICAgKiBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSByZWdFeHAgVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBhZ2FpbnN0IFVSTHMuXG4gICAgICogQHBhcmFtIHttb2R1bGU6d29ya2JveC1yb3V0aW5nfmhhbmRsZXJDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrXG4gICAgICogZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZSByZXN1bHRpbmcgaW4gYSBSZXNwb25zZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21ldGhvZD0nR0VUJ10gVGhlIEhUVFAgbWV0aG9kIHRvIG1hdGNoIHRoZSBSb3V0ZVxuICAgICAqIGFnYWluc3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVnRXhwLCBoYW5kbGVyLCBtZXRob2QpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc0luc3RhbmNlKHJlZ0V4cCwgUmVnRXhwLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUmVnRXhwUm91dGUnLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnY29uc3RydWN0b3InLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ3BhdHRlcm4nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0Y2ggPSAoeyB1cmwgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVnRXhwLmV4ZWModXJsLmhyZWYpO1xuICAgICAgICAgICAgLy8gUmV0dXJuIGltbWVkaWF0ZWx5IGlmIHRoZXJlJ3Mgbm8gbWF0Y2guXG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlcXVpcmUgdGhhdCB0aGUgbWF0Y2ggc3RhcnQgYXQgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgVVJMIHN0cmluZ1xuICAgICAgICAgICAgLy8gaWYgaXQncyBhIGNyb3NzLW9yaWdpbiByZXF1ZXN0LlxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvd29ya2JveC9pc3N1ZXMvMjgxIGZvciB0aGUgY29udGV4dFxuICAgICAgICAgICAgLy8gYmVoaW5kIHRoaXMgYmVoYXZpb3IuXG4gICAgICAgICAgICBpZiAoKHVybC5vcmlnaW4gIT09IGxvY2F0aW9uLm9yaWdpbikgJiYgKHJlc3VsdC5pbmRleCAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFRoZSByZWd1bGFyIGV4cHJlc3Npb24gJyR7cmVnRXhwfScgb25seSBwYXJ0aWFsbHkgbWF0Y2hlZCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBhZ2FpbnN0IHRoZSBjcm9zcy1vcmlnaW4gVVJMICcke3VybH0nLiBSZWdFeHBSb3V0ZSdzIHdpbGwgb25seSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBoYW5kbGUgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzIGlmIHRoZXkgbWF0Y2ggdGhlIGVudGlyZSBVUkwuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSByb3V0ZSBtYXRjaGVzLCBidXQgdGhlcmUgYXJlbid0IGFueSBjYXB0dXJlIGdyb3VwcyBkZWZpbmVkLCB0aGVuXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgcmV0dXJuIFtdLCB3aGljaCBpcyB0cnV0aHkgYW5kIHRoZXJlZm9yZSBzdWZmaWNpZW50IHRvXG4gICAgICAgICAgICAvLyBpbmRpY2F0ZSBhIG1hdGNoLlxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGNhcHR1cmUgZ3JvdXBzLCB0aGVuIGl0IHdpbGwgcmV0dXJuIHRoZWlyIHZhbHVlcy5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuc2xpY2UoMSk7XG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKG1hdGNoLCBoYW5kbGVyLCBtZXRob2QpO1xuICAgIH1cbn1cbmV4cG9ydCB7IFJlZ0V4cFJvdXRlIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzJztcbmltcG9ydCB7IGdldEZyaWVuZGx5VVJMIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2dldEZyaWVuZGx5VVJMLmpzJztcbmltcG9ydCB7IGRlZmF1bHRNZXRob2QgfSBmcm9tICcuL3V0aWxzL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IG5vcm1hbGl6ZUhhbmRsZXIgfSBmcm9tICcuL3V0aWxzL25vcm1hbGl6ZUhhbmRsZXIuanMnO1xuaW1wb3J0IHsgV29ya2JveEVycm9yIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBUaGUgUm91dGVyIGNhbiBiZSB1c2VkIHRvIHByb2Nlc3MgYSBGZXRjaEV2ZW50IHRocm91Z2ggb25lIG9yIG1vcmVcbiAqIFtSb3V0ZXNde0BsaW5rIG1vZHVsZTp3b3JrYm94LXJvdXRpbmcuUm91dGV9IHJlc3BvbmRpbmcgIHdpdGggYSBSZXF1ZXN0IGlmXG4gKiBhIG1hdGNoaW5nIHJvdXRlIGV4aXN0cy5cbiAqXG4gKiBJZiBubyByb3V0ZSBtYXRjaGVzIGEgZ2l2ZW4gYSByZXF1ZXN0LCB0aGUgUm91dGVyIHdpbGwgdXNlIGEgXCJkZWZhdWx0XCJcbiAqIGhhbmRsZXIgaWYgb25lIGlzIGRlZmluZWQuXG4gKlxuICogU2hvdWxkIHRoZSBtYXRjaGluZyBSb3V0ZSB0aHJvdyBhbiBlcnJvciwgdGhlIFJvdXRlciB3aWxsIHVzZSBhIFwiY2F0Y2hcIlxuICogaGFuZGxlciBpZiBvbmUgaXMgZGVmaW5lZCB0byBncmFjZWZ1bGx5IGRlYWwgd2l0aCBpc3N1ZXMgYW5kIHJlc3BvbmQgd2l0aCBhXG4gKiBSZXF1ZXN0LlxuICpcbiAqIElmIGEgcmVxdWVzdCBtYXRjaGVzIG11bHRpcGxlIHJvdXRlcywgdGhlICoqZWFybGllc3QqKiByZWdpc3RlcmVkIHJvdXRlIHdpbGxcbiAqIGJlIHVzZWQgdG8gcmVzcG9uZCB0byB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtcm91dGluZ1xuICovXG5jbGFzcyBSb3V0ZXIge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IFJvdXRlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fcm91dGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9kZWZhdWx0SGFuZGxlck1hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7TWFwPHN0cmluZywgQXJyYXk8bW9kdWxlOndvcmtib3gtcm91dGluZy5Sb3V0ZT4+fSByb3V0ZXMgQSBgTWFwYCBvZiBIVFRQXG4gICAgICogbWV0aG9kIG5hbWUgKCdHRVQnLCBldGMuKSB0byBhbiBhcnJheSBvZiBhbGwgdGhlIGNvcnJlc3BvbmRpbmcgYFJvdXRlYFxuICAgICAqIGluc3RhbmNlcyB0aGF0IGFyZSByZWdpc3RlcmVkLlxuICAgICAqL1xuICAgIGdldCByb3V0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3V0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBmZXRjaCBldmVudCBsaXN0ZW5lciB0byByZXNwb25kIHRvIGV2ZW50cyB3aGVuIGEgcm91dGUgbWF0Y2hlc1xuICAgICAqIHRoZSBldmVudCdzIHJlcXVlc3QuXG4gICAgICovXG4gICAgYWRkRmV0Y2hMaXN0ZW5lcigpIHtcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjgzNTcjaXNzdWVjb21tZW50LTQzNjQ4NDcwNVxuICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2ZldGNoJywgKChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyByZXF1ZXN0IH0gPSBldmVudDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IHRoaXMuaGFuZGxlUmVxdWVzdCh7IHJlcXVlc3QsIGV2ZW50IH0pO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnJlc3BvbmRXaXRoKHJlc3BvbnNlUHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG1lc3NhZ2UgZXZlbnQgbGlzdGVuZXIgZm9yIFVSTHMgdG8gY2FjaGUgZnJvbSB0aGUgd2luZG93LlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIHRvIGNhY2hlIHJlc291cmNlcyBsb2FkZWQgb24gdGhlIHBhZ2UgcHJpb3IgdG8gd2hlbiB0aGVcbiAgICAgKiBzZXJ2aWNlIHdvcmtlciBzdGFydGVkIGNvbnRyb2xsaW5nIGl0LlxuICAgICAqXG4gICAgICogVGhlIGZvcm1hdCBvZiB0aGUgbWVzc2FnZSBkYXRhIHNlbnQgZnJvbSB0aGUgd2luZG93IHNob3VsZCBiZSBhcyBmb2xsb3dzLlxuICAgICAqIFdoZXJlIHRoZSBgdXJsc1RvQ2FjaGVgIGFycmF5IG1heSBjb25zaXN0IG9mIFVSTCBzdHJpbmdzIG9yIGFuIGFycmF5IG9mXG4gICAgICogVVJMIHN0cmluZyArIGByZXF1ZXN0SW5pdGAgb2JqZWN0ICh0aGUgc2FtZSBhcyB5b3UnZCBwYXNzIHRvIGBmZXRjaCgpYCkuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB7XG4gICAgICogICB0eXBlOiAnQ0FDSEVfVVJMUycsXG4gICAgICogICBwYXlsb2FkOiB7XG4gICAgICogICAgIHVybHNUb0NhY2hlOiBbXG4gICAgICogICAgICAgJy4vc2NyaXB0MS5qcycsXG4gICAgICogICAgICAgJy4vc2NyaXB0Mi5qcycsXG4gICAgICogICAgICAgWycuL3NjcmlwdDMuanMnLCB7bW9kZTogJ25vLWNvcnMnfV0sXG4gICAgICogICAgIF0sXG4gICAgICogICB9LFxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhZGRDYWNoZUxpc3RlbmVyKCkge1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yODM1NyNpc3N1ZWNvbW1lbnQtNDM2NDg0NzA1XG4gICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsICgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhICYmIGV2ZW50LmRhdGEudHlwZSA9PT0gJ0NBQ0hFX1VSTFMnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXlsb2FkIH0gPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgQ2FjaGluZyBVUkxzIGZyb20gdGhlIHdpbmRvd2AsIHBheWxvYWQudXJsc1RvQ2FjaGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0UHJvbWlzZXMgPSBQcm9taXNlLmFsbChwYXlsb2FkLnVybHNUb0NhY2hlLm1hcCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5ID0gW2VudHJ5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoLi4uZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXF1ZXN0KHsgcmVxdWVzdCwgZXZlbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8ocGhpbGlwd2FsdG9uKTogVHlwZVNjcmlwdCBlcnJvcnMgd2l0aG91dCB0aGlzIHR5cGVjYXN0IGZvclxuICAgICAgICAgICAgICAgICAgICAvLyBzb21lIHJlYXNvbiAocHJvYmFibHkgYSBidWcpLiBUaGUgcmVhbCB0eXBlIGhlcmUgc2hvdWxkIHdvcmsgYnV0XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3Q6IGBBcnJheTxQcm9taXNlPFJlc3BvbnNlPiB8IHVuZGVmaW5lZD5gLlxuICAgICAgICAgICAgICAgIH0pKTsgLy8gVHlwZVNjcmlwdFxuICAgICAgICAgICAgICAgIGV2ZW50LndhaXRVbnRpbChyZXF1ZXN0UHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgIC8vIElmIGEgTWVzc2FnZUNoYW5uZWwgd2FzIHVzZWQsIHJlcGx5IHRvIHRoZSBtZXNzYWdlIG9uIHN1Y2Nlc3MuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnBvcnRzICYmIGV2ZW50LnBvcnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RQcm9taXNlcy50aGVuKCgpID0+IGV2ZW50LnBvcnRzWzBdLnBvc3RNZXNzYWdlKHRydWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIHJvdXRpbmcgcnVsZXMgdG8gYSBGZXRjaEV2ZW50IG9iamVjdCB0byBnZXQgYSBSZXNwb25zZSBmcm9tIGFuXG4gICAgICogYXBwcm9wcmlhdGUgUm91dGUncyBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R9IG9wdGlvbnMucmVxdWVzdCBUaGUgcmVxdWVzdCB0byBoYW5kbGUuXG4gICAgICogQHBhcmFtIHtFeHRlbmRhYmxlRXZlbnR9IG9wdGlvbnMuZXZlbnQgVGhlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZVxuICAgICAqICAgICByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8UmVzcG9uc2U+fHVuZGVmaW5lZH0gQSBwcm9taXNlIGlzIHJldHVybmVkIGlmIGFcbiAgICAgKiAgICAgcmVnaXN0ZXJlZCByb3V0ZSBjYW4gaGFuZGxlIHRoZSByZXF1ZXN0LiBJZiB0aGVyZSBpcyBubyBtYXRjaGluZ1xuICAgICAqICAgICByb3V0ZSBhbmQgdGhlcmUncyBubyBgZGVmYXVsdEhhbmRsZXJgLCBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBoYW5kbGVSZXF1ZXN0KHsgcmVxdWVzdCwgZXZlbnQgfSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgYXNzZXJ0LmlzSW5zdGFuY2UocmVxdWVzdCwgUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXJvdXRpbmcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1JvdXRlcicsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdoYW5kbGVSZXF1ZXN0JyxcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdvcHRpb25zLnJlcXVlc3QnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCwgbG9jYXRpb24uaHJlZik7XG4gICAgICAgIGlmICghdXJsLnByb3RvY29sLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFdvcmtib3ggUm91dGVyIG9ubHkgc3VwcG9ydHMgVVJMcyB0aGF0IHN0YXJ0IHdpdGggJ2h0dHAnLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNhbWVPcmlnaW4gPSB1cmwub3JpZ2luID09PSBsb2NhdGlvbi5vcmlnaW47XG4gICAgICAgIGNvbnN0IHsgcGFyYW1zLCByb3V0ZSB9ID0gdGhpcy5maW5kTWF0Y2hpbmdSb3V0ZSh7XG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBzYW1lT3JpZ2luLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGhhbmRsZXIgPSByb3V0ZSAmJiByb3V0ZS5oYW5kbGVyO1xuICAgICAgICBjb25zdCBkZWJ1Z01lc3NhZ2VzID0gW107XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGRlYnVnTWVzc2FnZXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIGBGb3VuZCBhIHJvdXRlIHRvIGhhbmRsZSB0aGlzIHJlcXVlc3Q6YCwgcm91dGUsXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z01lc3NhZ2VzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgYFBhc3NpbmcgdGhlIGZvbGxvd2luZyBwYXJhbXMgdG8gdGhlIHJvdXRlJ3MgaGFuZGxlcjpgLCBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgaGFuZGxlciBiZWNhdXNlIHRoZXJlIHdhcyBubyBtYXRjaGluZyByb3V0ZSwgdGhlblxuICAgICAgICAvLyBmYWxsIGJhY2sgdG8gZGVmYXVsdEhhbmRsZXIgaWYgdGhhdCdzIGRlZmluZWQuXG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgICAgICBpZiAoIWhhbmRsZXIgJiYgdGhpcy5fZGVmYXVsdEhhbmRsZXJNYXAuaGFzKG1ldGhvZCkpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZGVidWdNZXNzYWdlcy5wdXNoKGBGYWlsZWQgdG8gZmluZCBhIG1hdGNoaW5nIHJvdXRlLiBGYWxsaW5nIGAgK1xuICAgICAgICAgICAgICAgICAgICBgYmFjayB0byB0aGUgZGVmYXVsdCBoYW5kbGVyIGZvciAke21ldGhvZH0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVyID0gdGhpcy5fZGVmYXVsdEhhbmRsZXJNYXAuZ2V0KG1ldGhvZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIE5vIGhhbmRsZXIgc28gV29ya2JveCB3aWxsIGRvIG5vdGhpbmcuIElmIGxvZ3MgaXMgc2V0IG9mIGRlYnVnXG4gICAgICAgICAgICAgICAgLy8gaS5lLiB2ZXJib3NlLCB3ZSBzaG91bGQgcHJpbnQgb3V0IHRoaXMgaW5mb3JtYXRpb24uXG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBObyByb3V0ZSBmb3VuZCBmb3I6ICR7Z2V0RnJpZW5kbHlVUkwodXJsKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIGhhbmRsZXIsIG1lYW5pbmcgV29ya2JveCBpcyBnb2luZyB0byBoYW5kbGUgdGhlIHJvdXRlLlxuICAgICAgICAgICAgLy8gcHJpbnQgdGhlIHJvdXRpbmcgZGV0YWlscyB0byB0aGUgY29uc29sZS5cbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgUm91dGVyIGlzIHJlc3BvbmRpbmcgdG86ICR7Z2V0RnJpZW5kbHlVUkwodXJsKX1gKTtcbiAgICAgICAgICAgIGRlYnVnTWVzc2FnZXMuZm9yRWFjaCgobXNnKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobXNnKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKC4uLm1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXcmFwIGluIHRyeSBhbmQgY2F0Y2ggaW4gY2FzZSB0aGUgaGFuZGxlIG1ldGhvZCB0aHJvd3MgYSBzeW5jaHJvbm91c1xuICAgICAgICAvLyBlcnJvci4gSXQgc2hvdWxkIHN0aWxsIGNhbGxiYWNrIHRvIHRoZSBjYXRjaCBoYW5kbGVyLlxuICAgICAgICBsZXQgcmVzcG9uc2VQcm9taXNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlID0gaGFuZGxlci5oYW5kbGUoeyB1cmwsIHJlcXVlc3QsIGV2ZW50LCBwYXJhbXMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlID0gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2VQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSAmJiB0aGlzLl9jYXRjaEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZSA9IHJlc3BvbnNlUHJvbWlzZS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RpbGwgaW5jbHVkZSBVUkwgaGVyZSBhcyBpdCB3aWxsIGJlIGFzeW5jIGZyb20gdGhlIGNvbnNvbGUgZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIG1heSBub3QgbWFrZSBzZW5zZSB3aXRob3V0IHRoZSBVUkxcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBFcnJvciB0aHJvd24gd2hlbiByZXNwb25kaW5nIHRvOiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAgJHtnZXRGcmllbmRseVVSTCh1cmwpfS4gRmFsbGluZyBiYWNrIHRvIENhdGNoIEhhbmRsZXIuYCk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRXJyb3IgdGhyb3duIGJ5OmAsIHJvdXRlKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2F0Y2hIYW5kbGVyLmhhbmRsZSh7IHVybCwgcmVxdWVzdCwgZXZlbnQgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2VQcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgYSByZXF1ZXN0IGFuZCBVUkwgKGFuZCBvcHRpb25hbGx5IGFuIGV2ZW50KSBhZ2FpbnN0IHRoZSBsaXN0IG9mXG4gICAgICogcmVnaXN0ZXJlZCByb3V0ZXMsIGFuZCBpZiB0aGVyZSdzIGEgbWF0Y2gsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiByb3V0ZSBhbG9uZyB3aXRoIGFueSBwYXJhbXMgZ2VuZXJhdGVkIGJ5IHRoZSBtYXRjaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtVUkx9IG9wdGlvbnMudXJsXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fSBvcHRpb25zLnJlcXVlc3QgVGhlIHJlcXVlc3QgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtFdmVudH0gb3B0aW9ucy5ldmVudCBUaGUgY29ycmVzcG9uZGluZyBldmVudC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGByb3V0ZWAgYW5kIGBwYXJhbXNgIHByb3BlcnRpZXMuXG4gICAgICogICAgIFRoZXkgYXJlIHBvcHVsYXRlZCBpZiBhIG1hdGNoaW5nIHJvdXRlIHdhcyBmb3VuZCBvciBgdW5kZWZpbmVkYFxuICAgICAqICAgICBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZmluZE1hdGNoaW5nUm91dGUoeyB1cmwsIHNhbWVPcmlnaW4sIHJlcXVlc3QsIGV2ZW50IH0pIHtcbiAgICAgICAgY29uc3Qgcm91dGVzID0gdGhpcy5fcm91dGVzLmdldChyZXF1ZXN0Lm1ldGhvZCkgfHwgW107XG4gICAgICAgIGZvciAoY29uc3Qgcm91dGUgb2Ygcm91dGVzKSB7XG4gICAgICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hSZXN1bHQgPSByb3V0ZS5tYXRjaCh7IHVybCwgc2FtZU9yaWdpbiwgcmVxdWVzdCwgZXZlbnQgfSk7XG4gICAgICAgICAgICBpZiAobWF0Y2hSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXYXJuIGRldmVsb3BlcnMgdGhhdCB1c2luZyBhbiBhc3luYyBtYXRjaENhbGxiYWNrIGlzIGFsbW9zdCBhbHdheXNcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IHRoZSByaWdodCB0aGluZyB0byBkby4gXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBXaGlsZSByb3V0aW5nICR7Z2V0RnJpZW5kbHlVUkwodXJsKX0sIGFuIGFzeW5jIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBtYXRjaENhbGxiYWNrIGZ1bmN0aW9uIHdhcyB1c2VkLiBQbGVhc2UgY29udmVydCB0aGUgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGZvbGxvd2luZyByb3V0ZSB0byB1c2UgYSBzeW5jaHJvbm91cyBtYXRjaENhbGxiYWNrIGZ1bmN0aW9uOmAsIHJvdXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8yMDc5XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gbWF0Y2hSZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWF0Y2hSZXN1bHQpICYmIG1hdGNoUmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIHBhc3NpbmcgYW4gZW1wdHkgYXJyYXkgaW4gYXMgcGFyYW1zLCB1c2UgdW5kZWZpbmVkLlxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChtYXRjaFJlc3VsdC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG1hdGNoUmVzdWx0KS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgcGFzc2luZyBhbiBlbXB0eSBvYmplY3QgaW4gYXMgcGFyYW1zLCB1c2UgdW5kZWZpbmVkLlxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtYXRjaFJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciB0aGUgYm9vbGVhbiB2YWx1ZSB0cnVlIChyYXRoZXIgdGhhbiBqdXN0IHNvbWV0aGluZyB0cnV0aC15KSxcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc2V0IHBhcmFtcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvd29ya2JveC9wdWxsLzIxMzQjaXNzdWVjb21tZW50LTUxMzkyNDM1M1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJldHVybiBlYXJseSBpZiBoYXZlIGEgbWF0Y2guXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcm91dGUsIHBhcmFtcyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIG1hdGNoIHdhcyBmb3VuZCBhYm92ZSwgcmV0dXJuIGFuZCBlbXB0eSBvYmplY3QuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lIGEgZGVmYXVsdCBgaGFuZGxlcmAgdGhhdCdzIGNhbGxlZCB3aGVuIG5vIHJvdXRlcyBleHBsaWNpdGx5XG4gICAgICogbWF0Y2ggdGhlIGluY29taW5nIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBFYWNoIEhUVFAgbWV0aG9kICgnR0VUJywgJ1BPU1QnLCBldGMuKSBnZXRzIGl0cyBvd24gZGVmYXVsdCBoYW5kbGVyLlxuICAgICAqXG4gICAgICogV2l0aG91dCBhIGRlZmF1bHQgaGFuZGxlciwgdW5tYXRjaGVkIHJlcXVlc3RzIHdpbGwgZ28gYWdhaW5zdCB0aGVcbiAgICAgKiBuZXR3b3JrIGFzIGlmIHRoZXJlIHdlcmUgbm8gc2VydmljZSB3b3JrZXIgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOndvcmtib3gtcm91dGluZ35oYW5kbGVyQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFja1xuICAgICAqIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIFByb21pc2UgcmVzdWx0aW5nIGluIGEgUmVzcG9uc2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttZXRob2Q9J0dFVCddIFRoZSBIVFRQIG1ldGhvZCB0byBhc3NvY2lhdGUgd2l0aCB0aGlzXG4gICAgICogZGVmYXVsdCBoYW5kbGVyLiBFYWNoIG1ldGhvZCBoYXMgaXRzIG93biBkZWZhdWx0LlxuICAgICAqL1xuICAgIHNldERlZmF1bHRIYW5kbGVyKGhhbmRsZXIsIG1ldGhvZCA9IGRlZmF1bHRNZXRob2QpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEhhbmRsZXJNYXAuc2V0KG1ldGhvZCwgbm9ybWFsaXplSGFuZGxlcihoYW5kbGVyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGEgUm91dGUgdGhyb3dzIGFuIGVycm9yIHdoaWxlIGhhbmRsaW5nIGEgcmVxdWVzdCwgdGhpcyBgaGFuZGxlcmBcbiAgICAgKiB3aWxsIGJlIGNhbGxlZCBhbmQgZ2l2ZW4gYSBjaGFuY2UgdG8gcHJvdmlkZSBhIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6d29ya2JveC1yb3V0aW5nfmhhbmRsZXJDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrXG4gICAgICogZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZSByZXN1bHRpbmcgaW4gYSBSZXNwb25zZS5cbiAgICAgKi9cbiAgICBzZXRDYXRjaEhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9jYXRjaEhhbmRsZXIgPSBub3JtYWxpemVIYW5kbGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSByb3V0ZSB3aXRoIHRoZSByb3V0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp3b3JrYm94LXJvdXRpbmcuUm91dGV9IHJvdXRlIFRoZSByb3V0ZSB0byByZWdpc3Rlci5cbiAgICAgKi9cbiAgICByZWdpc3RlclJvdXRlKHJvdXRlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBhc3NlcnQuaXNUeXBlKHJvdXRlLCAnb2JqZWN0Jywge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXJvdXRpbmcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1JvdXRlcicsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdyZWdpc3RlclJvdXRlJyxcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdyb3V0ZScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFzc2VydC5oYXNNZXRob2Qocm91dGUsICdtYXRjaCcsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdSb3V0ZXInLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAncmVnaXN0ZXJSb3V0ZScsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAncm91dGUnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3NlcnQuaXNUeXBlKHJvdXRlLmhhbmRsZXIsICdvYmplY3QnLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUm91dGVyJyxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ3JlZ2lzdGVyUm91dGUnLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ3JvdXRlJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXNzZXJ0Lmhhc01ldGhvZChyb3V0ZS5oYW5kbGVyLCAnaGFuZGxlJywge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXJvdXRpbmcnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1JvdXRlcicsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICdyZWdpc3RlclJvdXRlJyxcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdyb3V0ZS5oYW5kbGVyJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXNzZXJ0LmlzVHlwZShyb3V0ZS5tZXRob2QsICdzdHJpbmcnLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUm91dGVyJyxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ3JlZ2lzdGVyUm91dGUnLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ3JvdXRlLm1ldGhvZCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3JvdXRlcy5oYXMocm91dGUubWV0aG9kKSkge1xuICAgICAgICAgICAgdGhpcy5fcm91dGVzLnNldChyb3V0ZS5tZXRob2QsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHaXZlIHByZWNlZGVuY2UgdG8gYWxsIG9mIHRoZSBlYXJsaWVyIHJvdXRlcyBieSBhZGRpbmcgdGhpcyBhZGRpdGlvbmFsXG4gICAgICAgIC8vIHJvdXRlIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAgICB0aGlzLl9yb3V0ZXMuZ2V0KHJvdXRlLm1ldGhvZCkucHVzaChyb3V0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXJzIGEgcm91dGUgd2l0aCB0aGUgcm91dGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6d29ya2JveC1yb3V0aW5nLlJvdXRlfSByb3V0ZSBUaGUgcm91dGUgdG8gdW5yZWdpc3Rlci5cbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyUm91dGUocm91dGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb3V0ZXMuaGFzKHJvdXRlLm1ldGhvZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ3VucmVnaXN0ZXItcm91dGUtYnV0LW5vdC1mb3VuZC13aXRoLW1ldGhvZCcsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHJvdXRlLm1ldGhvZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlSW5kZXggPSB0aGlzLl9yb3V0ZXMuZ2V0KHJvdXRlLm1ldGhvZCkuaW5kZXhPZihyb3V0ZSk7XG4gICAgICAgIGlmIChyb3V0ZUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3JvdXRlcy5nZXQocm91dGUubWV0aG9kKS5zcGxpY2Uocm91dGVJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCd1bnJlZ2lzdGVyLXJvdXRlLXJvdXRlLW5vdC1yZWdpc3RlcmVkJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgeyBSb3V0ZXIgfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IFJvdXRlciB9IGZyb20gJy4uL1JvdXRlci5qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbmxldCBkZWZhdWx0Um91dGVyO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBzaW5nbGV0b24gUm91dGVyIGluc3RhbmNlIGlmIG9uZSBkb2VzIG5vdCBleGlzdC4gSWYgb25lXG4gKiBkb2VzIGFscmVhZHkgZXhpc3QsIHRoYXQgaW5zdGFuY2UgaXMgcmV0dXJuZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge1JvdXRlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldE9yQ3JlYXRlRGVmYXVsdFJvdXRlciA9ICgpID0+IHtcbiAgICBpZiAoIWRlZmF1bHRSb3V0ZXIpIHtcbiAgICAgICAgZGVmYXVsdFJvdXRlciA9IG5ldyBSb3V0ZXIoKTtcbiAgICAgICAgLy8gVGhlIGhlbHBlcnMgdGhhdCB1c2UgdGhlIGRlZmF1bHQgUm91dGVyIGFzc3VtZSB0aGVzZSBsaXN0ZW5lcnMgZXhpc3QuXG4gICAgICAgIGRlZmF1bHRSb3V0ZXIuYWRkRmV0Y2hMaXN0ZW5lcigpO1xuICAgICAgICBkZWZhdWx0Um91dGVyLmFkZENhY2hlTGlzdGVuZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRSb3V0ZXI7XG59O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5qcyc7XG5pbXBvcnQgeyBXb3JrYm94RXJyb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCB7IFJvdXRlIH0gZnJvbSAnLi9Sb3V0ZS5qcyc7XG5pbXBvcnQgeyBSZWdFeHBSb3V0ZSB9IGZyb20gJy4vUmVnRXhwUm91dGUuanMnO1xuaW1wb3J0IHsgZ2V0T3JDcmVhdGVEZWZhdWx0Um91dGVyIH0gZnJvbSAnLi91dGlscy9nZXRPckNyZWF0ZURlZmF1bHRSb3V0ZXIuanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogRWFzaWx5IHJlZ2lzdGVyIGEgUmVnRXhwLCBzdHJpbmcsIG9yIGZ1bmN0aW9uIHdpdGggYSBjYWNoaW5nXG4gKiBzdHJhdGVneSB0byBhIHNpbmdsZXRvbiBSb3V0ZXIgaW5zdGFuY2UuXG4gKlxuICogVGhpcyBtZXRob2Qgd2lsbCBnZW5lcmF0ZSBhIFJvdXRlIGZvciB5b3UgaWYgbmVlZGVkIGFuZFxuICogY2FsbCBbcmVnaXN0ZXJSb3V0ZSgpXXtAbGluayBtb2R1bGU6d29ya2JveC1yb3V0aW5nLlJvdXRlciNyZWdpc3RlclJvdXRlfS5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd8bW9kdWxlOndvcmtib3gtcm91dGluZy5Sb3V0ZX5tYXRjaENhbGxiYWNrfG1vZHVsZTp3b3JrYm94LXJvdXRpbmcuUm91dGV9IGNhcHR1cmVcbiAqIElmIHRoZSBjYXB0dXJlIHBhcmFtIGlzIGEgYFJvdXRlYCwgYWxsIG90aGVyIGFyZ3VtZW50cyB3aWxsIGJlIGlnbm9yZWQuXG4gKiBAcGFyYW0ge21vZHVsZTp3b3JrYm94LXJvdXRpbmd+aGFuZGxlckNhbGxiYWNrfSBbaGFuZGxlcl0gQSBjYWxsYmFja1xuICogZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZSByZXN1bHRpbmcgaW4gYSBSZXNwb25zZS4gVGhpcyBwYXJhbWV0ZXJcbiAqIGlzIHJlcXVpcmVkIGlmIGBjYXB0dXJlYCBpcyBub3QgYSBgUm91dGVgIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0aG9kPSdHRVQnXSBUaGUgSFRUUCBtZXRob2QgdG8gbWF0Y2ggdGhlIFJvdXRlXG4gKiBhZ2FpbnN0LlxuICogQHJldHVybiB7bW9kdWxlOndvcmtib3gtcm91dGluZy5Sb3V0ZX0gVGhlIGdlbmVyYXRlZCBgUm91dGVgKFVzZWZ1bCBmb3JcbiAqIHVucmVnaXN0ZXJpbmcpLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1yb3V0aW5nXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyUm91dGUoY2FwdHVyZSwgaGFuZGxlciwgbWV0aG9kKSB7XG4gICAgbGV0IHJvdXRlO1xuICAgIGlmICh0eXBlb2YgY2FwdHVyZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgY2FwdHVyZVVybCA9IG5ldyBVUkwoY2FwdHVyZSwgbG9jYXRpb24uaHJlZik7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoIShjYXB0dXJlLnN0YXJ0c1dpdGgoJy8nKSB8fCBjYXB0dXJlLnN0YXJ0c1dpdGgoJ2h0dHAnKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdpbnZhbGlkLXN0cmluZycsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAncmVnaXN0ZXJSb3V0ZScsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ2NhcHR1cmUnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBjaGVjayBpZiBFeHByZXNzLXN0eWxlIHdpbGRjYXJkcyBhcmUgaW4gdGhlIHBhdGhuYW1lIG9ubHkuXG4gICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBsb2cgbWVzc2FnZSBpbiB2NC5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlVG9DaGVjayA9IGNhcHR1cmUuc3RhcnRzV2l0aCgnaHR0cCcpID9cbiAgICAgICAgICAgICAgICBjYXB0dXJlVXJsLnBhdGhuYW1lIDogY2FwdHVyZTtcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGlsbGFyanMvcGF0aC10by1yZWdleHAjcGFyYW1ldGVyc1xuICAgICAgICAgICAgY29uc3Qgd2lsZGNhcmRzID0gJ1sqOj8rXSc7XG4gICAgICAgICAgICBpZiAoKG5ldyBSZWdFeHAoYCR7d2lsZGNhcmRzfWApKS5leGVjKHZhbHVlVG9DaGVjaykpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFRoZSAnJGNhcHR1cmUnIHBhcmFtZXRlciBjb250YWlucyBhbiBFeHByZXNzLXN0eWxlIHdpbGRjYXJkIGAgK1xuICAgICAgICAgICAgICAgICAgICBgY2hhcmFjdGVyICgke3dpbGRjYXJkc30pLiBTdHJpbmdzIGFyZSBub3cgYWx3YXlzIGludGVycHJldGVkIGFzIGAgK1xuICAgICAgICAgICAgICAgICAgICBgZXhhY3QgbWF0Y2hlczsgdXNlIGEgUmVnRXhwIGZvciBwYXJ0aWFsIG9yIHdpbGRjYXJkIG1hdGNoZXMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0Y2hDYWxsYmFjayA9ICh7IHVybCB9KSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICgodXJsLnBhdGhuYW1lID09PSBjYXB0dXJlVXJsLnBhdGhuYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICAodXJsLm9yaWdpbiAhPT0gY2FwdHVyZVVybC5vcmlnaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgJHtjYXB0dXJlfSBvbmx5IHBhcnRpYWxseSBtYXRjaGVzIHRoZSBjcm9zcy1vcmlnaW4gVVJMIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCR7dXJsfS4gVGhpcyByb3V0ZSB3aWxsIG9ubHkgaGFuZGxlIGNyb3NzLW9yaWdpbiByZXF1ZXN0cyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpZiB0aGV5IG1hdGNoIHRoZSBlbnRpcmUgVVJMLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1cmwuaHJlZiA9PT0gY2FwdHVyZVVybC5ocmVmO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJZiBgY2FwdHVyZWAgaXMgYSBzdHJpbmcgdGhlbiBgaGFuZGxlcmAgYW5kIGBtZXRob2RgIG11c3QgYmUgcHJlc2VudC5cbiAgICAgICAgcm91dGUgPSBuZXcgUm91dGUobWF0Y2hDYWxsYmFjaywgaGFuZGxlciwgbWV0aG9kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2FwdHVyZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAvLyBJZiBgY2FwdHVyZWAgaXMgYSBgUmVnRXhwYCB0aGVuIGBoYW5kbGVyYCBhbmQgYG1ldGhvZGAgbXVzdCBiZSBwcmVzZW50LlxuICAgICAgICByb3V0ZSA9IG5ldyBSZWdFeHBSb3V0ZShjYXB0dXJlLCBoYW5kbGVyLCBtZXRob2QpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgY2FwdHVyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBJZiBgY2FwdHVyZWAgaXMgYSBmdW5jdGlvbiB0aGVuIGBoYW5kbGVyYCBhbmQgYG1ldGhvZGAgbXVzdCBiZSBwcmVzZW50LlxuICAgICAgICByb3V0ZSA9IG5ldyBSb3V0ZShjYXB0dXJlLCBoYW5kbGVyLCBtZXRob2QpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjYXB0dXJlIGluc3RhbmNlb2YgUm91dGUpIHtcbiAgICAgICAgcm91dGUgPSBjYXB0dXJlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcigndW5zdXBwb3J0ZWQtcm91dGUtdHlwZScsIHtcbiAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXJvdXRpbmcnLFxuICAgICAgICAgICAgZnVuY05hbWU6ICdyZWdpc3RlclJvdXRlJyxcbiAgICAgICAgICAgIHBhcmFtTmFtZTogJ2NhcHR1cmUnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFJvdXRlciA9IGdldE9yQ3JlYXRlRGVmYXVsdFJvdXRlcigpO1xuICAgIGRlZmF1bHRSb3V0ZXIucmVnaXN0ZXJSb3V0ZShyb3V0ZSk7XG4gICAgcmV0dXJuIHJvdXRlO1xufVxuZXhwb3J0IHsgcmVnaXN0ZXJSb3V0ZSB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIFJlbW92ZXMgYW55IFVSTCBzZWFyY2ggcGFyYW1ldGVycyB0aGF0IHNob3VsZCBiZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7VVJMfSB1cmxPYmplY3QgVGhlIG9yaWdpbmFsIFVSTC5cbiAqIEBwYXJhbSB7QXJyYXk8UmVnRXhwPn0gaWdub3JlVVJMUGFyYW1ldGVyc01hdGNoaW5nIFJlZ0V4cHMgdG8gdGVzdCBhZ2FpbnN0XG4gKiBlYWNoIHNlYXJjaCBwYXJhbWV0ZXIgbmFtZS4gTWF0Y2hlcyBtZWFuIHRoYXQgdGhlIHNlYXJjaCBwYXJhbWV0ZXIgc2hvdWxkIGJlXG4gKiBpZ25vcmVkLlxuICogQHJldHVybiB7VVJMfSBUaGUgVVJMIHdpdGggYW55IGlnbm9yZWQgc2VhcmNoIHBhcmFtZXRlcnMgcmVtb3ZlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUlnbm9yZWRTZWFyY2hQYXJhbXModXJsT2JqZWN0LCBpZ25vcmVVUkxQYXJhbWV0ZXJzTWF0Y2hpbmcgPSBbXSkge1xuICAgIC8vIENvbnZlcnQgdGhlIGl0ZXJhYmxlIGludG8gYW4gYXJyYXkgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsb29wIHRvIG1ha2Ugc3VyZVxuICAgIC8vIGRlbGV0aW9uIGRvZXNuJ3QgbWVzcyB1cCBpdGVyYXRpb24uXG4gICAgZm9yIChjb25zdCBwYXJhbU5hbWUgb2YgWy4uLnVybE9iamVjdC5zZWFyY2hQYXJhbXMua2V5cygpXSkge1xuICAgICAgICBpZiAoaWdub3JlVVJMUGFyYW1ldGVyc01hdGNoaW5nLnNvbWUoKHJlZ0V4cCkgPT4gcmVnRXhwLnRlc3QocGFyYW1OYW1lKSkpIHtcbiAgICAgICAgICAgIHVybE9iamVjdC5zZWFyY2hQYXJhbXMuZGVsZXRlKHBhcmFtTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVybE9iamVjdDtcbn1cbiIsIi8qXG4gIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCB7IHJlbW92ZUlnbm9yZWRTZWFyY2hQYXJhbXMgfSBmcm9tICcuL3JlbW92ZUlnbm9yZWRTZWFyY2hQYXJhbXMuanMnO1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEdlbmVyYXRvciBmdW5jdGlvbiB0aGF0IHlpZWxkcyBwb3NzaWJsZSB2YXJpYXRpb25zIG9uIHRoZSBvcmlnaW5hbCBVUkwgdG9cbiAqIGNoZWNrLCBvbmUgYXQgYSB0aW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiogZ2VuZXJhdGVVUkxWYXJpYXRpb25zKHVybCwgeyBpZ25vcmVVUkxQYXJhbWV0ZXJzTWF0Y2hpbmcgPSBbL151dG1fLywgL15mYmNsaWQkL10sIGRpcmVjdG9yeUluZGV4ID0gJ2luZGV4Lmh0bWwnLCBjbGVhblVSTHMgPSB0cnVlLCB1cmxNYW5pcHVsYXRpb24sIH0gPSB7fSkge1xuICAgIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5ocmVmKTtcbiAgICB1cmxPYmplY3QuaGFzaCA9ICcnO1xuICAgIHlpZWxkIHVybE9iamVjdC5ocmVmO1xuICAgIGNvbnN0IHVybFdpdGhvdXRJZ25vcmVkUGFyYW1zID0gcmVtb3ZlSWdub3JlZFNlYXJjaFBhcmFtcyh1cmxPYmplY3QsIGlnbm9yZVVSTFBhcmFtZXRlcnNNYXRjaGluZyk7XG4gICAgeWllbGQgdXJsV2l0aG91dElnbm9yZWRQYXJhbXMuaHJlZjtcbiAgICBpZiAoZGlyZWN0b3J5SW5kZXggJiYgdXJsV2l0aG91dElnbm9yZWRQYXJhbXMucGF0aG5hbWUuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICBjb25zdCBkaXJlY3RvcnlVUkwgPSBuZXcgVVJMKHVybFdpdGhvdXRJZ25vcmVkUGFyYW1zLmhyZWYpO1xuICAgICAgICBkaXJlY3RvcnlVUkwucGF0aG5hbWUgKz0gZGlyZWN0b3J5SW5kZXg7XG4gICAgICAgIHlpZWxkIGRpcmVjdG9yeVVSTC5ocmVmO1xuICAgIH1cbiAgICBpZiAoY2xlYW5VUkxzKSB7XG4gICAgICAgIGNvbnN0IGNsZWFuVVJMID0gbmV3IFVSTCh1cmxXaXRob3V0SWdub3JlZFBhcmFtcy5ocmVmKTtcbiAgICAgICAgY2xlYW5VUkwucGF0aG5hbWUgKz0gJy5odG1sJztcbiAgICAgICAgeWllbGQgY2xlYW5VUkwuaHJlZjtcbiAgICB9XG4gICAgaWYgKHVybE1hbmlwdWxhdGlvbikge1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsVVJMcyA9IHVybE1hbmlwdWxhdGlvbih7IHVybDogdXJsT2JqZWN0IH0pO1xuICAgICAgICBmb3IgKGNvbnN0IHVybFRvQXR0ZW1wdCBvZiBhZGRpdGlvbmFsVVJMcykge1xuICAgICAgICAgICAgeWllbGQgdXJsVG9BdHRlbXB0LmhyZWY7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IGdldEZyaWVuZGx5VVJMIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2dldEZyaWVuZGx5VVJMLmpzJztcbmltcG9ydCB7IFJvdXRlIH0gZnJvbSAnd29ya2JveC1yb3V0aW5nL1JvdXRlLmpzJztcbmltcG9ydCB7IGdlbmVyYXRlVVJMVmFyaWF0aW9ucyB9IGZyb20gJy4vdXRpbHMvZ2VuZXJhdGVVUkxWYXJpYXRpb25zLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEEgc3ViY2xhc3Mgb2YgW1JvdXRlXXtAbGluayBtb2R1bGU6d29ya2JveC1yb3V0aW5nLlJvdXRlfSB0aGF0IHRha2VzIGFcbiAqIFtQcmVjYWNoZUNvbnRyb2xsZXJde0BsaW5rIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuUHJlY2FjaGVDb250cm9sbGVyfVxuICogaW5zdGFuY2UgYW5kIHVzZXMgaXQgdG8gbWF0Y2ggaW5jb21pbmcgcmVxdWVzdHMgYW5kIGhhbmRsZSBmZXRjaGluZ1xuICogcmVzcG9uc2VzIGZyb20gdGhlIHByZWNhY2hlLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nXG4gKiBAZXh0ZW5kcyBtb2R1bGU6d29ya2JveC1yb3V0aW5nLlJvdXRlXG4gKi9cbmNsYXNzIFByZWNhY2hlUm91dGUgZXh0ZW5kcyBSb3V0ZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQcmVjYWNoZUNvbnRyb2xsZXJ9IHByZWNhY2hlQ29udHJvbGxlciBBIGBQcmVjYWNoZUNvbnRyb2xsZXJgXG4gICAgICogaW5zdGFuY2UgdXNlZCB0byBib3RoIG1hdGNoIHJlcXVlc3RzIGFuZCByZXNwb25kIHRvIGZldGNoIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgdG8gY29udHJvbCBob3cgcmVxdWVzdHMgYXJlIG1hdGNoZWRcbiAgICAgKiBhZ2FpbnN0IHRoZSBsaXN0IG9mIHByZWNhY2hlZCBVUkxzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kaXJlY3RvcnlJbmRleD1pbmRleC5odG1sXSBUaGUgYGRpcmVjdG9yeUluZGV4YCB3aWxsXG4gICAgICogY2hlY2sgY2FjaGUgZW50cmllcyBmb3IgYSBVUkxzIGVuZGluZyB3aXRoICcvJyB0byBzZWUgaWYgdGhlcmUgaXMgYSBoaXQgd2hlblxuICAgICAqIGFwcGVuZGluZyB0aGUgYGRpcmVjdG9yeUluZGV4YCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5PFJlZ0V4cD59IFtvcHRpb25zLmlnbm9yZVVSTFBhcmFtZXRlcnNNYXRjaGluZz1bL151dG1fLywgL15mYmNsaWQkL11dIEFuXG4gICAgICogYXJyYXkgb2YgcmVnZXgncyB0byByZW1vdmUgc2VhcmNoIHBhcmFtcyB3aGVuIGxvb2tpbmcgZm9yIGEgY2FjaGUgbWF0Y2guXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jbGVhblVSTHM9dHJ1ZV0gVGhlIGBjbGVhblVSTHNgIG9wdGlvbiB3aWxsXG4gICAgICogY2hlY2sgdGhlIGNhY2hlIGZvciB0aGUgVVJMIHdpdGggYSBgLmh0bWxgIGFkZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGVuZC5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp3b3JrYm94LXByZWNhY2hpbmd+dXJsTWFuaXB1bGF0aW9ufSBbb3B0aW9ucy51cmxNYW5pcHVsYXRpb25dXG4gICAgICogVGhpcyBpcyBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIHRha2UgYSBVUkwgYW5kIHJldHVybiBhbiBhcnJheSBvZlxuICAgICAqIGFsdGVybmF0aXZlIFVSTHMgdGhhdCBzaG91bGQgYmUgY2hlY2tlZCBmb3IgcHJlY2FjaGUgbWF0Y2hlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwcmVjYWNoZUNvbnRyb2xsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSAoeyByZXF1ZXN0IH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVybHNUb0NhY2hlS2V5cyA9IHByZWNhY2hlQ29udHJvbGxlci5nZXRVUkxzVG9DYWNoZUtleXMoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcG9zc2libGVVUkwgb2YgZ2VuZXJhdGVVUkxWYXJpYXRpb25zKHJlcXVlc3QudXJsLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gdXJsc1RvQ2FjaGVLZXlzLmdldChwb3NzaWJsZVVSTCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGNhY2hlS2V5IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFByZWNhY2hpbmcgZGlkIG5vdCBmaW5kIGEgbWF0Y2ggZm9yIGAgK1xuICAgICAgICAgICAgICAgICAgICBnZXRGcmllbmRseVVSTChyZXF1ZXN0LnVybCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICBzdXBlcihtYXRjaCwgcHJlY2FjaGVDb250cm9sbGVyLnN0cmF0ZWd5KTtcbiAgICB9XG59XG5leHBvcnQgeyBQcmVjYWNoZVJvdXRlIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgcmVnaXN0ZXJSb3V0ZSB9IGZyb20gJ3dvcmtib3gtcm91dGluZy9yZWdpc3RlclJvdXRlLmpzJztcbmltcG9ydCB7IGdldE9yQ3JlYXRlUHJlY2FjaGVDb250cm9sbGVyIH0gZnJvbSAnLi91dGlscy9nZXRPckNyZWF0ZVByZWNhY2hlQ29udHJvbGxlci5qcyc7XG5pbXBvcnQgeyBQcmVjYWNoZVJvdXRlIH0gZnJvbSAnLi9QcmVjYWNoZVJvdXRlLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIEFkZCBhIGBmZXRjaGAgbGlzdGVuZXIgdG8gdGhlIHNlcnZpY2Ugd29ya2VyIHRoYXQgd2lsbFxuICogcmVzcG9uZCB0b1xuICogW25ldHdvcmsgcmVxdWVzdHNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2aWNlX1dvcmtlcl9BUEkvVXNpbmdfU2VydmljZV9Xb3JrZXJzI0N1c3RvbV9yZXNwb25zZXNfdG9fcmVxdWVzdHN9XG4gKiB3aXRoIHByZWNhY2hlZCBhc3NldHMuXG4gKlxuICogUmVxdWVzdHMgZm9yIGFzc2V0cyB0aGF0IGFyZW4ndCBwcmVjYWNoZWQsIHRoZSBgRmV0Y2hFdmVudGAgd2lsbCBub3QgYmVcbiAqIHJlc3BvbmRlZCB0bywgYWxsb3dpbmcgdGhlIGV2ZW50IHRvIGZhbGwgdGhyb3VnaCB0byBvdGhlciBgZmV0Y2hgIGV2ZW50XG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBTZWVcbiAqIFtQcmVjYWNoZVJvdXRlIG9wdGlvbnNde0BsaW5rIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuUHJlY2FjaGVSb3V0ZX0uXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmdcbiAqL1xuZnVuY3Rpb24gYWRkUm91dGUob3B0aW9ucykge1xuICAgIGNvbnN0IHByZWNhY2hlQ29udHJvbGxlciA9IGdldE9yQ3JlYXRlUHJlY2FjaGVDb250cm9sbGVyKCk7XG4gICAgY29uc3QgcHJlY2FjaGVSb3V0ZSA9IG5ldyBQcmVjYWNoZVJvdXRlKHByZWNhY2hlQ29udHJvbGxlciwgb3B0aW9ucyk7XG4gICAgcmVnaXN0ZXJSb3V0ZShwcmVjYWNoZVJvdXRlKTtcbn1cbmV4cG9ydCB7IGFkZFJvdXRlIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBnZXRPckNyZWF0ZVByZWNhY2hlQ29udHJvbGxlciB9IGZyb20gJy4vdXRpbHMvZ2V0T3JDcmVhdGVQcmVjYWNoZUNvbnRyb2xsZXIuanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLmpzJztcbi8qKlxuICogQWRkcyBpdGVtcyB0byB0aGUgcHJlY2FjaGUgbGlzdCwgcmVtb3ZpbmcgYW55IGR1cGxpY2F0ZXMgYW5kXG4gKiBzdG9yZXMgdGhlIGZpbGVzIGluIHRoZVxuICogW1wicHJlY2FjaGUgY2FjaGVcIl17QGxpbmsgbW9kdWxlOndvcmtib3gtY29yZS5jYWNoZU5hbWVzfSB3aGVuIHRoZSBzZXJ2aWNlXG4gKiB3b3JrZXIgaW5zdGFsbHMuXG4gKlxuICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQbGVhc2Ugbm90ZTogVGhpcyBtZXRob2QgKip3aWxsIG5vdCoqIHNlcnZlIGFueSBvZiB0aGUgY2FjaGVkIGZpbGVzIGZvciB5b3UuXG4gKiBJdCBvbmx5IHByZWNhY2hlcyBmaWxlcy4gVG8gcmVzcG9uZCB0byBhIG5ldHdvcmsgcmVxdWVzdCB5b3UgY2FsbFxuICogW2FkZFJvdXRlKClde0BsaW5rIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuYWRkUm91dGV9LlxuICpcbiAqIElmIHlvdSBoYXZlIGEgc2luZ2xlIGFycmF5IG9mIGZpbGVzIHRvIHByZWNhY2hlLCB5b3UgY2FuIGp1c3QgY2FsbFxuICogW3ByZWNhY2hlQW5kUm91dGUoKV17QGxpbmsgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5wcmVjYWNoZUFuZFJvdXRlfS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdHxzdHJpbmc+fSBbZW50cmllcz1bXV0gQXJyYXkgb2YgZW50cmllcyB0byBwcmVjYWNoZS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZ1xuICovXG5mdW5jdGlvbiBwcmVjYWNoZShlbnRyaWVzKSB7XG4gICAgY29uc3QgcHJlY2FjaGVDb250cm9sbGVyID0gZ2V0T3JDcmVhdGVQcmVjYWNoZUNvbnRyb2xsZXIoKTtcbiAgICBwcmVjYWNoZUNvbnRyb2xsZXIucHJlY2FjaGUoZW50cmllcyk7XG59XG5leHBvcnQgeyBwcmVjYWNoZSB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgYWRkUm91dGUgfSBmcm9tICcuL2FkZFJvdXRlLmpzJztcbmltcG9ydCB7IHByZWNhY2hlIH0gZnJvbSAnLi9wcmVjYWNoZS5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBUaGlzIG1ldGhvZCB3aWxsIGFkZCBlbnRyaWVzIHRvIHRoZSBwcmVjYWNoZSBsaXN0IGFuZCBhZGQgYSByb3V0ZSB0b1xuICogcmVzcG9uZCB0byBmZXRjaCBldmVudHMuXG4gKlxuICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCB0aGF0IHdpbGwgY2FsbFxuICogW3ByZWNhY2hlKClde0BsaW5rIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcucHJlY2FjaGV9IGFuZFxuICogW2FkZFJvdXRlKClde0BsaW5rIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuYWRkUm91dGV9IGluIGEgc2luZ2xlIGNhbGwuXG4gKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3R8c3RyaW5nPn0gZW50cmllcyBBcnJheSBvZiBlbnRyaWVzIHRvIHByZWNhY2hlLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBTZWVcbiAqIFtQcmVjYWNoZVJvdXRlIG9wdGlvbnNde0BsaW5rIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuUHJlY2FjaGVSb3V0ZX0uXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmdcbiAqL1xuZnVuY3Rpb24gcHJlY2FjaGVBbmRSb3V0ZShlbnRyaWVzLCBvcHRpb25zKSB7XG4gICAgcHJlY2FjaGUoZW50cmllcyk7XG4gICAgYWRkUm91dGUob3B0aW9ucyk7XG59XG5leHBvcnQgeyBwcmVjYWNoZUFuZFJvdXRlIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IGdldEZyaWVuZGx5VVJMIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2dldEZyaWVuZGx5VVJMLmpzJztcbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuZXhwb3J0IGNvbnN0IG1lc3NhZ2VzID0ge1xuICAgIHN0cmF0ZWd5U3RhcnQ6IChzdHJhdGVneU5hbWUsIHJlcXVlc3QpID0+IGBVc2luZyAke3N0cmF0ZWd5TmFtZX0gdG8gcmVzcG9uZCB0byAnJHtnZXRGcmllbmRseVVSTChyZXF1ZXN0LnVybCl9J2AsXG4gICAgcHJpbnRGaW5hbFJlc3BvbnNlOiAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoYFZpZXcgdGhlIGZpbmFsIHJlc3BvbnNlIGhlcmUuYCk7XG4gICAgICAgICAgICBsb2dnZXIubG9nKHJlc3BvbnNlIHx8ICdbTm8gcmVzcG9uc2UgcmV0dXJuZWRdJyk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLmpzJztcbmltcG9ydCB7IFdvcmtib3hFcnJvciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9Xb3JrYm94RXJyb3IuanMnO1xuaW1wb3J0IHsgU3RyYXRlZ3kgfSBmcm9tICcuL1N0cmF0ZWd5LmpzJztcbmltcG9ydCB7IG1lc3NhZ2VzIH0gZnJvbSAnLi91dGlscy9tZXNzYWdlcy5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBhIFtjYWNoZS1maXJzdF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL2Z1bmRhbWVudGFscy9pbnN0YW50LWFuZC1vZmZsaW5lL29mZmxpbmUtY29va2Jvb2svI2NhY2hlLWZhbGxpbmctYmFjay10by1uZXR3b3JrfVxuICogcmVxdWVzdCBzdHJhdGVneS5cbiAqXG4gKiBBIGNhY2hlIGZpcnN0IHN0cmF0ZWd5IGlzIHVzZWZ1bCBmb3IgYXNzZXRzIHRoYXQgaGF2ZSBiZWVuIHJldmlzaW9uZWQsXG4gKiBzdWNoIGFzIFVSTHMgbGlrZSBgL3N0eWxlcy9leGFtcGxlLmE4ZjVmMS5jc3NgLCBzaW5jZSB0aGV5XG4gKiBjYW4gYmUgY2FjaGVkIGZvciBsb25nIHBlcmlvZHMgb2YgdGltZS5cbiAqXG4gKiBJZiB0aGUgbmV0d29yayByZXF1ZXN0IGZhaWxzLCBhbmQgdGhlcmUgaXMgbm8gY2FjaGUgbWF0Y2gsIHRoaXMgd2lsbCB0aHJvd1xuICogYSBgV29ya2JveEVycm9yYCBleGNlcHRpb24uXG4gKlxuICogQGV4dGVuZHMgbW9kdWxlOndvcmtib3gtc3RyYXRlZ2llcy5TdHJhdGVneVxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXNcbiAqL1xuY2xhc3MgQ2FjaGVGaXJzdCBleHRlbmRzIFN0cmF0ZWd5IHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UmVxdWVzdHxzdHJpbmd9IHJlcXVlc3QgQSByZXF1ZXN0IHRvIHJ1biB0aGlzIHN0cmF0ZWd5IGZvci5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp3b3JrYm94LXN0cmF0ZWdpZXMuU3RyYXRlZ3lIYW5kbGVyfSBoYW5kbGVyIFRoZSBldmVudCB0aGF0XG4gICAgICogICAgIHRyaWdnZXJlZCB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJlc3BvbnNlPn1cbiAgICAgKi9cbiAgICBhc3luYyBfaGFuZGxlKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgbG9ncyA9IFtdO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgYXNzZXJ0LmlzSW5zdGFuY2UocmVxdWVzdCwgUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXN0cmF0ZWdpZXMnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnbWFrZVJlcXVlc3QnLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ3JlcXVlc3QnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlci5jYWNoZU1hdGNoKHJlcXVlc3QpO1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbG9ncy5wdXNoKGBObyByZXNwb25zZSBmb3VuZCBpbiB0aGUgJyR7dGhpcy5jYWNoZU5hbWV9JyBjYWNoZS4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBXaWxsIHJlc3BvbmQgd2l0aCBhIG5ldHdvcmsgcmVxdWVzdC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmZldGNoQW5kQ2FjaGVQdXQocmVxdWVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dzLnB1c2goYEdvdCByZXNwb25zZSBmcm9tIG5ldHdvcmsuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dzLnB1c2goYFVuYWJsZSB0byBnZXQgYSByZXNwb25zZSBmcm9tIHRoZSBuZXR3b3JrLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbG9ncy5wdXNoKGBGb3VuZCBhIGNhY2hlZCByZXNwb25zZSBpbiB0aGUgJyR7dGhpcy5jYWNoZU5hbWV9JyBjYWNoZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKG1lc3NhZ2VzLnN0cmF0ZWd5U3RhcnQodGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCByZXF1ZXN0KSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxvZyBvZiBsb2dzKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhsb2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZXMucHJpbnRGaW5hbFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ25vLXJlc3BvbnNlJywgeyB1cmw6IHJlcXVlc3QudXJsLCBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuZXhwb3J0IHsgQ2FjaGVGaXJzdCB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IHByZXZlbnRzIGEgcHJvbWlzZSBmcm9tIGJlaW5nIGZsYWdnZWQgYXMgdW51c2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZG9udFdhaXRGb3IocHJvbWlzZSkge1xuICAgIC8vIEVmZmVjdGl2ZSBuby1vcC5cbiAgICBwcm9taXNlLnRoZW4oKCkgPT4geyB9KTtcbn1cbiIsIi8qXG4gIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcblxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAgbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuKi9cbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQgd3JhcHMgY29tbW9uIEluZGV4ZWREQiBmdW5jdGlvbmFsaXR5IGluIGEgcHJvbWlzZS1iYXNlZCBBUEkuXG4gKiBJdCBleHBvc2VzIGFsbCB0aGUgdW5kZXJseWluZyBwb3dlciBhbmQgZnVuY3Rpb25hbGl0eSBvZiBJbmRleGVkREIsIGJ1dFxuICogd3JhcHMgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBmZWF0dXJlcyBpbiBhIHdheSB0aGF0J3MgbXVjaCBzaW1wbGVyIHRvIHVzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgREJXcmFwcGVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBbY2FsbGJhY2tdXG4gICAgICogQHBhcmFtIHshRnVuY3Rpb259IFtjYWxsYmFja3Mub251cGdyYWRlbmVlZGVkXVxuICAgICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBbY2FsbGJhY2tzLm9udmVyc2lvbmNoYW5nZV0gRGVmYXVsdHMgdG9cbiAgICAgKiAgICAgREJXcmFwcGVyLnByb3RvdHlwZS5fb252ZXJzaW9uY2hhbmdlIHdoZW4gbm90IHNwZWNpZmllZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHZlcnNpb24sIHsgb251cGdyYWRlbmVlZGVkLCBvbnZlcnNpb25jaGFuZ2UsIH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9kYiA9IG51bGw7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fb251cGdyYWRlbmVlZGVkID0gb251cGdyYWRlbmVlZGVkO1xuICAgICAgICB0aGlzLl9vbnZlcnNpb25jaGFuZ2UgPSBvbnZlcnNpb25jaGFuZ2UgfHwgKCgpID0+IHRoaXMuY2xvc2UoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElEQkRhdGFiYXNlIGluc3RhbmNlIChub3Qgbm9ybWFsbHkgbmVlZGVkKS5cbiAgICAgKiBAcmV0dXJuIHtJREJEYXRhYmFzZXx1bmRlZmluZWR9XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldCBkYigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyBhIGNvbm5lY3RlZCB0byBhbiBJREJEYXRhYmFzZSwgaW52b2tlcyBhbnkgb251cGdyYWRlZG5lZWRlZFxuICAgICAqIGNhbGxiYWNrLCBhbmQgYWRkZWQgYW4gb252ZXJzaW9uY2hhbmdlIGNhbGxiYWNrIHRvIHRoZSBkYXRhYmFzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lEQkRhdGFiYXNlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgb3BlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9kYiA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIFRoaXMgZmxhZyBpcyBmbGlwcGVkIHRvIHRydWUgaWYgdGhlIHRpbWVvdXQgY2FsbGJhY2sgcnVucyBwcmlvclxuICAgICAgICAgICAgLy8gdG8gdGhlIHJlcXVlc3QgZmFpbGluZyBvciBzdWNjZWVkaW5nLiBOb3RlOiB3ZSB1c2UgYSB0aW1lb3V0IGluc3RlYWRcbiAgICAgICAgICAgIC8vIG9mIGFuIG9uYmxvY2tlZCBoYW5kbGVyIHNpbmNlIHRoZXJlIGFyZSBjYXNlcyB3aGVyZSBvbmJsb2NrZWQgd2lsbFxuICAgICAgICAgICAgLy8gbmV2ZXIgbmV2ZXIgcnVuLiBBIHRpbWVvdXQgYmV0dGVyIGhhbmRsZXMgYWxsIHBvc3NpYmxlIHNjZW5hcmlvczpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvSW5kZXhlZERCL2lzc3Vlcy8yMjNcbiAgICAgICAgICAgIGxldCBvcGVuUmVxdWVzdFRpbWVkT3V0ID0gZmFsc2U7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBvcGVuUmVxdWVzdFRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGUgb3BlbiByZXF1ZXN0IHdhcyBibG9ja2VkIGFuZCB0aW1lZCBvdXQnKSk7XG4gICAgICAgICAgICB9LCB0aGlzLk9QRU5fVElNRU9VVCk7XG4gICAgICAgICAgICBjb25zdCBvcGVuUmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMuX25hbWUsIHRoaXMuX3ZlcnNpb24pO1xuICAgICAgICAgICAgb3BlblJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChvcGVuUmVxdWVzdC5lcnJvcik7XG4gICAgICAgICAgICBvcGVuUmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9wZW5SZXF1ZXN0VGltZWRPdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlblJlcXVlc3QudHJhbnNhY3Rpb24uYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgb3BlblJlcXVlc3QucmVzdWx0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9vbnVwZ3JhZGVuZWVkZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb251cGdyYWRlbmVlZGVkKGV2dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9wZW5SZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYiA9IG9wZW5SZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAob3BlblJlcXVlc3RUaW1lZE91dCkge1xuICAgICAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGIub252ZXJzaW9uY2hhbmdlID0gdGhpcy5fb252ZXJzaW9uY2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9seWZpbGxzIHRoZSBuYXRpdmUgYGdldEtleSgpYCBtZXRob2QuIE5vdGUsIHRoaXMgaXMgb3ZlcnJpZGRlbiBhdFxuICAgICAqIHJ1bnRpbWUgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIG5hdGl2ZSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVOYW1lXG4gICAgICogQHBhcmFtIHsqfSBxdWVyeVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0S2V5KHN0b3JlTmFtZSwgcXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldEFsbEtleXMoc3RvcmVOYW1lLCBxdWVyeSwgMSkpWzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb2x5ZmlsbHMgdGhlIG5hdGl2ZSBgZ2V0QWxsKClgIG1ldGhvZC4gTm90ZSwgdGhpcyBpcyBvdmVycmlkZGVuIGF0XG4gICAgICogcnVudGltZSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgbmF0aXZlIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZU5hbWVcbiAgICAgKiBAcGFyYW0geyp9IHF1ZXJ5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBbGwoc3RvcmVOYW1lLCBxdWVyeSwgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QWxsTWF0Y2hpbmcoc3RvcmVOYW1lLCB7IHF1ZXJ5LCBjb3VudCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9seWZpbGxzIHRoZSBuYXRpdmUgYGdldEFsbEtleXMoKWAgbWV0aG9kLiBOb3RlLCB0aGlzIGlzIG92ZXJyaWRkZW4gYXRcbiAgICAgKiBydW50aW1lIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBuYXRpdmUgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0b3JlTmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gcXVlcnlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIGdldEFsbEtleXMoc3RvcmVOYW1lLCBxdWVyeSwgY291bnQpIHtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IGF3YWl0IHRoaXMuZ2V0QWxsTWF0Y2hpbmcoc3RvcmVOYW1lLCB7IHF1ZXJ5LCBjb3VudCwgaW5jbHVkZUtleXM6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBlbnRyaWVzLm1hcCgoZW50cnkpID0+IGVudHJ5LmtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIGZsZXhpYmxlIGxvb2t1cCBpbiBhbiBvYmplY3Qgc3RvcmUgYnkgc3BlY2lmeWluZyBhbiBpbmRleCxcbiAgICAgKiBxdWVyeSwgZGlyZWN0aW9uLCBhbmQgY291bnQuIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gYXJyYXkgb2Ygb2JqZWN0c1xuICAgICAqIHdpdGggdGhlIHNpZ25hdHVyZSAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVOYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pbmRleF0gVGhlIGluZGV4IHRvIHVzZSAoaWYgc3BlY2lmaWVkKS5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRzLnF1ZXJ5XVxuICAgICAqIEBwYXJhbSB7SURCQ3Vyc29yRGlyZWN0aW9ufSBbb3B0cy5kaXJlY3Rpb25dXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmNvdW50XSBUaGUgbWF4IG51bWJlciBvZiByZXN1bHRzIHRvIHJldHVybi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVLZXlzXSBXaGVuIHRydWUsIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlXG4gICAgICogICAgIHJldHVybmVkIG9iamVjdHMgaXMgY2hhbmdlZCBmcm9tIGFuIGFycmF5IG9mIHZhbHVlcyB0byBhbiBhcnJheSBvZlxuICAgICAqICAgICBvYmplY3RzIGluIHRoZSBmb3JtIHtrZXksIHByaW1hcnlLZXksIHZhbHVlfS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIGdldEFsbE1hdGNoaW5nKHN0b3JlTmFtZSwgeyBpbmRleCwgcXVlcnkgPSBudWxsLCAvLyBJRS9FZGdlIGVycm9ycyBpZiBxdWVyeSA9PT0gYHVuZGVmaW5lZGAuXG4gICAgZGlyZWN0aW9uID0gJ25leHQnLCBjb3VudCwgaW5jbHVkZUtleXMgPSBmYWxzZSwgfSA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zYWN0aW9uKFtzdG9yZU5hbWVdLCAncmVhZG9ubHknLCAodHhuLCBkb25lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZSA9IHR4bi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gaW5kZXggPyBzdG9yZS5pbmRleChpbmRleCkgOiBzdG9yZTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0YXJnZXQub3BlbkN1cnNvcihxdWVyeSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IHJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGluY2x1ZGVLZXlzID8gY3Vyc29yIDogY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ICYmIHJlc3VsdHMubGVuZ3RoID49IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2VwdHMgYSBsaXN0IG9mIHN0b3JlcywgYSB0cmFuc2FjdGlvbiB0eXBlLCBhbmQgYSBjYWxsYmFjayBhbmRcbiAgICAgKiBwZXJmb3JtcyBhIHRyYW5zYWN0aW9uLiBBIHByb21pc2UgaXMgcmV0dXJuZWQgdGhhdCByZXNvbHZlcyB0byB3aGF0ZXZlclxuICAgICAqIHZhbHVlIHRoZSBjYWxsYmFjayBjaG9vc2VzLiBUaGUgY2FsbGJhY2sgaG9sZHMgYWxsIHRoZSB0cmFuc2FjdGlvbiBsb2dpY1xuICAgICAqIGFuZCBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czpcbiAgICAgKiAgIDEuIFRoZSBJREJUcmFuc2FjdGlvbiBvYmplY3RcbiAgICAgKiAgIDIuIEEgYGRvbmVgIGZ1bmN0aW9uLCB0aGF0J3MgdXNlZCB0byByZXNvbHZlIHRoZSBwcm9taXNlIHdoZW5cbiAgICAgKiAgICAgIHdoZW4gdGhlIHRyYW5zYWN0aW9uIGlzIGRvbmUsIGlmIHBhc3NlZCBhIHZhbHVlLCB0aGUgcHJvbWlzZSBpc1xuICAgICAqICAgICAgcmVzb2x2ZWQgdG8gdGhhdCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gc3RvcmVOYW1lcyBBbiBhcnJheSBvZiBvYmplY3Qgc3RvcmUgbmFtZXNcbiAgICAgKiAgICAgaW52b2x2ZWQgaW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIENhbiBiZSBgcmVhZG9ubHlgIG9yIGByZWFkd3JpdGVgLlxuICAgICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4geyp9IFRoZSByZXN1bHQgb2YgdGhlIHRyYW5zYWN0aW9uIHJhbiBieSB0aGUgY2FsbGJhY2suXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyB0cmFuc2FjdGlvbihzdG9yZU5hbWVzLCB0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICBhd2FpdCB0aGlzLm9wZW4oKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHR4biA9IHRoaXMuX2RiLnRyYW5zYWN0aW9uKHN0b3JlTmFtZXMsIHR5cGUpO1xuICAgICAgICAgICAgdHhuLm9uYWJvcnQgPSAoKSA9PiByZWplY3QodHhuLmVycm9yKTtcbiAgICAgICAgICAgIHR4bi5vbmNvbXBsZXRlID0gKCkgPT4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgY2FsbGJhY2sodHhuLCAodmFsdWUpID0+IHJlc29sdmUodmFsdWUpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGVnYXRlcyBhc3luYyB0byBhIG5hdGl2ZSBJREJPYmplY3RTdG9yZSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIFRoZSBtZXRob2QgbmFtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVOYW1lIFRoZSBvYmplY3Qgc3RvcmUgbmFtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBDYW4gYmUgYHJlYWRvbmx5YCBvciBgcmVhZHdyaXRlYC5cbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgVGhlIGxpc3Qgb2YgYXJncyB0byBwYXNzIHRvIHRoZSBuYXRpdmUgbWV0aG9kLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSByZXN1bHQgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobWV0aG9kLCBzdG9yZU5hbWUsIHR5cGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAodHhuLCBkb25lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvYmpTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICAgICAgLy8gVE9ETyhwaGlsaXB3YWx0b24pOiBGaXggdGhpcyB1bmRlcmx5aW5nIFRTMjY4NCBlcnJvci5cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBvYmpTdG9yZVttZXRob2RdLmFwcGx5KG9ialN0b3JlLCBhcmdzKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gZG9uZShyZXF1ZXN0LnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zYWN0aW9uKFtzdG9yZU5hbWVdLCB0eXBlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgY29ubmVjdGlvbiBvcGVuZWQgYnkgYERCV3JhcHBlci5vcGVuKClgLiBHZW5lcmFsbHkgdGhpcyBtZXRob2RcbiAgICAgKiBkb2Vzbid0IG5lZWQgdG8gYmUgY2FsbGVkIHNpbmNlOlxuICAgICAqICAgMS4gSXQncyB1c3VhbGx5IGJldHRlciB0byBrZWVwIGEgY29ubmVjdGlvbiBvcGVuIHNpbmNlIG9wZW5pbmdcbiAgICAgKiAgICAgIGEgbmV3IGNvbm5lY3Rpb24gaXMgc29tZXdoYXQgc2xvdy5cbiAgICAgKiAgIDIuIENvbm5lY3Rpb25zIGFyZSBhdXRvbWF0aWNhbGx5IGNsb3NlZCB3aGVuIHRoZSByZWZlcmVuY2UgaXNcbiAgICAgKiAgICAgIGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgICAqIFRoZSBwcmltYXJ5IHVzZSBjYXNlIGZvciBuZWVkaW5nIHRvIGNsb3NlIGEgY29ubmVjdGlvbiBpcyB3aGVuIGFub3RoZXJcbiAgICAgKiByZWZlcmVuY2UgKHR5cGljYWxseSBpbiBhbm90aGVyIHRhYikgbmVlZHMgdG8gdXBncmFkZSBpdCBhbmQgd291bGQgYmVcbiAgICAgKiBibG9ja2VkIGJ5IHRoZSBjdXJyZW50LCBvcGVuIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fZGIpIHtcbiAgICAgICAgICAgIHRoaXMuX2RiLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9kYiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBFeHBvc2VkIG9uIHRoZSBwcm90b3R5cGUgdG8gbGV0IHVzZXJzIG1vZGlmeSB0aGUgZGVmYXVsdCB0aW1lb3V0IG9uIGFcbi8vIHBlci1pbnN0YW5jZSBvciBnbG9iYWwgYmFzaXMuXG5EQldyYXBwZXIucHJvdG90eXBlLk9QRU5fVElNRU9VVCA9IDIwMDA7XG4vLyBXcmFwIG5hdGl2ZSBJREJPYmplY3RTdG9yZSBtZXRob2RzIGFjY29yZGluZyB0byB0aGVpciBtb2RlLlxuY29uc3QgbWV0aG9kc1RvV3JhcCA9IHtcbiAgICByZWFkb25seTogWydnZXQnLCAnY291bnQnLCAnZ2V0S2V5JywgJ2dldEFsbCcsICdnZXRBbGxLZXlzJ10sXG4gICAgcmVhZHdyaXRlOiBbJ2FkZCcsICdwdXQnLCAnY2xlYXInLCAnZGVsZXRlJ10sXG59O1xuZm9yIChjb25zdCBbbW9kZSwgbWV0aG9kc10gb2YgT2JqZWN0LmVudHJpZXMobWV0aG9kc1RvV3JhcCkpIHtcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XG4gICAgICAgIGlmIChtZXRob2QgaW4gSURCT2JqZWN0U3RvcmUucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAvLyBEb24ndCB1c2UgYXJyb3cgZnVuY3Rpb25zIGhlcmUgc2luY2Ugd2UncmUgb3V0c2lkZSBvZiB0aGUgY2xhc3MuXG4gICAgICAgICAgICBEQldyYXBwZXIucHJvdG90eXBlW21ldGhvZF0gPVxuICAgICAgICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIChzdG9yZU5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2NhbGwobWV0aG9kLCBzdG9yZU5hbWUsIG1vZGUsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgJy4uL192ZXJzaW9uLmpzJztcbi8qKlxuICogRGVsZXRlcyB0aGUgZGF0YWJhc2UuXG4gKiBOb3RlOiB0aGlzIGlzIGV4cG9ydGVkIHNlcGFyYXRlbHkgZnJvbSB0aGUgREJXcmFwcGVyIG1vZHVsZSBiZWNhdXNlIG1vc3RcbiAqIHVzYWdlcyBvZiBJbmRleGVkREIgaW4gd29ya2JveCBkb250IG5lZWQgZGVsZXRpbmcsIGFuZCB0aGlzIHdheSBpdCBjYW4gYmVcbiAqIHJldXNlZCBpbiB0ZXN0cyB0byBkZWxldGUgZGF0YWJhc2VzIHdpdGhvdXQgY3JlYXRpbmcgREJXcmFwcGVyIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgZGF0YWJhc2UgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBkZWxldGVEYXRhYmFzZSA9IGFzeW5jIChuYW1lKSA9PiB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKG5hbWUpO1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Qub25ibG9ja2VkID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRGVsZXRlIGJsb2NrZWQnKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gQHRzLWlnbm9yZVxudHJ5IHtcbiAgICBzZWxmWyd3b3JrYm94OmV4cGlyYXRpb246Ni4wLjInXSAmJiBfKCk7XG59XG5jYXRjaCAoZSkgeyB9XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBEQldyYXBwZXIgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvREJXcmFwcGVyLmpzJztcbmltcG9ydCB7IGRlbGV0ZURhdGFiYXNlIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2RlbGV0ZURhdGFiYXNlLmpzJztcbmltcG9ydCAnLi4vX3ZlcnNpb24uanMnO1xuY29uc3QgREJfTkFNRSA9ICd3b3JrYm94LWV4cGlyYXRpb24nO1xuY29uc3QgT0JKRUNUX1NUT1JFX05BTUUgPSAnY2FjaGUtZW50cmllcyc7XG5jb25zdCBub3JtYWxpemVVUkwgPSAodW5Ob3JtYWxpemVkVXJsKSA9PiB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh1bk5vcm1hbGl6ZWRVcmwsIGxvY2F0aW9uLmhyZWYpO1xuICAgIHVybC5oYXNoID0gJyc7XG4gICAgcmV0dXJuIHVybC5ocmVmO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgdGltZXN0YW1wIG1vZGVsLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENhY2hlVGltZXN0YW1wc01vZGVsIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2FjaGVOYW1lKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlTmFtZSA9IGNhY2hlTmFtZTtcbiAgICAgICAgdGhpcy5fZGIgPSBuZXcgREJXcmFwcGVyKERCX05BTUUsIDEsIHtcbiAgICAgICAgICAgIG9udXBncmFkZW5lZWRlZDogKGV2ZW50KSA9PiB0aGlzLl9oYW5kbGVVcGdyYWRlKGV2ZW50KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3VsZCBwZXJmb3JtIGFuIHVwZ3JhZGUgb2YgaW5kZXhlZERCLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hhbmRsZVVwZ3JhZGUoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZGIgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAvLyBUT0RPKHBoaWxpcHdhbHRvbik6IEVkZ2VIVE1MIGRvZXNuJ3Qgc3VwcG9ydCBhcnJheXMgYXMgYSBrZXlQYXRoLCBzbyB3ZVxuICAgICAgICAvLyBoYXZlIHRvIHVzZSB0aGUgYGlkYCBrZXlQYXRoIGhlcmUgYW5kIGNyZWF0ZSBvdXIgb3duIHZhbHVlcyAoYVxuICAgICAgICAvLyBjb25jYXRlbmF0aW9uIG9mIGB1cmwgKyBjYWNoZU5hbWVgKSBpbnN0ZWFkIG9mIHNpbXBseSB1c2luZ1xuICAgICAgICAvLyBga2V5UGF0aDogWyd1cmwnLCAnY2FjaGVOYW1lJ11gLCB3aGljaCBpcyBzdXBwb3J0ZWQgaW4gb3RoZXIgYnJvd3NlcnMuXG4gICAgICAgIGNvbnN0IG9ialN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX05BTUUsIHsga2V5UGF0aDogJ2lkJyB9KTtcbiAgICAgICAgLy8gVE9ETyhwaGlsaXB3YWx0b24pOiBvbmNlIHdlIGRvbid0IGhhdmUgdG8gc3VwcG9ydCBFZGdlSFRNTCwgd2UgY2FuXG4gICAgICAgIC8vIGNyZWF0ZSBhIHNpbmdsZSBpbmRleCB3aXRoIHRoZSBrZXlQYXRoIGBbJ2NhY2hlTmFtZScsICd0aW1lc3RhbXAnXWBcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBkb2luZyBib3RoIHRoZXNlIGluZGV4ZXMuXG4gICAgICAgIG9ialN0b3JlLmNyZWF0ZUluZGV4KCdjYWNoZU5hbWUnLCAnY2FjaGVOYW1lJywgeyB1bmlxdWU6IGZhbHNlIH0pO1xuICAgICAgICBvYmpTdG9yZS5jcmVhdGVJbmRleCgndGltZXN0YW1wJywgJ3RpbWVzdGFtcCcsIHsgdW5pcXVlOiBmYWxzZSB9KTtcbiAgICAgICAgLy8gUHJldmlvdXMgdmVyc2lvbnMgb2YgYHdvcmtib3gtZXhwaXJhdGlvbmAgdXNlZCBgdGhpcy5fY2FjaGVOYW1lYFxuICAgICAgICAvLyBhcyB0aGUgSURCRGF0YWJhc2UgbmFtZS5cbiAgICAgICAgZGVsZXRlRGF0YWJhc2UodGhpcy5fY2FjaGVOYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXBcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgc2V0VGltZXN0YW1wKHVybCwgdGltZXN0YW1wKSB7XG4gICAgICAgIHVybCA9IG5vcm1hbGl6ZVVSTCh1cmwpO1xuICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIGNhY2hlTmFtZTogdGhpcy5fY2FjaGVOYW1lLFxuICAgICAgICAgICAgLy8gQ3JlYXRpbmcgYW4gSUQgZnJvbSB0aGUgVVJMIGFuZCBjYWNoZSBuYW1lIHdvbid0IGJlIG5lY2Vzc2FyeSBvbmNlXG4gICAgICAgICAgICAvLyBFZGdlIHN3aXRjaGVzIHRvIENocm9taXVtIGFuZCBhbGwgYnJvd3NlcnMgd2Ugc3VwcG9ydCB3b3JrIHdpdGhcbiAgICAgICAgICAgIC8vIGFycmF5IGtleVBhdGhzLlxuICAgICAgICAgICAgaWQ6IHRoaXMuX2dldElkKHVybCksXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRoaXMuX2RiLnB1dChPQkpFQ1RfU1RPUkVfTkFNRSwgZW50cnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0aW1lc3RhbXAgc3RvcmVkIGZvciBhIGdpdmVuIFVSTC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIGdldFRpbWVzdGFtcCh1cmwpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCB0aGlzLl9kYi5nZXQoT0JKRUNUX1NUT1JFX05BTUUsIHRoaXMuX2dldElkKHVybCkpO1xuICAgICAgICByZXR1cm4gZW50cnkudGltZXN0YW1wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyB0aHJvdWdoIGFsbCB0aGUgZW50cmllcyBpbiB0aGUgb2JqZWN0IHN0b3JlIChmcm9tIG5ld2VzdCB0b1xuICAgICAqIG9sZGVzdCkgYW5kIHJlbW92ZXMgZW50cmllcyBvbmNlIGVpdGhlciBgbWF4Q291bnRgIGlzIHJlYWNoZWQgb3IgdGhlXG4gICAgICogZW50cnkncyB0aW1lc3RhbXAgaXMgbGVzcyB0aGFuIGBtaW5UaW1lc3RhbXBgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblRpbWVzdGFtcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhDb3VudFxuICAgICAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIGV4cGlyZUVudHJpZXMobWluVGltZXN0YW1wLCBtYXhDb3VudCkge1xuICAgICAgICBjb25zdCBlbnRyaWVzVG9EZWxldGUgPSBhd2FpdCB0aGlzLl9kYi50cmFuc2FjdGlvbihPQkpFQ1RfU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScsICh0eG4sIGRvbmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHhuLm9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9OQU1FKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5pbmRleCgndGltZXN0YW1wJykub3BlbkN1cnNvcihudWxsLCAncHJldicpO1xuICAgICAgICAgICAgY29uc3QgZW50cmllc1RvRGVsZXRlID0gW107XG4gICAgICAgICAgICBsZXQgZW50cmllc05vdERlbGV0ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSByZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhwaGlsaXB3YWx0b24pOiBvbmNlIHdlIGNhbiB1c2UgYSBtdWx0aS1rZXkgaW5kZXgsIHdlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdvbid0IGhhdmUgdG8gY2hlY2sgYGNhY2hlTmFtZWAgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5jYWNoZU5hbWUgPT09IHRoaXMuX2NhY2hlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIGFuIGVudHJ5IGlmIGl0J3Mgb2xkZXIgdGhhbiB0aGUgbWF4IGFnZSBvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIHRoZSBtYXggbnVtYmVyIGFsbG93ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG1pblRpbWVzdGFtcCAmJiByZXN1bHQudGltZXN0YW1wIDwgbWluVGltZXN0YW1wKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXhDb3VudCAmJiBlbnRyaWVzTm90RGVsZXRlZENvdW50ID49IG1heENvdW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8ocGhpbGlwd2FsdG9uKTogd2Ugc2hvdWxkIGJlIGFibGUgdG8gZGVsZXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVudHJ5IHJpZ2h0IGhlcmUsIGJ1dCBkb2luZyBzbyBjYXVzZXMgYW4gaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnVnIGluIFNhZmFyaSBzdGFibGUgKGZpeGVkIGluIFRQKS4gSW5zdGVhZCB3ZSBjYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUga2V5cyBvZiB0aGUgZW50cmllcyB0byBkZWxldGUsIGFuZCB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSBzZXBhcmF0ZSB0cmFuc2FjdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8xOTc4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3Vyc29yLmRlbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byByZXR1cm4gdGhlIFVSTCwgbm90IHRoZSB3aG9sZSBlbnRyeS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzVG9EZWxldGUucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllc05vdERlbGV0ZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZShlbnRyaWVzVG9EZWxldGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUT0RPKHBoaWxpcHdhbHRvbik6IG9uY2UgdGhlIFNhZmFyaSBidWcgaW4gdGhlIGZvbGxvd2luZyBpc3N1ZSBpcyBmaXhlZCxcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlIHRoaXMgbG9vcCBhbmQgZG8gdGhlIGVudHJ5IGRlbGV0aW9uIGluIHRoZVxuICAgICAgICAvLyBjdXJzb3IgbG9vcCBhYm92ZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93b3JrYm94L2lzc3Vlcy8xOTc4XG4gICAgICAgIGNvbnN0IHVybHNEZWxldGVkID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllc1RvRGVsZXRlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9kYi5kZWxldGUoT0JKRUNUX1NUT1JFX05BTUUsIGVudHJ5LmlkKTtcbiAgICAgICAgICAgIHVybHNEZWxldGVkLnB1c2goZW50cnkudXJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsc0RlbGV0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgVVJMIGFuZCByZXR1cm5zIGFuIElEIHRoYXQgd2lsbCBiZSB1bmlxdWUgaW4gdGhlIG9iamVjdCBzdG9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRJZCh1cmwpIHtcbiAgICAgICAgLy8gQ3JlYXRpbmcgYW4gSUQgZnJvbSB0aGUgVVJMIGFuZCBjYWNoZSBuYW1lIHdvbid0IGJlIG5lY2Vzc2FyeSBvbmNlXG4gICAgICAgIC8vIEVkZ2Ugc3dpdGNoZXMgdG8gQ2hyb21pdW0gYW5kIGFsbCBicm93c2VycyB3ZSBzdXBwb3J0IHdvcmsgd2l0aFxuICAgICAgICAvLyBhcnJheSBrZXlQYXRocy5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlTmFtZSArICd8JyArIG5vcm1hbGl6ZVVSTCh1cmwpO1xuICAgIH1cbn1cbmV4cG9ydCB7IENhY2hlVGltZXN0YW1wc01vZGVsIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0LmpzJztcbmltcG9ydCB7IGRvbnRXYWl0Rm9yIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2RvbnRXYWl0Rm9yLmpzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIuanMnO1xuaW1wb3J0IHsgV29ya2JveEVycm9yIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5qcyc7XG5pbXBvcnQgeyBDYWNoZVRpbWVzdGFtcHNNb2RlbCB9IGZyb20gJy4vbW9kZWxzL0NhY2hlVGltZXN0YW1wc01vZGVsLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIFRoZSBgQ2FjaGVFeHBpcmF0aW9uYCBjbGFzcyBhbGxvd3MgeW91IGRlZmluZSBhbiBleHBpcmF0aW9uIGFuZCAvIG9yXG4gKiBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIHJlc3BvbnNlcyBzdG9yZWQgaW4gYVxuICogW2BDYWNoZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYWNoZSkuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LWV4cGlyYXRpb25cbiAqL1xuY2xhc3MgQ2FjaGVFeHBpcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUbyBjb25zdHJ1Y3QgYSBuZXcgQ2FjaGVFeHBpcmF0aW9uIGluc3RhbmNlIHlvdSBtdXN0IHByb3ZpZGUgYXQgbGVhc3RcbiAgICAgKiBvbmUgb2YgdGhlIGBjb25maWdgIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIE5hbWUgb2YgdGhlIGNhY2hlIHRvIGFwcGx5IHJlc3RyaWN0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubWF4RW50cmllc10gVGhlIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgdG8gY2FjaGUuXG4gICAgICogRW50cmllcyB1c2VkIHRoZSBsZWFzdCB3aWxsIGJlIHJlbW92ZWQgYXMgdGhlIG1heGltdW0gaXMgcmVhY2hlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5tYXhBZ2VTZWNvbmRzXSBUaGUgbWF4aW11bSBhZ2Ugb2YgYW4gZW50cnkgYmVmb3JlXG4gICAgICogaXQncyB0cmVhdGVkIGFzIHN0YWxlIGFuZCByZW1vdmVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm1hdGNoT3B0aW9uc10gVGhlIFtgQ2FjaGVRdWVyeU9wdGlvbnNgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FjaGUvZGVsZXRlI1BhcmFtZXRlcnMpXG4gICAgICogdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiBjYWxsaW5nIGBkZWxldGUoKWAgb24gdGhlIGNhY2hlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNhY2hlTmFtZSwgY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JlcnVuUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBhc3NlcnQuaXNUeXBlKGNhY2hlTmFtZSwgJ3N0cmluZycsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1leHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdDYWNoZUV4cGlyYXRpb24nLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnY29uc3RydWN0b3InLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ2NhY2hlTmFtZScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghKGNvbmZpZy5tYXhFbnRyaWVzIHx8IGNvbmZpZy5tYXhBZ2VTZWNvbmRzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ21heC1lbnRyaWVzLW9yLWFnZS1yZXF1aXJlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtZXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ0NhY2hlRXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnY29uc3RydWN0b3InLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZy5tYXhFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmlzVHlwZShjb25maWcubWF4RW50cmllcywgJ251bWJlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtZXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ0NhY2hlRXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnY29uc3RydWN0b3InLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdjb25maWcubWF4RW50cmllcycsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLm1heEFnZVNlY29uZHMpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuaXNUeXBlKGNvbmZpZy5tYXhBZ2VTZWNvbmRzLCAnbnVtYmVyJywge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1leHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnQ2FjaGVFeHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ2NvbmZpZy5tYXhBZ2VTZWNvbmRzJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXhFbnRyaWVzID0gY29uZmlnLm1heEVudHJpZXM7XG4gICAgICAgIHRoaXMuX21heEFnZVNlY29uZHMgPSBjb25maWcubWF4QWdlU2Vjb25kcztcbiAgICAgICAgdGhpcy5fbWF0Y2hPcHRpb25zID0gY29uZmlnLm1hdGNoT3B0aW9ucztcbiAgICAgICAgdGhpcy5fY2FjaGVOYW1lID0gY2FjaGVOYW1lO1xuICAgICAgICB0aGlzLl90aW1lc3RhbXBNb2RlbCA9IG5ldyBDYWNoZVRpbWVzdGFtcHNNb2RlbChjYWNoZU5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBpcmVzIGVudHJpZXMgZm9yIHRoZSBnaXZlbiBjYWNoZSBhbmQgZ2l2ZW4gY3JpdGVyaWEuXG4gICAgICovXG4gICAgYXN5bmMgZXhwaXJlRW50cmllcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xuICAgICAgICAgICAgdGhpcy5fcmVydW5SZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IG1pblRpbWVzdGFtcCA9IHRoaXMuX21heEFnZVNlY29uZHMgP1xuICAgICAgICAgICAgRGF0ZS5ub3coKSAtICh0aGlzLl9tYXhBZ2VTZWNvbmRzICogMTAwMCkgOiAwO1xuICAgICAgICBjb25zdCB1cmxzRXhwaXJlZCA9IGF3YWl0IHRoaXMuX3RpbWVzdGFtcE1vZGVsLmV4cGlyZUVudHJpZXMobWluVGltZXN0YW1wLCB0aGlzLl9tYXhFbnRyaWVzKTtcbiAgICAgICAgLy8gRGVsZXRlIFVSTHMgZnJvbSB0aGUgY2FjaGVcbiAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBzZWxmLmNhY2hlcy5vcGVuKHRoaXMuX2NhY2hlTmFtZSk7XG4gICAgICAgIGZvciAoY29uc3QgdXJsIG9mIHVybHNFeHBpcmVkKSB7XG4gICAgICAgICAgICBhd2FpdCBjYWNoZS5kZWxldGUodXJsLCB0aGlzLl9tYXRjaE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodXJsc0V4cGlyZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgRXhwaXJlZCAke3VybHNFeHBpcmVkLmxlbmd0aH0gYCArXG4gICAgICAgICAgICAgICAgICAgIGAke3VybHNFeHBpcmVkLmxlbmd0aCA9PT0gMSA/ICdlbnRyeScgOiAnZW50cmllcyd9IGFuZCByZW1vdmVkIGAgK1xuICAgICAgICAgICAgICAgICAgICBgJHt1cmxzRXhwaXJlZC5sZW5ndGggPT09IDEgPyAnaXQnIDogJ3RoZW0nfSBmcm9tIHRoZSBgICtcbiAgICAgICAgICAgICAgICAgICAgYCcke3RoaXMuX2NhY2hlTmFtZX0nIGNhY2hlLmApO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYEV4cGlyZWQgdGhlIGZvbGxvd2luZyAke3VybHNFeHBpcmVkLmxlbmd0aCA9PT0gMSA/XG4gICAgICAgICAgICAgICAgICAgICdVUkwnIDogJ1VSTHMnfTpgKTtcbiAgICAgICAgICAgICAgICB1cmxzRXhwaXJlZC5mb3JFYWNoKCh1cmwpID0+IGxvZ2dlci5sb2coYCAgICAke3VybH1gKSk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYENhY2hlIGV4cGlyYXRpb24gcmFuIGFuZCBmb3VuZCBubyBlbnRyaWVzIHRvIHJlbW92ZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX3JlcnVuUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXJ1blJlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZG9udFdhaXRGb3IodGhpcy5leHBpcmVFbnRyaWVzKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgdGltZXN0YW1wIGZvciB0aGUgZ2l2ZW4gVVJMLiBUaGlzIGVuc3VyZXMgdGhlIHdoZW5cbiAgICAgKiByZW1vdmluZyBlbnRyaWVzIGJhc2VkIG9uIG1heGltdW0gZW50cmllcywgbW9zdCByZWNlbnRseSB1c2VkXG4gICAgICogaXMgYWNjdXJhdGUgb3Igd2hlbiBleHBpcmluZywgdGhlIHRpbWVzdGFtcCBpcyB1cC10by1kYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVRpbWVzdGFtcCh1cmwpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc1R5cGUodXJsLCAnc3RyaW5nJywge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LWV4cGlyYXRpb24nLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ0NhY2hlRXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6ICd1cGRhdGVUaW1lc3RhbXAnLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ3VybCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl90aW1lc3RhbXBNb2RlbC5zZXRUaW1lc3RhbXAodXJsLCBEYXRlLm5vdygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuIGJlIHVzZWQgdG8gY2hlY2sgaWYgYSBVUkwgaGFzIGV4cGlyZWQgb3Igbm90IGJlZm9yZSBpdCdzIHVzZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIHJlcXVpcmVzIGEgbG9vayB1cCBmcm9tIEluZGV4ZWREQiwgc28gY2FuIGJlIHNsb3cuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCB3aWxsIG5vdCByZW1vdmUgdGhlIGNhY2hlZCBlbnRyeSwgY2FsbFxuICAgICAqIGBleHBpcmVFbnRyaWVzKClgIHRvIHJlbW92ZSBpbmRleGVkREIgYW5kIENhY2hlIGVudHJpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBhc3luYyBpc1VSTEV4cGlyZWQodXJsKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWF4QWdlU2Vjb25kcykge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKGBleHBpcmVkLXRlc3Qtd2l0aG91dC1tYXgtYWdlYCwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2ROYW1lOiAnaXNVUkxFeHBpcmVkJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnbWF4QWdlU2Vjb25kcycsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBhd2FpdCB0aGlzLl90aW1lc3RhbXBNb2RlbC5nZXRUaW1lc3RhbXAodXJsKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGlyZU9sZGVyVGhhbiA9IERhdGUubm93KCkgLSAodGhpcy5fbWF4QWdlU2Vjb25kcyAqIDEwMDApO1xuICAgICAgICAgICAgcmV0dXJuICh0aW1lc3RhbXAgPCBleHBpcmVPbGRlclRoYW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIEluZGV4ZWREQiBvYmplY3Qgc3RvcmUgdXNlZCB0byBrZWVwIHRyYWNrIG9mIGNhY2hlIGV4cGlyYXRpb25cbiAgICAgKiBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUoKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBhdHRlbXB0IGFub3RoZXIgcmVydW4gaWYgd2UncmUgY2FsbGVkIGluIHRoZSBtaWRkbGUgb2ZcbiAgICAgICAgLy8gYSBjYWNoZSBleHBpcmF0aW9uLlxuICAgICAgICB0aGlzLl9yZXJ1blJlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICBhd2FpdCB0aGlzLl90aW1lc3RhbXBNb2RlbC5leHBpcmVFbnRyaWVzKEluZmluaXR5KTsgLy8gRXhwaXJlcyBhbGwuXG4gICAgfVxufVxuZXhwb3J0IHsgQ2FjaGVFeHBpcmF0aW9uIH07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiovXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL19wcml2YXRlL2xvZ2dlci5qcyc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuL19wcml2YXRlL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBxdW90YUVycm9yQ2FsbGJhY2tzIH0gZnJvbSAnLi9tb2RlbHMvcXVvdGFFcnJvckNhbGxiYWNrcy5qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24uanMnO1xuLyoqXG4gKiBBZGRzIGEgZnVuY3Rpb24gdG8gdGhlIHNldCBvZiBxdW90YUVycm9yQ2FsbGJhY2tzIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBpZlxuICogdGhlcmUncyBhIHF1b3RhIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtY29yZVxuICovXG5mdW5jdGlvbiByZWdpc3RlclF1b3RhRXJyb3JDYWxsYmFjayhjYWxsYmFjaykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydC5pc1R5cGUoY2FsbGJhY2ssICdmdW5jdGlvbicsIHtcbiAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LWNvcmUnLFxuICAgICAgICAgICAgZnVuY05hbWU6ICdyZWdpc3RlcicsXG4gICAgICAgICAgICBwYXJhbU5hbWU6ICdjYWxsYmFjaycsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBxdW90YUVycm9yQ2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnUmVnaXN0ZXJlZCBhIGNhbGxiYWNrIHRvIHJlc3BvbmQgdG8gcXVvdGEgZXJyb3JzLicsIGNhbGxiYWNrKTtcbiAgICB9XG59XG5leHBvcnQgeyByZWdpc3RlclF1b3RhRXJyb3JDYWxsYmFjayB9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4qL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBjYWNoZU5hbWVzIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2NhY2hlTmFtZXMuanMnO1xuaW1wb3J0IHsgZG9udFdhaXRGb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZG9udFdhaXRGb3IuanMnO1xuaW1wb3J0IHsgZ2V0RnJpZW5kbHlVUkwgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwuanMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5qcyc7XG5pbXBvcnQgeyByZWdpc3RlclF1b3RhRXJyb3JDYWxsYmFjayB9IGZyb20gJ3dvcmtib3gtY29yZS9yZWdpc3RlclF1b3RhRXJyb3JDYWxsYmFjay5qcyc7XG5pbXBvcnQgeyBXb3JrYm94RXJyb3IgfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvV29ya2JveEVycm9yLmpzJztcbmltcG9ydCB7IENhY2hlRXhwaXJhdGlvbiB9IGZyb20gJy4vQ2FjaGVFeHBpcmF0aW9uLmpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5qcyc7XG4vKipcbiAqIFRoaXMgcGx1Z2luIGNhbiBiZSB1c2VkIGluIGEgYHdvcmtib3gtc3RyYXRlZ3lgIHRvIHJlZ3VsYXJseSBlbmZvcmNlIGFcbiAqIGxpbWl0IG9uIHRoZSBhZ2UgYW5kIC8gb3IgdGhlIG51bWJlciBvZiBjYWNoZWQgcmVxdWVzdHMuXG4gKlxuICogSXQgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIGB3b3JrYm94LXN0cmF0ZWd5YCBpbnN0YW5jZXMgdGhhdCBoYXZlIGFcbiAqIFtjdXN0b20gYGNhY2hlTmFtZWAgcHJvcGVydHkgc2V0XSgvd2ViL3Rvb2xzL3dvcmtib3gvZ3VpZGVzL2NvbmZpZ3VyZS13b3JrYm94I2N1c3RvbV9jYWNoZV9uYW1lc19pbl9zdHJhdGVnaWVzKS5cbiAqIEluIG90aGVyIHdvcmRzLCBpdCBjYW4ndCBiZSB1c2VkIHRvIGV4cGlyZSBlbnRyaWVzIGluIHN0cmF0ZWd5IHRoYXQgdXNlcyB0aGVcbiAqIGRlZmF1bHQgcnVudGltZSBjYWNoZSBuYW1lLlxuICpcbiAqIFdoZW5ldmVyIGEgY2FjaGVkIHJlcXVlc3QgaXMgdXNlZCBvciB1cGRhdGVkLCB0aGlzIHBsdWdpbiB3aWxsIGxvb2tcbiAqIGF0IHRoZSBhc3NvY2lhdGVkIGNhY2hlIGFuZCByZW1vdmUgYW55IG9sZCBvciBleHRyYSByZXF1ZXN0cy5cbiAqXG4gKiBXaGVuIHVzaW5nIGBtYXhBZ2VTZWNvbmRzYCwgcmVxdWVzdHMgbWF5IGJlIHVzZWQgKm9uY2UqIGFmdGVyIGV4cGlyaW5nXG4gKiBiZWNhdXNlIHRoZSBleHBpcmF0aW9uIGNsZWFuIHVwIHdpbGwgbm90IGhhdmUgb2NjdXJyZWQgdW50aWwgKmFmdGVyKiB0aGVcbiAqIGNhY2hlZCByZXF1ZXN0IGhhcyBiZWVuIHVzZWQuIElmIHRoZSByZXF1ZXN0IGhhcyBhIFwiRGF0ZVwiIGhlYWRlciwgdGhlblxuICogYSBsaWdodCB3ZWlnaHQgZXhwaXJhdGlvbiBjaGVjayBpcyBwZXJmb3JtZWQgYW5kIHRoZSByZXF1ZXN0IHdpbGwgbm90IGJlXG4gKiB1c2VkIGltbWVkaWF0ZWx5LlxuICpcbiAqIFdoZW4gdXNpbmcgYG1heEVudHJpZXNgLCB0aGUgZW50cnkgbGVhc3QtcmVjZW50bHkgcmVxdWVzdGVkIHdpbGwgYmUgcmVtb3ZlZFxuICogZnJvbSB0aGUgY2FjaGUgZmlyc3QuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LWV4cGlyYXRpb25cbiAqL1xuY2xhc3MgRXhwaXJhdGlvblBsdWdpbiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLm1heEVudHJpZXNdIFRoZSBtYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzIHRvIGNhY2hlLlxuICAgICAqIEVudHJpZXMgdXNlZCB0aGUgbGVhc3Qgd2lsbCBiZSByZW1vdmVkIGFzIHRoZSBtYXhpbXVtIGlzIHJlYWNoZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubWF4QWdlU2Vjb25kc10gVGhlIG1heGltdW0gYWdlIG9mIGFuIGVudHJ5IGJlZm9yZVxuICAgICAqIGl0J3MgdHJlYXRlZCBhcyBzdGFsZSBhbmQgcmVtb3ZlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5tYXRjaE9wdGlvbnNdIFRoZSBbYENhY2hlUXVlcnlPcHRpb25zYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhY2hlL2RlbGV0ZSNQYXJhbWV0ZXJzKVxuICAgICAqIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gY2FsbGluZyBgZGVsZXRlKClgIG9uIHRoZSBjYWNoZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb25maWcucHVyZ2VPblF1b3RhRXJyb3JdIFdoZXRoZXIgdG8gb3B0IHRoaXMgY2FjaGUgaW4gdG9cbiAgICAgKiBhdXRvbWF0aWMgZGVsZXRpb24gaWYgdGhlIGF2YWlsYWJsZSBzdG9yYWdlIHF1b3RhIGhhcyBiZWVuIGV4Y2VlZGVkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIFwibGlmZWN5Y2xlXCIgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIHRyaWdnZXJlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZVxuICAgICAgICAgKiBgd29ya2JveC1zdHJhdGVnaWVzYCBoYW5kbGVycyB3aGVuIGEgYFJlc3BvbnNlYCBpcyBhYm91dCB0byBiZSByZXR1cm5lZFxuICAgICAgICAgKiBmcm9tIGEgW0NhY2hlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FjaGUpIHRvXG4gICAgICAgICAqIHRoZSBoYW5kbGVyLiBJdCBhbGxvd3MgdGhlIGBSZXNwb25zZWAgdG8gYmUgaW5zcGVjdGVkIGZvciBmcmVzaG5lc3MgYW5kXG4gICAgICAgICAqIHByZXZlbnRzIGl0IGZyb20gYmVpbmcgdXNlZCBpZiB0aGUgYFJlc3BvbnNlYCdzIGBEYXRlYCBoZWFkZXIgdmFsdWUgaXNcbiAgICAgICAgICogb2xkZXIgdGhhbiB0aGUgY29uZmlndXJlZCBgbWF4QWdlU2Vjb25kc2AuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNhY2hlTmFtZSBOYW1lIG9mIHRoZSBjYWNoZSB0aGUgcmVzcG9uc2UgaXMgaW4uXG4gICAgICAgICAqIEBwYXJhbSB7UmVzcG9uc2V9IG9wdGlvbnMuY2FjaGVkUmVzcG9uc2UgVGhlIGBSZXNwb25zZWAgb2JqZWN0IHRoYXQncyBiZWVuXG4gICAgICAgICAqICAgICByZWFkIGZyb20gYSBjYWNoZSBhbmQgd2hvc2UgZnJlc2huZXNzIHNob3VsZCBiZSBjaGVja2VkLlxuICAgICAgICAgKiBAcmV0dXJuIHtSZXNwb25zZX0gRWl0aGVyIHRoZSBgY2FjaGVkUmVzcG9uc2VgLCBpZiBpdCdzXG4gICAgICAgICAqICAgICBmcmVzaCwgb3IgYG51bGxgIGlmIHRoZSBgUmVzcG9uc2VgIGlzIG9sZGVyIHRoYW4gYG1heEFnZVNlY29uZHNgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWNoZWRSZXNwb25zZVdpbGxCZVVzZWQgPSBhc3luYyAoeyBldmVudCwgcmVxdWVzdCwgY2FjaGVOYW1lLCBjYWNoZWRSZXNwb25zZSB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlZFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc0ZyZXNoID0gdGhpcy5faXNSZXNwb25zZURhdGVGcmVzaChjYWNoZWRSZXNwb25zZSk7XG4gICAgICAgICAgICAvLyBFeHBpcmUgZW50cmllcyB0byBlbnN1cmUgdGhhdCBldmVuIGlmIHRoZSBleHBpcmF0aW9uIGRhdGUgaGFzXG4gICAgICAgICAgICAvLyBleHBpcmVkLCBpdCdsbCBvbmx5IGJlIHVzZWQgb25jZS5cbiAgICAgICAgICAgIGNvbnN0IGNhY2hlRXhwaXJhdGlvbiA9IHRoaXMuX2dldENhY2hlRXhwaXJhdGlvbihjYWNoZU5hbWUpO1xuICAgICAgICAgICAgZG9udFdhaXRGb3IoY2FjaGVFeHBpcmF0aW9uLmV4cGlyZUVudHJpZXMoKSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG1ldGFkYXRhIGZvciB0aGUgcmVxdWVzdCBVUkwgdG8gdGhlIGN1cnJlbnQgdGltZXN0YW1wLFxuICAgICAgICAgICAgLy8gYnV0IGRvbid0IGBhd2FpdGAgaXQgYXMgd2UgZG9uJ3Qgd2FudCB0byBibG9jayB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVUaW1lc3RhbXBEb25lID0gY2FjaGVFeHBpcmF0aW9uLnVwZGF0ZVRpbWVzdGFtcChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC53YWl0VW50aWwodXBkYXRlVGltZXN0YW1wRG9uZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGV2ZW50IG1heSBub3QgYmUgYSBmZXRjaCBldmVudDsgb25seSBsb2cgdGhlIFVSTCBpZiBpdCBpcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgncmVxdWVzdCcgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgVW5hYmxlIHRvIGVuc3VyZSBzZXJ2aWNlIHdvcmtlciBzdGF5cyBhbGl2ZSB3aGVuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgdXBkYXRpbmcgY2FjaGUgZW50cnkgZm9yIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJyR7Z2V0RnJpZW5kbHlVUkwoZXZlbnQucmVxdWVzdC51cmwpfScuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNGcmVzaCA/IGNhY2hlZFJlc3BvbnNlIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgXCJsaWZlY3ljbGVcIiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgdHJpZ2dlcmVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlXG4gICAgICAgICAqIGB3b3JrYm94LXN0cmF0ZWdpZXNgIGhhbmRsZXJzIHdoZW4gYW4gZW50cnkgaXMgYWRkZWQgdG8gYSBjYWNoZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2FjaGVOYW1lIE5hbWUgb2YgdGhlIGNhY2hlIHRoYXQgd2FzIHVwZGF0ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJlcXVlc3QgVGhlIFJlcXVlc3QgZm9yIHRoZSBjYWNoZWQgZW50cnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhY2hlRGlkVXBkYXRlID0gYXN5bmMgKHsgY2FjaGVOYW1lLCByZXF1ZXN0IH0pID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmlzVHlwZShjYWNoZU5hbWUsICdzdHJpbmcnLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LWV4cGlyYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdQbHVnaW4nLFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ2NhY2hlRGlkVXBkYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAnY2FjaGVOYW1lJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhc3NlcnQuaXNJbnN0YW5jZShyZXF1ZXN0LCBSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LWV4cGlyYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdQbHVnaW4nLFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogJ2NhY2hlRGlkVXBkYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lOiAncmVxdWVzdCcsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYWNoZUV4cGlyYXRpb24gPSB0aGlzLl9nZXRDYWNoZUV4cGlyYXRpb24oY2FjaGVOYW1lKTtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlRXhwaXJhdGlvbi51cGRhdGVUaW1lc3RhbXAocmVxdWVzdC51cmwpO1xuICAgICAgICAgICAgYXdhaXQgY2FjaGVFeHBpcmF0aW9uLmV4cGlyZUVudHJpZXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGlmICghKGNvbmZpZy5tYXhFbnRyaWVzIHx8IGNvbmZpZy5tYXhBZ2VTZWNvbmRzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ21heC1lbnRyaWVzLW9yLWFnZS1yZXF1aXJlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtZXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1BsdWdpbicsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnY29uc3RydWN0b3InLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZy5tYXhFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmlzVHlwZShjb25maWcubWF4RW50cmllcywgJ251bWJlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtZXhwaXJhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ1BsdWdpbicsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiAnY29uc3RydWN0b3InLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWU6ICdjb25maWcubWF4RW50cmllcycsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLm1heEFnZVNlY29uZHMpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuaXNUeXBlKGNvbmZpZy5tYXhBZ2VTZWNvbmRzLCAnbnVtYmVyJywge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1leHBpcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnUGx1Z2luJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogJ2NvbmZpZy5tYXhBZ2VTZWNvbmRzJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuX21heEFnZVNlY29uZHMgPSBjb25maWcubWF4QWdlU2Vjb25kcztcbiAgICAgICAgdGhpcy5fY2FjaGVFeHBpcmF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wdXJnZU9uUXVvdGFFcnJvcikge1xuICAgICAgICAgICAgcmVnaXN0ZXJRdW90YUVycm9yQ2FsbGJhY2soKCkgPT4gdGhpcy5kZWxldGVDYWNoZUFuZE1ldGFkYXRhKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIGhlbHBlciBtZXRob2QgdG8gcmV0dXJuIGEgQ2FjaGVFeHBpcmF0aW9uIGluc3RhbmNlIGZvciBhIGdpdmVuXG4gICAgICogY2FjaGUgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWVcbiAgICAgKiBAcmV0dXJuIHtDYWNoZUV4cGlyYXRpb259XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDYWNoZUV4cGlyYXRpb24oY2FjaGVOYW1lKSB7XG4gICAgICAgIGlmIChjYWNoZU5hbWUgPT09IGNhY2hlTmFtZXMuZ2V0UnVudGltZU5hbWUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignZXhwaXJlLWN1c3RvbS1jYWNoZXMtb25seScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjYWNoZUV4cGlyYXRpb24gPSB0aGlzLl9jYWNoZUV4cGlyYXRpb25zLmdldChjYWNoZU5hbWUpO1xuICAgICAgICBpZiAoIWNhY2hlRXhwaXJhdGlvbikge1xuICAgICAgICAgICAgY2FjaGVFeHBpcmF0aW9uID0gbmV3IENhY2hlRXhwaXJhdGlvbihjYWNoZU5hbWUsIHRoaXMuX2NvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUV4cGlyYXRpb25zLnNldChjYWNoZU5hbWUsIGNhY2hlRXhwaXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlRXhwaXJhdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtSZXNwb25zZX0gY2FjaGVkUmVzcG9uc2VcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNSZXNwb25zZURhdGVGcmVzaChjYWNoZWRSZXNwb25zZSkge1xuICAgICAgICBpZiAoIXRoaXMuX21heEFnZVNlY29uZHMpIHtcbiAgICAgICAgICAgIC8vIFdlIGFyZW4ndCBleHBpcmluZyBieSBhZ2UsIHNvIHJldHVybiB0cnVlLCBpdCdzIGZyZXNoXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgJ2RhdGUnIGhlYWRlciB3aWxsIHN1ZmZpY2UgYSBxdWljayBleHBpcmF0aW9uIGNoZWNrLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvc3ctdG9vbGJveC9pc3N1ZXMvMTY0IGZvclxuICAgICAgICAvLyBkaXNjdXNzaW9uLlxuICAgICAgICBjb25zdCBkYXRlSGVhZGVyVGltZXN0YW1wID0gdGhpcy5fZ2V0RGF0ZUhlYWRlclRpbWVzdGFtcChjYWNoZWRSZXNwb25zZSk7XG4gICAgICAgIGlmIChkYXRlSGVhZGVyVGltZXN0YW1wID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBVbmFibGUgdG8gcGFyc2UgZGF0ZSwgc28gYXNzdW1lIGl0J3MgZnJlc2guXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgdmFsaWQgaGVhZGVyVGltZSwgdGhlbiBvdXIgcmVzcG9uc2UgaXMgZnJlc2ggaWZmIHRoZVxuICAgICAgICAvLyBoZWFkZXJUaW1lIHBsdXMgbWF4QWdlU2Vjb25kcyBpcyBncmVhdGVyIHRoYW4gdGhlIGN1cnJlbnQgdGltZS5cbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIGRhdGVIZWFkZXJUaW1lc3RhbXAgPj0gbm93IC0gKHRoaXMuX21heEFnZVNlY29uZHMgKiAxMDAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBleHRyYWN0IHRoZSBkYXRhIGhlYWRlciBhbmQgcGFyc2UgaXQgaW50byBhIHVzZWZ1bFxuICAgICAqIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZXNwb25zZX0gY2FjaGVkUmVzcG9uc2VcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ8bnVsbH1cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldERhdGVIZWFkZXJUaW1lc3RhbXAoY2FjaGVkUmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKCFjYWNoZWRSZXNwb25zZS5oZWFkZXJzLmhhcygnZGF0ZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRlSGVhZGVyID0gY2FjaGVkUmVzcG9uc2UuaGVhZGVycy5nZXQoJ2RhdGUnKTtcbiAgICAgICAgY29uc3QgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKGRhdGVIZWFkZXIpO1xuICAgICAgICBjb25zdCBoZWFkZXJUaW1lID0gcGFyc2VkRGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgIC8vIElmIHRoZSBEYXRlIGhlYWRlciB3YXMgaW52YWxpZCBmb3Igc29tZSByZWFzb24sIHBhcnNlZERhdGUuZ2V0VGltZSgpXG4gICAgICAgIC8vIHdpbGwgcmV0dXJuIE5hTi5cbiAgICAgICAgaWYgKGlzTmFOKGhlYWRlclRpbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVyVGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIGhlbHBlciBtZXRob2QgdGhhdCBwZXJmb3JtcyB0d28gb3BlcmF0aW9uczpcbiAgICAgKlxuICAgICAqIC0gRGVsZXRlcyAqYWxsKiB0aGUgdW5kZXJseWluZyBDYWNoZSBpbnN0YW5jZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcGx1Z2luXG4gICAgICogaW5zdGFuY2UsIGJ5IGNhbGxpbmcgY2FjaGVzLmRlbGV0ZSgpIG9uIHlvdXIgYmVoYWxmLlxuICAgICAqIC0gRGVsZXRlcyB0aGUgbWV0YWRhdGEgZnJvbSBJbmRleGVkREIgdXNlZCB0byBrZWVwIHRyYWNrIG9mIGV4cGlyYXRpb25cbiAgICAgKiBkZXRhaWxzIGZvciBlYWNoIENhY2hlIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogV2hlbiB1c2luZyBjYWNoZSBleHBpcmF0aW9uLCBjYWxsaW5nIHRoaXMgbWV0aG9kIGlzIHByZWZlcmFibGUgdG8gY2FsbGluZ1xuICAgICAqIGBjYWNoZXMuZGVsZXRlKClgIGRpcmVjdGx5LCBzaW5jZSB0aGlzIHdpbGwgZW5zdXJlIHRoYXQgdGhlIEluZGV4ZWREQlxuICAgICAqIG1ldGFkYXRhIGlzIGFsc28gY2xlYW5seSByZW1vdmVkIGFuZCBvcGVuIEluZGV4ZWREQiBpbnN0YW5jZXMgYXJlIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgaWYgeW91J3JlICpub3QqIHVzaW5nIGNhY2hlIGV4cGlyYXRpb24gZm9yIGEgZ2l2ZW4gY2FjaGUsIGNhbGxpbmdcbiAgICAgKiBgY2FjaGVzLmRlbGV0ZSgpYCBhbmQgcGFzc2luZyBpbiB0aGUgY2FjaGUncyBuYW1lIHNob3VsZCBiZSBzdWZmaWNpZW50LlxuICAgICAqIFRoZXJlIGlzIG5vIFdvcmtib3gtc3BlY2lmaWMgbWV0aG9kIG5lZWRlZCBmb3IgY2xlYW51cCBpbiB0aGF0IGNhc2UuXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlQ2FjaGVBbmRNZXRhZGF0YSgpIHtcbiAgICAgICAgLy8gRG8gdGhpcyBvbmUgYXQgYSB0aW1lIGluc3RlYWQgb2YgYWxsIGF0IG9uY2UgdmlhIGBQcm9taXNlLmFsbCgpYCB0b1xuICAgICAgICAvLyByZWR1Y2UgdGhlIGNoYW5jZSBvZiBpbmNvbnNpc3RlbmN5IGlmIGEgcHJvbWlzZSByZWplY3RzLlxuICAgICAgICBmb3IgKGNvbnN0IFtjYWNoZU5hbWUsIGNhY2hlRXhwaXJhdGlvbl0gb2YgdGhpcy5fY2FjaGVFeHBpcmF0aW9ucykge1xuICAgICAgICAgICAgYXdhaXQgc2VsZi5jYWNoZXMuZGVsZXRlKGNhY2hlTmFtZSk7XG4gICAgICAgICAgICBhd2FpdCBjYWNoZUV4cGlyYXRpb24uZGVsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgdGhpcy5fY2FjaGVFeHBpcmF0aW9ucyB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cbiAgICAgICAgdGhpcy5fY2FjaGVFeHBpcmF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB9XG59XG5leHBvcnQgeyBFeHBpcmF0aW9uUGx1Z2luIH07XG4iLCJpbXBvcnQgeyB0aW1lc3RhbXAsIGZpbGVzLCBzaGVsbCB9IGZyb20gJ0BzYXBwZXIvc2VydmljZS13b3JrZXInO1xuaW1wb3J0IHsgcHJlY2FjaGVBbmRSb3V0ZSB9IGZyb20gJ3dvcmtib3gtcHJlY2FjaGluZyc7XG5pbXBvcnQgeyBDYWNoZUZpcnN0IH0gZnJvbSAnd29ya2JveC1zdHJhdGVnaWVzJztcbmltcG9ydCB7IHJlZ2lzdGVyUm91dGUgfSBmcm9tICd3b3JrYm94LXJvdXRpbmcnO1xuaW1wb3J0IHsgRXhwaXJhdGlvblBsdWdpbiB9IGZyb20gJ3dvcmtib3gtZXhwaXJhdGlvbic7XG5cbmNvbnN0IEFTU0VUUyA9IGBjYWNoZSR7dGltZXN0YW1wfWA7XG5cbi8vIGBzaGVsbGAgaXMgYW4gYXJyYXkgb2YgYWxsIHRoZSBmaWxlcyBnZW5lcmF0ZWQgYnkgdGhlIGJ1bmRsZXIsXG4vLyBgZmlsZXNgIGlzIGFuIGFycmF5IG9mIGV2ZXJ5dGhpbmcgaW4gdGhlIGBzdGF0aWNgIGRpcmVjdG9yeVxuY29uc3QgdG9fY2FjaGUgPSBzaGVsbC5jb25jYXQoZmlsZXMpO1xuY29uc3Qgc3RhdGljQXNzZXRzID0gbmV3IFNldCh0b19jYWNoZSk7XG5cbnNlbGYuX19XQl9ESVNBQkxFX0RFVl9MT0dTID0gdHJ1ZTtcblxucHJlY2FjaGVBbmRSb3V0ZShzaGVsbCk7XG5wcmVjYWNoZUFuZFJvdXRlKGZpbGVzKTtcblxucmVnaXN0ZXJSb3V0ZShcbi8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAqL1xuICBuZXcgUmVnRXhwKCdodHRwczpcXC9cXC9wcm9kdWN0ZXVyc2FncmlcXC5vcGVuZGF0YXNvZnRcXC5jb20nKSxcbiAgbmV3IENhY2hlRmlyc3Qoe1xuICAgIGNhY2hlTmFtZTogYG9kcy1yZXF1ZXN0cy0ke3RpbWVzdGFtcH1gLFxuICAgIHBsdWdpbnM6IFtcbiAgICAgIG5ldyBFeHBpcmF0aW9uUGx1Z2luKHtcbiAgICAgICAgbWF4RW50cmllczogNTAsXG4gICAgICAgIG1heEFnZVNlY29uZHM6IDM2MDAgKiAyNCxcbiAgICAgIH0pLFxuICAgIF0sXG4gIH0pLFxuKTtcbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJtZXNzYWdlcyJdLCJtYXBwaW5ncyI6Ijs7O0NBQUE7Q0FDTyxNQUFNLFNBQVMsR0FBRyxhQUFhLENBQUM7QUFDdkM7Q0FDTyxNQUFNLEtBQUssR0FBRztDQUNyQixDQUFDLDRCQUE0QjtDQUM3QixDQUFDLHVDQUF1QztDQUN4QyxDQUFDLHVDQUF1QztDQUN4QyxDQUFDLGlDQUFpQztDQUNsQyxDQUFDLDhCQUE4QjtDQUMvQixDQUFDLDhCQUE4QjtDQUMvQixDQUFDLDhCQUE4QjtDQUMvQixDQUFDLHdCQUF3QjtDQUN6QixDQUFDLHdCQUF3QjtDQUN6QixDQUFDLHVCQUF1QjtDQUN4QixDQUFDLHlCQUF5QjtDQUMxQixDQUFDLHlCQUF5QjtDQUMxQixDQUFDLHlCQUF5QjtDQUMxQixDQUFDLGlDQUFpQztDQUNsQyxDQUFDLCtCQUErQjtDQUNoQyxDQUFDLCtCQUErQjtDQUNoQyxDQUFDLCtCQUErQjtDQUNoQyxDQUFDLCtCQUErQjtDQUNoQyxDQUFDLDZCQUE2QjtDQUM5QixDQUFDLGtDQUFrQztDQUNuQyxDQUFDLENBQUM7QUFFRjtDQUNPLE1BQU0sS0FBSyxHQUFHO0NBQ3JCLENBQUMsNEJBQTRCO0NBQzdCLENBQUMsbUNBQW1DO0NBQ3BDLENBQUMs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
